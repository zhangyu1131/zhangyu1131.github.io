<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZRainy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-10T14:39:27.654Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZRainy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Redis设计与实现》笔记</title>
    <link href="http://yoursite.com/2018/12/09/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/</id>
    <published>2018-12-09T08:33:16.000Z</published>
    <updated>2018-12-10T14:39:27.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h1><p>在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8</p><a id="more"></a><h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sds.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用该结构比直接使用C字符串有以下好处：</p><ol><li>获取字符串长度的复杂度从O（n）降低到O（1）；</li><li>杜绝缓冲区溢出，SDS在进行字符串操作时会先检查是否有足够的空间p11；</li><li>减少修改字符串时带来的内存重分配次数，通过free字段，SDS实现了空间预分配和惰性空间释放两种优化策略。对于空间预分配策略而言，如果对SDS修改后len小于1MB，则将分配和len相同长度的未使用空间，如果修改后len大于1MB，则分配1MB的未使用空间；对于惰性空间释放，则是说缩短字符串长度时，并没有真正释放空间，而是将free值增大而已，便于将来可能有的增长操作。另外SDS也提供了相应的API用来真正释放未使用空间。</li><li>C字符串中不能包含空字符，所以也不能保存像图片、音频等二进制数据，但SDS可以，它是二进制安全的。</li><li>兼容部分C字符串函数，如strcasecamp、strcat。</li></ol><p>主要API见p17。</p><h1 id="第三章-链表"><a href="#第三章-链表" class="headerlink" title="第三章 链表"></a>第三章 链表</h1><p>当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除此以外，发布与订阅、慢查询、监视器等功能也用到了链表。</p><h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//adlist.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode* head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode* tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> * ptr,<span class="keyword">void</span> * key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>双端</li><li>无环</li><li>有头尾节点</li><li>有链表长度计数器</li><li>多态，链表节点使用void*指针保存节点值，所以可以保存各种不同类型的值</li></ul><p>API见p21</p><h1 id="第四章-字典"><a href="#第四章-字典" class="headerlink" title="第四章 字典"></a>第四章 字典</h1><p>Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查也是构建在对字典的操作之上的。当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h/dictht</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;<span class="comment">//dictEntry定义也在dict.h中，每个dictEntry保存一个键值对</span></span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">//指向下个hash表节点，形成链表，解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;distEntry;</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引，当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*keyDup)(<span class="keyword">void</span> * privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*valDup)(<span class="keyword">void</span> privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span>* key1,<span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure><p>一般情况下，字典只使用ht[0]哈希表，ht[1]只会在对ht[0]进行rehash时使用。</p><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>Redis计算哈希值和索引值的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字典设置的哈希函数计算键key的哈希值</span></span><br><span class="line">hash=dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">//使用哈希表的sizemask属性和哈希值计算出索引值，根据情况不同，ht[x]可以是ht[0] 或 //ht[1]</span></span><br><span class="line">index=hash&amp;dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>因为dictEntry节点组成的链表没有指向链表尾部的指针，所以在哈希冲突的时候为了速度考虑，程序总是将新节点添加到链表的表头位置（O（1）），排在已有元素前面。</p><p>当字典呗用作数据库或哈希键的底层实现时，Redis使用MurmurHash2算法来计算哈希值。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会增多或减少，为了保证负载因子在一个合理的范围内，则需要对哈希表的大小进行相应的扩展或者收缩，这可以通过rehash来完成。</p><p>步骤如下：</p><ol><li>为ht[1]分配空间，如果是扩展操作，则大小等于第一个大于等于ht[0].used*2的2^n，如果是收缩操作，则大小等于第一个大于等于ht[0].used的2^n；</li><li>将ht[0]中的所有键值对重新计算哈希值和索引值放入ht[1]中；</li><li>释放ht[0]，并将ht[1]置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次做准备。</li></ol><p>当以下条件之一满足时，会开始扩展：</p><ol><li>服务器没有执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于1；</li><li>服务器在执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于5；</li></ol><p>当负载因子小于0.1时，或进行收缩操作。</p><h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>为了避免一次性rehash对服务器性能造成影响，服务器分多次、渐进地将ht[0]慢慢rehash到ht[1]。</p><p>步骤如下：</p><ol><li>为ht[1]分配空间；</li><li>在字典中维持一个索引计数器变量rehashidx，并将它赋值为0，标志rehash开始；</li><li>在rehash期间，每次对字典执行增删改查时，除了执行该操作外，还会顺带将ht[0]中rehashidx上的所有键值对rehash到ht[1]上，当rehash完成后，rehashidx++；</li><li>当ht[0]所有键值对都rehash到ht[1]上时，rehashidx置为-1，结束rehash。</li></ol><p>在rehash期间，删改查会在两个哈希表上进行，而增操作只会在ht[1]上进行。</p><p>主要API见p36.</p><h1 id="第五章-跳跃表"><a href="#第五章-跳跃表" class="headerlink" title="第五章 跳跃表"></a>第五章 跳跃表</h1><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>查找效率平均水平O（logN），最坏O（N），大部分情况下，跳跃表的效率可以和平衡树媲美，所以有些程序可以用跳跃表来代替平衡树。</p><p>Redis使用跳跃表来作为有序集合键的底层实现之一，也被用在集群节点中，其余地方没有再用。</p><p>如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会用跳跃表来作为有序集合键的底层实现。</p><h2 id="跳跃表实现"><a href="#跳跃表实现" class="headerlink" title="跳跃表实现"></a>跳跃表实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点 redis.h/zskiplistNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//层，程序可以通过层来加快访问其他节点的速度，一般来说</span></span><br><span class="line">    <span class="comment">//层越多，访问其他节点的速度就越快</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针，用于从表头向表尾方向访问节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度，跨度越大，相距越远，与遍历操作无关，是用来计算排位的，排位就是在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来的值</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值，可相同</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象，不可相同</span></span><br><span class="line">    robj* obj;</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure><p>多个跳跃表节点就可以组成一个跳跃表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量，不算表头节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> longn length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数，每个层高都是1至32之间的随机数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure><p>API见p45</p><h1 id="第六章-整数集合"><a href="#第六章-整数集合" class="headerlink" title="第六章 整数集合"></a>第六章 整数集合</h1><p>整数集合（intset）时候集合键的底层实现之一，当一个集合只包含整数值元素，并且集合元素数量不多时，Redis就会使用整数集合来作为集合键的底层实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-简单动态字符串&quot;&gt;&lt;a href=&quot;#第二章-简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;第二章 简单动态字符串&quot;&gt;&lt;/a&gt;第二章 简单动态字符串&lt;/h1&gt;&lt;p&gt;在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://yoursite.com/2018/12/08/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/12/08/Redis入门/</id>
    <published>2018-12-08T08:16:18.000Z</published>
    <updated>2018-12-08T09:53:41.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个高性能内存key-value数据库，和其他key-value缓存产品相比有其他特点：</p><ol><li>Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时可以重新加载使用；</li><li>Redis不仅支持简单的key-value类型的数据，同时还提供list，set，hash，zset等数据结构；</li><li>Redis支持数据备份，即master-slave模式。</li></ol><a id="more"></a><p>Redis性能极高，读110000次/s，写81000次/s。</p><p>Redis的所有操作都是原子性的，单个操作是原子性的，多个操作可以支持事务，通过multi和exec指令包起来。</p><p>Redis还支持pulish/subscribe，通知，key过期等特性。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="windows下使用和安装"><a href="#windows下使用和安装" class="headerlink" title="windows下使用和安装"></a>windows下使用和安装</h2><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">下载地址</a></p><ol><li>解压后将文件夹名字改为redis；</li><li>进入redis目录打开cmd窗口，运行以下命令打开redis服务器（win10下的powershell似乎不行，原因不明）<code>redis-server.exe redis.windows.cof</code></li><li>另启一个cmd窗口，启动redis客户端连接服务器<code>redis-cli.exe -h 127.0.0.1 -p 6379</code></li></ol><h2 id="linux下使用和安装"><a href="#linux下使用和安装" class="headerlink" title="linux下使用和安装"></a>linux下使用和安装</h2><p>暂未用，后续用到再记录</p><h1 id="Redis的五大数据结构"><a href="#Redis的五大数据结构" class="headerlink" title="Redis的五大数据结构"></a>Redis的五大数据结构</h1><p>redis存储的是key-value键值对，所谓的五大数据结构指的是value的类型，key一般都是string类型，其中key定义的时候不要过长或过短，最好有统一的命名规范。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string类型是以二进制存储的，这意味着redis的string可以包含任意数据，比如图片或序列化对象，一个string类型的值最大能存储512MB。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>set key value</code></li><li><code>get key</code></li><li><code>getrange key start end</code> 返回key中字符串值从start到end的字符</li><li><code>getset key value</code> 将指定key的值设为value，但返回旧值</li><li><code>mget key1 [key2..]</code>获取多个给定key的值</li><li><code>setex key seconds value</code>设置key和value，并将key的过期时间设为seconds</li><li><code>setnx key value</code>只有key不存在时才设值</li><li><code>mset key value [key value..]</code>同时设置多个k-v对</li><li><code>incr key</code>将key中存储的值加1，若value不能转化成整数，则会报错</li><li><code>incrby key increment</code>将key对应的value加increment</li><li><code>decr key</code></li><li><code>decrby key decrement</code></li><li><code>append key value</code> 在key对应的值后拼接字符串key</li></ol><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash特别适合存储对象，每个hash可以存储2^32-1个键值对（42.9亿）</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>hdel key field1 [field2..]</code>删除key中某个字段</li><li><code>hexists key field</code>判断字段是否存在你</li><li><code>hget key field</code></li><li><code>hgetall key</code> 获得key所有字段和值</li><li><code>hincreby key field increment</code></li><li><code>hkeys key</code>获取key中所有字段</li><li><code>hlen key</code>获取key中字段数量</li><li><code>hmget key field1 [field2..]</code></li><li><code>hmset key field1 value1 [field2 value2..]</code></li><li><code>hset key field value</code></li><li><code>hsetnx key field value</code></li><li><code>hvals key</code>获取key所有值</li></ol><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>字符串列表，可以左右添加，用作消息队列等，列表最多存储2^32-1个元素。</p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>lpop key</code>弹出左边第一个元素</li><li><code>lpush key value1 [value2..]</code>在左边依次插入多个值</li><li><code>llen key</code>获取列表长度</li><li><code>lrange key start end</code>获取列表指定范围内的元素，-1表示倒数第一个元素，依次类推</li><li><code>lrem key count value</code>从左往右删除count个value值</li><li><code>lset key index value</code>通过索引设置值</li><li><code>rpop key</code>弹出右边第一个元素</li><li><code>rpoplpush source dest</code>移除source右边第一个元素，加入到dest最左边</li><li><code>rpush key value1 [value2..]</code></li></ol><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>是字符串的无序集合，元素不可重复，是通过哈希表实现的，所以添加删除查找的时间复杂度都是O(1)，最大成员数2^32-1，支持交并差。</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>sadd key mem1 [mem2..]</code></li><li><code>scard key</code> 获取集合的成员数</li><li><code>sdiff key1 [key2]</code>返回key1和key2的差集</li><li><code>sdiffstore dest key1 [key2]</code>返回key1和key2的差集并存入dest中</li><li><code>sinter key1 [key2]</code>交集</li><li><code>sinterstore dest key1 [key2]</code></li><li><code>sunion key1 [key2]</code>并集</li><li><code>sunionstore dest key1 [key2]</code></li><li><code>sismember key member</code>判断member是否在集合key中</li><li><code>smembers key</code>返回key的成员</li><li><code>smove source dest member</code>将member从source移到dest中</li><li><code>spop key</code>移除并返回集合中的一个随机数</li><li><code>srandmember key [count]</code> 随机返回集合中count个元素</li><li><code>srem key member1 [member2]</code> 移除集合中元素</li></ol><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>除了有序外，和set相同，每个元素会关联一个double的分数，通过该分数排序，zset成员是唯一的，但是成员的分数可以相同。</p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>zadd key score1 member1 [score2 member2..]</code></li><li><code>zcard key</code></li><li><code>zcount key min max</code> 计算在有序集合中指定区间分数内的成员数</li><li><code>zincrby key increment member</code> 在有序集合中对指定成员的分数加上增量</li><li><code>zinterstore dest numkeys key [key..]</code>求numkeys个有序集合的交集并存到dest中</li><li><code>zrange key start end [withscores]</code>返回有序集合指定范围内的值（可带分数）</li><li><code>zrevrange key start end [withscores]</code></li><li><code>zremrangebyrank key start end</code>按索引删</li><li><code>zremrangebyscore key start end</code>按分数删</li><li><code>zrank key member</code>返回有序集合中指定成员的索引</li><li><code>zrem key member [member..]</code></li><li><code>zremrangebylex key min max</code>移除有序集合中给定的字典区间的所有成员</li><li><code>zrangebyscore key min max [withscores] [limit]</code>通过分数返回有序集合指定区间内的成员</li></ol><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis的高性能是因为它所有数据都存在内存当中，要保证重启后数据不丢失，就需要数据持久化。有两种方式——RDB和AOF，可以只用一种，也可以两种结合使用。</p><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><p>在指定的时间间隔内将数据集快照写入到磁盘。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>整个redis数据只包含一个文件，备份方便</li><li>对于灾难恢复，比较容易</li><li>性能最大化，分叉出一些子进程，由子进程进行持久化</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li>不能保证有效性，因为是定时写的</li><li>fork子进程太多</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认持久化方法，在redis.conf中，保存文件是dump.rdb</p><h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>将以日志的形式记录redis的每一次操作，当redis重启时会从该日志重现redis的每一次操作，重构redis。</p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ol><li>能带来更高数据安全性，有三种同步：每秒同步、每个修改同步、不同步</li><li>对日志文件写入采用append模式，所以即便写入的时候出错，也不会影响日志，可以通过redis -check -aof来解决数据一致性</li><li>如果日志过大，可以自动重写，在重写切换的时候可以更好地保证安全性</li><li>日志文件格式清晰</li></ol><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ol><li>对于相同数据集而言，aof文件比rdb文件大</li><li>aof执行效率上会低于rdb</li></ol><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>不是默认方式，也在redis.conf中，查找到appendonly no这一行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;p&gt;Redis是一个高性能内存key-value数据库，和其他key-value缓存产品相比有其他特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时可以重新加载使用；&lt;/li&gt;
&lt;li&gt;Redis不仅支持简单的key-value类型的数据，同时还提供list，set，hash，zset等数据结构；&lt;/li&gt;
&lt;li&gt;Redis支持数据备份，即master-slave模式。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>《弗雷的小说写作坊-飞起来》笔记</title>
    <link href="http://yoursite.com/2018/10/29/%E3%80%8A%E5%BC%97%E9%9B%B7%E7%9A%84%E5%B0%8F%E8%AF%B4%E5%86%99%E4%BD%9C%E5%9D%8A-%E9%A3%9E%E8%B5%B7%E6%9D%A5%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/29/《弗雷的小说写作坊-飞起来》笔记/</id>
    <published>2018-10-29T14:58:23.000Z</published>
    <updated>2018-11-15T09:51:19.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、唤醒虚构梦境"><a href="#一、唤醒虚构梦境" class="headerlink" title="一、唤醒虚构梦境"></a>一、唤醒虚构梦境</h1><p>1、要展示，不要叙述。小说家试图去“展示”，通过感官细节上的暗示将读者拖入虚幻的梦境。    </p><p>2、同情是一种“认可”。要让观众产生同情，得先让他们对角色产生同情感，这是很关键的一点。<br><a id="more"></a><br>3、同情是深入故事的途径，有了同情，读者就能从内心真正感受到故事的情感，没有产生同情则说明读者在读故事时没有参与到故事的情感中来。获得了读者的同情之后，写作者应该进一步深入虚构梦境的创作，让读者认可你创造的角色。</p><p>4、只有当读者不仅同情角色的困境，还支持他的目标和勇气，并强烈希望这个角色能实现他的目标时，他们才能说这个角色得到了读者的认同。</p><p>5、移情是一种比同情心更强烈的情感。个人感觉移情就是靠细节描写。激发情感的感官细节，能够通过暗示的力量激发读者的情感，抚慰读者的同理心。</p><p>6、身临其境时，读者进入一种梦境，完全进入虚幻的世界里，现实世界消失了。这就是小说家的目标：带领读者沉浸在他们所塑造的角色世界中。</p><p>7、怎样使你的读者从同情、认同、移情到完全沉浸其中呢？答案就是：内心冲突。</p><p>8、内心冲突可以被看做角色心中两种“声音”之间的战争：一个是理智，另一个是情感，或者两种情感之间的冲突。</p><h1 id="二、设置悬念还是循规蹈矩——这是一个问题"><a href="#二、设置悬念还是循规蹈矩——这是一个问题" class="headerlink" title="二、设置悬念还是循规蹈矩——这是一个问题"></a>二、设置悬念还是循规蹈矩——这是一个问题</h1><p>1、“担心和好奇”也就是我们所说的给读者设置悬念。《韦氏词典》是这样定义悬念的：悬念就是一种悬而未决的状态。</p><p>2、故事问题是一种让读者好奇的策略。它们一般不是以问题的形式出现，而是以需深入理解的叙述、亟待解决的问题或是灾难的预测等类似的形式出现。</p><p>3、不管是短篇小说作家还是长篇小说作家，都应该尽早呈现故事问题，通常是在开头的第一句或第二句。p33</p><p>4、因此，一篇很好的小说的开篇，在最开始就要像大师一样，以一个强有力的故事问题姥姥拴住读者，让他们想一直读下去。《韦氏词典》列出了悬念的第二个定义：悬念是一种不确定的状态，就像等待一个决定，通常伴随着焦虑或担忧。</p><p>5、首先，悬念是一种好奇，作者提出让读者好奇的问题。其次，作者将读者置于一种焦虑或担忧的状态，使读者又不单单局限在好奇的层面上。</p><p>6、为了让读者感到焦虑和担忧，作者首先必须创作一个能让人产生共鸣的任务，也就是大多数读者都希望有好结局的人物。</p><p>7、点燃导火索是设置悬念最有力的技巧，它意味着将有可怕的事情发生，并且在一个约定的时间内，故事中的人物必须要阻止，但这并不是一件简单的事情。</p><p>8、其实悬念就是一个提出故事问题、将能产生同情感的人物设置在一个充满威胁的情境中，然后再点燃导火索的过程。</p><h1 id="三、懦夫或疯子：真正令人难忘的人物"><a href="#三、懦夫或疯子：真正令人难忘的人物" class="headerlink" title="三、懦夫或疯子：真正令人难忘的人物"></a>三、懦夫或疯子：真正令人难忘的人物</h1><p>1、以一个懦弱的人物开篇没有错，选主妇或会计作为人物也没有错。问题不在于主角是否懦弱，而在于他或她是否麻木不仁、不会改变。</p><p>2、作者一定要避免自己笔下出现麻木不仁的人物。</p><p>3、人物必须有真实人物的独特性，他们必须跟一般人物形成对比，对比中产生了个性。</p><p>4、创作一个古怪的人物是有趣的。一种方式就是简单地塑造一个特征，然后再把这个特征夸大。另外一种方式就是赋予人物一种颇有偏差的人生哲学观。</p><p>5、人物之间不仅应该形成对比反差，还应该跟各自所在的情节环境有对比。比如乡巴佬进城、社会名流进入监狱。</p><p>6、人物的主导情感是人物的主要驱动力，是人物内心动力和推力的总和。</p><p>7、文学作品中，一些最难忘的人物都具有双重性。事实上，具有双重人格的人物就是一个身体里面有两种截然不同性格的人。</p><p>8、为了让人物值得深入了解，你要创造一个耐人寻味的背景环境，你的人物要特立独行、见解独到。你可以把他们塑造成奇葩怪物，让人物相互之间、人物与背景环境之间形成对比与反差，或者再给他们加上一个双重性格。塑造人物时可以大胆尝试，让读者耳目一新。</p><h1 id="四、预设的再讨论之第一部分：概念的释义与简化"><a href="#四、预设的再讨论之第一部分：概念的释义与简化" class="headerlink" title="四、预设的再讨论之第一部分：概念的释义与简化"></a>四、预设的再讨论之第一部分：概念的释义与简化</h1><p>1、在小说创工作中，再没有比预设更有力的概念了。若你在脑海里以强烈的预设来编织你的故事，那么你的小说将中心突出并富有戏剧性，这样的作品将吸引你的读者从头读到尾。</p><p>2、预设是发生在角色身上事件的叙述，也是故事里核心冲突的结果。</p><p>3、我的故事应该是写人们生活里的某些方面，不是所有方面。</p><p>4、寓意是故事要教给读者的东西。把主题定义为小说里反复出现的想法，是人性中受检验或探讨的某一面。预设就是发生在角色身上事件的叙述，也是故事里动作的结果，它既不是寓意，也不是主题。</p><p>5、小说有三种预设：（1）连锁反应式；（2）反向式；（3）情景式。</p><h1 id="五、预设的再讨论之第二部分：小说家的魔杖"><a href="#五、预设的再讨论之第二部分：小说家的魔杖" class="headerlink" title="五、预设的再讨论之第二部分：小说家的魔杖"></a>五、预设的再讨论之第二部分：小说家的魔杖</h1><p>1、如果没有讽刺与意外的事件发生，角色们自身也没有得到成长，那么显然这个故事不值得一写。</p><p>2、问自己几个相关问题：故事的预设被证明了吗？是否有多余的情节？是否有讽刺或意外的事情？故事角色是否有成长或升华？这个故事值得一写吗？</p><p>3、多预设小说。每个故事都有一个预设，一本小说可以有一个以上的故事，因此也可以有一个以上的预设。</p><p>4、先看几部电影，从预设的角度描述影片内容；接下来看看在不同预设的指引下故事会发生怎样的变化；下一步便是在预设的指导下开始创作。</p><h1 id="六、语气或“谁”，谁在讲故事"><a href="#六、语气或“谁”，谁在讲故事" class="headerlink" title="六、语气或“谁”，谁在讲故事"></a>六、语气或“谁”，谁在讲故事</h1><p>1、强有力的叙述语气给读者一种感觉，即作者对他的叙述了如指掌。在非虚构作品中，强有力的叙述语气通过对语气和事实的支配来实现；而在小说中，则是由对语气和细节的支配来达成的。</p><p>2、作者（叙事者）不应该隐身。</p><p>3、所谓的第一人称比第三人称更亲切、更富色彩的定律毫无根据。事实上，不管是用第一人称还是第三人称，都能实现小说的价值观、表现亲密度、渲染气氛、烘托色彩。</p><h1 id="七、作者与读者合同的订立：不要承诺樱草却交付泡菜"><a href="#七、作者与读者合同的订立：不要承诺樱草却交付泡菜" class="headerlink" title="七、作者与读者合同的订立：不要承诺樱草却交付泡菜"></a>七、作者与读者合同的订立：不要承诺樱草却交付泡菜</h1><p>1、除了小说内容精彩之外，你的读者期待的还是一部常规小说——类型小说、主流小说、纯文学小说。</p><p>2、读者一开始就会对你的预设进行揣测，如果你要履行你在合同中的义务，预设的证实便必不可少。</p><p>3、按照与读者拟定合同的要求，你必须公平公正地向读者履行在合同中的义务。这就是说，如果你写的是一本推理小说，你就要向读者提供一个智胜侦探的公平机会；换言之，你要向读者提供所有的事实、线索等信息。</p><p>4、要不遗余力地避免作者帮助故事中的人物解决难题。你要必须发誓要将老生常谈统统抛弃、要对欠佳的情节退避三舍。</p><h1 id="八、七个致命的错误"><a href="#八、七个致命的错误" class="headerlink" title="八、七个致命的错误"></a>八、七个致命的错误</h1><p>1、第一个错误——胆小。要成为一名作家需要勇气和胆量。你得战胜你的胆小和怯懦，勇敢面对这个坚强的作家团队的批评。其中的一个办法就是忍耐，还可以学会自我朝服，另一个途径就是绝不能让大家讨论你为何要这样创作，不要对自己的作品做任何辩解。</p><p>2、创作中的另一种胆小就是不愿意冒险。不要害怕尝试实现你的效果。</p><p>3、一个作家必须要自我推销，否则他注定是一个无名小卒。</p><p>4、第二个错误——试图成为一个“文人”。这些人的问题在于：他们不是尝试着去掌握创意写作的基本原则，也不是去学习如何让自己的文学作品独具匠心、引人注目，而是把某一个文学巨人当成神。</p><p>5、第三个错误——自我写作。要以读者为中心，而不是以自我为中心，要吸引读者、循循善诱、将读者带进故事中来、通过创造情感试金石来构建读者和故事之间的桥梁、让读者认可故事人物。要让你的读者身心愉悦，而不是自我满足。</p><p>6、客观关联物指的是读者有必要了解和经历故事中引起他们情感共鸣的行为。</p><p>7、第四个错误——不会重构故事。尽管改写故事情节是一项很难掌握的技能，但如果你学不会，就将成为你创作时致命的错误。</p><p>8、第五个错误——不能坚持信念。一旦信念破灭了，作家就不可能再回到以前写作时的状态。</p><p>9、第六个错误——不当的生活方式。p191</p><p>10、第七个错误——没法创作。灵感枯竭的作家还有另一个名字——胆小鬼，他害怕的是作品没能符合自己的标准，然而又有谁的作品符合过呢？p197</p><h1 id="九、激情写作"><a href="#九、激情写作" class="headerlink" title="九、激情写作"></a>九、激情写作</h1><p>1、这是小说家的黄金时代。</p><p>2、除了写作，没有更好的方法可供你在地球上消磨时光了。</p><p>3、你必须仔细审视你的内心，并找到生活中你最在意的事物，这样你才能实现你真正的愿景。</p><p>4、写一份写作目的宣言书很有必要，例如，如果你将作家当做你一生的职业，你想要获得怎样的成就；就你所写的某本书而言，你想借此得到什么。等等。</p><p>5、写作是一个分享经历、传达人生信条的过程，没有所谓的“纯属娱乐”一说。你写作的内容无论是在情感层面还是精神层面上都应有极大的影响力，如果你发挥得好，这种影响力会深入骨髓。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、唤醒虚构梦境&quot;&gt;&lt;a href=&quot;#一、唤醒虚构梦境&quot; class=&quot;headerlink&quot; title=&quot;一、唤醒虚构梦境&quot;&gt;&lt;/a&gt;一、唤醒虚构梦境&lt;/h1&gt;&lt;p&gt;1、要展示，不要叙述。小说家试图去“展示”，通过感官细节上的暗示将读者拖入虚幻的梦境。    &lt;/p&gt;
&lt;p&gt;2、同情是一种“认可”。要让观众产生同情，得先让他们对角色产生同情感，这是很关键的一点。&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《C++并发编程实战》笔记</title>
    <link href="http://yoursite.com/2018/10/25/%E3%80%8AC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/25/《C-并发编程实战》笔记/</id>
    <published>2018-10-25T14:36:33.000Z</published>
    <updated>2018-10-25T14:44:04.053Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action" target="_blank" rel="noopener">书籍中文版翻译地址</a></p><p><a href="https://github.com/bsmr-c-cpp/Cpp-Concurrency-in-Action" target="_blank" rel="noopener">书中源码地址</a></p><h1 id="一、你好，C-的并发世界！"><a href="#一、你好，C-的并发世界！" class="headerlink" title="一、你好，C++的并发世界！"></a>一、你好，C++的并发世界！</h1><p>1、最简单和最基本的并发，是指两个或更多个独立的活动同时发生。</p><p>2、为性能而使用并发就像其他所有优化策略一样：它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。<br><a id="more"></a><br>3、C++多线程历史：C++98标准不承认线程的存在，并且各种语言要素的操作效果都已顺序抽象机的形式编写。不仅如此，内存模型也没有正式定义，所以没办法在缺少编译器相关扩展的情况下编写多线程应用程序。但C++11新标准改变了这一切，主要模型是Boost中的线程库。</p><p>4、管理线程的函数和类在头文件<thread>中，而保护共享数据的函数和类在其他头文件中声明。简单例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;//添加头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span><span class="comment">//每个线程都必须有一个初始函数，新线程的执行将从这里开始，对于主线程来说是main()。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;<span class="comment">//将hello函数作为新线程的初始函数，</span></span><br><span class="line">t.join();<span class="comment">//使调用线程等待t相关联的线程运行结束，少了这一行会报错，因为main可能就会在新线程运行之前结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></thread></p><h1 id="二、线程管理"><a href="#二、线程管理" class="headerlink" title="二、线程管理"></a>二、线程管理</h1><p>1、使用C++线程库启动线程，可以归结为构造thread对象。</p><p>2、构造对象时要避免“最令人头痛的语法解析”问题，如：<br>std::thread    my_thread(background_task());<br>这里相当与声明了一个名为my_thread的函数，这个函数带有一个参数(函数指针指向没有参 数并返回background_task对象的函数)，返回一个std::thread对象的函数，而非启动了一个线程。<br>可使用如下写法避免：<br>std::thread    my_thread((background_task()));        //    1<br>std::thread    my_thread{background_task()};        //    2<br>或用lambda表达式：<br>std::thread    my_thread([]{<br>        do_something();<br>        do_something_else(); })</p><p>3、启动了线程，你需要明确是要等待线程结束(加入式)，还是让其自主运行(分离式)。</p><p>4、使用一个能访问局部变量的函数去创建线程是一个糟糕的主意(除非十分确定线程会在函数完成前结束)。</p><p>5、通常称分离线程为守护线程(daemon    threads),UNIX中守护线程是指，没有任何用户接口，并且在后台运行的线程。</p><p>6、向线程函数函数传递参数。P29</p><p>7、需要在线程对象被析构前，显式地等待线程完成，或者分离它；进行复制时也需要满足这些条件(说明：不能通过赋一个新值给std::thread对象的方式来”丢弃”一个线程)。</p><p>8、    std::thread::hardware_concurrency()在新版C++标准库中是一个很有用的函数。这个函数将返回能同时并发在一个程序中的线程数。</p><p>9、线程标识类型是std::thread::id，可以通过两种方式进行检索。第一种，可以通过调 用std::thread    对象的成员函数get_id()来直接获取。如果std::thread对象没有与任何执行线程相关联，get_id()将返回std::thread::type默认构造值，这个值表示“没有线程”。第二种，当前线程中调用std::this_thread::get_id()(这个函数定义在<thread>头文件中)也可以获得线程标识。</thread></p><h1 id="三、线程间共享数据"><a href="#三、线程间共享数据" class="headerlink" title="三、线程间共享数据"></a>三、线程间共享数据</h1><p>1、不变量通常会在一次更新中被破坏，特别是比较复杂的数据结构，或者一次更新就要改动很大的数据结构。</p><p>2、C++中通过实例化std::mutex    创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。C++标准库为互斥量提供了一个RAII语法的模板类std::lack_guard，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。</p><p>3、具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书籍中文版翻译地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bsmr-c-cpp/Cpp-Concurrency-in-Action&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书中源码地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、你好，C-的并发世界！&quot;&gt;&lt;a href=&quot;#一、你好，C-的并发世界！&quot; class=&quot;headerlink&quot; title=&quot;一、你好，C++的并发世界！&quot;&gt;&lt;/a&gt;一、你好，C++的并发世界！&lt;/h1&gt;&lt;p&gt;1、最简单和最基本的并发，是指两个或更多个独立的活动同时发生。&lt;/p&gt;
&lt;p&gt;2、为性能而使用并发就像其他所有优化策略一样：它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。&lt;br&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>《弗雷的小说写作坊-秘境游走》笔记</title>
    <link href="http://yoursite.com/2018/10/10/%E3%80%8A%E5%BC%97%E9%9B%B7%E7%9A%84%E5%B0%8F%E8%AF%B4%E5%86%99%E4%BD%9C%E5%9D%8A-%E7%A7%98%E5%A2%83%E6%B8%B8%E8%B5%B0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/10/《弗雷的小说写作坊-秘境游走》笔记/</id>
    <published>2018-10-09T16:03:43.000Z</published>
    <updated>2018-10-28T15:36:09.297Z</updated>
    
    <content type="html"><![CDATA[<p>一部戏剧性小说具有如下特点：它以一个中心人物即主人公为焦点，该主人公面临困境；这个困境发展成一种危机；这种危机通过一系列纠纷构建成小说的故事高潮；在高潮部分危机化解。p13<br><a id="more"></a></p><h1 id="一、所有的秘密就在于“人物”"><a href="#一、所有的秘密就在于“人物”" class="headerlink" title="一、所有的秘密就在于“人物”"></a>一、所有的秘密就在于“人物”</h1><p>1、如果你不能塑造出在读者心目中活灵活现的人物形象，那你就不可能创作出令人拍案叫绝的劲爆小说。小说中的人物形象无论如何不能等同于现实中有血有肉的活人本身，要更加不同寻常，但要依然可以认识、理解。p3<br>小说人物是对现实人物的抽象描写，他展现现实生活中原型的本质，但并不是原型的全部。</p><p>2、小说人物有两种类型：扁平人物和圆形人物。<br>圆形人物三位一体：生理维度、社会学维度以及心理维度。</p><p>3、对大多数作者来说，包括所有的写作初学者，为角色写传记是小说创作中最必要也最重要的一步。</p><p>4、两个主要因素决定你在小说创作中对人物特征的取舍：打破原型、精心编排。</p><p>5、为角色写传记的时候，应寻找能影响故事中角色的情感和行为的因素。</p><p>6、塑造一个鲜活、不刻板的人物形象，其秘诀在于将人物身上那些读者没能预料到在同一个角色里会见到的特质糅合起来。</p><p>7、无论何时，你的主人公都面临这些要紧的决定。再问问自己关于能力极限的两个问题：第一，他真的会这么干吗？第二，他还能做其他更加巧妙、更戏剧化、更令人惊奇或者更有趣的事情吗？</p><h1 id="二、杰作生成三大妙法：冲突、冲突、冲突。"><a href="#二、杰作生成三大妙法：冲突、冲突、冲突。" class="headerlink" title="二、杰作生成三大妙法：冲突、冲突、冲突。"></a>二、杰作生成三大妙法：冲突、冲突、冲突。</h1><p>1、如果没有了由矛盾冲突所产生的紧张和刺激，即使世界上最精心设计的情节也是不起作用的。</p><p>2、主要人物+目标+对抗性因素=冲突。</p><p>3、让你的人物处于熔炉之内。熔炉是一个能够将人物聚集在一起像物品一样加热的容器。</p><p>4、内心冲突。假设你的主人公被召唤上战场，首先要确定他有强而有力的理由让他极不情愿参战。</p><p>5、戏剧冲突的模式：静止型、跳跃型和渐进型。P57<br>静止型冲突是指任何一种不发生变化的戏剧冲突。<br>跳跃型冲突时指在没有充足动因或过渡阶段的情况下，从一个紧张强度跃进到另外一个。<br>在顶级的戏剧性小说里，冲突是循序渐进的，渐进型冲突的秘密是从进攻和反击的角度来思考冲突。</p><p>6、如何确保拥有渐进型冲突？<br>第一、经常在脑海里用渐进型冲突构思小说。<br>第二、只有当人物发展变化时，冲突才可以升级；当冲突升级时，人物随之变化发展。<br>第三、为了确保你能有一个逐渐升级的冲突，在场景开始和结束的时候你都应该关注人物的情绪波动状况。人物在每个场景中都应该有循序渐进的变化。</p><p>7、核心矛盾：人类反抗自然、人类反抗人类、人类反抗社会、人类反抗自己、人类反抗命运。</p><p>8、类型，文学的分隔板。要深入了解那些传统、惯例和不同流派的类型。一旦熟知那些类型，就会知道在这些类型中的前提假设是什么。如果你把矛盾冲突看成小说写作的火药，那前提就是加农炮。</p><h1 id="三、前提很重要，小说没有前提就如同无桨划船"><a href="#三、前提很重要，小说没有前提就如同无桨划船" class="headerlink" title="三、前提很重要，小说没有前提就如同无桨划船"></a>三、前提很重要，小说没有前提就如同无桨划船</h1><p>1、在一本小说中，写作前提只有在小说的特殊场景中才能够成为真实。</p><p>2、故事的前提是故事角色在核心矛盾发展下各自的最终命运的简单表现。</p><p>3、寻找自己小说的前提，但不要从一个前提展开故事，而是用人物。</p><p>4、一个好的前提应该包含一个可以通过矛盾冲突带出结论的人物。要记得三C理论：人物(Character)、冲突(conflict)以及结论(conclusion)。</p><p>5、选择性是作家作品的关键部分，选择性即在一部小说中选择囊括什么、忽略什么。</p><p>6、如果没有与整体故事发生如果、而且、但是之类的关系，只能删去。</p><p>7、人物角色、冲突还有前提是砖块和水泥，它们构建了故事。</p><h1 id="四、讲故事的顺序"><a href="#四、讲故事的顺序" class="headerlink" title="四、讲故事的顺序"></a>四、讲故事的顺序</h1><p>1、所有的故事都是事件的叙述，但却不止如此。</p><p>2、故事是对一系列有因果关系的事件的叙述，这些事件涉及有价值的、随着时间变化而变化的人物。</p><p>3、在一个戏剧性故事里，人物斗争是唯一值得一读的东西。人物因为遭受磨难而发生了改变，这样的事件的叙述才可以称其为一个故事，但还不能算是一个戏剧性故事。戏剧中，人物必须要抗争。</p><p>4、小说中的人物面临的困境叫做“故事悬念”，故事悬念使读者愿意继续读下去寻找答案，它是你上大餐前的开胃菜。</p><p>5、现状向读者展示了在核心冲突发生前小说的世界，它是上主菜前的汤和沙拉。</p><p>6、可以从故事开始前开篇，也有在另一种选择。p102但最好在故事开始前开篇，读者就会了解人物并同情他。你可以将标志着故事开始且发生于现状中的改变戏剧化。</p><p>7、阶段表是一个记载故事巧合的详细的计划表。使用阶段表是作者掌控故事的一个方法，可以将之看做一个蓝图。</p><p>8、故事的事件、冲突能影响读者，因此人物应对冲突时，会随着故事的推进而改变。</p><h1 id="五、冲突上升或证据存在于前提中"><a href="#五、冲突上升或证据存在于前提中" class="headerlink" title="五、冲突上升或证据存在于前提中"></a>五、冲突上升或证据存在于前提中</h1><p>1、将故事的高潮看做目标，其他的故事情节看作飞行的射线。</p><p>2、故事就是斗争。主人公遇到困境、受到攻击时，你的小说就开始了。人物与困境斗争，困境变成危机；危机发展到一定程度，急需解决；采取行动后，带来了高潮。结果要么令人满意，要么令人不满，但是危机结束了。无论如何，整个现状发生了改变，不管事态发展如何，进化都是必然。</p><p>3、尽管在高潮时刻核心冲突得到解决，但这并没有验证前提。前提是由结合成一个整体的冲突和化解证明的。</p><p>4、每一个故事的主要人物都有自己的命运。因此，每个角色都有各自的前提。</p><p>5、如何构成一个伟大的高潮？第一，寻找惊喜；第二，激发强烈的情感；第三，在诗意的正义法院宣布判决；第四，发掘人物新的一面；第五，高潮——解决应使小说完整。</p><h1 id="六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意"><a href="#六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意" class="headerlink" title="六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意"></a>六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意</h1><p>1、人物视角是该任务所有意见的集合，包括偏见、喜好、态度。他的视角决定了他怎样解读世界。</p><p>2、视角分类：客观视角、修正的客观视角、第一人称主观视角、全知视角、有限的全知视角。</p><p>3、叙述者独特的说话方式叫做叙述声音。</p><p>4、小说家是一个魔术师，向读者编织一个咒语。为了催动周瑜，小说家用了一个叫做“认同”的魔术。</p><p>5、一旦一种情感在故事的开头被激起，人物应该立即被置于不断发展的危机中。如果你已经感动了读者，他们就会感兴趣，但是，真正的认同只能发生在人物面临选择时，读者也能参与到决策过程中。</p><p>6、倒叙是经常被错用和滥用的小说技巧。读者觉得大部分倒叙都难以忍受，但还有许多新手像疯了一样倒叙。倒叙可能只是愚蠢的作者想要避免冲突的手段。</p><p>7、什么时候倒叙是绝对必需的呢？如果你的人物被置于一个境遇中，他的行为与他在故事发生的这个时刻之前的行为完全相反，那么它是必要的。在你使用倒叙之前，问问自己在当下的小说中采用冲突是否能达到同样的效果。</p><p>8、伏笔并不是冲突，而是冲突的迹象。伏笔是提出故事悬念的艺术。伏笔是一个预示，如果作出了预示而没有实现它的话，你就是在欺骗读者。</p><p>9、如果有无聊又冗长的叙述，在其中加伏笔。</p><p>10、象征符号是除了事物本身的意义外对一些人有其他意义的事物。</p><p>11、如果一位人物有任务和目标，它应该符号化。</p><h1 id="七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧"><a href="#七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧" class="headerlink" title="七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧"></a>七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧</h1><p>1、直白对话表达的恰好是人物所想，不用费力去描述人物如何表示反对、使用诡计、说谎、表现机智等。成功的对话含蓄地表达人物的意志。</p><p>2、戏剧性小说有三种模式：戏剧化叙事模式、场景叙事模式、半场景叙事模式。在戏剧化叙事模式中，叙事者叙述相关情节，展现角色成长经历，运用内部矛盾，但这些都是以一种总结性方式来叙述的；场景叙事模式是，在某一个场景中，叙述者描述所发生的情节；半场景叙事模式是一种被打断的戏剧性叙事，里面糅合着部分场景。</p><p>3、戏剧性创作需要不断激化的矛盾，这种矛盾不仅对整个戏剧性故事来说有必要，而且对戏剧性场景也有必要。</p><p>4、很多情况下全场景并不可取，，因为在场景开头时矛盾的力道通常不足以吸引读者。而跳入其他场景可以加速小说剧情发展，使你的读者参与矛盾激化的过程。写小说时，你要考虑每一个场景，问问自己哪些场景可以剪掉，以便加快小说节奏。</p><p>5、好的对话应该是置于矛盾中的、间接的、机智的、丰富多彩的。p172~p176的例子。</p><p>6、对每行对话思考以下几个问题：是不是有冲突？是不是太陈腐？委婉地说会不会更好？台词是否已经尽量做到巧妙、生动了？</p><p>7、动态散文体小说有三条戒律：具体、有感染力、富有诗意。具体：概括性的话要变具体，加入细节。有感染力：带起多种感官上的感受：视觉、嗅觉、味觉、触觉以及听觉甚至心理上的感觉。富有诗意：富有诗意但又不要太诗意，诗意意味着用修辞来实现不错的效果。</p><p>8、练习比喻，每次叙述时，都要试着尽可能多地运用恰当的修辞。</p><p>9、总的来说，散文体小说应该有时间跨度，色彩斑斓，结构缜密（具体而明确，不是泛泛之谈）；能够传递一种动作感；能够调动七种感官——听觉、视觉、触觉、味觉、嗅觉、心灵感和幽默感。</p><h1 id="八、修改：最后的煎熬"><a href="#八、修改：最后的煎熬" class="headerlink" title="八、修改：最后的煎熬"></a>八、修改：最后的煎熬</h1><p>1、几乎每个人都能写东西，但是只有作家知道如何修改，只有这种能力才能使业余作家提升为专业作家。</p><p>2、让作家评估自己所写的内容是极其困难的，除非他们知道初稿的亮点和缺陷，否则不可能将初稿变为成品。</p><p>3、解决问题的一个方法是找得到一个作家群，征询他们的意见。有三种作家群：吹捧派、文学派和抨击派。抨击派是唯一一个有价值的群体。</p><p>4、没有抨击性作家群的话，自己做自己的评论家，并寻求朋友的帮忙，可以不告诉他们是你写的，让他们没有道德负担，让他们说清楚每一个不好的地方，确切说出他们不喜欢的点——角色、环境、节奏等等。</p><p>5、为评论者们提供一张评论要素清单，让他们列举你故事中的哪些要素得到了“最专业的处理”。也可以将小说中的每一个场景按等级排列在一条兴趣曲线上，让他们给每一个场景打分，分值从1到10。</p><p>6、可以请读者们看完后给你复述这个故事，他们遗漏的部分可能就是无聊得犯困的部分。</p><p>7、可以将你的小说录到录音机里，然后播放它。或者试着将小说从头到尾讲给朋友听，你略去的和那些讲述起来笨嘴拙舌的地方能帮你定位缺陷之处。如果把草稿搁置一段时间再分析的话，你会更容易、更客观地进行分析。</p><p>8、问自己几个问题：1、你是否已经证明了自己的前提？2、是否已经使读者对人物产生共鸣？3、有没有反面人物，他们都表现得淋漓尽致吗？等等p199</p><h1 id="九、小说写作之道"><a href="#九、小说写作之道" class="headerlink" title="九、小说写作之道"></a>九、小说写作之道</h1><p>1、什么最重要？并不是天赋。是自我训练、顽强的决心、坚韧不拔的毅力。天赋只会带来阻碍，因为如果拥有天赋，你就会认为写小说很容易。</p><p>2、完成一篇小说的秘诀是规律性。每天都要坚持在同一时间写作。你必须对在那个时间段的所有其他事情、所有干扰你创作的事情说“不”。</p><p>3、灵感丧失时，你的行为将你与那些声称“我将要写一本书”的人区分开来。</p><p>4、如果你真的思路受阻，最重要的是记住，作家都会经历瓶颈期，这没什么好担心的。你要做的就是让这些刺激因素消失。你可以重新打出自己已经写好的内容，从而起到热身的作用。也可以放热门音乐。不管做什么，只要别推迟写作就行。继续敲打键盘，即使写出的是官样文章也行。只要坚持写，你就会度过写作的瓶颈期。如果离开打字机，你永远也无法走出瓶颈，并且在下一次瓶颈到来的时候更容易重蹈覆辙。</p><p>5、不要讲其他影响创作的情绪与作家的瓶颈期混淆。真正的作家瓶颈期有四个基本原因：对你的人物不够了解，试图将编辑和写作同时进行，害怕失败，害怕成功。解决办法见p214</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一部戏剧性小说具有如下特点：它以一个中心人物即主人公为焦点，该主人公面临困境；这个困境发展成一种危机；这种危机通过一系列纠纷构建成小说的故事高潮；在高潮部分危机化解。p13&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>未完待续-贰</title>
    <link href="http://yoursite.com/2018/05/31/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E8%B4%B0/"/>
    <id>http://yoursite.com/2018/05/31/未完待续-贰/</id>
    <published>2018-05-31T09:36:46.000Z</published>
    <updated>2018-05-31T09:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2017年1月21日，2018年5月31日上传保存。）</p><p>有的时候是看见一句话。<br>有的时候是听见一首歌。<br>有的时候是站在老地方。<br>有的时候是见到老朋友。<br>有的时候是静在沉默里。<br>但更多的时候是在呼吸里。<br>想你。<br>想我是怎么渐渐失去了你。<br>我的匆匆时光。<br><a id="more"></a></p><p>是2013年吧，我结束高考，怀揣着一份不满意的成绩，来到我满意的城市，上了一所不甚满意的大学。依稀还记得军训时我曾独自坐在宿舍靠窗的位置，透过窗外那颗不知年岁几何的枇杷树树隙，看蓝天被枝条切割成零碎不一的图案，偶尔被阳光刺到，就像是斑驳的万花筒晃了我的眼。<br>江南曾在《此间的少年》里写他当年北大宿舍窗外是一棵梧桐树，静若仙女的王语嫣某个清晨从树下走过，就轻轻带走了碰巧趴在窗前的段誉的心。我的学校比北大差远，枇杷树也不如梧桐树有意境，男生宿舍区里的枇杷树下更不会有女生走过，但也曾无数次听到这棵枇杷树在雨夜里的交响曲，也曾见过枇杷成熟的季节里男生们偷着竹竿背着宿管大妈打落果实，短裤背心，摸滚打爬。<br>就这么一晃眼，2017便已到了，他笑眯眯地说着：“你终于来了”，似乎等了我们很久，却又偷偷摸摸地把沉重压上我们的肩头。<br>嘿，又要毕业了。<br>谁能想到这么快呢？</p><p>2015年8月的时候，我写了《未完待续1》，到如今已经一年半的时间，大学本科还剩下最后半年的时间。在这个春节之前我犹豫了很久，最终决定还是写下《未完待续2》，大概没有《未完待续3》了吧，也可能会有，也可能换一种形式……比如《梧桐树下的少年》这种形式（微笑）？<br>兴许是人老了记忆衰退，也或者是大三之后事情变多，很少有之前所写的大块事件，记忆里的事情大多琐碎，就像那年夏天我透过那棵枇杷树看到的蓝天。<br>记不起事情的时候我就会默默翻开自己的说说，沿着时间顺序阅读下去，有些说说早已忘了为何而发，那应该是些惹人冲动的事，时间已经抚平就无须再刨根问底，依然记得的那些才是重要的。</p><p>2015年八月，时间在刚发完《未完待续1》后不久，我受ZC等人挑唆曾入过《天涯明月刀》的坑，着着实实地玩了一月有余。<br>天涯、明月、树影、孤鸟的加载界面出现的时候，我心中似乎有根弦绷紧，仿佛一扇大门打开，刀光剑影、快意恩仇的世界展现，带着丝丝凛意。<br>如今游戏早已弃坑，但那时我选择了唐门，角色名为牧南山，紫袍荡荡，折扇翩翩。<br>是的，他是《南山北海》的主角原型，是我笔下第一个武侠人物。我倾注了不少心血，最终把他写成那个天下第一、唐门无双、为亡妻与天下敌的绝世高手！虽然在游戏里他被一个叫“心有林西”的神威用一杆枪戳得不要不要的……好吧我打不过你我还写不过你？<br>没有玩游戏的天赋，真是不能不认。<br>顺带提一句，我女朋友也被我拉进了坑……<br>对，你们猜的没错，她游戏的ID就是北海，北海谷。<br>南山有墓，北海有谷。<br>如果还有下一篇武侠，可能就在北海。</p><p>我本想把大学的事情都留到一本可能名为《梧桐树下的少年》这样中二名字的书中去，可是当时间来到2015年九月后，即大三上半学期时，有些事却还是想稍微提一提。<br>这一学期，我接替学长的位置，荣幸担任院科协某部部长一职。<br>我曾经仔细想过，为什么生性内向腼腆的我会毫不犹豫接受任职？<br>可能是为了锻炼自己，可能是为了那几点加分，自然也可能是为了年轻可人的学妹们啊！<br>不过现在，我感觉应该找到了答案。<br>很简单，只是为了不后悔吧。<br>迎新那天，面对满满一屋子学弟学妹，上台介绍的时候，我的双腿还在微微打颤，语言也不慎利索，自己都觉得已经搞砸了。可是最后的结果还不错，竟然成功地骗到，哦不，招到十几位新学员，最关键的是……学妹整整一半多哩！<br>也是那时，我才真正走进科协这个大家庭，认识了一群新的伙伴：一起打撸的SSM、一起聊天说地的WTT、一起闹腾的ZY学妹……<br>有人的地方就有江湖，科协不过二三十平米，大家低头不见抬头见，自然便是江湖。江湖里可说的东西太多，三天三夜也讲不完，我会尽量把它写入《梧桐树下的少年》里，如果真的会有这本书的话……<br>若有一天我真的写那样一本书，真的又能写到结尾，那说不定会有这么一个段落：<br>我毕业一年后的某天，科协里已经空荡荡了，突然有人挤开钥匙走进来，是ZY，那天是她毕业的日子，她来科协收拾东西。她可能会在开门之后站在门口默默朝里注视一会儿，然后才打开灯走进来。<br>她座位正上方的那盏灯可能到那时也没有人修，显得她的位置稍暗一些，整个人的表情都看不清。<br>她坐在座位上，撕去桌上贴着的名牌，揉成一团，却又慢慢展开摊在桌前。<br>她沉默地收拾东西，轻轻地放进包里。<br>收拾完了桌上东西，她可能会发现被压在桌下已久的、老旧的纸张。<br>那是往届的名牌。<br>可能是SSM的，可能是WTT的，可能是我的……<br>…………<br>哈哈，熟悉的人一定会大喊：“你扯淡吧就！ZY是那样安静文艺的人吗？！”<br>哈哈，说的也是，如果真是ZY，恐怕最可能的情形就是……<br>“嘭！”科协的门被摔开。<br>“啪！”灯被拍开。<br>“咚咚咚！”东西被灌进书里。<br>“唰唰唰！”名牌、废纸连通着垃圾被甩进垃圾桶。<br>“哗！”拉链拉上。<br>灯灭。<br>门阖。<br>ZY就是这么雷厉风行的妹子。<br>但即便是她，我相信也会在某个的时刻想起那间屋子里的欢声笑语、淙淙流年。<br>然后，可能，我是说可能。<br>她会站在门外，轻轻松开关门的手，透过窗户深深往里看一眼，缓缓握紧那把钥匙。</p><p>大三上半学期还有些事，比如宿舍二公子终于脱单，对象是大一的某学妹……<br>不管怎么说，宿舍终于不是我单独面对五只单身汪的局面了。<br>事到如今不得不简单提一提宿舍六位公子了。<br>宿舍一公子的常态就是盘膝坐在上铺，床帘围得严严实实，玩手机。如果是冬天他还会戴上羽绒服的帽子，然后盘膝坐在上铺，床帘围得严严实实，玩手机……<br>宿舍二公子，和一公子并称宿舍两睡神，大多时稍逊一公子一筹，巅峰时堪称一时瑜亮！二公子社交能力极强，巧言善辩，学生会副主席，他说他梦想做《此间的少年》里的杨康，我却总觉得他是欧阳克……<br>宿舍三公子，清秀小白脸，大学两件事，睡觉配游戏，是那种传说中的“高玩”，巅峰时期《梦幻西游》五开，卖出去不少钱，也带我入过不少坑，《天龙八部》、《武魂》、《剑灵》、《天谕》……当然不能少了LOL。除了LOL，其他游戏没在我这活过一个月。现在和二公子迷上狼人杀，都是狼王级别。<br>宿舍四公子，本宿舍学霸，保研狗一枚，大三时任学生会学习部部长，大一时就跟我念叨妹子，到现在还是跟我念叨妹子，有贼心没贼胆的典型代表，长年占据宿舍找资源的第一把交椅。<br>宿舍五公子，文艺暖男，周董资深粉丝，什么雨中送伞没钱刷卡找他准没错，大二时恋上学妹一枚，不果遂黯然神伤，口号是“忧伤是一种态度”。<br>宿舍六公子，不多说了，神仙下凡。<br>二公子谈恋爱是用了心的，每晚都很晚回来，然后朋友圈就会在每晚的固定一段时间多一条动态，有时候是学校的夜景，有时候是稍远一些地方的夜景图，佳人依袖，灯火几重，美不胜言<br>…………<br>后来有个深夜，二公子重重捶床，久久不寐。那晚一公子前往南航赴约，缺席一出。<br>“出去喝酒吧。”黑暗中他轻轻说。<br>凌晨一点的光景，五条汉子从被窝里钻出来，撑开伞，走在只剩路灯的校园里，安静得只剩小雨淅淅沥沥的声音。<br>夜太深了，烧烤店都灭火打烊了，辗转几圈只有饺子店还开着门。<br>饺子店里还有不少聚餐的学生，人声鼎沸。<br>“吃什么饺子？”服务员问道。<br>“酒，来酒。”二公子说着，便上了楼。<br>有饺子，有肘子，当然还有酒。<br>大家聊着，依旧没心没肺的，有些事却避而不谈。<br>渐渐二公子的神情松弛了些，脸上却已微红。<br>不说二公子，便嘲讽五公子，嘲讽他追学妹一年无果，那曾是宿舍的乐事，五公子也不生气。<br>“舍长，XXX最近咋样了？”三公子问。<br>忘了说，五公子是我们的舍长。<br>五公子喝了口酒，也不避讳，直接道：“和YYY在一起了好像。”<br>“那是谁？”<br>“球队的。”五公子说着，又喝了口酒，“快当队长了。”<br>“哦……”我们不问了。<br>我们还能问什么呢？<br>五公子也是球队的，是这一届的队长。<br>五公子把部门留给了那位学弟，把球队留给了他，现在好像连学妹也留给了他。<br>聊到三点多终于决定回去，多年后我可能还记得那个夜晚，他们四个走在前面的路灯下，我眯眼看他们的背影，觉得路灯下的影子格外得长。<br>我总怀疑二公子会突然冲到马路中央冲着空旷无人的马路大吼，但他没有，反而走得比我们都稳，好像要证明什么。<br>可是经过学妹宿舍的时候，他没有忍住。<br>他猛地冲了过去，很快就融入了黑暗里看不见了。<br>我们四个静静站在一边，等着他吼，或者不吼。<br>他没有吼。<br>过了会儿他的身影重新从黑暗里靠近，眼神疲倦。<br>“困了，回去睡觉。”他说。<br>从我身边经过时我感觉到他外套上褪不去的寒意。<br>我不知道那时他在黑暗里看了些什么，又想了些什么。<br>我到现在也不知道。</p><p>大三到这告一段落吧，不然就收不住了，还是那句话，如果有《梧桐树下的少年》的话，我会尽量写进去，我们宿舍其实每个都是大好青年啊！<br>时间来到大三下，也就是2016年的上班年，也面试过几次实习不过好像都没过，对于一个内向不善交际的人来说，只能把每次面试都当做锻炼，吸取教训再逆流而上。<br>也是在2016的上半年，我完结了在创世连载的小说，共计209W字，耗时两年多，算是给了自己一个交代。<br>关于这本小说，实在没什么好说的，扑街是自然的，靠着拿全勤赚的几千块钱也早花光。<br>借着新年的机会，感谢感谢那些一直支持我到这本小说完结的人，没有你们，实在写不下去。<br>也是从这本小说完结时开始，我决定不写网文了，一来是硬性要求比较累，二来则是我觉得那不是我真正想要的，三则是觉得自己似乎不适合，我挺喜欢宁忘川、叶芷柔、林月雅等人的，可好像没什么其他人喜欢，那便算了。<br>要说我真正想要的，《南山北海》算是一篇，这些日志也可以算，不过都只是雏形，差得还很多。<br>以后，还需努力。<br>至于放弃，还没想过。</p><p>其实2016那个暑假就已经是毕业的前奏，XS放假很晚，等他回来CX已经去学校准备考研了，三人竟没能聚到一起。<br>我和XS思忖了几天，决定去常州CX玩玩，顺便去一次淹城动物园。<br>天很热，TY和SYY等人一直在群里质疑我和XS这种大热天白找罪受的行为，懒得解释，女生有时候是搞不懂男生的，反之也一样。<br>不过……天真的很热啊，我们三人平均在动物园厕所里冲了不下三次头，T恤脱下冷水一冲再套上，唯有这样才能有些凉意。<br>动物园里那些叫得上名叫不上名的动物也很热，有水坑的例如河马等根本不露头，没有水坑的一脸生无可恋，躲在阴影里不屑地看着我们，像是也在说：“这么热的天傻逼才来看我们。”<br>“好热啊！”我把脑袋探出浏览车外对天大喊。<br>浏览车租价一天八十，本来只坐两个人，售票大妈见我们三人块头都不大遂大手一挥：“三人挤一辆吧，帮你们省钱吧！”<br>我是挺感谢她的，可就是……真的挺热的。<br>“轰隆隆！！”空中雷声大作，转瞬间暴雨倾盆而下，阳光却依旧刺眼。<br> “我了个靠……”我连忙把头缩回来，撑开伞挡住一边，回头对左边的CX喊，“你打伞撑住那边！”<br>于是，一辆小小浏览车，挤着三个老爷们，撑着两把雨伞当车门，慢悠悠地行驶在雨中。<br>雨砸在车窗上，“咚咚”作响。<br>“张Y你真牛逼！”XS握着方向盘，道。<br>“简直雨神。”CX说。<br>“嘿嘿，”我笑，“雨中漫步，多特么有意境！懂不懂啊你们！”<br>“有意境你自己漫去！”二人异口同声。<br>路经一道回廊，回廊上藤蔓缠绕地十分严实，竟将大雨遮了七七八八。<br>我从回廊这边望去，雨帘里还有几辆浏览车也在缓缓前进，有的是情侣，有的是亲子，也有的是一个人，静静地停在回廊里，斜斜靠在座位上不知在看些什么。<br>那天后来的天气就在曝晒和暴雨之间切换，太阳可能觉得换来换去烦了，干脆一直高悬在空中，便成了太阳雨。<br>光和雨都从那些缝隙里透进来，雨金光闪闪的，像是过往的岁月在流动，也像是我们在时光里彼此追逐彼此相融。<br>我想起很多很多年前在空间写的矫情文字，那时还是个中二的少年，矫情的文字现在是决计看不下去的。隐约记得在那篇不知能不能称为文章的文章里，太阳雨有深刻的含义。<br>如今想想，自己都不由摇头笑出了声。<br>当时真是年轻。<br>不过转念一想，自己竟然喜欢写东西喜欢了这么久？倒也是不容易。<br>时光匆匆，很少有东西是不变的，但这份热爱不变，纵使没啥成绩，也真是开心啊。<br>淹城动物园有野生区，这还是我第一次进野生区，动物不再被囚禁在可见的牢笼里，而是就在我们身边。<br>斑马在奔跑，羚羊在漫步，狮子在咆哮，狗熊在蹭树。<br>我们买了两包喂食，递给路边的羚羊。羚羊并不怕人，雄羚羊顶着树杈型的鹿角缓步靠近，鼻翼扇动，眼睛大得吓人。<br>从野生区离开，我们去看了表演。<br>鹦鹉表演和别处一样，倒也没什么出彩；<br>狗熊表演十分搞笑，我记住了那两只对拳的狗熊；<br>最后的大马戏无比震撼，杂技魔术精彩丰呈，场面美轮美奂，强烈推荐。<br>马戏团来自乌克兰，乌克兰美女名不虚传！！<br>马戏结束后天色已晚，我和XS也和CX告别，坐上返程的汽车。<br>如今已是寒假，只是三人却彻底没了聚在一起的机会，XS被学校派往帝都实习，过年也不回家。<br>下次见他，还不知是什么时候。<br>可能到时他的肩上已经别着军章了吧。</p><p>暑假里按照传统和FXT、TM聚了一回、和ZL吃了一顿饭，也和许久不见的BLY约了一次，她依然明媚如花，一起看了一场《大鱼海棠》，画面挺好的。<br>后来得知BLY竟然也在玩撸啊撸，我便腆着老脸找她一起开黑了几次，哈哈，反正我菜得抠脚，她也不嫌弃我，有点找回曾经前后桌的感觉，真好。<br>八月一日，我记得这一天，对我来说是个好日子。<br>南航面试通过，亚信面试也通过，一时间好像学业事业双丰收。<br>如果没有我后来的傻逼行为，确实很好。</p><p>八月和九月，是我2016年两度转折的时间。<br>八月份的那张实习offer让我错过和CX等人在家相约的日子，早早来到南京，开始我短短的两个月实习之旅，熬过夜、吃过苦，认识了不少公司前辈，尤其是我的导师为我解了不少惑。<br>若是没有九月份发生的事情，我恐怕会在公司呆得久一些。<br>九月……痛苦的九月。<br>因为自己的失误，保研名额拱手让人，我不得不辞去工作，不得不从九月末十月初加入茫茫考研大军，再一次拼独木桥。<br>起初当然是痛苦的，记不清有多少个夜晚我蜷缩着对着冰冷的墙壁，只觉得痛苦从每一个细胞里挤出来，顺着四肢百骸撕扯着、咆哮着，像要把我扯碎。<br>三年前高考输了，三年后，又输给了自己。<br>没有人知道那段时间我重读了《老人与海》，一遍又一遍。<br>二公子也不知道这事，但他曾拍拍我说：“人如果颓废了，那才真的废了。”那时我把自己整个人都裹在被子里，半天都不说话。<br>有时候想想人真的是个神奇的物种，二公子自己也是颓废起来能整天不下床的人物，竟偏偏能说出这样的话。而我明明知道他是个怎样的人，却还偏偏觉得他说的真特么对，好像他真的废寝忘食一样。<br>FXT还说：“说不定考研对你来说更好，你能去个更好的学校。”<br>嗯，可能吧。<br>几天之后终于恢复得差不多，望着面前厚厚的复习书，我一头钻了进去。<br>没有plan B。<br>那就只能拾起刀剑，一往无前。<br>所谓不破不立，可能就是这样。</p><p>有人说考研比高考更痛苦，因为高考有一群人在陪你，而考研是一个人在战斗。<br>这么说来的话我倒是运气不错，并不那么害怕孤独，一个人关在科协旁边的培训教室里学一整天也不觉得有什么。<br>隔壁有时会SSM和WTT等人的欢闹声，什么游戏又赢了什么小说好看极了诸如此类。我没觉得吵，反而觉得温馨，嘴角会微微扬起，胸中弥漫着温热的感觉。<br>有什么孤独呢，他们就在隔壁啊！<br>当然也有疲倦的时候，那时就翻开手机找研友聊聊天。</p><p>有时候找CX，他暑假就开始复习了，目标是他女票家乡的一所大学。<br>我复习得晚，数学不会的就问他，惊叹一句：“这你都会！”<br>“废话，这不会考个毛线啊！”<br>“那我不会。”<br>“你才复习几天，怎么可能会？复习完了就会了。”<br>我还会问：“考不上咋办？”<br>“考不上就找工作，我要赚钱。”<br>“不想工作。”<br>“那你二战啊！”<br>“也不想。”<br>“那你去死吧。”<br>“哼唧，爸爸一定会考上的。”<br>“哦，滚去看书。”</p><p>有时候和FJY聊天，她也考研，目标远大，却不够自信，一遍一遍地问我她能考上么她能考上么，像个紧张过度的妹妹。<br>我说：“能能能，当然能，不能不行！”<br>仿佛咬牙切齿，怒目如龙。<br>她很单纯，我这么说她便笃定地不得了，学我一样得咬牙切齿：“嗯嗯！！我们都能考上的！！一定！！！”<br>“考不上提头来见！”<br>“好！截图为证！！”<br>过了一会儿，她果然把截图发了过来，这张截图至今保留在我手机里，每每想起，都像有鼓声响在耳边，振聋发聩。<br>我想象屏幕那头的丫头，轻咬着下唇，目光里光芒涌动，微微鼓着腮帮子，用力握拳。<br>嘿，真是力量源源不断地上涌啊！</p><p>有时候和ZYN聊天，她沉稳得多，言语比我还少，我总觉得她才有真正考研人的样子，每天天蒙蒙亮就起床，在图书馆帮姗姗来迟的我占座，然后直到深夜才离开，而那时我大多时候已经躺下了。<br>她目标明确并且决心很大，一年前就立下跨考的志向，努力的整整一年，我相信上天总会给她个好结果。<br>我有时候会沉不住气问她：“感觉怎么样，有没有把握？”<br>她轻轻笑笑，摇摇头：“没想过，尽力吧。”<br>“累不累？”<br>她有时会摇摇头，有时候会歪着脑袋思索片刻，长发垂在桌上，然后说：“有什么累不累，累也要继续，不然能怎样？”<br>然后她又沉浸到张宇八套卷里去了。<br>而那时，我还没买八套卷……<br>真不知道现在自己的感觉良好是从哪来的……</p><p>还有时候和LYF聊天，她竟然报考我们学校，还好不是农业信息化，一到晚上十一点后就给我发各种学校美图。<br>我只想说智障么我呆了四年还用得着你给我发图么……<br>好像有天我受了刺激，跟她说了些不想考了啥的。我也只是随口发泄发泄说完便又埋进书里，过了一会儿手机却响了，是个陌生的号码。<br>我接通，没想到就是她，这才想起来好像真的没有存过彼此的号码。<br>“你别放弃好不好？”上来一句话就把我给整懵了。<br>我呆呆地：“啊？”<br>她竟然有些急了：“我说你千万别放弃啊。你都不知道当你告诉我只剩三个月时间你还要考研的时候我有多震撼……”巴拉巴拉说了一大堆。<br>我已经彻底懵了，想笑却又笑不出来，只是低着头，不断地“嗯嗯”。<br>终于她好像累了，沉默了会儿问道：“所以，你不会放弃了吧？”<br>“嗯，不会。”<br>“那好，我看书去了。”<br>“去吧。”<br>挂断电话，我眯眼透过教学区的窗户看天边一轮明月。<br>后来ZL也来找我，问我出了什么，害得LYF忙急忙慌地找她要我电话。<br>喂，搞什么啊……<br>放弃什么的，我真的没想过啊……</p><p>更多时候是和女票聊天，她虽然也报了名，不过嘛……用她自己的话来说就是“陪我考”，该吃还是吃，该睡到太阳晒屁股还是睡。<br>有时候我气急败坏地骂她，她也不恼，只是冲我笑。<br>“笑笑笑，笑个屁啊，考不上怎么办！！”<br>“有你啊。”她说。<br>“考不上你就找不到好工作了你知道吗！”<br>“有你啊。”她说。<br>“没好工作怎么养活自己？！”<br>“有你啊。”她还是说。<br>我……我没脾气了，灰溜溜滚去看书。<br>当然，她也在努力，只是在我面前故意这样罢了。</p><p>有时候也会和不考研的人聊。</p><p>ZL有阵子忙着写论文，偏偏中国知网上不去，求助于我。<br>我将我的账号发给她，她电脑竟然又显示下载失败，真是气煞我也。<br>没办法，我只能让她远程控制我的电脑下载，下好了再发给她……我可没那闲工夫帮她下载，控制权给她，自己忙活去吧！<br>然而，接通之后她足足三分钟啥也没干，鼠标在桌面上晃荡来去半天也不知道干嘛。<br>我翻了翻白眼，二话不说，握起鼠标，找到角落里的浏览器，打开。<br>鼠标静止。<br>片刻后她发消息给我：“你怎么知道我找不到浏览器！！”<br>我抚额……<br>呵呵……<br>有时候想想，真心佩服我自己……<br>后来ZL特意发微博夸我，说默契终于在十年后体现了。<br>嗯，十年了。</p><p>ZSK那段时间帮了我很多，复习的专业课书籍都是他寄给我的，他这学期去上海实习了，世界五百强企业，又保研本校，有些屌。<br>他一直是这么优秀，至少我这么看。<br>听说他女票也保研来了南京某所学校。<br>真替他高兴，四年的异地恋终于画上句号。<br>距离考研还有十天左右的时候他突然给我打电话，语气有些低沉，似乎是有了心事，迷茫得不行。<br>即使在我眼里独立如他，原来也会迷茫。<br>足足说了有半个小时，最后他道：“回家再说吧，你加油啊，别没考上。”<br>“嗯，我知道。”我点头，“放心吧，不出意外……”<br>“出意外也不行。”<br>我哂笑：“好，我明白。”<br>和他说话真是无需拐弯抹角，一词一句都是真话，好像承诺。</p><p>BLY高三复读一年，所以今年还没有考研，却也很关心我，经常问我进展如何，有时候甚至还给我发红包，说是要吃点好的。<br>有天晚上买了粥和烤鸭，发图给她看，她说：“好丰盛！”<br>“很贵的，十几块呢。”<br>“贵也要吃，吃饱了才有力气学习。加油！”<br>“吃吃吃……”<br>等到明年她考研的时候，我也会支持她，给她发红包，对她说要吃点好的。<br>考研这件事，有人支持真的很重要。</p><p>TY和SYY自然也不会不管我，某个傍晚我正在快递处拿刚到的《张宇真题详解》，口袋里的电话突然响起来。<br>我一愣，竟然是TY的电话。<br>“喂，干嘛？”我接通电话。<br>“你在干嘛啊？”电话那头的声音却是SYY。<br>“我还能干嘛，拿快递回去学习！”<br>“我们马上来看你啊，你吃了吗？想吃啥我们给你带！”<br>我看了一眼手中刚买的粥和包子，说道：“刚买了一碗粥两个包子。你们要干嘛？”<br>“慰问你啊！”TY的声音从一边窜出来。<br>SYY说：“那反正你也吃不饱，一会儿给你带点吃的。”<br>后来她们真地来了，拎着一个袋子。<br>我带她们去教学楼前的池塘回廊里坐着，那时天还不算冷，风吹着池水，还不逼人。<br>“喏，给你。”SYY把袋子扔给我。<br>TY一把拦住：“等会儿，我买了两块蛋糕呢，一块给他，一块我要自己吃的。”<br>我看了看TY不见瘦的体型，笑出了声。<br>“笑个屁。”她骂道，小胖子做凶狠状。<br>“哦还有鸭脖，我要吃鸭脖！”SYY翻着袋子，突然大喊道。<br>我在她们对面坐下，屈腿靠着柱子，笑道：“到底是带给我吃的还是你们自己吃的？”<br>“干嘛！”两人瞪我。<br>我举手投降：“不敢不敢。”<br>天已渐渐黑了，看不清楚池水，只听得见风吹过树叶的声音和……她们吃东西的声音。<br>“对了，SYY你要出国吧？”我突然问道。<br>“是啊，刚考完GRE，不然我哪有时间来看你？”SYY吸着冷气，龇牙咧嘴，“啊啊啊好辣好辣……”<br>“哦……去美国？”<br>“嗯。”<br>“还回来么？”<br>“不知道，看情况！”她跳上跳下的，还是当年那个在东南大学中山楼下吐着舌头对我诉苦DYM好像来了的女孩。<br>“那TY呢？”<br>“我啊？明年考研啊！”TY咽下最后一口蛋糕，我手里的还剩大半。<br>TY学医，五年制。<br>顿了顿，她又说道：“我们这个不专业不考研没出路的，如果我能考上南京市人民医院的话就好了。”<br>我不太懂，她解释了，我现在又忘了……<br>“太笨了你，反正你只要知道如果我能考上就人生巅峰，考不上就死翘翘了。”<br>“哦……”我挠挠头，眯起眼睛，“那以后就见不到啦，SYY去美国，你留在南京，我还不一定去哪呢……”<br>“本来就是咯，大家都要分开了。”TY说，死死盯着我。<br>我避开她的目光，装作看不懂那里面的离别，耸了耸肩：“哈，那以后去美国找SYY和CSB玩啊！你们买个大房子，有院子的那种，听说美国房子不贵，我们去投奔你们，一人一间房，多好！”<br>“好啊好啊！”SYY又跳起来，“不过我要留一间衣帽间！！”<br>“什，什么间……”我没听清。<br>“衣——帽——间！”<br>“那是啥？”<br>两人对我白了白眼，SYY道：“就是放衣服裤子帽子啊什么的……没看过《小时代》吗？顾里家里的那种！”<br>哦，我想起来了，《小时代》里顾里有个大房间。<br>“哗”的一声房门推开，玻璃反射光华晃了所有人眼，放眼望去房间都看不到头，全都是……衣服衣服衣服……帽子帽子帽子……裤子裤子裤子……靴子靴子靴子……<br>想想有点可怕！<br>“可怕。”我哆嗦了一下，说道。<br>“可怕个大头鬼咧！”SYY道，“不要太爽哦……”<br>“好吧……希望你有，然后我们连衣服都省的买了。”<br>“想得美哦，要给钱的！”<br>…………<br>“饱了。”TY打了个嗝，道。<br>我没好气地摇头。<br>她们站起来拍拍灰：“不早了，你回去看书吧，我们走了！”<br>“嗯。”我点点头，也不留她们。<br>不知何时月亮都已经升起来了。<br>我目送着两人在月光下沿着勤仁坡那条路渐渐远去，胳膊挽着胳膊，蹦蹦跳跳的。</p><p>现在，已经结束了，不管结果如何，我们都曾经努力过。</p><p>时间过得太快了。<br>说起来还是在去年八月，有个夜晚WYZ又给我推歌，然后她说《夏至未至》要拍影视了，她不喜欢白敬亭演陆之昂。<br>《夏至未至》，我看过的唯一一本郭敬明的言情小说，她推荐我看的，那时她说她觉得我像陆之昂，ZSK像傅小司，时隔多年早已记不清情节，只记得那座城好像叫浅川。<br>WYZ曾用过一个网名，叫忘川。<br>我笑着回她：“陆之昂不是我吗？”<br>然后，然后然后然后！<br>她说“拜托，你已经不是18岁了。”<br>我有些惊悚，原来……早就不是18岁了啊！<br>书里的人不会老，什么时候翻开他都是那个年纪，站在阳光里浅笑嫣然。<br>书外的人却老得快，快得出乎意料，快得毫无察觉。<br>后来很少聊天，只是有时候我发些发泄用的说说，她会留个言或者找我，问我怎么了。<br>她问我，我却不知从何说起，于是随便扯些别的，随意聊聊，知道彼此都过得还算好就行。<br>讲真，我真的很喜欢《未完1》里关于她的比喻。</p><p>想着不写长，写完又是近一万字。<br>能写的太多了，没写的也太多了。<br>结束来得太匆匆，我还没想好要怎么结尾。<br>想来想去，既然我把它们归为一个系列，那就还用《未完1》的话结尾吧。<br>2017，我们的故事，未完待续。</p><p>即使我真的不会再写《未完3》，这些故事，该续的还在续。<br>毕竟这人生，我们都在相互扶持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2017年1月21日，2018年5月31日上传保存。）&lt;/p&gt;
&lt;p&gt;有的时候是看见一句话。&lt;br&gt;有的时候是听见一首歌。&lt;br&gt;有的时候是站在老地方。&lt;br&gt;有的时候是见到老朋友。&lt;br&gt;有的时候是静在沉默里。&lt;br&gt;但更多的时候是在呼吸里。&lt;br&gt;想你。&lt;br&gt;想我是怎么渐渐失去了你。&lt;br&gt;我的匆匆时光。&lt;br&gt;
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>未完待续-壹</title>
    <link href="http://yoursite.com/2018/05/31/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E5%A3%B9/"/>
    <id>http://yoursite.com/2018/05/31/未完待续-壹/</id>
    <published>2018-05-31T09:30:03.000Z</published>
    <updated>2018-05-31T09:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2015年8月3日，2018年5月31日上传保存。）</p><p>水灌进眼底，我看见当年的你。<br>我坐在这里，岁月也无声无息。</p><p>谁能告诉我过去和现在、现在和未来之间到底有多远？<br>转眼已经大三，梧桐树叶轻轻洒落几个秋，我有时候看着它，沉默，然后把它胡乱踢进路旁的垃圾桶，转身离去，装作从来没见过。<br>风萧萧叶悄悄。<br><a id="more"></a><br>翻开尘封的空间，时间已经停留在去年的八月。<br>TY时不时会翻我的空间，将那些已经寂寞了很久的文字挨个再读一次，然后在每一篇下面再给我留一条言，接着在QQ上问我：“你什么时候再写日志啊？我想看。”<br>看到她留言的那瞬间，我心中起先是无比满足的，没什么比文字让人记住让人喜欢让人追忆更能让作者满足的了。我虽然只会自己瞎鼓捣，写作的技巧阅历还差得远，但作者的通病倒是已经学了个遍。<br>TY有时候在白天问我，正在课堂上，我的思绪却飞到天际，开始在自己曾经写过的文字和更多自己没有写过的文字里飞窜；有时候是在晚上，我侧枕着枕头，手机从手里滑落，眼睛盯着黑暗发呆，直到眼睛酸痛。<br>我想我是热爱文字的，要不然怎么可能因为TY的一句话每次都情绪奔腾？<br>可又是为什么，每次我回过去的话都是“过一段时间吧。”或者干脆“有什么好写的。”？</p><p>后来经过好几个不眠的夜晚，我找到了自己认为正确的答案。<br>原来，写作既是孤独的，但潜在目的却是渴求热闹的。<br>每个作者，在写东西时候忍受的孤独，都希望在作品完成之后能够用加倍的热闹还回来。<br>我孤独了，然后很悲哀的，变得更孤独。<br>就像一个人花整整一天准备了一桌丰盛的晚宴，结果原来只有自己一个人吃。<br>于是，扔掉刀具关上炉灶拉上门，干脆不做了。</p><p>匆匆几年，大学毕业竟然已经不再遥远，身边每个人都有自己的打算，彼此生命的轨迹分得越来越明显。<br>忙了，自然空余时间就变少，哪里还有时间看长篇的东西？正是说说微博朋友圈当道的年头啊！<br>我自己也是这样，懒得去看长篇的文章，以前特地下载下来的“一个”早就不知落下了多少期。<br>时代太匆忙，言简意赅才是王道。<br>因为这样，所以我才会拒绝TY的吧，我怕写了也没人看，最后难过的只有自己。<br>岁月无声无息，所以当我们回过神来，原来有些人有些习惯早就不知所踪。</p><p>我现在坐在床上，房间里只亮着一盏微弱的台灯光，电脑屏幕冰冷的光芒照在眼镜镜片上，眼睛有些累。<br>但我还是在写着，纵然天马行空，纵然不知道在写什么，但只要在写着，我就感觉心安。<br>有句话说得好，所谓梦想，就是坚持下去就会感觉到幸福的事情。<br>所以就算没有人看，一年我也实在忍不住了，必须要写点什么，大不了厚着脸皮挨个骚扰让来评论就是了，反正我一向这么厚脸皮。<br>耳机里的歌是姚贝娜的《鱼》，前两天淘到的歌，听说是姚贝娜生前最后一首歌，安静且忧伤，是我喜欢的风格。<br>女友的消息还在任务栏里“嘀嘀”作响，像她顽皮在身前跳动的模样。<br>安静的夜晚总是能给人灵感，这时候人的情绪会变得非常脆弱。<br>心里有故事的人会知道，回忆总在这种时候带着笑拿着刀撬开心里那扇门。<br>鱼只有七秒记忆，我开始庆幸自己不是一条鱼，我还记得那么多人那么多事。</p><p>今年南京的天气有些反常，雨下得特别多，那阵子每天都枕着雨声入睡，第二天伴着雨声醒来，发潮的衣物堆积了很多，让我每次看见满满一盆就无比想念我妈。<br>不过六月之前的南京天气却还不错，不算太热，适合结伴而行。<br>五月十六日，SYY约我们去浦口老车站，那是当年拍摄《情深深雨蒙蒙》的地方。<br>我和LJL之前已经去过，所以这一次纯属被拉着当导游。<br>天气没法跟这两天比，但也是明日高悬，一行人浩浩荡荡到弘阳广场的时候已经是十一点。<br>“热死了热死了！”SYY喊。<br>“饿死了饿死了！”TY喊。<br>“热死你热死你！”CSB喊。<br>“你在哪你在哪？”我对着电话喊。<br>“快到了快到了！”LJL在电话里喊。<br>浦口，是她的主场。<br>但其实，还得靠我指路，她那个猪脑子知道个屁哦……那么热的天可不能跟着她乱晃半天然后看她一脸无辜地说“走反了”……<br>好不容易和LJL汇合，五个人商量了一下决定去吃英伦自助餐。<br>其实也有很久没和TY他们一起吃饭了，嗯，好久没有见识SYY那人不可貌相的饭量了。<br>还是第一次，在南京的人聚得那么齐。<br>自助餐当然得吃得风卷残云，餐桌上狼藉一片，每个人都吃得老撑了。<br>然后就去浦口车站。<br>先坐637路公交到浦口公园，637路公交坐的不是特别多，但是每次坐都有一种穿越时空的感觉。<br>在南京坐车并不无聊，车窗外总是密密麻麻的参天梧桐树。车从树影光斑中穿过，我的目光随着那些光斑晃动，渐渐连成一条线，延伸向看不到的远方和过去。<br>它带着一车人，从繁华的商业区驶入那个曾经的老南京，安静祥和。<br>老南京没有鸡肉卷，老南京有老梧桐。<br>我喜欢南京，很大原因是因为那无论走到哪都能看到的漫漫梧桐，即便是在浦口公园那样的老地方，狭窄的道路两旁也不会种植其他树木。南京和梧桐，就是一对相依相靠的恋人，彼此交融，无法分开。<br>下了车，沿着小路绕几个弯，便是天桥。<br>天桥下是从中被截断的铁轨，道路两侧就是在烈日下烤的发亮的老铁轨。<br>铁轨中间的木块一日既往地沉默。<br>脚下的地面有些烫。<br>驻足，拍照。<br>走过天桥，拐过弯，就会看到一条小路。<br>小路两旁是老式的房屋，每一座房屋墙上都还留着黑色的火车标记，在岁月的风化下有些变得模糊，有些却还算清楚，能分辨出写着“津浦路区”四个字。<br>TY走上去摸了摸黑色的火车标记，墙壁上凸出的石子颗粒非常粗糙，几十年的时间就藏在这些瓦砾里，不知道她感受到了没有。<br>有一户人家墙上挂着鸟笼，门里坐着一位老人，仰在藤椅上，微闭着眼，手指轻轻打着节拍，鸟儿被SYY逗得啾啾而鸣，老人睁开眼看了她一眼，然后又闭上。<br>回过头，看到一对新人正在这条路上拍婚纱照。<br>年轻的男女执手奔跑，回头对着镜头微笑，新娘蓝色的裙摆水波一样在面前荡开。<br>SYY拉着CSB跑到摄影师身旁，对着摄影师叽叽喳喳不知说些什么。<br>我和LJL绕道走开，真想说不认识他们。<br>再回过头的时候，看到SYYTY两人在偷拍我们。<br>跟她们不用客气，我直接骂道：“拍什么拍啊？我们不要拍照！”<br>“你那么丑我高兴拍你是你的福气！”SYY翻白眼。<br>“就是就是，要不是沾我家刘的光，谁高兴拍你啊？！”TY挥舞着肉拳，满脸笑容。<br>CSB一脸无奈地站在两人身边，挠头。<br>我深吸一口气，明智地转身，拉着LJL往前走去。<br>虽然确实不喜欢拍照，不过如果能和心爱的人一起，拍就拍吧！<br>后来LJL给我单独拍了一张，然后用某个软件修改了一下，画风立刻变为漫画风，而且个人觉得特别像言情小说的封面。<br>葱翠的梧桐树下，我背着她的包，微微仰着头，光从梧桐树树叶间投下，洒在我脸上，洒在我脚下，两侧的汽车安静如沉睡的守卫。<br>嗯，至少不那么丑了。<br>再往前走，就是真正的老浦口火车站了，道路两旁的老房子多半已经尘封多年，只留下墙壁上斑驳的大字，比如“住宿”，比如“食堂”，比如“售票处”……<br>曾经的候车处也是一层厚厚的灰，大门紧闭。<br>我们透过窗户破裂的地方朝里看去，扑鼻而来一阵霉味，我发现上次看到的椅子全部不见了，候车厅里空空荡荡的，只有透窗而过的光线寂寞地照耀着，灰尘翩翩起舞。<br>那边有一群老年人在跳广场舞，SYY拉着CSB竟似乎要冲进去来上一段，TY举着相机在旁边嗷嗷叫着。<br>LJL也想找我，却发现我已经很有先见之明地绕开，并且在一张石凳子上坐下。<br>“接下来去哪啊？火车站就这些地方吗？”TY走过来问。<br>“差不多啊，里面又不让进。”我指了指对面说道，“接下来我们可以坐渡轮过江啊！”<br>“好啊好啊，ｇｏｇｏｇｏ！！”SYY已经冲了出去，CSB赶紧跟在后面。<br>到了渡轮上有些小失望，上次我和LJL来的时候还能站在甲板上，可是现在却只能呆在船舱里，门已经全部关闭起来了。<br>SYY不甘心，跑去问工作人员能不能站到甲板上，并且开始卖萌讨好。<br>我们转过身，不忍直视。<br>“这都不行，妈蛋！”<br>果然，不要脸有时候也是没用的。<br>进了渡轮，找一个位置坐好，坐了没到两分钟，船离岸之后，三个女生就干脆直接站起来推开窗户，伸手到外面，趴在窗户上。<br>我和CSB就负责把她们的鞋子收好。<br>江上的风挺大，吹起三个女孩的发，青春的笑容洋溢在她们脸上，发着光。<br>长江依旧浪滔滔，一去而东从不复返。<br>后来不知怎的开始在船舱里打闹，互相扯皮调侃，最欢乐的时光莫过于此，因为让人欢乐得几乎忘了一切，要不然我现在怎么会想不起来当时是谁说了什么笑话，逗得五人哈哈大笑。<br>照片也是一定要留下的，我难得地在照片上搞怪起来，捏着LJL的脸，比一个二二的剪刀手。<br>平时的我是怎么也想象不出会这么拍照的。<br>来来去去往往返返，我们从浦口码头到中山码头，然后再返回。<br>太阳不知不觉间已经靠西，不再那么炎热，却多了一分温暖，照在人脸上，映得人脸发红，人心发烫。<br>再次路过天桥的时候，我们选择了上去。<br>天桥两侧是台阶，台阶之间是滑坡。<br>CSB站在台阶上拉着SYY的手，SYY张开手从滑坡往上走。<br>我和LJL跟在他们之后。<br>TY早就一个人从滑坡上冲了上去，谁能想象出她胖胖的身躯里还有这样的爆发力？<br>“快点啊你们，慢死了！”她站在天桥上双手叉腰对我们喊。<br>我抬头看她，夕阳的光芒从她右侧照来，小胖子在金光里笑得无比有感染力，发丝在风里如狂蛇般飞舞。<br>嗯，以前那个快乐的胖子终于是回来了。<br>在天桥上，我们五人靠在一起，背对着夕阳，拍下了五个相依在一起的影子，剪刀手向天冲冲冲。<br>“那个最胖的影子一看就是TY！！”SYY大声喊道。<br>“你放屁！”TY自然不会承认。<br>“那最矮的那个是你咯……”CSB慢悠悠地说。<br>“不是！！”<br>“其实……这两个影子不是同一个吗？”LJL忍着笑说道。<br>“啊啊啊我跟你们拼了！！不活了！！”<br>“别啊，虽然这里不高，可从这里摔下去也挺疼的，尤其是你脸着地的情况下。”我严肃地补了最后一刀。<br>“再见！！”TY“嗖”地一声窜出去，张开双手“蹬蹬蹬”沿着滑坡几步就跑了下去。<br>速度之快，当真让人瞠目结舌。<br>倒是我们四个人，因为两个女生的缘故，走得非常慢。<br>“诶，你们等下，站着别动，我给你们拍张照！”TY突然在下面喊道，举起了手机。<br>我们四人两左两右并肩站着，我深深吸了口气，嘴角露出一丝满足的微笑。<br>风从我脑后轻轻吹来，树叶沙沙作响。<br>身边站着最爱的人，耳边吹过最轻的风，拍照的是最好的朋友。<br>嗯，时间就该在这种时候定格。<br>我朝LJL靠了靠，牵上她的手，一片温存。<br>“咔擦”<br>……<br>回去的路上，夕阳远远跟在身后，SYY说：“我现在和未来的医生、未来的老师还有未来的作家走在一起，感觉好厉害！”<br>CSB拉下脸补充：“还有未来的老公！”<br>“滚一边去！”SYY直接两巴掌。<br>“滚呀滚呀滚呀！”TY说。<br>我走在最前面，低下头。<br>我看到时光笑了。<br>那么温柔。</p><p>更早一些的时候，我和LJL去过一次常州找CX玩。<br>出车站的时候是晚上十点钟，常州的火车站确实该装修装修了，走在里面要不是人多甚至会怀疑拐角会突然跳出一只鬼怪。<br>出了车站，我已经忘了那天晚上有没有月亮，因为CX带着他女朋友早就在门口等候多时。<br>汇合之后买了回程票，我们便去打的。<br>那时候因为舍友的关系刚刚喜欢说“并”这个字，无论说什么话都要加上“并”这个字，觉得逼格特别得高。<br>“待会儿干嘛？”CX问我。<br>“并不知道啊！”我排在队伍里说道。<br>“你们吃东西了没？”<br>“并不饿啊，待会儿再说。”<br>“并并并，并你个头，再并我弄死你！！”LJL直接给我一巴掌。<br>“并不能控制自己……”我捂着脑袋，大叫，“我也并不想这样啊……”<br>“大哥，你累不累？”CX抚额。<br>“并不会。”<br>CX和他女朋友已经无奈，LJL对我张牙舞爪，直接挥手：“我不认识你，你是谁啊？”<br>“你并不能这样。”我很严肃。<br>三人不再废话，直接招呼一辆车把我塞了进去。<br>“你们这样对我，我并不开心！！”<br>汽车呼啸而过。<br>晚上也没地方去，反正早就约好了去网吧开黑，就直接在CX学校附近找了一家网吧，正好有个四连坐，运气很不错。<br>坐下来就玩游戏，首先当然要和CX开黑搞几盘英雄联盟，她女朋友看会儿视频，LJL还装模作样地做起作业来了！！<br>“我靠，你到这里来做作业的啊？！”<br>“干嘛，不服啊？你以为都像你没作业啊！”<br>“并没有不服，做你的傻逼作业去吧！我撸咯……”<br>“撸你个大头鬼，肯定又掉段。”<br>“并不会。”<br>网吧是年轻人的场所，大学之前我还从没去过网吧，记忆里的网吧都是蒙在一层厚厚满是油腻的厚帘子之后，哪有像现在这样灯光明亮？<br>网吧的电脑果然屏幕够大，玩起来感觉倍儿爽，手感走位什么的都比自己的笔记本电脑好得多。<br>于是那天晚上不仅没掉段，我还晋级了，CX运气就差一些，仅仅一盘之差没有晋级成功。<br>其实就是他太菜！！我带不动！！（此处应有傲慢的表情。）<br>晋级之后就变得满足，没有再撸下去的欲望了，况且时间也已经是深夜两点多钟，肚子有些饿。<br>“出去买点吃的。”CX说。<br>“并没有意见。”我拍拍屁股站起来，摘下LJL的耳麦，“喂，想吃什么？”<br>“肉。”她甚至没看我一眼，直接从我手里把耳麦抢了回去重套在脑袋上。<br>深夜的街道上只有黄色的路灯亮着，网吧对面有一家烧烤还开着门，浓郁的香味瞬间俘虏了我的胃。<br>小时候就曾经很多次想象过深夜街道的场景，曾经很多次想走在孤独的路灯下，抬起头是不是能看到飞蛾在灯罩上扑打？晚风“呜呜”地吹过，吹起谁的发，明月又照着谁的衣摆？小路的转弯口是不是有人在等我？我如果走过去你会不会伸出手牵起我？<br>等到真正站在深夜空旷无人的街道上，放眼望去只看到寂寞的道路一直延伸进尽头的黑暗，两旁的车辆早已安睡，烧烤店老板也变得沉默寡言，一直低着头准备烧烤。许久小路的转弯口驶过来一辆车，远光灯晃了我的眼，没有人在等我，也没有手。<br>车开过，耳中只有烧烤轻微的 “滋滋”声。<br>我和CX没有说话，毕竟深夜，都有些累了，对立着眼睛落在烧烤上，渐渐发呆。<br>慢慢地，就觉得有些凉意。<br>深夜外面有的只是安静，白天那种繁华宛若一场梦。而且白天越是热闹的地方，到了深夜就越发冷清可怕，这条街上幸好还有几家网吧开着，幸好还有一群年轻人。<br>拿了烧烤回网吧，三下五除二就消灭干净。<br>不想玩英雄联盟，于是带着两个女生玩QQ飞车。<br>这是一款对我来说有很多回忆的游戏，甚至至今在我家那台十几年的老电脑上还装着，从没有舍得卸载过，英雄联盟早就卸载重装过不知多少次。<br>虽然很久没有玩飞车了，但是老将宝刀还未老！<br>许久不玩，QQ飞车的地图很少有熟悉的了，偶尔随机到一张老地图，漂移加速的瞬间似乎看到了曾经的自己，看到曾经自己的超越与被超越。<br>“唰唰唰”几盘，毫无悬念地全是第一名。<br>看着角色站在领奖台上做着熟悉的喷啤酒动作，我眼前竟似乎朦胧了，难以言明的感觉涌上来，千百种情绪最终只变成嘴角浅浅的一丝笑容。<br>游戏承载着的东西，永远都比游戏本身重要难忘地多。<br>我没有去打开飞车好友列表，那些曾经一起飞跃奔驰的小伙伴们早已不知所向。<br>不过，网吧永远不是个适合回忆的地方，接下来，LJL毅然奋起，直接把我的键盘抢了过去压在自己键盘下，让我永远只能停留在起跑线上。<br>“我靠，你这样也行啊？！”我骂道。<br>“你别动！老实呆着！！”LJL盯着屏幕，手忙脚乱地按方向键。<br>另一边，CX女朋友虽然没有那么直接，但嘴里的威胁就更浓了：“我跟你讲，你要是再敢开在我前面，信不信我弄死你？”<br>CX和我对视一眼苦笑，然后跟屁虫一样跟在女朋友车后。<br>于是乎，原本竞速的游戏只剩下跌跌撞撞、晕头转向，和一个可怜只能在起跑线玩方向盘的角色。<br>但是，却也多了一些别的东西，比如笑容。<br>所以，那些感怀什么的，都通通离远一些吧，不管是过去还是未来，都不如现在重要。<br>“这要是真开车你九条命都死光了啊……”我为屏幕上的角色心疼。<br>“闭嘴！不许动！！”<br>再后来，永远是第四名的LJL不服，一脸委屈。<br>“诶诶诶，别说我欺负你，你会玩什么游戏？拿出来让你炫耀炫耀咯……”我推她的肩膀，一脸挑衅。<br>“这可是你说的，来，QQ炫舞！！”LJL跳起来，眼睛里闪着逼人的寒光，满是自信。<br>第一盘，她赢了。<br>但是片刻后……<br>某网吧，某女掐着某男的脖子大叫：“啊啊啊你这个变态，这我都跳不过你！！”<br>“嘿嘿……”我被她推得来回晃，心中却得意得紧，“玩游戏如果不如你我还不如去死咧！！”<br>嘿嘿，虽然我炫舞确实玩得不咋地，但无奈某人实在是手残……<br>CX一直在女友的威逼之下，处境不比我好多少。<br>总共也没多少时间，去不了什么大景区，只去了常州的红梅公园，像我们这种穷鬼就只能去公园这些免费的地方了。<br>事实证明，没钱的时候就该去逛公园，因为说不定就能捡到钱！！<br>当我们四个人围着一张红票子站成一圈的时候，我们的内心是激动的。<br>“捡了！”CX一咬牙，弯腰捡起来。<br>“晚饭可以吃好的了！”LJL欢呼。<br>我以极其协调的动作从CX手中把一百块钱拿过来，行云流水一般塞入口袋，拍拍屁股走人喽~<br>“诶？钱呢？”CX看着空空的手心问。<br>“好像哪里不对……”他女朋友PCL眨了眨大眼睛。<br>“小兔崽子，给老娘站住！”LJL手指一指脱掉鞋子以一百二十码的速度追出去。<br>我在一处小亭子前被逮住，三人把我逼到边缘，后面就是一片湖！<br>天呐，这些人为了一百块钱全部化身黄世仁，之前我怎么一点没看出来？<br>一个个的……<br>都！欺！负！我！<br>“交出来！”LJL一手叉腰又伸出另一只手，气势汹汹。<br>“你太贱了。”CX低头轻摇，让我怀疑下一刻他会从袖子里掏出一把水果刀。<br>“嘿嘿……这是干啥呀……不就一百块钱吗……大家都有份都有份哈……”我伸手保持安全距离，“先放我保管而已……我你们还信不过吗？！”我摆出一副信不过我就是瞧不起我的眼神。<br>“废话，当然信不过！”这三货异口同声！<br>最终，我还是没能独吞那一百块钱，现在想来委实是一大憾事啊！不过那天晚上的烧烤倒是吃饱了……<br>这已经不是第一次捡到百元大钞了，第一次还是在高中的时候，我CXXS三人在食堂遇到了生平第一次！<br>事后三人就把钱平分了，我拿了四十，他们一人三十，晚上自然在学校外面的地边摊上加餐加餐再加餐，现在想来那竟已成再也回不去的岁月，只能留在回忆里发酵。<br>再一次捡到一百块，当然要和唯一不在场的XS炫耀，哦不，分享一下。<br>“XS，我和CX又捡到一百块！！”我在讨论组里噼里啪啦地写，后面跟着一大串表情。<br>XS在军校，CX和我都没想到他竟然能秒回。<br>“你们俩在一起？”<br>“废话，要不怎么一起捡到？”我说。<br>“放屁，明明就是我捡到的，章鱼个禽兽想私吞！”CX说。<br>“明明我先看到的好吧？！”我当然宁死不屈。<br>“别废话，见者有份，打我支付宝就行。”XS这小子倒也真是不客气。<br>“想得美！”我和CX终于站在了一条战线上。<br>“你们告诉我这件事不就是想和我分享成果吗？太没诚意了吧！傻逼们！”<br>“你让CX打给你。”队友这种东西，该卖的时候一定要果断！<br>“再见！”CX打出挥手的表情。<br>“太伤人了，好歹一毛钱意思意思啊！你们这两个碧池！”XS大呼不甘。<br>“嘿嘿！”发完这句话就把手机重新塞进口袋，继续逛公园去！<br>有钱了心情就是不一样，逛公园也敢往那些收费项目上瞄两眼了！！<br>话说回来，现在已经八月份了，XS那小子却还没回来，军校每年都有军训，他此时此刻正在大海上晾着呢……<br>嗯，希望他回来的时候比黑炭白一些，除此之外还能对他的皮肤提什么要求呢？<br>红梅公园很大，逛了好久才走完一圈，路过一家鬼屋，我兴致大发，嚷嚷着要去玩，没想到LJL跟我闹起来，说什么也不肯往那再走一步，看来这家伙上次被吓坏了……<br>真是的，有我在，怕什么？<br>倒不是说因为我胆子大所以她在我身边没事，而是因为她在我身边所以我胆子必须大。<br>僵持了半天我也没能如愿，兴致有些缺缺，不过后来她向我示好，我大人不记小人过捏她脸蛋两下就原谅她了。<br>唉，我总是心太软。<br>再后来，到了六月份的时候，CX也来了一次南京，行程大体相仿，都是网吧呆一晚然后再继续玩，玩得四个人全都筋疲力尽就各自打道回府。<br>在玄武湖划船的时候，湖水悠悠，船晃地悠悠，阳光软绵绵地照在身上，睡意袭来，三人倒着就要睡过去，留下我这个开船的在硬撑！！稍微一不留神，船差点撞上岸，吓得顿时睡意全无！<br>嗯，即使很玩得很疲倦，但是再不疯狂我们就老了。<br>我想，老了之后再做这些一定会有另一番感受，我会等待那种感受，但至少现在我要铭记年轻的感受，因为老了之后一定会无比怀念年少时光，我可不希望到时候想起来只记得曾经在玄武湖划过船，而那些岸边的垂柳、白色的拱桥、心中的感觉却都已遗忘。<br>那必将是一种莫大的忧伤，青春期忧伤已成基调，我可不要老来也忧伤。</p><p>……<br>……</p><p>记事总是这样，起初不知道怎么开头，然后打开回忆之后便不知如何收手。<br>能写的事情还有很多，全部写下来恐怕能有好几万字，那样未免太冗长，而且也没有必要。<br>写的时候会不禁想到更多难忘的回忆，就像是找东西，有的时候怎么也找不到，有的时候却又一股脑冒出来。<br>我想到和舍友们一起窝在宿舍看电影，我的小床上最多的时候能够坐五个大男生，凑在一起盯着电脑屏幕。看的电影有的喜悦有的则充满悲伤基调，但年轻就是神奇，不管无论多么悲伤的电影都能看得宿舍里一片欢笑。<br>不是说男生不悲伤，而是我们表达的方式不一样。<br>女生在一起看悲剧，悲伤了，所以哭。<br>男生在一起看悲剧，悲伤了，所以笑。<br>我们男生，不能轻易流露心中悲伤，纵使千愁万苦心中过，回头时也一定要表现得云淡风轻！</p><p>我想到和一群人开黑玩英雄联盟，一起玩的最多的是CX，然后就是依旧贼眉贼眼的ZC。<br>提到ZC就不得不提每次假期在他家的聚餐，不管烈阳高照还是冰雪交加，那是丢下一切也必须要赴的宴。<br>因为那是在家里，因为那是一家人。<br>ZC每次整出一桌好菜还不收半分钱，兴许就是这样攒的人品让他在不久前找到了女朋友？<br>嗯，一定是这样。<br>我只想提醒一下，好习惯要保持下去啊，再接再厉！！<br>今年暑假说话的聚餐呢？我相信ZC一定在默默准备着。<br>不过话说回来，玩起英雄联盟，谁管是不是一家人？<br>该坑坑，该卖卖，该挂机还得挂机！！<br>我早就说过，游戏本就该是一群人一起玩，输赢不重要，重要的是为了守住一座塔在任何时间从任何地点赶回来，重要的是你扛了半天BUFF伤害只等我来取走，重要的是你默默守在身边让掉一切资源，重要的是哪怕你开错团我也义无反顾冲上去，重要的是被人喷了毫不讲理地帮你喷回去！！<br>CXZC一定是懂的。</p><p>我想到前两天和FXTTM吃饭，这也是一项优良传统，每次寒暑假必有一次聚餐。<br>FXT变瘦了，TM还是老样子，不过是不是变高了些？<br>这次聚餐我带上了妹妹，妹妹下半年六年级，明年上初中。<br>我对她们说时间过得真快，转眼我妹妹都要上初中了，我觉得她还是个小屁孩，可我自己初中那会儿已经觉得自己是个大人了。<br>FXT说大家都一样。<br>TM问我初中那会儿都想什么？<br>我摇了摇头没有说话，我觉得初中就在昨天，但是真正回忆起来却发现已经隔了一层厚厚的浓雾，仿佛一切都是模糊的，而偏偏最清晰的那个人那些事已没有必要也不能再提。<br>因为最清晰，所以分界线显得那么刺眼。<br>我伸筷子，说道：“吃饭，吃饭……”</p><p>和FXTTM吃完饭的第二天，我和初中另两个妹子约在必胜客吃饭，就是ZL和FJY。<br>这还是第一次三人一起吃饭，如果可以的话，我不介意让它也成为一个传统。<br>和ZL见面次数还比较多，不过和FJY却是高中毕业后的第一次。<br>她也已经有了男朋友，再次见到她，似乎比印象中瘦了一些，却又比她发给我的照片胖一些……不过还是和记忆里一样漂亮就是了。<br>还好，饭间没有出现我一直担心的冷场情形，相反彼此说了很多话，没有一刻停歇，仿佛回到在实验学校上课的那段时光。<br>这顿饭时间吃得很长，因为聊了很多，大多是对未来的打算。<br>过去是让人感怀的，而未来是让人迷茫的。考研还是工作？考什么研？以后在哪里发展？等等等等。<br>和ZL聊天也比较多，可能是因为多吧，有事没事就会骚扰她一下，骂一句傻逼什么的，也不在乎她回不回我，不回我我发窗口抖动就是了。<br>至于FJY，对我来说就像一个妹妹一样，亲切地称呼她“小弱智”，听她时不时说些烦恼，前几个学期也帮了不少学习上的忙，不过专业毕竟不一样，以后的学习要靠她自己了，烦恼什么的我还是很乐意倾听的。<br>如果我难过了，找ZL那一定得到的答复是心灵鸡汤，而如果找FJY则不一样。<br>她并不会什么心灵鸡汤，她的方法要简单得多，那就是夸我，往死里夸，夸得我每次都心虚不已。<br>我就算有再多的难过，也没法在她的夸奖下坚持太久，只能融化。<br>然后她就会说：“夸你夸得我自己都觉得过分了。”<br>我笑笑，脑中却又想到另一个女孩。<br>嗯，是LYF。<br>是“锋”不是“峰”，我一直打错，一直被她骂。<br>不过已经很少有联系，只在这一学期聊过一两次天，还是因为她说做梦梦到我结婚了却没有请她。<br>咳咳，如果真结婚了，应该不会忘了的。<br>那天还聊了不少，聊着聊着她说我变自卑了很多。<br>我问她：“那你印象里我是啥样的？”<br>然后，她说：“我十六岁时最美好的少年。”<br>我说不清那个时候我的感觉，后来她又说那时的我在她眼里风光无限。<br>风光无限。<br>我从没想过这四个字能用来形容我。<br>就像在她之前，我从没想过我能够被人喜欢。<br>那时她眼里的我，比真正的我耀眼太多。<br>她给予过我很多，但是可能每个人的年少时光里都会有一个人，一旦出现，就会让人无法再关注其他人，我的那个人不是她，于是注定给不了她任何回报。<br>有一声“谢谢”，我从来没有对她说过，是我欠她的。</p><p>还有WYZ，相识已经很久，几乎上了多少年学便认识了多少年，关系一直都不错。<br>到了如今，因为有些相似的经历，在一些事上能够互相安慰，就像两只原野里的孤狼，难得相逢一次，轻轻互舔伤口，便重新站起来朝着不同的方向前进，不约定什么时候再相见，但是一定会再相见。<br>她曾经也是个明媚活泼的女孩，现在就算笑着眉眼深处也有一丝哀伤，像是把心中的火种亲自埋在百米冰山之中。<br>我说过，未来一定有个人能重新点亮她。<br>她说她喜欢“点亮”这个词。<br>我说你要等待。<br>该来的，总会来。<br>到最后，来的一定是最绚烂夺目的那个人。</p><p>还有看到《盗墓笔记》就会想起我的YWW，虽然没有太多交流，不过我还是记得那些年你坐在我身后，轻轻戳我的后背，唤我一声最亲切的“小哥”……</p><p>时间已经过去不少年，很多东西已经沉淀或者消失，现在我回想起来，我的身边竟有过那么多好女孩。<br>能遇到你们，感觉还不错。</p><p>当然还有兄弟，不过男生之间还是少点语言比较好，只要我记得我曾经只说了一句话ZSK就翘课来陪我就行了……还有刚刚结束小学期的ZZJ，我等着他请我看电影吃饭唱歌呢，可是刚刚聊天他说已经看电影看过两遍了，心塞塞……还有……还有……</p><p>那么多人，那么多事。<br>但是最美的我却觉得是那么一句话：<br>我们的故事，未完待续。<br>请听下回分解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2015年8月3日，2018年5月31日上传保存。）&lt;/p&gt;
&lt;p&gt;水灌进眼底，我看见当年的你。&lt;br&gt;我坐在这里，岁月也无声无息。&lt;/p&gt;
&lt;p&gt;谁能告诉我过去和现在、现在和未来之间到底有多远？&lt;br&gt;转眼已经大三，梧桐树叶轻轻洒落几个秋，我有时候看着它，沉默，然后把它胡乱踢进路旁的垃圾桶，转身离去，装作从来没见过。&lt;br&gt;风萧萧叶悄悄。&lt;br&gt;
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>春招面试准备</title>
    <link href="http://yoursite.com/2018/05/31/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2018/05/31/春招面试准备/</id>
    <published>2018-05-30T16:21:18.000Z</published>
    <updated>2018-10-09T15:59:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="90道"><a href="#90道" class="headerlink" title="90道"></a>90道</h1><h2 id="1、引用和指针的区别。"><a href="#1、引用和指针的区别。" class="headerlink" title="1、引用和指针的区别。"></a>1、引用和指针的区别。</h2><p>a、定义指针时分配内存，引用不分配内存，而和原变量内存地址相同，这是最本质的区别。<br>b、引用必须初始化<br>c、没有指向空值的引用，但是存在指向空值的指针。<br><a id="more"></a></p><h2 id="2、值传递、地址传递、引用传递的区别。"><a href="#2、值传递、地址传递、引用传递的区别。" class="headerlink" title="2、值传递、地址传递、引用传递的区别。"></a>2、值传递、地址传递、引用传递的区别。</h2><p>a、值传递，为形参重新分配内存空间，拷贝，形参不改变实参的值，结束后释放空间。<br>b、引用传递：不重新分配内存，形参会改变实参的值，不涉及内存分配和释放，效率最高。<br>c、地址传递：形参是指针变量，会给该指针变量分配内存空间，形参会改变实参的值，结束后释放空间。</p><h2 id="3、static的作用"><a href="#3、static的作用" class="headerlink" title="3、static的作用"></a>3、static的作用</h2><p>a、static变量的作用范围属于整个函数体，内存只会分配一次，和auto变量不同，多次调用该函数不会重<br>新分配新的变量，一次调用，持久保存。<br>普通函数f，调用三次，输出000<br>若f中有static，调用三次，输出012<br>b、在模块内的static变量可以被模块内函数访问，但不能被模块外其他函数访问，即使extern也不行。<br>c、static函数也会被限定在模块内<br>d、类中static成员变量属于整个类所拥有的，所有对象只有一个实例<br>e、类中static成员函数属于整个类所拥有，所以不接受this指针，只能访问类中static成员变量。</p><h2 id="4、const关键字的用处"><a href="#4、const关键字的用处" class="headerlink" title="4、const关键字的用处"></a>4、const关键字的用处</h2><p>a、阻止一个变量被改变，const表示常量，需要初始化<br>b、对指针来说，可以指定指针本身const，也可以指定指针所指的数据为const，或两者都是const<br>const int <em> p;//const是底层cosnt，表示p所指向的数据是一个常量，不可通过p修改该常量的值，但是p可以指向其他变量<br>int </em> const p;//顶层const，表示指针p本身是一个常量，不可以再指向其他变量，但是它所指的变量可以改变值<br>c、函数参数const，函数内不能改变值<br>d、类的成员函数const，常函数，不能修改类的成员变量<br>e、对类的成员函数，有时候会指定其返回值为cosnt，以使得返回值不为“左值”，因为在c++中可能存在给一个函数赋值的情况，即函数返回一个引用。</p><h2 id="5、链表和数组的区别。"><a href="#5、链表和数组的区别。" class="headerlink" title="5、链表和数组的区别。"></a>5、链表和数组的区别。</h2><p>a、数组是顺序表，开辟连续空间。而链表靠指针连接不连续的空间<br>b、数组要求空间连续，占用总空间小，链表则相反<br>c、数组方便排序查找，删除修改较慢；链表则相反。</p><h2 id="6、直接实现strlen（）"><a href="#6、直接实现strlen（）" class="headerlink" title="6、直接实现strlen（）"></a>6、直接实现strlen（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrlen</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(str==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;i++);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、直接实现strstr-char-str-char-sub-搜寻子串的函数"><a href="#7、直接实现strstr-char-str-char-sub-搜寻子串的函数" class="headerlink" title="7、直接实现strstr(char str,char sub)搜寻子串的函数"></a>7、直接实现strstr(char <em>str,char </em>sub)搜寻子串的函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">mystrstr</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">char</span>* sub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *pos;</span><br><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</span><br><span class="line">&#123;</span><br><span class="line">pos=&amp;str[i];</span><br><span class="line">s=sub;</span><br><span class="line"><span class="keyword">while</span>(*pos==*s)</span><br><span class="line">&#123;</span><br><span class="line">pos++;s++;</span><br><span class="line"><span class="keyword">if</span>(*s==<span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;str[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、直接实现strcat-char-str1-char-str2"><a href="#8、直接实现strcat-char-str1-char-str2" class="headerlink" title="8、直接实现strcat(char str1,char str2)"></a>8、直接实现strcat(char <em>str1,char </em>str2)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p=str1;</span><br><span class="line"><span class="keyword">while</span>(*str1!=<span class="string">'\0'</span>)</span><br><span class="line">str1++;</span><br><span class="line"><span class="keyword">while</span>(*str2!=<span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">*str1=*str2;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line">*str1=<span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、直接实现strcmp-char-str1-char-str2"><a href="#9、直接实现strcmp-char-str1-char-str2" class="headerlink" title="9、直接实现strcmp(char str1,char str2)"></a>9、直接实现strcmp(char <em>str1,char </em>str2)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrcmp</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str1==<span class="literal">NULL</span> || str2==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"invalid arguments"</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*str1&gt;*str2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*str1&lt;*str2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*str1==<span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str1++;str2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、请给出函数指针数组等定义"><a href="#10、请给出函数指针数组等定义" class="headerlink" title="10、请给出函数指针数组等定义"></a>10、请给出函数指针数组等定义</h2><p>int *<em>a;指向指针的指针<br>int </em>a[10];一个数组，每个元素是一个int指针<br>int (<em>a)[10];一个指针，指向有10个元素的int数组<br>int (</em>a) (int);一个指向函数的指针，该函数有一个整形参数并返回一个整形<br>int (*a[10])(int);函数指针数组，一个包含10个元素的数组，每个元素是一个函数指针，每个函数一个int参数返回一个int</p><h2 id="11、给定一个整形变量a，设置或清除bit-N"><a href="#11、给定一个整形变量a，设置或清除bit-N" class="headerlink" title="11、给定一个整形变量a，设置或清除bit N"></a>11、给定一个整形变量a，设置或清除bit N</h2><p>与或非操作</p><h2 id="12、C-中的空类，默认产生哪些成员函数"><a href="#12、C-中的空类，默认产生哪些成员函数" class="headerlink" title="12、C++中的空类，默认产生哪些成员函数."></a>12、C++中的空类，默认产生哪些成员函数.</h2><p>缺省构造函数<br>拷贝构造函数<br>析构函数<br>赋值运算符<br>当类成员有指针的时候，拷贝构造和赋值运算符需要重写。</p><h2 id="13、struct和class的区别"><a href="#13、struct和class的区别" class="headerlink" title="13、struct和class的区别"></a>13、struct和class的区别</h2><p>c中struct不可以有成员函数，c++中可以<br>c++中 struct默认权限public，class默认权限private</p><h2 id="14、内存思考题"><a href="#14、内存思考题" class="headerlink" title="14、内存思考题"></a>14、内存思考题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);&#125;</span><br><span class="line"><span class="function">voit <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str=<span class="literal">NULL</span>;</span><br><span class="line">get(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序崩溃，因为get不会传递动态内存，test中的str一直是null。<br>指针free后需要置为null，否则会成野指针</p><h2 id="15、关键字volatile有什么含义"><a href="#15、关键字volatile有什么含义" class="headerlink" title="15、关键字volatile有什么含义"></a>15、关键字volatile有什么含义</h2><p>被volatile修饰的变量是说这个变量可能会被意想不到地改变<br>比如硬件寄存器中的值可能经常变，所以使用的时候就要读取<br>多线程中的变量也是一样。<br>volatile告诉编译器不要优化这个变量，每次读取都读取实际的值而不是读取缓存</p><h2 id="16、读写绝对地址"><a href="#16、读写绝对地址" class="headerlink" title="16、读写绝对地址"></a>16、读写绝对地址</h2><p>int <em>ptr;<br>ptr=(int </em>)0x67a9;<br>*ptr=0xaa55</p><h2 id="17、heap与stack的区别"><a href="#17、heap与stack的区别" class="headerlink" title="17、heap与stack的区别"></a>17、heap与stack的区别</h2><p>stack的空间由操作系统自动分配/释放，heap上的空间是手动分配释放的。<br>stack空间有限，heap有很大的自由存储区（new）<br>程序在编译期对变量和函数分配内存都在栈上，且程序运行过程中函数调用参数的传递也在栈上。<br>还有一种静态内存，保存局部static对象</p><h2 id="18、不借助第三个数交换两个数的值。"><a href="#18、不借助第三个数交换两个数的值。" class="headerlink" title="18、不借助第三个数交换两个数的值。"></a>18、不借助第三个数交换两个数的值。</h2><p>第一种：a=a+b;b=a-b;a=a-b;<br>第二种：a=a*b;b=a/b;a=a/b;（b不为0）<br>第三种：a=a^b;b=a^b;a=a^b;</p><h2 id="19、用宏定义写出swap（x，y）"><a href="#19、用宏定义写出swap（x，y）" class="headerlink" title="19、用宏定义写出swap（x，y）"></a>19、用宏定义写出swap（x，y）</h2><p>#define swap(x,y) (x)=(x)+(y);(y)=(x)-(y);(x)=(x)-(y);<br>宏定义时参数用括号括起来，且表达式之间不要有空格</p><h2 id="20、用宏定义返回两个参数中较小的一个"><a href="#20、用宏定义返回两个参数中较小的一个" class="headerlink" title="20、用宏定义返回两个参数中较小的一个"></a>20、用宏定义返回两个参数中较小的一个</h2><p>#define Min(x,y) ((x)&gt;(y)?(y):(x))<br>结尾没有分号</p><h2 id="21、带参数的宏和带参数的函数的区别"><a href="#21、带参数的宏和带参数的函数的区别" class="headerlink" title="21、带参数的宏和带参数的函数的区别"></a>21、带参数的宏和带参数的函数的区别</h2><p>a、宏在编译时处理，会展开，而函数在运行时处理<br>b、宏里的参数不需要定义类型，函数中参数必须有类型<br>c、宏会使程序变长，而函数不会<br>d、宏不占用存储空间，函数占用<br>e、宏不占用运行时间，函数调用和返回时占用运行时间<br>带参宏简单，不灵活</p><h2 id="22、定义宏，求出数组元素的个数"><a href="#22、定义宏，求出数组元素的个数" class="headerlink" title="22、定义宏，求出数组元素的个数"></a>22、定义宏，求出数组元素的个数</h2><p>#define NTBL(table) (sizeof(table)/sizeof(table[0]))</p><h2 id="23、两个栈实现一个队列的功能"><a href="#23、两个栈实现一个队列的功能" class="headerlink" title="23、两个栈实现一个队列的功能"></a>23、两个栈实现一个队列的功能</h2><p>入队：将元素压入栈a<br>出队：<br>（1）判断栈b是否为空<br>（2）如果不为空，则将栈a中所有元素依次pop出并push到栈b<br>（3）将栈b的栈顶元素pop出，即出队元素</p><h2 id="24、在c-中调用c函数，为什么要加extern-c"><a href="#24、在c-中调用c函数，为什么要加extern-c" class="headerlink" title="24、在c++中调用c函数，为什么要加extern c?"></a>24、在c++中调用c函数，为什么要加extern c?</h2><p>答：c++支持函数重载，c语言不支持函数重载。函数被c++编译后在库中的名字和c的不同。<br>void foo(int x,int y)<br>在c中编译结果：_foo<br>在c++中：_foo_int_int<br>所以要加extern “c”来解决名字匹配问题</p><h2 id="25、找出程序中的错误"><a href="#25、找出程序中的错误" class="headerlink" title="25、找出程序中的错误"></a>25、找出程序中的错误</h2><p>视频第26题：5个错误<br>27题：4个（可不看）</p><h2 id="26、一句话判断x是否是2的次幂"><a href="#26、一句话判断x是否是2的次幂" class="headerlink" title="26、一句话判断x是否是2的次幂"></a>26、一句话判断x是否是2的次幂</h2><p>a、x&amp;(x-1)<br>上式为0，则是，否则不是。<br>b、判断logx/log2是不是整数</p><h2 id="27、按要求定义变量"><a href="#27、按要求定义变量" class="headerlink" title="27、按要求定义变量"></a>27、按要求定义变量</h2><p>定义全零全一的变量<br>unsigned int zero=0;<br>unsigned int compzero=~0;<br>不能写unsigned int compzero=0xFFFF，因为处理器位数不一定</p><h2 id="28、malloc分配内存"><a href="#28、malloc分配内存" class="headerlink" title="28、malloc分配内存"></a>28、malloc分配内存</h2><p>ptr=(char *)malloc(0)<br>分配能否成功？<br>分配虽然成功，但它是0个字节，无法真正使用。</p><h2 id="29、对数组名取地址"><a href="#29、对数组名取地址" class="headerlink" title="29、对数组名取地址"></a>29、对数组名取地址</h2><p>数组名本身表示数组第一个元素的地址<br>数组名取地址代表整个数组，该地址+1是加了整个数组的长度。</p><h2 id="30、static修饰局部变量"><a href="#30、static修饰局部变量" class="headerlink" title="30、static修饰局部变量"></a>30、static修饰局部变量</h2><p>生命周期延长</p><h2 id="31、switch。。。case接受哪种基本数据类型？省略break会怎样？"><a href="#31、switch。。。case接受哪种基本数据类型？省略break会怎样？" class="headerlink" title="31、switch。。。case接受哪种基本数据类型？省略break会怎样？"></a>31、switch。。。case接受哪种基本数据类型？省略break会怎样？</h2><p>不接受float、double。<br>若省略break则匹配成功后一直运行到结束或遇到第一个break</p><h2 id="32、无符号数据类型转换"><a href="#32、无符号数据类型转换" class="headerlink" title="32、无符号数据类型转换"></a>32、无符号数据类型转换</h2><p>无符号和有符号相运算，有符号会转化成无符号，若是负数则会变为极大的正数。</p><h2 id="33、算出一个字节中被置1的位个数"><a href="#33、算出一个字节中被置1的位个数" class="headerlink" title="33、算出一个字节中被置1的位个数"></a>33、算出一个字节中被置1的位个数</h2><p>循环移位并判断最后一位是否为1<br>或者用x&amp;(x-1)计算</p><h2 id="34、编写函数将给定的字符串转换成整数。"><a href="#34、编写函数将给定的字符串转换成整数。" class="headerlink" title="34、编写函数将给定的字符串转换成整数。"></a>34、编写函数将给定的字符串转换成整数。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(*str!=<span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d=*str<span class="number">-48</span>;</span><br><span class="line">num=num*<span class="number">10</span>+d;</span><br><span class="line">str=str+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35、将整数转换成字符串。"><a href="#35、将整数转换成字符串。" class="headerlink" title="35、将整数转换成字符串。"></a>35、将整数转换成字符串。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> *pval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> strval[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> val0=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> val1=<span class="number">0</span>;</span><br><span class="line">val0=num;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">val1=val0%<span class="number">10</span>;</span><br><span class="line">val0=val0/<span class="number">10</span>;</span><br><span class="line">strval[i]=val1+<span class="number">48</span>;</span><br><span class="line"><span class="keyword">if</span>(val0&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">strval[i]=val0+<span class="number">48</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">pval[j]=strval[i-j];</span><br><span class="line">pval[j]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36、怎么判断链表中是否有环？"><a href="#36、怎么判断链表中是否有环？" class="headerlink" title="36、怎么判断链表中是否有环？"></a>36、怎么判断链表中是否有环？</h2><p>追逐方式。<br>两个指针遍历链表，一个每次走一步，一个每次走两步，若后者能追上前者，则表示有环。</p><h2 id="37、双向链表的插入和删除。"><a href="#37、双向链表的插入和删除。" class="headerlink" title="37、双向链表的插入和删除。"></a>37、双向链表的插入和删除。</h2><p>插入修改四个指针。<br>删除只需要修改两个。</p><h2 id="38、二维数组转置。"><a href="#38、二维数组转置。" class="headerlink" title="38、二维数组转置。"></a>38、二维数组转置。</h2><p>核心操作:b[j][i]=a[i][j]</p><h2 id="39、输入一行字符，统计其中有多少个单词。"><a href="#39、输入一行字符，统计其中有多少个单词。" class="headerlink" title="39、输入一行字符，统计其中有多少个单词。"></a>39、输入一行字符，统计其中有多少个单词。</h2><p>按空格累加。</p><h2 id="40、杨辉三角"><a href="#40、杨辉三角" class="headerlink" title="40、杨辉三角"></a>40、杨辉三角</h2><h2 id="41、计算字符串中子串出现的次数"><a href="#41、计算字符串中子串出现的次数" class="headerlink" title="41、计算字符串中子串出现的次数"></a>41、计算字符串中子串出现的次数</h2><p>循环比较。</p><h2 id="42、数组a-n-，存放1到n，找出被重复的数字，时间复杂度为O（n）"><a href="#42、数组a-n-，存放1到n，找出被重复的数字，时间复杂度为O（n）" class="headerlink" title="42、数组a[n]，存放1到n，找出被重复的数字，时间复杂度为O（n）"></a>42、数组a[n]，存放1到n，找出被重复的数字，时间复杂度为O（n）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_dup</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=a[i];</span><br><span class="line">sum=sum-(N<span class="number">-1</span>)(N)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43、16bit的整数，每4bit为一个数，写函数求他们的和"><a href="#43、16bit的整数，每4bit为一个数，写函数求他们的和" class="headerlink" title="43、16bit的整数，每4bit为一个数，写函数求他们的和"></a>43、16bit的整数，每4bit为一个数，写函数求他们的和</h2><p>循环，移位相加即可。<br>c+=n&15;<br>n=n&gt;&gt;4;</p><h2 id="47、什么函数不能声明为虚函数？"><a href="#47、什么函数不能声明为虚函数？" class="headerlink" title="47、什么函数不能声明为虚函数？"></a>47、什么函数不能声明为虚函数？</h2><p>virtual<br>a、内联函数，内联函数在编译时展开，而虚函数是运行时动态绑定，所以两者矛盾。<br>b、构造函数，构造函数用来创建一个新的对象，而虚函数运行时建立在对象基础上，在构造函数时对象尚未形成。<br>c、静态成员函数，静态成员函数属于一个类而非某一对象，没有this指针，无法进行对象的判别。<br>d、非成员函数<br>e、类的成员函数是模板函数的时候。</p><h2 id="48、编写一个函数作用是把char数组字符串循环右移n位"><a href="#48、编写一个函数作用是把char数组字符串循环右移n位" class="headerlink" title="48、编写一个函数作用是把char数组字符串循环右移n位"></a>48、编写一个函数作用是把char数组字符串循环右移n位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoopMove</span><span class="params">(<span class="keyword">char</span> *pstr,<span class="keyword">int</span> steps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(pstr)-steps;</span><br><span class="line"><span class="keyword">char</span> temp[MAX_LEN];</span><br><span class="line"><span class="built_in">strcpy</span>(temp,pstr+n);</span><br><span class="line"><span class="built_in">strcpy</span>(temp+steps,pstr);</span><br><span class="line">*(tmp+<span class="built_in">strlen</span>(pstr))=<span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(pstr,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="49、编写类String的构造函数、析构函数和赋值函数。"><a href="#49、编写类String的构造函数、析构函数和赋值函数。" class="headerlink" title="49、编写类String的构造函数、析构函数和赋值函数。"></a>49、编写类String的构造函数、析构函数和赋值函数。</h2><p>一个类包含指针的话，一般会有析构函数，而且要重写拷贝构造和赋值运算符，因为默认是地址的拷贝和赋值，对指针来说无意义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">String(<span class="keyword">const</span> <span class="keyword">char</span> *str=<span class="literal">NULL</span>);</span><br><span class="line">String(<span class="keyword">const</span> <span class="built_in">string</span> &amp;other);<span class="comment">//拷贝构造</span></span><br><span class="line">~String();</span><br><span class="line">String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;other);<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="50、指向二维数组的指针1。"><a href="#50、指向二维数组的指针1。" class="headerlink" title="50、指向二维数组的指针1。"></a>50、指向二维数组的指针1。</h2><h2 id="51、指向二维数组的指针2。"><a href="#51、指向二维数组的指针2。" class="headerlink" title="51、指向二维数组的指针2。"></a>51、指向二维数组的指针2。</h2><p>注意++到底是加的一维数组还是一个元素。</p><h2 id="52、逗号运算符（优先级最低）"><a href="#52、逗号运算符（优先级最低）" class="headerlink" title="52、逗号运算符（优先级最低）"></a>52、逗号运算符（优先级最低）</h2><p>a=3;b=5;<br>c=a,b;<br>d=(a,b);<br>执行之后，c=3，d=5.</p><h2 id="53、sizeof运算符。"><a href="#53、sizeof运算符。" class="headerlink" title="53、sizeof运算符。"></a>53、sizeof运算符。</h2><p>int i=3;<br>int j;<br>j=sizeof(++i+ ++i);<br>print(“i=%d,j=%d”,i,j);<br>输出：i=3，j=4<br>原因：编译器进行优化，发现++对sizeof根本没影响，所以会优化不计算++，发生短路现象。</p><h2 id="54、递归展开求值。"><a href="#54、递归展开求值。" class="headerlink" title="54、递归展开求值。"></a>54、递归展开求值。</h2><h2 id="55、赋值运算符-作为循环条件。"><a href="#55、赋值运算符-作为循环条件。" class="headerlink" title="55、赋值运算符=作为循环条件。"></a>55、赋值运算符=作为循环条件。</h2><p>赋非零值，无限循环。<br>赋0，不循环。</p><h2 id="56、（a-b）-c与（a-c）-b是否恒等"><a href="#56、（a-b）-c与（a-c）-b是否恒等" class="headerlink" title="56、（a+b）+c与（a+c）+b是否恒等"></a>56、（a+b）+c与（a+c）+b是否恒等</h2><p>不一定，可能会溢出。假设a+b溢出，但是c是负数，a+c后再加b就不一定溢出了。<br>a+b+c一定等于b+a+c</p><h2 id="57、进程和线程的差别。"><a href="#57、进程和线程的差别。" class="headerlink" title="57、进程和线程的差别。"></a>57、进程和线程的差别。</h2><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>a、线程是调度分配的基本单位，进程是拥有资源的基本单位。<br>b、并发性，都可以并发。进程切换比线程切换开销大。<br>c、拥有资源，进程是拥有资源的独立单位，线程不拥有系统资源，但是可以访问所属进程的资源。<br>d、系统开销，在创建或撤销进程时，由于系统都要分配和回收资源，所以开销较大。</p><h2 id="58、解释const-char-const-p"><a href="#58、解释const-char-const-p" class="headerlink" title="58、解释const char * const p"></a>58、解释const char * const p</h2><p>左边是底层const，右边是顶层const。<br>char <em> const p//常量指针，p的地址不可以修改，即指针本身不可修改<br>const char </em> p;//指向常量的指针，指针本身可修改，但指向的内容不可修改。<br>char const * p;//同上<br>两个const就是指针本身不可以修改，所指内容也不可更改。</p><h2 id="59、memset、memcpy和strcpy的根本区别。"><a href="#59、memset、memcpy和strcpy的根本区别。" class="headerlink" title="59、memset、memcpy和strcpy的根本区别。"></a>59、memset、memcpy和strcpy的根本区别。</h2><p>memset和memcpy需要包含memory.h，strcpy需要string.h<br>memset用来对一段内存空间全部设置为某个字符 memset(a,0,sizeof(a))<br>memcpy用来内存拷贝，拷贝任何数据类型的对象 memcpy(b,a,sizeof(b))<br>strcpy只能拷贝字符串，遇到’\0’就结束，所以不需要指定大小。<br>要注意内存溢出。</p><h2 id="60、析构函数有何特点。"><a href="#60、析构函数有何特点。" class="headerlink" title="60、析构函数有何特点。"></a>60、析构函数有何特点。</h2><p>a、析构函数也是特殊的类成员函数，和构造函数一样没有返回类型<br>b、没有参数<br>c、不能重载<br>d、public、private、protected对析构函数无效<br>e、析构函数不能手动调用，只有在类对象生命周期结束的时候，由系统自动调用释放在构造函数中分配的资源，回收内存。<br>f、构造函数不可以是virtual，但析构函数可以。</p><h2 id="61、虚函数有什么用？"><a href="#61、虚函数有什么用？" class="headerlink" title="61、虚函数有什么用？"></a>61、虚函数有什么用？</h2><p>a、虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没覆盖调用父类中的函数，从而实现灵活扩展和多态性。<br>b、如果是纯虚函数，则纯粹是为了在子类覆盖时有个统一的命名而已，子类必须覆盖纯虚函数，否则子类也是抽象类<br>c、含有纯虚函数的类称为抽象类，不能实例化对象，主要用于做接口</p><h2 id="62、虚析构函数的作用"><a href="#62、虚析构函数的作用" class="headerlink" title="62、虚析构函数的作用"></a>62、虚析构函数的作用</h2><p>虚构函数调用是先子后父。<br>当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，就会导致运行时派生类不会被销毁，然而基类部分已经被销毁，这就导致了部分析构，造成内存泄露。<br>此时就需要给基类一个虚析构函数。</p><h2 id="63、分别给出bool、in、float、指针变量与零值比较的if语句"><a href="#63、分别给出bool、in、float、指针变量与零值比较的if语句" class="headerlink" title="63、分别给出bool、in、float、指针变量与零值比较的if语句"></a>63、分别给出bool、in、float、指针变量与零值比较的if语句</h2><p>bool:if(!var)<br>int:if(var==0)<br>float: const float var=0.000001;<br>    if(x&gt;-var &amp;&amp; x&lt;var)<br>浮点数不能精确到0，所以需要在一个范围内近似看做0<br>指针：if(var==NULL)</p><h2 id="64、32位下，计算sizeof"><a href="#64、32位下，计算sizeof" class="headerlink" title="64、32位下，计算sizeof"></a>64、32位下，计算sizeof</h2><p>a、<br>void fun(char str[100])<br>{<br>sizeof(str)=?//4<br>}<br>原因：数组做函数形参，会转化成指针<br>b、<br>void <em>p=malloc(100);<br>sizeof(p) //4<br>c、<br>int a[100]<br>sizeof(a)//4</em>100<br>d、<br>char *p=”aaa”<br>sizeof(p)=?//4</p><h2 id="65、写函数返回1-2-3-。。-n的值"><a href="#65、写函数返回1-2-3-。。-n的值" class="headerlink" title="65、写函数返回1+2+3+。。+n的值"></a>65、写函数返回1+2+3+。。+n的值</h2><p>解法1：一重循环<br>解法2：利用高斯公式直接求 （1+n）*n/2</p><h2 id="66、深度广度遍历二叉树。"><a href="#66、深度广度遍历二叉树。" class="headerlink" title="66、深度广度遍历二叉树。"></a>66、深度广度遍历二叉树。</h2><h2 id="67、内联函数和普通函数的区别。"><a href="#67、内联函数和普通函数的区别。" class="headerlink" title="67、内联函数和普通函数的区别。"></a>67、内联函数和普通函数的区别。</h2><p>a、内联函数是将简单函数内嵌道调用它的程序代码中，目的是节约原本函数调用时的时空开销，不能含有循环、条件、选择等复杂的结构。<br>b、内联函数和宏的区别，宏是由预处理器对宏进行替代，而内联函数是通过编译器来控制的。内联函数是真正的函数，取消了函数的参数压栈，减少调用开销，不用担心像宏函数的问题。<br>c、用inline定义内联函数，任何在类的说明部分定义的函数都会自动认为是内联函数。</p><h2 id="68、c-重写和重载重定义区别"><a href="#68、c-重写和重载重定义区别" class="headerlink" title="68、c++重写和重载重定义区别"></a>68、c++重写和重载重定义区别</h2><p>a、重载特征：相同的范围（同一个类），函数名字相同，参数不同<br>b、重写（覆盖）：派生类函数覆盖基类函数，分别位于基类和派生类中，名字相同，参数相同，基类函数必须有virtual<br>c、重定义是指派生类的函数屏蔽了与其同名的基类函数<br>如果派生类的函数和基类的函数同名，参数不同，此时不管有无virtual，基类的函数被隐藏<br>如果派生类的函数与基类的函数同名，参数也相同，但基类没有virtual，此时基类的函数被隐藏</p><h2 id="69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。"><a href="#69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。" class="headerlink" title="69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。"></a>69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。</h2><p>可以的。<br>static一般在类外初始化，const一般在构造函数里初始化。<br>既是const又是static就在类外初始化，但要在类外初始化的同时声明为const。</p><h2 id="70、构造函数和析构函数的异同点。"><a href="#70、构造函数和析构函数的异同点。" class="headerlink" title="70、构造函数和析构函数的异同点。"></a>70、构造函数和析构函数的异同点。</h2><p>构造函数的特点：<br>1、构造函数名字与类名相同<br>2、构造函数可以有任意的参数，但不能具有返回类型<br>3、定义对象时，编译系统自动调用构造函数<br>4、够咱函数是特殊的成员函数，函数体可以在类内，也可以在类外<br>5、构造函数不能像其他成员函数那样被显示调用，它是在定义对象的同时被调用</p><p>析构函数的特点：<br>1、析构函数名字与类型相同，析构函数前加一个~<br>2、析构函数没有参数，也没有返回值，不能被重载，一个类只能有一个析构函数<br>3、在撤销对象时，编译系统会自动调用析构函数<br>4、析构函数可以是virtual，而构造函数不可以。</p><h2 id="71、自动调用拷贝构造函数的几种情形。"><a href="#71、自动调用拷贝构造函数的几种情形。" class="headerlink" title="71、自动调用拷贝构造函数的几种情形。"></a>71、自动调用拷贝构造函数的几种情形。</h2><p>拷贝构造函数是用一个已知对象来初始化另一个同类对象。<br>拷贝构造函数也是类的构造函数，与雷鸣相同，又一个该类对象引用的参数。<br>若自己不写，则会自动生成一个默认的。<br>若一个类中有指针，就需要自己写，不能用默认的，因为默认的是地址拷贝。</p><p>自动调用情况：<br>1当类的一个对象去初始化该类另一个对象时。<br>2如果函数形参是类的对象，调用函数进行形参和实参结合时<br>3如果函数返回值是类对象，函数返回时。</p><h2 id="72、类型转换构造函数是什么？"><a href="#72、类型转换构造函数是什么？" class="headerlink" title="72、类型转换构造函数是什么？"></a>72、类型转换构造函数是什么？</h2><p>自动调用类型匹配的构造函数，自动将基本数据类型转换成对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> height;</span><br><span class="line">Person(<span class="keyword">double</span> h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p=<span class="number">2.3</span>;<span class="comment">//类型转换构造函数，将2.3转换成double调用该构造函数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">类型转换函数可以产生自动类型转换匹配，如下：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">intheight;</span><br><span class="line">Person(<span class="keyword">int</span> h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span>的构造函数也可以调用成功。</span><br></pre></td></tr></table></figure></p><h2 id="73、异常处理方式。"><a href="#73、异常处理方式。" class="headerlink" title="73、异常处理方式。"></a>73、异常处理方式。</h2><p>步骤：<br>1、程序执行时发生错误<br>2、以一个异常对象记录错误的原因及相关信息<br>3、程序检测到这个错误（读取错误对象）<br>4、程序决定如何处理错误<br>5、错误处理，并在此后恢复或终止程序的执行</p><h2 id="74、成员函数和友元函数的区别"><a href="#74、成员函数和友元函数的区别" class="headerlink" title="74、成员函数和友元函数的区别"></a>74、成员函数和友元函数的区别</h2><p>a、成员函数是类定义的一部分通过特定的对象来调用。成员函数可以隐式访问对象的成员，而无须使用成员操作符<br>b、友元函数不是类的组成部分，因为被称为直接函数调用。友元函数不能隐式访问类成员，必须将成员操作符用于参数传递的对象。</p><h2 id="75、c-中哪些运算符不能重载"><a href="#75、c-中哪些运算符不能重载" class="headerlink" title="75、c++中哪些运算符不能重载"></a>75、c++中哪些运算符不能重载</h2><p>.<br>?:<br>sizeof（不是函数是运算符）<br>::<br><em>（指针解引用不可以重载，乘号可以）<br>.</em></p><h2 id="76、如何重载前-和后"><a href="#76、如何重载前-和后" class="headerlink" title="76、如何重载前++和后++"></a>76、如何重载前++和后++</h2><p>前++不带参数，后++带一个（int）以示区分<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iCount &amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">data++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iCount <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">iCount temp=*<span class="keyword">this</span>;</span><br><span class="line">data++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="77、请说出STL标准模板库中的几个常用类"><a href="#77、请说出STL标准模板库中的几个常用类" class="headerlink" title="77、请说出STL标准模板库中的几个常用类"></a>77、请说出STL标准模板库中的几个常用类</h2><p>vector<br>list<br>set<br>stack<br>queue<br>map</p><h2 id="78、函数模板和函数重载的异同"><a href="#78、函数模板和函数重载的异同" class="headerlink" title="78、函数模板和函数重载的异同"></a>78、函数模板和函数重载的异同</h2><p>函数重载是指函数名字相同，但是参数类型或者个数不同，顺序不同。<br>函数模板是指函数算法相同，而参数类型不同。</p><h2 id="79、类型转换构造函数是什么？"><a href="#79、类型转换构造函数是什么？" class="headerlink" title="79、类型转换构造函数是什么？"></a>79、类型转换构造函数是什么？</h2><p>是隐式调用构造函数，将基本数据类型转换成对象。<br>对象不可转换成基本数据类型。</p><h2 id="80、c-中explicit关键字有什么用。"><a href="#80、c-中explicit关键字有什么用。" class="headerlink" title="80、c++中explicit关键字有什么用。"></a>80、c++中explicit关键字有什么用。</h2><p>explicit和构造函数一起使用，指明构造函数只能显式调用，目的是为了防止不必要的隐式调用类型转换构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> height;</span><br><span class="line">explicit Person(double h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p=<span class="number">2.3</span>;<span class="comment">//会报错，因为explicit阻止了隐式调用，必须显式调用</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">2.4</span>)</span></span>;<span class="comment">//显示调用，可以</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="81、c-中restrict关键字有什么作用？"><a href="#81、c-中restrict关键字有什么作用？" class="headerlink" title="81、c++中restrict关键字有什么作用？"></a>81、c++中restrict关键字有什么作用？</h2><p>是用来优化的，是c99新加的关键字。<br>restrict只能修饰指针，修饰的指针时能够访问所指区域的唯一入口，限制多个指针指向同一地址。<br>如果两个指针指向同一个地址，一个被释放了，另一个就成了野指针。</p><h2 id="82、c-中常用的设计模式又哪些？"><a href="#82、c-中常用的设计模式又哪些？" class="headerlink" title="82、c++中常用的设计模式又哪些？"></a>82、c++中常用的设计模式又哪些？</h2><p>工厂方法<br>策略模式<br>单例模式<br>迭代器模式<br>抽象工厂模式<br>建造者模式<br>适配器模式<br>桥接模式<br>折磨死<br>解释器模式<br>命令模式<br>中介者模式<br>观察者陌生<br>状态模式<br>代理模式</p><h2 id="83、写一个单例模式的例子。"><a href="#83、写一个单例模式的例子。" class="headerlink" title="83、写一个单例模式的例子。"></a>83、写一个单例模式的例子。</h2><p>其目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。比如定义常量的类。<br>将构造函数私有。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">C()&#123;&#125;;<span class="comment">//构造函数私有</span></span><br><span class="line"><span class="keyword">static</span> C * p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> C * <span class="title">Get</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">p=<span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">C * C::p==<span class="literal">NULL</span>;<span class="comment">//static属性类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C* p1=C::get();</span><br><span class="line">C* p2=C::get();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(p1==p2)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="84、面向对象的三大特征。"><a href="#84、面向对象的三大特征。" class="headerlink" title="84、面向对象的三大特征。"></a>84、面向对象的三大特征。</h2><p>a、封装<br>b、继承<br>c、多态</p><h2 id="85、什么是封装"><a href="#85、什么是封装" class="headerlink" title="85、什么是封装"></a>85、什么是封装</h2><p>封装是面向对象的特征之一，是对象和类概念的主要特性。<br>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<br>c++中，public、protected、private就是封装的访问权限说明符。</p><h2 id="86、什么是继承"><a href="#86、什么是继承" class="headerlink" title="86、什么是继承"></a>86、什么是继承</h2><p>继承可以使现有类的所有功能，并在无需重新编写原来类的情况下对功能进行扩展。<br>c++支持单继承和多继承，也有多级继承。<br>用public、protected和private修饰继承特性。</p><h2 id="87、什么是多态"><a href="#87、什么是多态" class="headerlink" title="87、什么是多态"></a>87、什么是多态</h2><p>polymorphisn<br>允许将父对象设置成为一个或更多的他的子对象相等的技术。<br>父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。<br>父类的指针用引用赋子类的值。<br>两种方式，覆盖（重写），重载。<br>覆盖，子类重新定义父类的virtual虚函数。<br>重载，允许存在多个同名函数，但参数列表不同。</p><h2 id="88、类和对象的区别。"><a href="#88、类和对象的区别。" class="headerlink" title="88、类和对象的区别。"></a>88、类和对象的区别。</h2><p>是一般与个别、抽象与具体、集体与个体的区别。<br>举个例子即可（人类和张三）</p><h2 id="89、c-中的namespace是什么？"><a href="#89、c-中的namespace是什么？" class="headerlink" title="89、c++中的namespace是什么？"></a>89、c++中的namespace是什么？</h2><p>命名空间，类似于java中的包<br>避免在不同程序库中的命名冲突。<br>详看c++ primer</p><h2 id="90、什么是可重入和不可重入函数？"><a href="#90、什么是可重入和不可重入函数？" class="headerlink" title="90、什么是可重入和不可重入函数？"></a>90、什么是可重入和不可重入函数？</h2><p>可重入性：reentrant<br>函数可以由多于一个任务并发使用，而不必担心数据错误，可以在任意时刻被中断，稍后再继续运行不会丢失数据。<br>不可重入函数不能超过一个任务所共享。</p><p>可重入函数：<br>不为连续的调用持有静态数据<br>不返回指向静态数据的指针<br>使用本地数据<br>如果必须访问全局变量需要利用互斥信号量<br>不调用不可重入函数</p><p>不可重入函数：<br>使用了静态变量<br>返回静态变量<br>调用了不可重入函数<br>调用了malloc或free<br>调用了其他标准i/o</p><p>总的来说，一个函数使用了未受保护的共享资源，就不可重入。</p><h1 id="hash函数、数据库基本"><a href="#hash函数、数据库基本" class="headerlink" title="hash函数、数据库基本"></a>hash函数、数据库基本</h1><p>hash函数性质：输入域巨大，输出域固定<br>1、输入域无限<br>2、相同输入，结果相同<br>3、不通输入，结果可能相同也可能不同<br>4、不同输入值得到的hash值，均匀分布在输出域上（优劣评判）</p><p>32位无符号整数范围，0到40一亿左右。    </p><p>第一范式：每一个分量都是不可分的数据项。<br>第二范式：每一个非主属性完全函数依赖于任何一个候选码。<br>第三范式：每一个非主属性既不传递依赖于码，也不部分依赖于码。<br>BCNF：若每一个决定因素都包含码。<br>一个满足BCNF的关系模式有：<br>所有非主属性对每一个码都是完全函数依赖。<br>所有主属性对每一个不包含它的码也是完全函数依赖。<br>没有任何属性完全函数依赖于非码的任何一组属性。</p><p>事务的ACID特性<br>原子性：事务中的操作要么都做，要么都不做。<br>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。<br>隔离性：一个事务的执行不能被其他事务干扰。<br>持续性：事务一旦提交，它对数据库中数据的改变就应是永久性的。</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>1、网络协议主要由三要素组成：语法、语义和 同步。</p><p>2、osi体系结构<br>物理层：单位bit，为上层提供了传输数据的物理介质。<br>数据链路层：单位帧，在不可靠的物理介质上提供可靠的传输。HDLC、PPP。<br>网络层：单位分组或数据包，负责对子网间的数据包进行路由选择。IP。<br>传输层：单位报文，是第一个端到端即进程到进程的层次，提供端到端的传输。TCP、UDP。<br>会话层：负责建立、管理、终止进程之间的会话。<br>表示层：进行数据转换，包括加密、压缩、格式转换等。<br>应用层：为操作系统或网络应用程序提供网络服务的接口。FTP、HTTP。</p><p>tcp/ip体系结构：网络接口层、网际层、传输层和应用层。<br>五层体系结构就是把网络接口层依然分解为物理层和数据链路层。</p><p>3、数据链路层三个基本问题：数据成帧，透明传输，差错检测。<br>CRC检验码的位数就是生成多项式的最高次数。</p><p>4、路由器分组转发流程<br>a、从分组首部提取目的站的IP地址D，得出目的网络地址为N<br>b、若网络N与此路由器直接相连，则直接将分组交付给目的站D，否则转到c<br>c、若路由表中有目的地址为D的特定主机路由，则将分组传送给路由表中所指明的下一跳路由器，否则转d<br>d、若路由表有到达网络N的路由，则将分组传送给路由器表指明的下一跳路由器，否则转e<br>e、若路由表中有一个默认路由，则将分组传送到默认路由，否则报错。</p><p>5、ping的过程<br>ping是ICMP的一个重要应用。<br>ping同一个网段的主机：查找目的主机的mac地址，然后直接交付。如果没查到mac地址，就进行一次arp请求。<br>ping不同网段的主机：发送到网关让其进行转发，同样要发送到网关也得知道网关的mac地址，根据mac地址进行转发。</p><p>6、三块专用地址<br>A类：10.0.0.0 ~ 10.255.255.255<br>B类：172.16.0.0 ~ 172.31.255.255<br>C类：192.168.0.0 ~ 192.168.255.255</p><p>7、用户数据包协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。</p><p>传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</p><p>8、web页面请求过程<br>a、向DNS服务器发送DNS查询报文解析域名获得IP地址。<br>b、通过TCP向服务器发送连接请求。<br>c、服务器上会有个服务进程在不断监听80端口，当监听到连接请求后便与浏览器建立连接。建立之后服务器会随机分配一个端口号给客户端，之后的tcp传输都用这个分配的客户端。<br>d、TCP建立后，浏览器向服务器放松要求获取某一Web页面的http请求。<br>e、服务器收到http请求后构建所需信息，通过HTTP响应返回给浏览器。<br>f、浏览器将信息进行解析并渲染，显示页面。最后会断开tcp连接。</p><h1 id="HTTP部分"><a href="#HTTP部分" class="headerlink" title="HTTP部分"></a>HTTP部分</h1><p>1、get和post的请求都能使用额外的参数，但是get的参数是以查询字符串出现在url中，而post的参数存储在实体主体部分。<br>get的传参方式相比于post安全性较差，因为get传的参数在url是可见的，可能会谢露私密信息。并且get只支ASCII字符，如果参数为中文则可能会出现乱码，而post支持标准字符集。<br>get的主要目的是获取资源，而post的主要目的是传输实体主体数据。</p><p>head和get一样，但是不返回报文实体主体部分。<br>put不带验证机制，存在安全问题。<br>delete作用和put相反。<br>trace追踪路径<br>connect要求用隧道协议连接代理，加密后经过隧道传输。</p><p>状态码：<br>1xx：信息性状态码<br>2xx：成功<br>3xx：重定向<br>4xx：客户端错误<br>5xx：服务器错误</p><p>四种类型首部字段：<br>通用首部、请求首部、响应首部和实体首部</p><p>HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP/1.1引入Cookie来保存状态信息。</p><p>Cookie信息存在浏览器上。</p><p>Session和Cookie区别<br>Session是服务器用来跟踪用户的一种手段，每个Session都有一个唯一标识Session ID。<br>当服务器创建一个Session时，给客户端发送的响应报文就包含了Set-Cookie字段，其中有个名为sid的键值对，这就是Session ID。当客户端收到后就把Cookie保存在浏览器中，并且之后发送的请求报文都包含Session ID。<br>HTTP就是通过Session和Cookie一起合作实现跟踪用户状态的，Session用于服务器端，Cookie用于客户端。</p><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。 持久连接 只需要进行一次 TCP 连接就能进行多次 HTTP 通信。HTTP/1.1 开始，所有的连接默认都是持久连接。</p><p>持久连接需要使用Connection首部字段进行管理。<br>HTTP1.1开始HTTP默认是持久连接，若要关闭需要客户端或服务端提出断开，使用connection：close。<br>而在HTTP1.1之前默认是非持久连接，若要持久连接则需要使用keep-alive。</p><p>代理服务器不会改变url，主要目的是缓存、网络访问控制以及访问日志记录。<br>网关服务器则不同，会将HTTP转化为其他协议进行通信，从而请求非HTTP服务器。</p><p>隧道：使用SSL等加密手段，为客户端和服务器之间建立一条安全的通信线路。</p><p>HTTP安全问题：<br>1、使用明文进行通信，内容可能会被窃听<br>2、不验证通信方的身份，通信方的身份可能遭遇伪装<br>3、无法证明报文的完整性，报文有可能被篡改。</p><p>HTTPS并不是新协议，而是HTTP先和SSL通信，再由SSL和TCP通信，提供了加密、认证和完整性保护。</p><p>加密：HTTPs使用混合加密机制，使用公钥加密用于传输信息的对称秘钥，之后使用对称秘钥进行通信。<br>对称秘钥的缺点：无法安全传输秘钥本身。<br>公钥缺点：更耗时。</p><p>认证使用证书。<br>SSL提供摘要功能来验证完整性。</p><p>HTTP/1.1新增内容：<br>1、默认为持久连接<br>2、提供了范围请求功能<br>3、提供了虚拟主机功能<br>4.、多了一些缓存处理字段<br>5、多了一些状态码</p><h1 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h1><p>操作系统基本特征：并发、共享、虚拟、异步</p><p>进程和线程的区别：<br>1、进程是除CPU外资源分配的基本单位，但是线程不拥有资源，线程访问隶属进程的资源<br>2、调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程内的线程时，会引起进程切换。<br>3、系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，所付出的开销远大于创建或撤销线程时的开销。类似的，在进程切换时，涉及到当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。<br>4、通信方面：进程间通信需要进程同步和异步手段的辅助，以保证数据的一致性。而进程内部通信可以通过直接读/写同一进程中的数据段来进行通信。</p><p>windows进程间通信：管道、共享内存、消息队列，信号量，socket<br>Windows线程间通信：临界区、互斥量、信号量和事件。</p><p>临界区与互斥体的区别<br>1、临界区只能用来同步本进程内的线程，而不能同步多个进程中的线程。互斥量、信号量、事件都可以跨越进程使用来进行同步数据操作。<br>2、临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。<br>3、临界区和互斥体在windows平台下都可用。</p><p>死锁的必要条件：<br>1、互斥条件<br>2、占有和等待<br>3、不剥夺条件<br>4、循环等待<br>死锁防止策略：<br>打破1，可同时访问<br>打破2，进程执行前申请需要的全部资源，在执行过程中不再申请资源<br>打破3，占有资源的进程若要申请新资源，必须主动释放已占用资源<br>打破4，层次分配。</p><p>死锁避免：银行家算法</p><p>分段分页的区别：<br>1、分页透明，分区需要程序员显式划分每个段。<br>2、分页是一维地址，分段是二维地址。<br>3、页的大小不可变，而段的大小可以动态改变。<br>4、分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了让程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p><h1 id="内存池、Nginx"><a href="#内存池、Nginx" class="headerlink" title="内存池、Nginx"></a>内存池、Nginx</h1><p>内存池可以减少内存碎片、避免内存泄露，提高内存分配效率。</p><p>通常我们习惯直接使用new、malloc等API申请分配内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。</p><p>Nginx（发音同 engine x）是一款轻量级的Web 服务器／反向代理服务器及电子邮件（IMAP/POP3）代理服务器</p><p>Nginx提供的负载均衡有两种：内置策略和扩展策略。<br>内置策略微轮询，加权轮询，IP hash。<br>扩展策略url hash</p><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>目的：因为阻塞模型在没有收到数据的时候就会阻塞卡住，如果一次需要接受多个socket fd的时候，就会导致必须处理完前面的fd，才能处理后面的fd，即使可能后面的fd比前面的fd还要先准备好，所以这样就会造成客户端的严重延迟。为了处理多个请求，我们自然先想到用多线程来处理多个socket fd，但是这样又会启动大量的线程，造成资源的浪费，所以这个时候就出现了io多路复用技术。就是用一个进程来处理多个fd的请求。</p><p>与多进程/多线程相比，IO多路复用最大的好处就是系统开销小。</p><p>1应用层数据到kernel<br>2 kernel复制到user space<br>阻塞io模型就是将这个两个过程合并在一起，一起阻塞。非阻塞就是第一个不阻塞，而是不断轮询，第二个仍然阻塞。</p><p>select：<br>程序呼叫select，然后整个程序就阻塞了，这个时候kernel就会轮询检查所有select负责的fd，当找到其中一个client的数据准备好了，select就会返回，这个时候程序启动系统调用，将数据从kernel复制到进程缓冲区。</p><p>poll<br>原理和select十分相似，差别如下：<br>描述fd集合的方式不同，poll没使用select的fd_set结构，所以poll是链式的，没有最大连接数的限制。<br>poll有个特点是水平触发，也就是通知fd就绪后，如果这次没有被处理，那么下次poll的时候会再次通知同个fd已经就绪。</p><p>select缺点：<br>1fd_size大小为32个整数（32位机器上就是32*32，1024bit），每个fd一个bit，所以最大只能处理1024个fd</p><p>2每一次呼叫select都要从user space把fd_set复制到kernel中，因为每一次呼叫前，set都可能有变动，而epoll提供了共享记忆存储结构。</p><p>3kernel轮询每个fd，约限行时间，消耗大且效率低下。</p><p>epoll提供三个函数：<br>创建epoll对象，传回id<br>事件注册函数，将需要监听的事件和需要监听的fd交给epoll对象。<br>等待注册的事件被触发或timeout。等待函数。</p><p>epoll没有数量限制，最大数量只和系统能够打开多少fd有关。<br>epoll不需要每次都将set赋值到kernel检查，因为在注册的时候已经将fd拷贝了进来。<br>select/poll都是主动轮询，而epoll是被动，它不仅可以知道有fd就绪，还可以知道是哪个fd就绪，直接处理。（类比轮询和中断方式。）</p><h1 id="3-12"><a href="#3-12" class="headerlink" title="3-12"></a>3-12</h1><p>nginx：异步非阻塞</p><p>nginx的请求处理：<br>1、操作系统提供的机制产生相关的时间<br>2、接受和处理这些事件，如果接收到数据，则产生更高层的request对象<br>3、处理request的header和body<br>4、产生响应，并发送回客户端<br>5、完成request的处理<br>6、重新初始化定时器及其他事件</p><h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><p>C++11新特性（很多，节选，完整看C++ Primer）<br>1、新定义long long类型，一个long long类型至少和一个long一样大。<br>2、列表初始化，就是用大括号来初始化变量。<br>3、引入新常量nullptr，用来得到或者初始化指针。<br>4、引入auto和decltype，auto一般会忽略顶层const，decltype处理顶层const和引用的方式和auto不同，他会将变量包括顶层const和引用在内的信息都返回。<br>5、范围for语句<br>6、引入了两个新函数cbegin和cend。<br>7、C++11规定商一律向0取整，不论正负。<br>8、initializer_list，参数数量未知但是全部实参类型相同时可以使用该类型，和vector类似，只是其中存储的元素都是常量，不能修改。<br>9、尾置返回类型：auto fun() -&gt; int (*)[10]，返回类型是一个指向一个十个整形数组的指针。<br>10、constexpr函数是指能够用于常量表达式的函数，函数的返回类型和所有形参类型都必须是字面值类型。<br>11、可以定义所谓的委托构造函数，使用它所属类的其他构造函数来执行它自己的初始化过程。<br>12、定义了array和forward_list，数组和单向链表。<br>13、新标准引入了三个新成员—emplace，这些操作构造而不是拷贝元素，将参数传给元素类型的构造参数。<br>14、lambda表达式<br>15、bind函数。<br>16、四个无序容器，unordere_map  unordered_set unordered_multiset  unordered_multimap，使用hash函数和==运算符<br>17、智能指针。shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象。还有一种weak_ptr的伴随类，是一种弱引用，指向shared_ptr所管理的对象，不改变引用计数。<br>18、使用=default生成默认构造函数</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>观察者模式：定义了对象间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><p>装饰模式：动态地将责任附加到对象上。在扩展功能上，装饰者提供了比继承更有弹性的替代方案。</p><p>工厂模式：<br>简单工厂：在实例化一个超类的时候，可以用它的所有子类来进行实例化，要根据具体的情况来决定使用哪个子类。<br>工厂模式：定义一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把类实例化推迟到子类。<br>抽象工厂模式：提供一个接口，用于创建相关对象家族，而不需要明确指定具体类。</p><p>单例模式：<br>确保一个类只有一个实例，并提供一个全局访问点。<br>使用一个私有构造器、一个私有静态变量以及一个公有静态函数来实现。</p><p>命令模式：将命令封装成对象，以便使用不同的命令来参数化其他对象。</p><p>适配器模式：将一个类的接口，转换为客户期望的另一个接口。适配器让原来不兼容的类可以合作无间。</p><p>外观模式：提供一个统一的接口，用来访问子系统中一群接口，从而让子系统更容易使用。</p><p>模板方法模式：在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。这使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p><p>迭代器模式：提供顺序访问一个聚合对象中各个元素的方法，而不暴露聚合对象内部的表示。<br>组合模式：允许将对象组合成树形结构来表现整体/部分层次结构。组合能让客户以一致的方式处理个别对象以及组合对象。</p><p>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p><p>复合模式：<br>MVC：视图使用组合模式、模型使用观察着模式，控制器使用策略模式。</p><p>主流PC机的每秒钟计算量约为10^7~10^8次，一亿次左右。</p><h1 id="3-14-2018"><a href="#3-14-2018" class="headerlink" title="3.14.2018"></a>3.14.2018</h1><p>C++11新标准补充：<br>1、可以用=delete定义删除的函数，删除的函数意思是：虽然声明了它们，但不能以任何方式使用它们。<br>2、新标准引入了移动构造函数和move的标准库函数。<br>3、引入了右值引用，右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。左值持久，右值短暂，不能将右值引用绑定到一个左值上。可以用static_cast显示的将一个左值转换为一个右值引用。<br>4.、标准库move函数来获得绑定到左值上的右值引用。<br>5、移动构造函数通常是noexcept。<br>6、虚函数的override指示符。<br>7、定义类为final来阻止继承。<br>8、引用折叠</p><h1 id="3-15、Effective-C-："><a href="#3-15、Effective-C-：" class="headerlink" title="3-15、Effective C++："></a>3-15、Effective C++：</h1><p>1、对于单纯常量，最好以const对象或enums替换#defines。对于形似函数的宏，最好改用inline函数来替换。<br>2、当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。<br>3、为内置型对象进行手工初始化，因为C++不保证初始化它们。构造函数最好使用成员初值列，而不要在构造函数体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。<br>为免除跨编译单元之初始化次序问题，请以local static对象替换non-local static对象。<br>4、编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。<br>5、带有多态性质的base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。如果不是为了作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数。<br>6、析构函数不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们或结束程序。<br>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数执行该操作。<br>7、在构造函数和析构函数中绝不要调用virtual函数。<br>8、令赋值操作符返回一个reference to *this。<br>9、确保当对象自我赋值时有良好行为，其中技术包括1比较来源对象和目标对象的地址2精心周到的语句顺序3copy and swap<br>10、copy函数应该确保复制对象内的所有成员变量以及所有base class成分。不要尝试以某个copy函数实现另一个copy函数，应该将共同机能放入第三个函数内，然后由两个copy函数分别调用它。<br>11、以对象管理资源。为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。两个常被使用RAII classes是shared_ptr和auto_ptr，前者通常是较佳选择，因为auto_ptr的copy操作会使它指向NULL。<br>12、赋值RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。<br>13、APIs往往要求访问原始资源，所以每一个RAII classes应该提供一个取得其所管理资源的方法。对原始资源的访问可能经由显式转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。<br>14、以独立语句将newed对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。<br>15、宁以pass-by-reference-to-const替换pass-by-value，但对于内置类型以及STL的迭代器和函数对象来说，pass-by-value比较好。<br>16、必须返回对象时，别妄想返回其reference。不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象。<br>17、将成员变量声明为private，这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证。protected并不比public更具封装性。<br>18、使用non-member、non-friend替换member函数。<br>19、如果一个函数的所有参数都需要类型转换，请为此采用non-member函数。<br>20、尽可能延后变量定义式的出现时间。<br>21、尽量少做转型动作，四种类型转换。<br>const_cast，转变对象的常量性，是唯一能将对象的常量性移除的C++转型操作符。<br>dynamic_cast：安全向下转型，唯一无法由旧式语法执行的动作。<br>reinterpret_cast：执行低级转型，强转。<br>static_cast:强迫隐式转换。<br>22、避免返回reference、pointer、iterator指向对象内部成分。<br>23、异常安全函数提供三个保证之一：<br>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。<br>强烈保证：如果异常被抛出、程序状态不会改变。如果函数成功，就是完全成功，如果函数失败，程序会回复到调用函数之前的状态。<br>不抛掷保证：承诺绝不抛出异常。<br>24、inline函数：会导致代码膨胀<br>inline只是一个申请，不是强制命令。<br>不能是virtual<br>通过函数指针而进行的调用可能也不会被inline<br>不要只因为function templates出现在头文件，就将他们声明为inlines。</p><h1 id="3-16、effective-C"><a href="#3-16、effective-C" class="headerlink" title="3-16、effective C++"></a>3-16、effective C++</h1><p>1、支持编译依存性最小化的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是handle classes和interface classes。程序库头文件应该以完全且仅有声明式的形式存在。这种做法不论是否涉及templates都试用。<br>2、public继承意味is-a，适用于base classes身上的每一件事情一定也适用于derived classes身上，每一个derived class对象也都是一个base class对象。<br>3、派生类内的名称会遮掩基类内的名称。在public继承下从来没有人希望如此。为了让被遮掩的名称再见天日，可使用using声明式。<br>4、接口继承与实现继承不同，在public继承下，derived classes纵使继承base classes的接口。<br>纯虚函数只具体指定接口继承。<br>非纯虚函数具体指定接口继承以及缺省的实现继承。<br>非虚函数指定接口继承和强制性实现继承。<br>5、绝不重新定义继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数是动态绑定。<br>6、复合的意义和public继承完全不同。在应用域，复合意味has-a，在实现域，复合意味着is-implemented-in-terms-of。<br>7、private继承意味is-implemented-in-terms-of，通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。<br>8、谨慎使用多重继承。如果virtual base classes不带任何数据，将是最具实用价值的情况。<br>9、TMP模板元编程是编写template-based C++程序并执行于编译期的过程，可以将工作由运行期移到编译期，因为得以实现早期错误侦测和更高的执行效率。<br>10、operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0bytes申请。operator delete应该在收到null指针时不做任何事。class专属版本还应该能够处理比正确大小更大的错误申请。<br>11、当你写一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，可能会发生隐微而时断时续的内存泄露。当你声明placement new 和placement delete，请不要无意识的遮掩他们的正常版本。</p><h1 id="3-18更新"><a href="#3-18更新" class="headerlink" title="3-18更新"></a>3-18更新</h1><p>redis<br>redis是速度非常快的非关系型内存键值数据库，可以存储五种不同类型之间的映射。<br>五种数据类型：<br>字符串string、列表list、集合set、有序集合zset、散列表hash。</p><p>键的过期时间：<br>redis可以为每个键设置过期时间，时间一到，自动删除。<br>但对于散列表，只能为整个散列表设置过期时间，而不能为键里面的单个元素设置过期时间。</p><p>redis最简单的事务实现方式是使用multi和exec命令将事务操作包裹起来。</p><p>持久化：<br>1、快照持久化<br>2、aof持久化</p><p>复制：<br>slave of host port命令来让一个服务器成为另一个服务器的从服务器<br>1、从服务器连接主服务器的过程<br>a、主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令。<br>b、从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令<br>c、主服务器每执行一次写命令，就向从服务器发送相同的写命令。<br>2、主从链<br>当负载不断增多时，可以创建中间层分担主服务器的复制工作。</p><p>分片<br>通过对数据进行分片，用户可以将数据存储到多台机器里面。<br>客户端分片：一致性hash<br>代理分片：将客户端请求发送到代理上，由代理转发<br>服务器分片：redis cluster</p><p>redis适用场景：<br>缓存、消息队列、计数器、好友关系</p><h1 id="h文件，-lib文件以及-dll文件"><a href="#h文件，-lib文件以及-dll文件" class="headerlink" title=".h文件，.lib文件以及.dll文件"></a>.h文件，.lib文件以及.dll文件</h1><p>头文件的作用是声明函数接口，用于编译阶段。<br>dll文件是函数可执行代码，用于运行阶段。<br>lib文件告诉编译器调用的函数在哪个dll文件中以及在该dll文件中哪个位置。是h和dll的桥梁。如果生成静态库文件，则没有dll，只有lib，这时函数的可执行代码也在lib中。用于链接阶段。</p><p>静态链接库和动态链接库的区别：<br>a、静态链接库就是把用到的函数代码直接链接进目标程序，程序运行的时候不再需要其他库文件。动态链接库就是把调用的函数所在文件模块和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从dll中寻找相应代码，因此需要dll的支持。<br>b、如果采用静态链接的方式，则无论你愿不愿意，lib中的指令都全部被包含在最终生成的exe文件中，所以会导致应用程序比较大。但如果使用动态链接库，该dll最终不会被包含在exe中，exe执行时动态的引用和卸载该dll文件。<br>c、静态链接库中不能再包含其他静态库或动态库，而动态链接库中可以包含其他动态或静态链接库。</p><p>dll的用法：<br>a、使用h、lib以及dll。<br>b、直接用dll，此时需要利用win32 的api函数LoadLibrary和GetProcAddress把函数指针取出来再用。</p><h1 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B-B+树"></a>B-B+树</h1><p>B-树：<br>B-树是一种平衡的多路查找树，在文件系统中很有用。<br>一棵m阶的B树，或者是一棵空树，或者是满足下列特性的m叉树：<br>1、树中每个结点至多有m棵子树<br>2、若根结点不是叶子结点，则至少有量棵子树<br>3、除根之外的所有非终端结点至少有m/2上限整数棵子树<br>4、所有非终端结点包含下列信息数据（n,A0,K1,A1,K2，A2……Kn，An）<br>5、所有的叶子结点都出现在同一层次上，并且不带信息。</p><p>B树的插入删除，看书。</p><p>B+树和B-树差异在于：<br>1、有n棵子树的结点中含有n个关键字<br>2、所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;90道&quot;&gt;&lt;a href=&quot;#90道&quot; class=&quot;headerlink&quot; title=&quot;90道&quot;&gt;&lt;/a&gt;90道&lt;/h1&gt;&lt;h2 id=&quot;1、引用和指针的区别。&quot;&gt;&lt;a href=&quot;#1、引用和指针的区别。&quot; class=&quot;headerlink&quot; title=&quot;1、引用和指针的区别。&quot;&gt;&lt;/a&gt;1、引用和指针的区别。&lt;/h2&gt;&lt;p&gt;a、定义指针时分配内存，引用不分配内存，而和原变量内存地址相同，这是最本质的区别。&lt;br&gt;b、引用必须初始化&lt;br&gt;c、没有指向空值的引用，但是存在指向空值的指针。&lt;br&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>王道程序员面试宝典笔记</title>
    <link href="http://yoursite.com/2018/05/31/%E7%8E%8B%E9%81%93%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/31/王道笔记/</id>
    <published>2018-05-30T16:08:31.000Z</published>
    <updated>2018-10-09T16:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、C-内置类型"><a href="#1、C-内置类型" class="headerlink" title="1、C++内置类型"></a>1、C++内置类型</h1><p>包括基本类型和复合类型。<br>基本类型包括整数和浮点数。<br>复合类型包括数组、字符串、指针、引用、结构体和共用体等。<br><a id="more"></a></p><h1 id="2、内存分区（5个）"><a href="#2、内存分区（5个）" class="headerlink" title="2、内存分区（5个）"></a>2、内存分区（5个）</h1><p>1）堆：动态内存区，由程序员手动分配和释放，不同于数据结构的堆，分配方式类似链表。由malloc或new分配，由free或delete释放，最好手动释放，如果程序员不释放且运行期间不出错，则程序结束后由系统释放。<br>2）栈：编译器自动分配和释放，存放函数的参数值、局部变量等，操作方式类似数据结构的栈。<br>3）全局静态存储区：存放全局变量和静态变量，包括DATA段和BSS段，初始化过的放在DATA中，否则放在BSS中。<br>4）文字常量区：存放常量字符串。<br>5）程序代码区：存放函数体的二进制代码。<br>详见P2</p><h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><p>1、没有引用数组，因为引用不能赋值。<br>2、C风格字符串包括两种，字符串常量（末尾自动添加空字符’\0’）和以’\0’结尾的字符数组。<br>3、C++规定，在声明和初始化一个二维数组时，如果对所有元素赋值，则可省略行数。<br>4、顺序表插入、删除和查找算法的平均时间是O（n）。<br>5、数组指针和指针数组。<br>习题14 15 16 17 18</p><h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><p>1、strcpy和memcpy的区别，前者参数是char<em>，后者是void</em>，表示后者可用于任何类型，范围比strcpy广。<br>a、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容。strcpy只用于字符串复制，并且它不仅复制字符串内容，还会复制字符串的结束符。memcpy对于需要复制的内容没有限制，因此用途更广。<br>b、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符‘\0’才结束，容易溢出。memcpy根据第三个参数决定复制的长度。<br>c、用途不同，strcpy复制字符串，其他类型一般用memcpy。<br>2、长度为M的字符串中查找长度为N的子串，最少时间复杂度O（M+N）。（利用KMP算法）<br>3、循环移位包串，第一种方法取模，第二种就是把m变成mm，再找n子串。<br>4、判断某字符串是不是包含什么字符之类的问题，可转为素数相乘。<br>5、字符串查找类题目可以联想到素数和桶排序，有时会解决问题。<br>6、memset将s中第三个参数表示的前n个字节用ch替换，作用是在一段内存块中填充某个给定的值，它是对较大结构体或数组清零的最快方法。</p><h1 id="三、结构体"><a href="#三、结构体" class="headerlink" title="三、结构体"></a>三、结构体</h1><p>1、sizeof是运算符不是函数，它的计算发生在编译时刻，所以可以被当做常量表达式使用，且会忽略括号中的各种运算，如sizeof（a++），“++”并不会执行。若对一个函数调用使用，则求到的是函数返回类型的值，不可以对函数使用，而且函数并不会被调用。<br>2、不可以用sizeof的：函数、返回void的函数调用、位域成员。<br>3、strlen不包括‘\0’，sizeof包括。<br>4、大小端对位域影响，自己的理解：<br>首先2个字节8位是一个划分单元。<br>大端下：对每个八位，按照位域成员声明顺序从左往右填入bit，不够的留到下一个八位中继续按照从左往右填。<br>小端下：对每个八位，按照位域成员声明顺序从右往左填入成员bit，以此类推。<br>（不知道对不对，总之根据题目上这么理解似乎正确。）<br>5、结构体占内存空间大小：P51.<br>6、结构体内函数和类型重定义不占字节。</p><h1 id="四、运算符及其优先级"><a href="#四、运算符及其优先级" class="headerlink" title="四、运算符及其优先级"></a>四、运算符及其优先级</h1><p>1、亦或运算可以用来找成对数组中不成对的那个数。<br>2、~运算符的优先级&gt;移位运算符优先级&gt;与或异或运算符的优先级<br>运算符优先级记忆规则：<br>a、括号、下标，-&gt;和.运算级别最高。<br>b、单目比双目高，算术双目的比其他双目的高<br>c、移位运算符高于关系运算符，关系运算符高于按位运算，按位运算高于逻辑运算。<br>d、三目的只有一个条件运算，低于逻辑运算<br>e、赋值运算符仅比逗号运算符高，且所有赋值运算符优先级相同，结合访问位从右到左。</p><h1 id="五、C预处理器、作用域、static、const以及内存管理"><a href="#五、C预处理器、作用域、static、const以及内存管理" class="headerlink" title="五、C预处理器、作用域、static、const以及内存管理"></a>五、C预处理器、作用域、static、const以及内存管理</h1><p>预处理主要有三个方面的内容：<br>a、宏定义与宏替换<br>b、文件包含<br>c、条件编译</p><p>1、宏定义和宏替换：<br>宏名一般大写，宏名和参数括号间不能有空格，末尾不加分号<br>宏替换只做替换，不做语法检查，不做计算，不做表达式求解；<br>宏替换在编译前进行，不分配内存，函数调用在编译后程序运行时进行，并且分配；<br>函数只有一个返回值，利用宏则可以设法得到多个值<br>宏替换使源程序变长，函数调用不会<br>宏替换不占运行时间，只占编译时间，函数调用占运行时间。<br>尽量少用宏，用const、enum和inline替换。</p><p>2、static的作用（不考虑类）：a隐藏，b把变量默认初始化为0，c保持局部变量内容的持久。<br>类中的作用：属于一个类但不属于此类中任何特定对象的变量和函数。<br>static数据成员必须在类定义体的外部定义。<br>static成员函数不能被声明为const、虚函数、volatile。</p><p>3、const<br>const和#define相比的好处：<br>1）const常量有数据类型，而宏常量没有数据类型，所以前者可以有类型安全检查。<br>2）使用const会产生更小的目标代码；<br>3）const还会进行常量折叠。<br>常量数据成员必须在构造函数的成员初始化列表中初始化。</p><p>c中的const意思是一个不能被改变的普通变量，纵使占用存储，不能把const视为一个编译期间的常量。</p><p>const的使用场景：<br>a常量<br>b指针和const修饰符<br>c修饰函数参数和返回值<br>d类中。const成员函数、const数据成员。</p><p>static、const以及static const成员变量初始化的不同。<br>static必须在类内声明，类外定义，定义时不能标为static。<br>const数据成员的初始化只能在类的构造函数初始值列表中进行，const数据成员只在某个对象生存期内是常量，对整个类而言却是可变的。<br>static const类内声明，类外定义，定义时加const不加static。</p><p>4、malloc/free和new/delete的异同（p104）<br>相同点：两组都是用来动态分配/释放内存的。<br>1）操作对象不同点：malloc和free是库函数，而new和delete是运算符，后者两个可以执行构造函数和析构函数。<br>operator new的执行流程：先分配足够大的原始空间，然后调用该类型的一个构造函数，最后返回指针。<br>operator delete的执行流程：先调用析构函数，再回收空间。<br>2）用法不同<br>malloc原型返回void*，所以要进行显式转换，它只关心分配的字节数，不关心类型。<br>malloc手工计算字节数，new自动分配。<br>new类型安全，而malloc不是。<br>malloc和free需要包含库文件，而new和delete不需要。</p><h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><p>1、使用无参数构造函数的时候不要加()，不然会被看做是某个函数的声明，如：<br>Foo b();<br>本意是构造Foo的一个对象b，但却被看做是一个函数声明，应改为 Foo b;</p><p>2、c++中调用被c编译过的函数，为什么要加extern “c”<br>c++是一种面向对象的编程语言，为了支持重载，编译器会对函数名字进行一些处理。而在c中编译就只是简单函数名而已，两者处理函数名的方式是不一样的。加了extern “c”就说明函数是用c编译器编译的，请用c的方式链接它们，否则链接会错。</p><h1 id="七、指针和引用"><a href="#七、指针和引用" class="headerlink" title="七、指针和引用"></a>七、指针和引用</h1><p>1、函数返回void<em>时表示返回一个特殊的指针，并不是没有返回值。<br>void</em>指针的操作：<br>和另一个指针进行比较。<br>向函数传递void<em>指针或从函数函数void</em>指针。<br>给另一个void*指针赋值。</p><p>2、具有函数类型的形参所对应的的实参将被自动转化为指向响应函数类型的指针，然而当返回类型是函数时，却不会转换成对应的指针。</p><p>3、引用和指针的区别<br>虽然引用和指针都可以间接访问另一个变量，但它们之间存在重要区别。<br>1）引用不能为空，当引用被创建时，必须被初始化，指针则可以为空。<br>2）一旦一个引用被初始化为指向某一对象，它就不能改变指向其他对象。指针可以。<br>3）没有NULL引用。<br>4）sizeof运算符对引用是求它所指对象大小，而对指针就是求指针本身大小。<br>5）给引用赋值就是修改它指向的那个对象的值，并不是改变引用所指的对象。<br>6）引用没有解引用，而指针需要解引用。<br>7）动态分配的对象或内存必须使用指针。<br>8）&amp;操作符对引用是取它所指对象的地址，而对指针就是求指针的地址。</p><p>4、引用类型类数据成员的初始化必须在初始化列表中，而且必须手动写构造函数。</p><p>5、野指针。<br>野指针是指向不可用内存的指针。<br>下列三种情况会产生野指针：<br>a当一个指针被初始化时不会自动成为NULl指针，而是一个野指针，默认值是随机的。<br>b当指针被free或delete后未把指针置为NULL，此时是野指针。<br>c指针操作超越变量作用范围时也是野指针。</p><h1 id="八、类"><a href="#八、类" class="headerlink" title="八、类"></a>八、类</h1><p>1、在c++中，成员变量的初始化顺序与变量在类中声明的顺序相同，与初始化时的顺序无关。<br>2、没有默认构造函数的类类型成员、const成员和引用成员必须在初始值列表里初始化。</p><p>3、深复制和浅复制。<br>浅复制：被复制的对象的所有变量都和原来对象的值相同，而所有的对其他对象的引用仍然指向原来的对象。浅复制仅复制对象，而不复制所引用的对象。<br>深复制：相反，深复制把所有对象以及引用的对象都复制了一遍。<br>浅复制可能导致运行时错误。</p><p>4、虚基类的构造函数最先调用。</p><p>5、复制构造函数只在对象实例化的时候才调用，没有返回值。<br>赋值运算符则在一个现存对象被赋值时调用，有返回值。</p><p>6、new operator和operator new不同。<br>可以重载的是operator new而不是new operator。<br>即不能重定义new和delete表达式的行为，可以重载的是全局函数operator new和operator delete。<br>new表达式行为中调用operator new分配空间，然后调用合适的构造函数。<br>delete表达式先析构，在调用合适的operator delete释放空间。</p><h1 id="九、面向对象编程。"><a href="#九、面向对象编程。" class="headerlink" title="九、面向对象编程。"></a>九、面向对象编程。</h1><p>1、公有继承下，派生类的对象、对象指针、对象引用可以赋值给基类的对象、对象指针、对象引用，这是隐式转化，保护继承和私有继承没有。<br>公有继承下，基类的对象指针、对象引用不可以隐式转换成派生类的指针和引用，但是可以显式转换（强制转换）过去。p157</p><p>2、类型转换函数的作用是将一个类的对象转换为另一个类型的数据。<br>转换函数必须是成员函数不能是友元，不能指定返回类型，但在函数体内必须用return以传值的方式返回一个目标类型的变量；转换函数不能有参数。<br>operator 类型(){return 类型的值；}</p><p>转换构造函数：可以用单个实参来调用的构造函数定义从形参类型到该类类型的一个隐式转换。</p><p>静态动态性包括函数重载和运算符重载，动态多态性包括虚函数。</p><p>3、非C++内建类型A和B，三种情况下B能隐式转换成A。<br>B公有继承自A<br>B中有类型转换函数转换成A<br>A实现了非explicit的参数为B的构造函数。</p><p>4、不能做虚函数的有哪些。<br>非成员函数、静态成员函数、构造函数、友元函数。<br>而内联成员函数和赋值操作符函数声明为虚函数也无意义。</p><p>5、C++对象模型p167，重要。<br>简单来说，static成员数据和函数都在全局静态区，非static数据成员才在对象内部，不是虚的成员函数也在对象外部。<br>虚函数在对象内部留一个pvtr指针，指向一个虚函数表，虚函数表里存放虚函数和type_info.</p><p>6、抽象类不可以定义对象，但可以作为指针或引用类型使用。</p><p>7、仅当类型之间存在隐式转换的时候（类间下行转换除外），static_cast才合法。<br>reinterpret_cast代替圆括号的显式转换，强制转换。<br>dynami_cast将基类指针或引用安全转换为派生类指针或引用，做两件事，检查是否可以转换，若有效才真正转换。</p><h1 id="十、分治法、动态规划与贪心算法"><a href="#十、分治法、动态规划与贪心算法" class="headerlink" title="十、分治法、动态规划与贪心算法"></a>十、分治法、动态规划与贪心算法</h1><p>p196，开学后看下算法导论对应例题。</p><h1 id="十一、"><a href="#十一、" class="headerlink" title="十一、"></a>十一、</h1><p>1、Catalan数p211<br>h(n)=h(0)<em>h(n-1)+h(1)</em>h(n-2)+…+h(n-1)*h(0)    h(0)=1</p><p>2、求二叉树中节点之间的最大距离。</p><p>3、树中路径上所有节点之和等于给定值。p223</p><p>4、红黑树是一种特殊的二叉搜索树，满足以下条件：<br>节点不是红就是黑。<br>根节点是黑。<br>如果节点是红，其子节点必须是黑。<br>任一节点至null的任何路径，所含之黑节点数必须相同。</p><p>5、判断树是不是平衡树p227</p><p>6、并查集p231</p><h1 id="第十四章、图"><a href="#第十四章、图" class="headerlink" title="第十四章、图"></a>第十四章、图</h1><h1 id="第十五章、排序"><a href="#第十五章、排序" class="headerlink" title="第十五章、排序"></a>第十五章、排序</h1><p>1、插入排序包括直接插入排序和希尔排序。<br>直接插入排序时间复杂度n2，空间复杂度1，最好情况下表中元素已经有序，此时每插入一个元素都只需要比较一次而不用移动，因为时间复杂度是n，是稳定的。<br>希尔排序的时间复杂度不确定，空间复杂度是1，不稳定。<br>2、交换排序<br>冒泡排序，时间复杂n2，空间复制1，稳定，最好情况下时间复杂n。<br>快速排序是所有内部排序中平均性能最好的算法，空间复杂度最坏n，平均logn，时间复杂度最坏n2但很少见，最好nlogn，不稳定。<br>快速排序两种划分方法p253</p><p>3、选择排序时间复杂度始终n2.<br>元素间的比较次数和原始序列无关，都是n(n-1)/2.</p><p>4、建堆的时间复杂度为n。<br>空间复杂度1，时间复杂度nlogn。</p><p>5、二路归并排序（递归分支，merge）<br>空间n，时间nlogn。</p><h1 id="第十六章：查找"><a href="#第十六章：查找" class="headerlink" title="第十六章：查找"></a>第十六章：查找</h1><p>1、后缀数组<br>2、键树又称数字查找树，用树的孩子-兄弟链表来表示键树。<br>用多重链表表示键树，则树的每个节点中包含d个指针域，此时又称Trie树<br>3、分布式存储方式<br>普通集群：把固定的key映射到固定的节点上，节点只存放各自key的数据。查找时需要遍历，查找速度慢。<br>hash集群：更迭慢，需要重新扫描计算一次所有节点。<br>一致性hash</p><p>4、处理海量数据大文件<br>分治——hash映射到不同块中，对每个块再分别处理。</p><p>最小k个数p261</p><p>布隆过滤器：<br>大小为m，样本数量为n，失误率为p<br>m=-(n<em>lnp)/(ln2)2<br>k=ln2</em>(m/n)<br>p=(1-e(-nk/m))k</p><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><p>1、ping使用ICMP协议。<br>网络层协议：IP 、IPX 、ICMP、IGMP、ARP、RARP、OSPF<br>传输层协议：TCP、UDP、SCTP<br>应用层协议：RIP、TELNET、TFP、HTTP、SNMP</p><p>TCP<br>a、TCP是一种面向连接的协议，提供客户与服务器的连接<br>b、tcp提供可靠性，当使用tcp向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，tcp自动重传数据并等待更长时间。在数次重传失败后，tcp才放弃。<br>c、tcp通过给发送数据的每一个字节关联一个序列号进行排序。udp提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。<br>d、tcp提供流量控制，而udp不提供。<br>e、tcp的连接是全双工的，udp的也可以是全双工的。</p><p>和udp的主要区别在于udp不一定提供可靠的数据传输，但是udp对系统资源要求少、实时性好、网络开销小。</p><p>2、终止tcp连接通常调用close，但是close有两个弊端，可用shutdown来避免。<br>close函数把套接字的引用计数减1，仅在计数变为0时才关闭，而使用shutdown不管计数如何会直接激发正常终止序列。<br>close同时关闭读写，但有时候需要关闭写但仍然可以读，这个时候就可以用shutdown。</p><p>3、tcp七个定时器：连接建立定时器，重传定时器，延迟定时器，持续定时器，保活定时器，FIN_WAIT2定时器，TIME_WAIT定时器</p><p>为了提高ip数据报成功交付机会，在网络层使用icmp来使得主机可以报告差错或异常情况。</p><p>4、输入url后按下回车发生什么？<br>向dns服务器查询url对应的IP地址。<br>dns返回ip地址。<br>浏览器打开tcp连接，并向web服务器发送http请求。<br>若页面发生跳转，服务器以重定向响应，然后转到5，否则直接转6.<br>浏览器跟随重定向，再次发送http请求。<br>服务器处理请求，并返回html响应。<br>浏览器接受请求的页面源码。<br>浏览器开始渲染html。<br>浏览器发送嵌入到html中的对象请求。<br>浏览器进一步发送异步请求。<br>浏览器关闭tcp连接。</p><p>ping用来检查网络是否通畅<br>tracert路由跟踪<br>telnet网络测试，如测试80端口的web服务器是否正常<br>netstat监控tcp/ip的工具</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>1、四个特征：并发、异步、共享、虚拟。<br>2、进程与线程的区别。p325<br>3、调度算法例题，p328例二。<br>4、死锁产生的必要条件：互斥、不剥夺、请求和保持、循环等待。<br>预防死锁：破坏四个条件之一<br>避免：银行家算法<br>检测及解除：剥夺资源、撤销进程、进程回退。</p><p>线程独有的：线程id、寄存器组的值、堆栈、错误返回码、信号屏蔽码、线程优先级</p><p>进程和线程的区别：<br>a、调度：引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位拟。在同一进程中，线程的切换不会引起进程切换，不同进程中的线程切换会引起进程切换。<br>b、拥有资源：进程是拥有资源的基本单位，但是线程可以共享其隶属进程的系统资源。<br>c、并发，进程可以并发，线程也可以并发，而且线程并发性更高，提高系统吞吐量。<br>d、系统开销：创建和撤销进程时，系统都要为之分配或回收资源，因为付出的开销远远大于创建或撤销线程的开销。进程切换的开销也比线程大。另外，同一进程后的多个线程共享进程的地址空间，因此及这些线程间的同步通信比较容易实现，无需操作系统干预。<br>e、进程的地址空间相互独立，统一进程的各线程间共享进程的资源，某进程内的线程对其他进程不可见。<br>f、通信方面，进程间通信需要借助操作系统，而线程可以直接读写（全局变量）进行通信。</p><p>5、临界区是统一进程下的线程间通信机制。<br>6、默认下，Linux一个进程最多能打开1024个文件。</p><p>进程间通信：管道、共享内存、消息队列、信号量、socket。<br>线程间通信：临界区（只可以用于线程间）、互斥量、信号量、事件。</p><p>Linux常用命令：<br>1、cd变换工作目录<br>2、pwd显示目前所在目录<br>3、mkdir建立新目录 rmdir删目录<br>4、ls<br>5、cp复制文件或目录<br>6、rm删除，加参数-r表示删除目录<br>7、cat由第一行开始查看文件<br>8、tac从最后一行开始显示文件<br>9、head -n number file 只显示一开始的几行<br>10、touch常用来新建空文件<br>11、grep分析一行信息，若其中有我们所需要的信息就将该行显示出来，常用在管道中。<br>12、df列出文件系统的整体磁盘使用量<br>13、ps将某个时间点的程序运行情况显示出来<br>14、top可以持续侦测程序运作的状态，比如看内存使用率</p><h1 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h1><p>1、数据库的核心和基础是数据模型。<br>2、数据模型一般由数据结构、数据操作和完整性约束条件三部分组成。<br>3、事务的四个特征：原子性a，一致性c，隔离性i，持续性d。<br>4、设置索引是要付出代价的，一是增加了存储空间，二是插入和修改数据要花费较多的时间。<br>5、mysql为学生表学号增加降序唯一索引<br>create unique index Stusno on Student（Sno desc）<br>删除该索引<br>alter table Student drop index Stusno<br>6、索引的优缺点以及该不该建索引。p345<br>创建索引可以大大提高系统的性能。<br>第一、通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二、可以加快数据检索速度，这也是加索引的最主要原因。<br>第三：可以加速表与表之间的连接，特别是在实现数据的参照完整性方面特别有意义。<br>第四、再使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五、通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能。<br>缺点：<br>第一、创建索引和维护索引要耗费时间，而且这种时间随着数据量的增加而增加。<br>第二、索引需要占物理空间。<br>第三、当表中数据增加、删除、修改的时候，索引也要动态维护，降低了数据维护性能。</p><p>索引是建在某些列上的。<br>适合建索引的：<br>1）、在经常需要搜索的列上建索引，强制该列的唯一性和组织表中数据的排列结构。<br>2、在作为主键的列上创建索引，加快连接的速度。<br>3、在经常用到连接的列上建索引。<br>4、在经常需要根据范围进行搜索的列上创建索引。<br>5、在经常需要排序的列上创建索引。<br>6、在经常使用where子句的列上创建索引，加快条件判断。</p><p>不适合建索引的：<br>1）、在查询中很少使用到的列<br>2）、只有很少数据值的列<br>3）、定义为text和bit等数据类型的列，因为这些列的数据量要么大要么取值很少，不利于使用索引<br>4）当修改操作远远大于检索操作时，不该建索引。修改性能和检索性能是相互对立矛盾的。</p><p>7、存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。<br>8、%表示任意长度的通配符，_表示一个长度的通配符<br>9、LIMIT两种参数使用，limit n等同于limit 0 n。输出从0开始，到n之前的n行数据。</p><h1 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h1><p>1、面向对象最基本的五个设计原则：单一职责原则，开放封闭原则，依赖倒置原则，接口隔离原则和Liskov替换原则。</p><h1 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h1><p>1、N条直线有M个交点，则平面被划分成N+M+1个区域。</p><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p>1、简述Java和C++的不同。<br>java运行在虚拟机上<br>c++支持无符号运算和指针，java不支持。<br>java中参数传递总是值传递（参数是对象时传递的是对象的引用），在c++中，参数传递有值传递、引用传递、指针传递。<br>java有垃圾回收，c++没有。<br>c++允许运算符重载，java不允许。<br>c++允许多继承，java只允许单继承。</p><p>2、常见的度量软件可靠性的指标。<br>MTTF平均失效前时间<br>MTBF平均无故障时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、C-内置类型&quot;&gt;&lt;a href=&quot;#1、C-内置类型&quot; class=&quot;headerlink&quot; title=&quot;1、C++内置类型&quot;&gt;&lt;/a&gt;1、C++内置类型&lt;/h1&gt;&lt;p&gt;包括基本类型和复合类型。&lt;br&gt;基本类型包括整数和浮点数。&lt;br&gt;复合类型包括数组、字符串、指针、引用、结构体和共用体等。&lt;br&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer+常用手写算法(C++)</title>
    <link href="http://yoursite.com/2018/05/28/%E5%89%91%E6%8C%87offer+%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/28/剑指offer+常见算法/</id>
    <published>2018-05-28T13:57:02.000Z</published>
    <updated>2018-10-09T16:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、编写赋值运算符"><a href="#1、编写赋值运算符" class="headerlink" title="1、编写赋值运算符"></a>1、编写赋值运算符</h1><p>四点：返回值、参数类型、释放已有内存、自身赋值特殊情况。<br>进阶：异常安全性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">CMyString temp(rhs);<span class="comment">//调用copy构造函数</span></span><br><span class="line"><span class="keyword">char</span>* ptemp=temp.m_pData;</span><br><span class="line">temp.m_pData=m_pData;</span><br><span class="line">m_pData=ptemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="2、简单实现一个Singleton类。"><a href="#2、简单实现一个Singleton类。" class="headerlink" title="2、简单实现一个Singleton类。"></a>2、简单实现一个Singleton类。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">initance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> singleton::mutex;</span><br><span class="line">singleton* singleton::initance()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">static</span> singleton obj;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleton()&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">static</span> object obj=<span class="keyword">new</span> object();<span class="comment">//一个互斥锁</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> Singleton&amp; GetInstance&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">lock(obj)&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="literal">NULL</span>)</span><br><span class="line">instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3、找出数组中重复的数字。"><a href="#3、找出数组中重复的数字。" class="headerlink" title="3、找出数组中重复的数字。"></a>3、找出数组中重复的数字。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">question3_3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vec.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line"><span class="keyword">if</span> (vec[i]&lt;<span class="number">0</span> || vec[i]&gt;vec.size() - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (vec[i] != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vec[i] == vec[vec[i]])</span><br><span class="line"><span class="keyword">return</span> vec[i];</span><br><span class="line"><span class="keyword">int</span> temp = vec[i];</span><br><span class="line">vec[i] = vec[temp];</span><br><span class="line">vec[temp] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line"><span class="keyword">if</span> (numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">question3_02</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( numbers.size() &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> end = numbers.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> middle = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">int</span> count = countRange(numbers, numbers.size(), start, middle);</span><br><span class="line"><span class="keyword">if</span> (end == start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; (middle - start + <span class="number">1</span>))</span><br><span class="line">end = middle;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">start = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、二维数组中的查找"><a href="#4、二维数组中的查找" class="headerlink" title="4、二维数组中的查找"></a>4、二维数组中的查找</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> m=<span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>&amp;&amp;<span class="built_in">array</span>[n<span class="number">-1</span>][m<span class="number">-1</span>]&lt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=m<span class="number">-1</span>;i&lt;n&amp;&amp;j&gt;=<span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]&lt;target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、替换空格"><a href="#5、替换空格" class="headerlink" title="5、替换空格"></a>5、替换空格</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> spaceCnt=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">           <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">               spaceCnt++;</span><br><span class="line">       <span class="keyword">int</span> newLength=length+<span class="number">2</span>*spaceCnt;</span><br><span class="line">       str[newLength]=<span class="string">'\0'</span>;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">       newLength--;</span><br><span class="line">       <span class="keyword">for</span>(i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               str[newLength--]=<span class="string">'0'</span>;</span><br><span class="line">               str[newLength--]=<span class="string">'2'</span>;</span><br><span class="line">               str[newLength--]=<span class="string">'%'</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               str[newLength--]=str[i];</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、从尾到头打印链表。"><a href="#6、从尾到头打印链表。" class="headerlink" title="6、从尾到头打印链表。"></a>6、从尾到头打印链表。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursion</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            Recursion(head-&gt;next,res);</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Recursion(head,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表："><a href="#反转链表：" class="headerlink" title="反转链表："></a>反转链表：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="树的四种遍历七种写法："><a href="#树的四种遍历七种写法：" class="headerlink" title="树的四种遍历七种写法："></a>树的四种遍历七种写法：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTra_Loop</span><span class="params">(TreeNode * root)</span><span class="comment">//先序循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"><span class="keyword">while</span> (cur || !sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur)<span class="comment">//找到最左</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">sta.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sta.empty())<span class="comment">//弹出栈顶元素并将选择其右子树再次遍历</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode* temp=sta.top();</span><br><span class="line">sta.pop();</span><br><span class="line">cur = temp-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTra_Recur</span><span class="params">(TreeNode * root)</span><span class="comment">//先序递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">PreorderTra_Recur(root-&gt;left);</span><br><span class="line">PreorderTra_Recur(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidorderTra_Loop</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur || !sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* temp = sta.top();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; temp-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">sta.pop();</span><br><span class="line">cur = temp-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidorderTra_Recur</span><span class="params">(TreeNode * root)</span><span class="comment">//中序递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">MidorderTra_Recur(root-&gt;left);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">MidorderTra_Recur(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序循环需要检查一个节点是否是第一次位于栈顶，若是第一次则引入它的右孩子，否则弹出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTra_Loop</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">while</span> (cur || !sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* temp = sta.top();</span><br><span class="line"><span class="keyword">if</span> (m[temp] == <span class="number">0</span>)<span class="comment">//第一次</span></span><br><span class="line">&#123;</span><br><span class="line">cur = temp-&gt;right;</span><br><span class="line">m[temp]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; temp-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">sta.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTra_Recur</span><span class="params">(TreeNode * root)</span><span class="comment">//后序递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">PostorderTra_Recur(root-&gt;left);</span><br><span class="line">PostorderTra_Recur(root-&gt;right);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelTra</span><span class="params">(TreeNode * root)</span><span class="comment">//层次遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">TreeNode* node = root;</span><br><span class="line">q.push(node);</span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* front = q.front();</span><br><span class="line"><span class="keyword">if</span> (front-&gt;left)</span><br><span class="line">q.push(front-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (front-&gt;right)</span><br><span class="line">q.push(front-&gt;right);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; front-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、重建二叉树。"><a href="#7、重建二叉树。" class="headerlink" title="7、重建二叉树。"></a>7、重建二叉树。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">recursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre,<span class="keyword">const</span> <span class="keyword">int</span> preStart,<span class="keyword">const</span> <span class="keyword">int</span> preEnd,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vin,<span class="keyword">const</span> <span class="keyword">int</span> vinStart,<span class="keyword">const</span> <span class="keyword">int</span> vinEnd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart&gt;preEnd||vinStart&gt;vinEnd)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* node=<span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=vinStart;i&lt;=vinEnd;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i]==pre[preStart])</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left=recursion(pre,preStart+<span class="number">1</span>,i-vinStart+preStart,vin,vinStart,vinEnd<span class="number">-1</span>);</span><br><span class="line">                node-&gt;right=recursion(pre,i-vinStart+preStart+<span class="number">1</span>,preEnd,vin,i+<span class="number">1</span>,vinEnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=recursion(pre,<span class="number">0</span>,pre.size()<span class="number">-1</span>,vin,<span class="number">0</span>,vin.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="8、二叉树的下一节点"><a href="#8、二叉树的下一节点" class="headerlink" title="8、二叉树的下一节点"></a>8、二叉树的下一节点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pRight = pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span>(pRight-&gt;m_pLeft != <span class="literal">nullptr</span>)</span><br><span class="line">            pRight = pRight-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;m_pParent != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        <span class="keyword">while</span>(pParent != <span class="literal">nullptr</span> &amp;&amp; pCurrent == pParent-&gt;m_pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9、用两个栈实现队列"><a href="#9、用两个栈实现队列" class="headerlink" title="9、用两个栈实现队列"></a>9、用两个栈实现队列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res=stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            res=stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="10、斐波那契数列。"><a href="#10、斐波那契数列。" class="headerlink" title="10、斐波那契数列。"></a>10、斐波那契数列。</h1><p>最容易想到的是递归，但是递归效率低下，栈可能溢出，在面试中最好使用从下往上的循环而不用递归。<br>利用从下往上循环的DP解法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="快排："><a href="#快排：" class="headerlink" title="快排："></a>快排：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data.empty()  || start&lt;<span class="number">0</span> || end&gt;data.size() - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid Parameters"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = (<span class="keyword">int</span>)(rand() % (end - start + <span class="number">1</span>)) + start;</span><br><span class="line">swap(data[index], data[start]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pivot = data[start];</span><br><span class="line"><span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end&amp;&amp;data[end] &gt;= pivot)</span><br><span class="line">end--;</span><br><span class="line">data[start] = data[end];</span><br><span class="line"><span class="keyword">while</span> (start &lt; end&amp;&amp;data[start] &lt;= pivot)</span><br><span class="line">start++;</span><br><span class="line">data[end] = data[start];</span><br><span class="line">&#125;</span><br><span class="line">data[start] = pivot;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span><span class="comment">//这种划分方法可保证小于的部分相对位置不变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = data[end];</span><br><span class="line"><span class="keyword">int</span> i = start - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt;= end - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data[j] &lt;= x)</span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">swap(data[i], data[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(data[i + <span class="number">1</span>], data[end]);</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> index = Partition(data, start, end);</span><br><span class="line"><span class="keyword">if</span> (index&gt;start)</span><br><span class="line">QuickSort(data, start, index - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (index &lt; end)</span><br><span class="line">QuickSort(data, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11、旋转数组的最小数字"><a href="#11、旋转数组的最小数字" class="headerlink" title="11、旋转数组的最小数字"></a>11、旋转数组的最小数字</h1><p>最好利用二分查找，时间效率快。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; rotateArray,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> small=rotateArray[left];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i]&lt;small)</span><br><span class="line">                small=rotateArray[i];</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[left]&gt;=rotateArray[right])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid=right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果left、right、mid指向的三个数字相同，则只能进行顺序查找</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[left]==rotateArray[right]&amp;&amp;rotateArray[right]==rotateArray[mid])</span><br><span class="line">                <span class="keyword">return</span> MinInOrder(rotateArray,left,right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(rotateArray[left]&lt;=rotateArray[mid])</span><br><span class="line">                left=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[right]&gt;=rotateArray[mid])</span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="12、矩阵中的路径（回溯法）"><a href="#12、矩阵中的路径（回溯法）" class="headerlink" title="12、矩阵中的路径（回溯法）"></a>12、矩阵中的路径（回溯法）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str,</span><br><span class="line">                pathLength, visited))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[pathLength] == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; matrix[row * cols + col] == str[pathLength]</span><br><span class="line">        &amp;&amp; !visited[row * cols + col])</span><br><span class="line">    &#123;</span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        hasPath = hasPathCore(matrix, rows, cols, row, col - <span class="number">1</span>,</span><br><span class="line">            str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row - <span class="number">1</span>, col,</span><br><span class="line">                str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row, col + <span class="number">1</span>,</span><br><span class="line">                str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row + <span class="number">1</span>, col,</span><br><span class="line">                str, pathLength, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasPath)</span><br><span class="line">        &#123;</span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13、机器人的运动范围"><a href="#13、机器人的运动范围" class="headerlink" title="13、机器人的运动范围"></a>13、机器人的运动范围</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(threshold&lt;<span class="number">0</span>||rows&lt;=<span class="number">0</span>||cols&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        backTracking(rows,cols,<span class="number">0</span>,<span class="number">0</span>,threshold,cnt,visited);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">const</span> <span class="keyword">int</span>&amp; threshold,<span class="keyword">int</span>&amp; cnt,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((digitSum(i)+digitSum(j))&gt;threshold)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;rows&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;j&lt;cols&amp;&amp;visited[i][j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i][j]=<span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            backTracking(rows,cols,i<span class="number">-1</span>,j,threshold,cnt,visited);</span><br><span class="line">            backTracking(rows,cols,i,j<span class="number">-1</span>,threshold,cnt,visited);</span><br><span class="line">            backTracking(rows,cols,i+<span class="number">1</span>,j,threshold,cnt,visited);</span><br><span class="line">            backTracking(rows,cols,i,j+<span class="number">1</span>,threshold,cnt,visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=i%<span class="number">10</span>;</span><br><span class="line">            i/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="14、剪绳子"><a href="#14、剪绳子" class="headerlink" title="14、剪绳子"></a>14、剪绳子</h1><p>动态规划和贪婪法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规动态规划方法,要求至少剪一刀</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(length+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; length+<span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = dp[i - j] * dp[j];</span><br><span class="line"><span class="keyword">if</span> (cur &gt; max)</span><br><span class="line">max = cur;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[length];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪婪法：需要想到数学证明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> timeOf3 = length / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (length % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">timeOf3--;</span><br><span class="line"><span class="keyword">int</span> timeOf2 = (length - <span class="number">3</span> * timeOf3) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, timeOf3))*(<span class="built_in">pow</span>(<span class="number">2</span>, timeOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="15、判断二进制数中1-的个数"><a href="#15、判断二进制数中1-的个数" class="headerlink" title="15、判断二进制数中1 的个数"></a>15、判断二进制数中1 的个数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">             cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> cnt;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="16、数值的整数次方"><a href="#16、数值的整数次方" class="headerlink" title="16、数值的整数次方"></a>16、数值的整数次方</h1><p>注意：本例虽然过了，但是double 型数值的比较建议使用范围比较<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">PowerWithAbsexponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        <span class="keyword">double</span> result=PowerWithAbsexponent(base,exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        result*=result;</span><br><span class="line">        <span class="keyword">if</span>((exponent&amp;<span class="number">0x1</span>)==<span class="number">1</span>)</span><br><span class="line">            result*=base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">0.0</span>&amp;&amp;exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> absExponent=(exponent&gt;<span class="number">0</span>)?exponent:(<span class="number">0</span>-exponent);</span><br><span class="line">        <span class="keyword">double</span> result=PowerWithAbsexponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1</span>/result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> InvalidInput=<span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="17、打印从1到最大的n位数"><a href="#17、打印从1到最大的n位数" class="headerlink" title="17、打印从1到最大的n位数"></a>17、打印从1到最大的n位数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18"><a href="#18" class="headerlink" title="18"></a>18</h1><h2 id="18-1、删除链表结点"><a href="#18-1、删除链表结点" class="headerlink" title="18-1、删除链表结点"></a>18-1、删除链表结点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">        *pListHead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;            </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        pNode-&gt;m_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-2-删除链表中重复结点"><a href="#18-2-删除链表中重复结点" class="headerlink" title="18-2 删除链表中重复结点"></a>18-2 删除链表中重复结点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur=pHead;</span><br><span class="line">        ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next=pHead;</span><br><span class="line">        ListNode* next=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* p=pre;</span><br><span class="line">        <span class="keyword">bool</span> duplicationFlag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            duplicationFlag=<span class="literal">false</span>;</span><br><span class="line">            next=cur-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(next&amp;&amp;next-&gt;val==cur-&gt;val)<span class="comment">//next存在且和cur重复，就把next往前移</span></span><br><span class="line">            &#123;</span><br><span class="line">                next=next-&gt;next;</span><br><span class="line">                duplicationFlag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!next)<span class="comment">//next结束了，说明cur后面所有结点值都和cur相同</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (duplicationFlag)</span><br><span class="line">pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(duplicationFlag)</span><br><span class="line">                    pre-&gt;next=next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pre=cur;</span><br><span class="line">                cur=next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="19、正则表达式匹配"><a href="#19、正则表达式匹配" class="headerlink" title="19、正则表达式匹配"></a>19、正则表达式匹配</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pattern == *str || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">            <span class="comment">// 进入有限状态机的下一个状态</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>)</span><br><span class="line">            <span class="comment">// 继续留在有限状态机的当前状态 </span></span><br><span class="line">            || matchCore(str + <span class="number">1</span>, pattern)</span><br><span class="line">            <span class="comment">// 略过一个'*' </span></span><br><span class="line">            || matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 略过一个'*'</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">        <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="20、表示数值的字符串"><a href="#20、表示数值的字符串" class="headerlink" title="20、表示数值的字符串"></a>20、表示数值的字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> numeric = scanInteger(&amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果出现'.'，接下来是数字的小数部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'.'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面一行代码用||的原因：</span></span><br><span class="line">        <span class="comment">// 1. 小数可以没有整数部分，例如.123等于0.123；</span></span><br><span class="line">        <span class="comment">// 2. 小数点后面可以没有数字，例如233.等于233.0；</span></span><br><span class="line">        <span class="comment">// 3. 当然小数点前面和后面可以有数字，例如233.666</span></span><br><span class="line">        numeric = scanUnsignedInteger(&amp;str) || numeric;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果出现'e'或者'E'，接下来跟着的是数字的指数部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面一行代码用&amp;&amp;的原因：</span></span><br><span class="line">        <span class="comment">// 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；</span></span><br><span class="line">        <span class="comment">// 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4</span></span><br><span class="line">        numeric = numeric &amp;&amp; scanInteger(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numeric &amp;&amp; *str == <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* before = *str;</span><br><span class="line">    <span class="keyword">while</span>(**str != <span class="string">'\0'</span> &amp;&amp; **str &gt;= <span class="string">'0'</span> &amp;&amp; **str &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ++(*str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当str中存在若干0-9的数字时，返回true</span></span><br><span class="line">    <span class="keyword">return</span> *str &gt; before;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数的格式可以用[+|-]B表示, 其中B为无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(**str == <span class="string">'+'</span> || **str == <span class="string">'-'</span>)</span><br><span class="line">        ++(*str);</span><br><span class="line">    <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="21、调整数组顺序使奇数位于偶数前面"><a href="#21、调整数组顺序使奇数位于偶数前面" class="headerlink" title="21、调整数组顺序使奇数位于偶数前面"></a>21、调整数组顺序使奇数位于偶数前面</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">array</span>[i] &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">                res.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">array</span>[i] &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span> = res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="23、找链表环的入口。"><a href="#23、找链表环的入口。" class="headerlink" title="23、找链表环的入口。"></a>23、找链表环的入口。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow=pHead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast=slow-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast)</span><br><span class="line">                fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fast)<span class="comment">//没有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow=pHead;<span class="comment">//slow回到原点</span></span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="24、反转链表"><a href="#24、反转链表" class="headerlink" title="24、反转链表"></a>24、反转链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pre,*cur,*next;</span><br><span class="line">        pre=<span class="literal">NULL</span>;</span><br><span class="line">        cur=pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">递归：</span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead||!pHead-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* next=pHead-&gt;next;</span><br><span class="line">        pHead-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* re=ReverseList(next);</span><br><span class="line">        next-&gt;next=pHead;</span><br><span class="line">        <span class="keyword">return</span> re; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="25、合并两个有序链表"><a href="#25、合并两个有序链表" class="headerlink" title="25、合并两个有序链表"></a>25、合并两个有序链表</h1><p>递归：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1&amp;&amp;!pHead2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(!pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        </span><br><span class="line">        ListNode* node=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            node=pHead1;</span><br><span class="line">            node-&gt;next=Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node=pHead2;</span><br><span class="line">            node-&gt;next=Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="26、树的子结构"><a href="#26、树的子结构" class="headerlink" title="26、树的子结构"></a>26、树的子结构</h1><p>递归<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasOrNo</span><span class="params">(TreeNode* r1, TreeNode* r2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!r1&amp;&amp;r2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!r2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1-&gt;val!=r2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> HasOrNo(r1-&gt;left,r2-&gt;left)&amp;&amp;HasOrNo(r1-&gt;right,r2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val==pRoot2-&gt;val)</span><br><span class="line">            flag=HasOrNo(pRoot1,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            flag=HasOrNo(pRoot1-&gt;left,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            flag=HasOrNo(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a>27、二叉树的镜像</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* left=pRoot-&gt;left;</span><br><span class="line">        TreeNode* right=pRoot-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(left)<span class="comment">//has left subtree</span></span><br><span class="line">        &#123;</span><br><span class="line">            pRoot-&gt;right=left;</span><br><span class="line">            <span class="keyword">if</span>(!right)</span><br><span class="line">                pRoot-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right)</span><br><span class="line">        &#123;</span><br><span class="line">            pRoot-&gt;left=right;</span><br><span class="line">            <span class="keyword">if</span>(!left)</span><br><span class="line">                pRoot-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//非递归：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* temp=st.top();</span><br><span class="line">            TreeNode* t=temp-&gt;left;</span><br><span class="line">            temp-&gt;left=temp-&gt;right;</span><br><span class="line">            temp-&gt;right=t;</span><br><span class="line">            </span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                st.push(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                st.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a>28、对称的二叉树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool isSymmetrical(TreeNode* left,TreeNode* right)；</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot-&gt;left,pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* left,TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left&amp;&amp;!right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left||!right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val!=right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(left-&gt;right,right-&gt;left)</span><br><span class="line">             &amp;&amp;isSymmetrical(left-&gt;left,right-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="29、顺时针打印矩阵"><a href="#29、顺时针打印矩阵" class="headerlink" title="29、顺时针打印矩阵"></a>29、顺时针打印矩阵</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrixInCircle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix,<span class="keyword">const</span> <span class="keyword">int</span> start,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endX=matrix[<span class="number">0</span>].size()<span class="number">-1</span>-start;</span><br><span class="line">        <span class="keyword">int</span> endY=matrix.size()<span class="number">-1</span>-start;</span><br><span class="line">        <span class="comment">//从左往右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=endX;i++)</span><br><span class="line">            res.push_back(matrix[start][i]);</span><br><span class="line">        <span class="comment">//从上往下，至少有两行的时候才需要</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endY)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=endY;i++)</span><br><span class="line">                res.push_back(matrix[i][endX]);</span><br><span class="line">        <span class="comment">//从右往左，至少两行两列才需要</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endX&amp;&amp;start&lt;endY)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=endX<span class="number">-1</span>;i&gt;=start;i--)</span><br><span class="line">                res.push_back(matrix[endY][i]);</span><br><span class="line">        <span class="comment">//从下往上，至少三行两列才需要</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endX&amp;&amp;start&lt;endY<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=endY<span class="number">-1</span>;i&gt;=start+<span class="number">1</span>;i--)</span><br><span class="line">                res.push_back(matrix[i][start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>||matrix[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(matrix.size()&gt;start*<span class="number">2</span>&amp;&amp;matrix[<span class="number">0</span>].size()&gt;start*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintMatrixInCircle(matrix,start,res);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="30、包含min的栈"><a href="#30、包含min的栈" class="headerlink" title="30、包含min的栈"></a>30、包含min的栈</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">        <span class="keyword">if</span>(m.empty())</span><br><span class="line">            m.push(value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(value&lt;=m.top())</span><br><span class="line">                m.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value=data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">        <span class="keyword">if</span>(value==m.top())</span><br><span class="line">            m.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="31、栈的压入弹出序列"><a href="#31、栈的压入弹出序列" class="headerlink" title="31、栈的压入弹出序列"></a>31、栈的压入弹出序列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.empty()||popV.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        data.push(pushV[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;<span class="comment">//i指向pushV下标，j指向popV下标</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;popV.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data.top()==popV[j])<span class="comment">//弹出数字刚好是栈顶元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                data.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">bool</span> findFlag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(;i&lt;pushV.size();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    data.push(pushV[i]);</span><br><span class="line">                    <span class="keyword">if</span>(pushV[i]==popV[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        findFlag=<span class="literal">true</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!findFlag)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="32、从上到下打印二叉树（即层次遍历，具体代码看上面树的遍历代码）"><a href="#32、从上到下打印二叉树（即层次遍历，具体代码看上面树的遍历代码）" class="headerlink" title="32、从上到下打印二叉树（即层次遍历，具体代码看上面树的遍历代码）"></a>32、从上到下打印二叉树（即层次遍历，具体代码看上面树的遍历代码）</h1><p>题目扩展：每一层结点占一行，换行打印<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">            <span class="keyword">if</span>(!pRoot)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">            TreeNode* lineLast;</span><br><span class="line">            TreeNode* nextLineLast;</span><br><span class="line">            lineLast=nextLineLast=pRoot;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">            q.push(pRoot);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* f=q.front();</span><br><span class="line">                line.push_back(f-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(f-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(f-&gt;left);</span><br><span class="line">                    nextLineLast=f-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(f-&gt;right);</span><br><span class="line">                    nextLineLast=f-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f==lineLast)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(line);</span><br><span class="line">                    line.clear();</span><br><span class="line">                    lineLast=nextLineLast;</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">扩展二：之字形打印</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"><span class="keyword">if</span> (!pRoot)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;TreeNode*&gt;&gt; stacks(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> stacksIndex = <span class="number">0</span>;<span class="comment">//stacks[0]从左到右</span></span><br><span class="line"></span><br><span class="line">stacks[<span class="number">0</span>].push(pRoot);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line"><span class="keyword">while</span> (!stacks[<span class="number">0</span>].empty() || !stacks[<span class="number">1</span>].empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* f = stacks[stacksIndex].top();</span><br><span class="line">stacks[stacksIndex].pop();</span><br><span class="line">line.push_back(f-&gt;val);</span><br><span class="line"><span class="keyword">if</span> (stacksIndex == <span class="number">0</span>)<span class="comment">//下一层从右往左</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;right)</span><br><span class="line">stacks[<span class="number">1</span>].push(f-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;left)</span><br><span class="line">stacks[<span class="number">1</span>].push(f-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;left)</span><br><span class="line">stacks[<span class="number">0</span>].push(f-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;right)</span><br><span class="line">stacks[<span class="number">0</span>].push(f-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stacks[stacksIndex].empty())&#123;</span><br><span class="line">reverse(line.begin(), line.end());</span><br><span class="line">res.push_back(line);</span><br><span class="line">line.clear();</span><br><span class="line">stacksIndex = <span class="number">1</span> - stacksIndex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   ``` </span><br><span class="line"># <span class="number">33</span>、二叉搜索树的后序遍历序列</span><br><span class="line">```C++</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> root=sequence[sequence.size()<span class="number">-1</span>];<span class="comment">//后序遍历中根节点是最后一个</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;sequence.size()<span class="number">-1</span>;i++)<span class="comment">//找左子树</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;root)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;sequence.size()<span class="number">-1</span>;j++)<span class="comment">//找右子树</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;root)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//右子树中如果有比根节点值小的，则返回false</span></span><br><span class="line">        <span class="keyword">bool</span> left=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; le(sequence.begin(),sequence.begin()+i);</span><br><span class="line">            left=VerifySquenceOfBST(le);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> right=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;sequence.size()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ri(sequence.begin()+i,sequence.end()<span class="number">-1</span>);</span><br><span class="line">            right=VerifySquenceOfBST(ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="34、二叉树中和为某一值的路径"><a href="#34、二叉树中和为某一值的路径" class="headerlink" title="34、二叉树中和为某一值的路径"></a>34、二叉树中和为某一值的路径</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(TreeNode* root,<span class="keyword">int</span> expectNum,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>((!root-&gt;left)&amp;&amp;(!root-&gt;right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(accumulate(path.begin(),path.end(),<span class="number">0</span>)==expectNum)</span><br><span class="line">                res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            backTracking(root-&gt;left,expectNum,res,path);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            backTracking(root-&gt;right,expectNum,res,path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        backTracking(root,expectNumber,res,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="35、复杂链表的复制"><a href="#35、复杂链表的复制" class="headerlink" title="35、复杂链表的复制"></a>35、复杂链表的复制</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1克隆节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* cloneNode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(cloneNode)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* cc=<span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">            cc-&gt;label=cloneNode-&gt;label;</span><br><span class="line">            cc-&gt;next=cloneNode-&gt;next;</span><br><span class="line">            cc-&gt;random=<span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">            cloneNode-&gt;next=cc;</span><br><span class="line">            cloneNode=cc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2为每个新节点赋值random</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConnectRandomNode</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* p=pHead;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* pp=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;random)</span><br><span class="line">                pp-&gt;random=p-&gt;random-&gt;next;</span><br><span class="line">            p=pp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3将原链表拆成两个相同链表</span></span><br><span class="line">    <span class="function">RandomListNode* <span class="title">ReconnectNode</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* p=pHead;</span><br><span class="line">        RandomListNode *cloneHead=<span class="literal">NULL</span>,*cloneNode=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cloneHead=p-&gt;next;</span><br><span class="line">            cloneNode=p-&gt;next;</span><br><span class="line">            p-&gt;next=cloneNode-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cloneNode-&gt;next=p-&gt;next;</span><br><span class="line">            cloneNode=cloneNode-&gt;next;</span><br><span class="line">            p-&gt;next=cloneNode-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CloneNodes(pHead);</span><br><span class="line">        ConnectRandomNode(pHead);</span><br><span class="line">        <span class="keyword">return</span> ReconnectNode(pHead);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="36、二叉搜索树与双向链表"><a href="#36、二叉搜索树与双向链表" class="headerlink" title="36、二叉搜索树与双向链表"></a>36、二叉搜索树与双向链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* root,TreeNode *&amp;node)</span><span class="comment">//指针的引用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur=root;</span><br><span class="line">            InOrder(root-&gt;left,node);</span><br><span class="line">            cur-&gt;left=node;</span><br><span class="line">            <span class="keyword">if</span>(node)</span><br><span class="line">                node-&gt;right=cur;</span><br><span class="line">            node=cur;</span><br><span class="line">            InOrder(root-&gt;right,node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRootOfTree)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* node=<span class="literal">NULL</span>;</span><br><span class="line">        InOrder(pRootOfTree,node);</span><br><span class="line">        <span class="keyword">while</span>(node&amp;&amp;node-&gt;left)</span><br><span class="line">            node=node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="37、序列化二叉树"><a href="#37、序列化二叉树" class="headerlink" title="37、序列化二叉树"></a>37、序列化二叉树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//牛客</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#,"</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        str=to_string(root-&gt;val);</span><br><span class="line">        str+=<span class="string">","</span>;</span><br><span class="line">        <span class="keyword">char</span>* left=Serialize(root-&gt;left);</span><br><span class="line">        <span class="keyword">char</span>* right=Serialize(root-&gt;right);</span><br><span class="line">        <span class="keyword">char</span>* res=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(left)+<span class="built_in">strlen</span>(right)+str.size()];</span><br><span class="line">        <span class="built_in">strcpy</span>(res,str.c_str());</span><br><span class="line">        <span class="built_in">strcat</span>(res,left);</span><br><span class="line">        <span class="built_in">strcat</span>(res,right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decode(str);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">decode</span><span class="params">(<span class="keyword">char</span> *&amp;str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'#'</span>)&#123;</span><br><span class="line">            str+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*str != <span class="string">','</span>)</span><br><span class="line">            num = num*<span class="number">10</span> + (*(str++)-<span class="string">'0'</span>);</span><br><span class="line">        str++;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        root-&gt;left = decode(str);</span><br><span class="line">        root-&gt;right = decode(str);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//书上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(<span class="keyword">const</span> BinaryTreeNode* pRoot, ostream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stream &lt;&lt; <span class="string">"$,"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stream &lt;&lt; pRoot-&gt;m_nValue &lt;&lt; <span class="string">','</span>;</span><br><span class="line">    Serialize(pRoot-&gt;m_pLeft, stream);</span><br><span class="line">    Serialize(pRoot-&gt;m_pRight, stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReadStream</span><span class="params">(istream&amp; stream, <span class="keyword">int</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream.eof())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    stream &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stream.eof() &amp;&amp; ch != <span class="string">','</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer[i++] = ch;</span><br><span class="line">        stream &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isNumeric = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; buffer[<span class="number">0</span>] != <span class="string">'$'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *number = atoi(buffer);</span><br><span class="line">        isNumeric = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNumeric;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deserialize</span><span class="params">(BinaryTreeNode** pRoot, istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(ReadStream(stream, &amp;number))</span><br><span class="line">    &#123;</span><br><span class="line">        *pRoot = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">        (*pRoot)-&gt;m_nValue = number;</span><br><span class="line">        (*pRoot)-&gt;m_pLeft = <span class="literal">nullptr</span>;</span><br><span class="line">        (*pRoot)-&gt;m_pRight = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        Deserialize(&amp;((*pRoot)-&gt;m_pLeft), stream);</span><br><span class="line">        Deserialize(&amp;((*pRoot)-&gt;m_pRight), stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="38、字符串的排列"><a href="#38、字符串的排列" class="headerlink" title="38、字符串的排列"></a>38、字符串的排列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursive</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">string</span>&amp; str,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=str.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(res.begin(),res.end(),str)==res.end())</span><br><span class="line">                res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(str[index],str[i]);</span><br><span class="line">            Recursive(index+<span class="number">1</span>,str,res);</span><br><span class="line">            swap(str[index],str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Recursive(<span class="number">0</span>,str,res);</span><br><span class="line">        sort(res.begin(),res.end());<span class="comment">//保证输出是按字典序排的，若题目不要求可注释</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">扩展：字符串的字符组合</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursive</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index, <span class="built_in">string</span>&amp; str, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res,<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (find(res.begin(), res.end(), s) == res.end())</span><br><span class="line">res.push_back(s);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= str.size())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//把index放入</span></span><br><span class="line">s += str[index];</span><br><span class="line">Recursive(num - <span class="number">1</span>, index + <span class="number">1</span>, str, res, s);</span><br><span class="line">s=s.substr(<span class="number">0</span>, s.size()<span class="number">-1</span>);<span class="comment">//去掉最后一个字符，回溯</span></span><br><span class="line"><span class="comment">//不放如index</span></span><br><span class="line">Recursive(num, index + <span class="number">1</span>, str, res, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">sort(str.begin(), str.end());</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size()+<span class="number">1</span>; i++)<span class="comment">//i表示组合中字符个数</span></span><br><span class="line">Recursive(i, <span class="number">0</span>,str, res,s);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kmp算法实现："><a href="#kmp算法实现：" class="headerlink" title="kmp算法实现："></a>kmp算法实现：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用KMP算法结题，实现KMP算法</span></span><br><span class="line">        <span class="keyword">int</span> n=needle.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next=getNextArray(needle);<span class="comment">//获取next数组</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">-1</span>;<span class="comment">//用来标志needle，也代表匹配程度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;haystack.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(k&gt;<span class="number">-1</span>&amp;&amp;needle[k+<span class="number">1</span>]!=haystack[i])<span class="comment">//部分匹配但是接下来的不匹配，就计算往后退的步数，回溯</span></span><br><span class="line">                k=next[k];</span><br><span class="line">            <span class="keyword">if</span>(needle[k+<span class="number">1</span>]==haystack[i])<span class="comment">//下一位相同，又匹配了一位，k++</span></span><br><span class="line">                k++;</span><br><span class="line">            <span class="keyword">if</span>(k==n<span class="number">-1</span>)<span class="comment">//完全匹配</span></span><br><span class="line">                <span class="keyword">return</span> i-n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要实现kmp算法，需要先实现针对needle的next数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNextArray(<span class="built_in">string</span> &amp;needle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(needle.size(),<span class="number">0</span>);</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;<span class="comment">//-1表示不存在相同最大前缀和最大后缀</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;needle.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(k&gt;<span class="number">-1</span>&amp;&amp;needle[k+<span class="number">1</span>]!=needle[i])<span class="comment">//如果k&gt;-1并且下一个字符不同，k就往前回溯，找到与当前点相同的之前点</span></span><br><span class="line">                k=next[k];</span><br><span class="line">            <span class="keyword">if</span>(needle[k+<span class="number">1</span>]==needle[i])<span class="comment">//如果下一个字符相同，k++</span></span><br><span class="line">                k++;</span><br><span class="line">            next[i]=k;<span class="comment">//赋值next数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="39、数组中出现次数超过一半的数字"><a href="#39、数组中出现次数超过一半的数字" class="headerlink" title="39、数组中出现次数超过一半的数字"></a>39、数组中出现次数超过一半的数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> value=numbers[<span class="number">0</span>],cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numbers.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==value)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span>(cnt==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    value=numbers[i];</span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count(numbers.begin(),numbers.end(),value)*<span class="number">2</span>&gt;numbers.size())</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="40、最小的k个数"><a href="#40、最小的k个数" class="headerlink" title="40、最小的k个数"></a>40、最小的k个数</h1><p>以下实现使用最大堆，也可用基于红黑树实现的set。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.size()||k&lt;=<span class="number">0</span>||input.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        make_heap(res.begin(),res.end());<span class="comment">//构造堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;input.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i]&lt;res[<span class="number">0</span>])<span class="comment">//比堆顶数小</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(input[i]);</span><br><span class="line">                push_heap(res.begin(),res.end());</span><br><span class="line">                pop_heap(res.begin(),res.end());</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort_heap(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="41、数据流中的中位数"><a href="#41、数据流中的中位数" class="headerlink" title="41、数据流中的中位数"></a>41、数据流中的中位数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(((min.size() + max.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                max.push_back(num);</span><br><span class="line">                push_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">                num = max[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                pop_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line">                max.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            min.push_back(num);</span><br><span class="line">            push_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(min.size() &gt; <span class="number">0</span> &amp;&amp; min[<span class="number">0</span>] &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                min.push_back(num);</span><br><span class="line">                push_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">                num = min[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            max.push_back(num);</span><br><span class="line">            push_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = min.size() + max.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> exception(<span class="string">"No numbers are available"</span>);</span><br><span class="line"></span><br><span class="line">        T median = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((size &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            median = min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            median = (min[<span class="number">0</span>] + max[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; min;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="42、连续子数组的最大和"><a href="#42、连续子数组的最大和" class="headerlink" title="42、连续子数组的最大和"></a>42、连续子数组的最大和</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="built_in">array</span>.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxSum=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i]=<span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;maxSum)</span><br><span class="line">                    maxSum=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="43、1-n整数中1出现的次数"><a href="#43、1-n整数中1出现的次数" class="headerlink" title="43、1~n整数中1出现的次数"></a>43、1~n整数中1出现的次数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i*=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> index = n % (i * <span class="number">10</span>) / i;<span class="comment">//得到i位数</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">1</span>)<span class="comment">//i位&gt;1</span></span><br><span class="line">    cnt += i*(n / (i * <span class="number">10</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)<span class="comment">//i位==1</span></span><br><span class="line">    cnt += i*(n / (i * <span class="number">10</span>)) + (n%i) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//i位==0</span></span><br><span class="line">    cnt += i*(n / (i * <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="44、数字序列中某一位的数字"><a href="#44、数字序列中某一位的数字" class="headerlink" title="44、数字序列中某一位的数字"></a>44、数字序列中某一位的数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> digits = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> numbers = countOfIntegers(digits);</span><br><span class="line"><span class="keyword">if</span>(index &lt; numbers * digits)</span><br><span class="line"><span class="keyword">return</span> digitAtIndex(index, digits);</span><br><span class="line"></span><br><span class="line">index -= digits * numbers;</span><br><span class="line">digits++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">9</span> * count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> number = beginNumber(digits) + index / digits;</span><br><span class="line"><span class="keyword">int</span> indexFromRight = digits - index % digits;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; indexFromRight; ++i)</span><br><span class="line">number /= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="45、把数组排成最小的数"><a href="#45、把数组排成最小的数" class="headerlink" title="45、把数组排成最小的数"></a>45、把数组排成最小的数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringNums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)</span><br><span class="line">            stringNums.push_back(to_string(numbers[i]));</span><br><span class="line">        sort(stringNums.begin(),stringNums.end(),[](<span class="built_in">string</span> s1,<span class="built_in">string</span> s2)</span><br><span class="line">             &#123;<span class="keyword">return</span> ((s1+s2).compare(s2+s1)&lt;<span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>; &#125;);</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stringNums.size();i++)</span><br><span class="line">            res+=stringNums[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="46、把数字翻译成字符串"><a href="#46、把数字翻译成字符串" class="headerlink" title="46、把数字翻译成字符串"></a>46、把数字翻译成字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTranslationCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTranslationCount</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> numberInString = to_string(number);</span><br><span class="line">    <span class="keyword">return</span> GetTranslationCount(numberInString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTranslationCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = number.length();</span><br><span class="line">    <span class="keyword">int</span>* counts = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">               count = counts[i + <span class="number">1</span>];</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">               count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit1 = number[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> digit2 = number[i + <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> converted = digit1 * <span class="number">10</span> + digit2;</span><br><span class="line">            <span class="keyword">if</span>(converted &gt;= <span class="number">10</span> &amp;&amp; converted &lt;= <span class="number">25</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; length - <span class="number">2</span>)</span><br><span class="line">                    count += counts[i + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts[i] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = counts[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] counts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="47、礼物的最大价值"><a href="#47、礼物的最大价值" class="headerlink" title="47、礼物的最大价值"></a>47、礼物的最大价值</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxValue_solution1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>** maxValues = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        maxValues[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                up = maxValues[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                left = maxValues[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            maxValues[i][j] = <span class="built_in">std</span>::max(left, up) + values[i * cols + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxValue = maxValues[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] maxValues[i];</span><br><span class="line">    <span class="keyword">delete</span>[] maxValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="48-、最长不包含重复字符的子字符串"><a href="#48-、最长不包含重复字符的子字符串" class="headerlink" title="48.、最长不包含重复字符的子字符串"></a>48.、最长不包含重复字符的子字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstringWithoutDuplication_2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        position[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> prevIndex = position[str[i] - <span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(prevIndex &lt; <span class="number">0</span> || i - prevIndex &gt; curLength)</span><br><span class="line">            ++curLength;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curLength &gt; maxLength)</span><br><span class="line">                maxLength = curLength;</span><br><span class="line"></span><br><span class="line">            curLength = i - prevIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        position[str[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curLength &gt; maxLength)</span><br><span class="line">        maxLength = curLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] position;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="49、丑数"><a href="#49、丑数" class="headerlink" title="49、丑数"></a>49、丑数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> n1,<span class="keyword">int</span> n2,<span class="keyword">int</span> n3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1&lt;=n2?(n1&lt;=n3?n1:n3):(n2&lt;=n3?n2:n3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uglyNums;</span><br><span class="line">        uglyNums.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> multiple2=<span class="number">0</span>,multiple3=<span class="number">0</span>,multiple5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(uglyNums.size()&lt;index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tempNum=Min(<span class="number">2</span>*uglyNums[multiple2],<span class="number">3</span>*uglyNums[multiple3],<span class="number">5</span>*uglyNums[multiple5]);</span><br><span class="line">            uglyNums.push_back(tempNum);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">2</span>*uglyNums[multiple2]&lt;=uglyNums[uglyNums.size()<span class="number">-1</span>])</span><br><span class="line">                multiple2++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">3</span>*uglyNums[multiple3]&lt;=uglyNums[uglyNums.size()<span class="number">-1</span>])</span><br><span class="line">                multiple3++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">5</span>*uglyNums[multiple5]&lt;=uglyNums[uglyNums.size()<span class="number">-1</span>])</span><br><span class="line">                multiple5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglyNums[uglyNums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="50、第一次只出现一次的字符"><a href="#50、第一次只出现一次的字符" class="headerlink" title="50、第一次只出现一次的字符"></a>50、第一次只出现一次的字符</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; charAndCnt;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; charFirstIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(charAndCnt[str[i]]==<span class="number">0</span>)<span class="comment">//第一次出现</span></span><br><span class="line">                charFirstIndex[str[i]]=i;</span><br><span class="line">            charAndCnt[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> firstCharIndex=str.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:charAndCnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span>(charFirstIndex[p.first]&lt;firstCharIndex)</span><br><span class="line">                    firstCharIndex=charFirstIndex[p.first];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstCharIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="50-2、字符流中出现一次的第一个字符"><a href="#50-2、字符流中出现一次的第一个字符" class="headerlink" title="50_2、字符流中出现一次的第一个字符"></a>50_2、字符流中出现一次的第一个字符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution():index(<span class="number">0</span>),occurence(<span class="number">256</span>,<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(occurence[ch]==<span class="number">-1</span>)</span><br><span class="line">             occurence[ch]=index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(occurence[ch]&gt;=<span class="number">0</span>)</span><br><span class="line">            occurence[ch]=<span class="number">-2</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex=index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(occurence[i]&gt;=<span class="number">0</span>&amp;&amp;occurence[i]&lt;=minIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex=occurence[i];</span><br><span class="line">                ch=<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex==index)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; occurence;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="51、数组中的逆序对"><a href="#51、数组中的逆序对" class="headerlink" title="51、数组中的逆序对"></a>51、数组中的逆序对</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(data);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt=MergeSort(data,temp,<span class="number">0</span>,data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[left]=data[left];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> leftCnt=MergeSort(temp,data,left,mid);<span class="comment">//temp和data需要调换位置，使递归的data部分有序</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rightCnt=MergeSort(temp,data,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开辟辅助空间，对左右两半数组进行归并排序，在归并排序的过程中统计逆序次数</span></span><br><span class="line">        <span class="keyword">int</span> leftIndex=mid,rightIndex=right,tempIndex=right;</span><br><span class="line">        <span class="keyword">while</span>(leftIndex&gt;=left&amp;&amp;rightIndex&gt;=mid+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[leftIndex]&gt;data[rightIndex])<span class="comment">//左边大，出现逆序对</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt+=rightIndex-mid;</span><br><span class="line">                temp[tempIndex--]=data[leftIndex--];</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;<span class="number">1000000007</span>)</span><br><span class="line">                    cnt=cnt%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp[tempIndex--]=data[rightIndex--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(leftIndex&gt;=left)<span class="comment">//右半边结束了</span></span><br><span class="line">            temp[tempIndex--]=data[leftIndex--];</span><br><span class="line">        <span class="keyword">while</span>(rightIndex&gt;=mid+<span class="number">1</span>)</span><br><span class="line">            temp[tempIndex--]=data[rightIndex--];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt+leftCnt+rightCnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="52、两个链表的第一个公共结点"><a href="#52、两个链表的第一个公共结点" class="headerlink" title="52、两个链表的第一个公共结点"></a>52、两个链表的第一个公共结点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1||!pHead2)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length1=<span class="number">1</span>,length2=<span class="number">1</span>;</span><br><span class="line">        ListNode* p1=pHead1,*p2=pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            length1++;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            length2++;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1!=p2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p1=pHead1;</span><br><span class="line">        p2=pHead2;</span><br><span class="line">        <span class="keyword">int</span> n=(length1&gt;length2)?(length1-length2):(length2-length1);</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(length1&gt;length2)</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="53、数字在排序数组中出现的次数"><a href="#53、数字在排序数组中出现的次数" class="headerlink" title="53、数字在排序数组中出现的次数"></a>53、数字在排序数组中出现的次数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first =getFirst(data,<span class="number">0</span>,data.size()<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">int</span> last=getLast(data,<span class="number">0</span>,data.size()<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">if</span>(first&gt;<span class="number">-1</span>&amp;&amp;last&gt;<span class="number">-1</span>)</span><br><span class="line">            cnt=last-first+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=start+((end-start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> midData=data[mid];</span><br><span class="line">        <span class="keyword">if</span>(midData==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((mid&gt;<span class="number">0</span>&amp;&amp;data[mid<span class="number">-1</span>]!=k)||mid==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midData&gt;k)</span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getFirst(data,start,end,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=start+((end-start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> midData=data[mid];</span><br><span class="line">        <span class="keyword">if</span>(midData==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((mid&lt;data.size()<span class="number">-1</span>&amp;&amp;data[mid+<span class="number">1</span>]!=k)||mid==data.size()<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midData&lt;k)</span><br><span class="line">            start=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> getLast(data,start,end,k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="53-2：0-n-1中缺失的数字"><a href="#53-2：0-n-1中缺失的数字" class="headerlink" title="53_2：0~n-1中缺失的数字"></a>53_2：0~n-1中缺失的数字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMissingNumber</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[middle] != middle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(middle == <span class="number">0</span> || numbers[middle - <span class="number">1</span>] == middle - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == length)</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    <span class="comment">// 无效的输入，比如数组不是按要求排序的，</span></span><br><span class="line">    <span class="comment">// 或者有数字不在0到n-1范围之内</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="54、二叉搜索树的第k大节点"><a href="#54、二叉搜索树的第k大节点" class="headerlink" title="54、二叉搜索树的第k大节点"></a>54、二叉搜索树的第k大节点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Inorder</span><span class="params">(TreeNode* root,<span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        TreeNode* target=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            target=Inorder(root-&gt;left,k);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                    target=root;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!target)</span><br><span class="line">                target=Inorder(root-&gt;right,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>||!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Inorder(pRoot,k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="55、二叉树的深度"><a href="#55、二叉树的深度" class="headerlink" title="55、二叉树的深度"></a>55、二叉树的深度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> (left&gt;right)?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">判断是否是平衡二叉树：</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> JudgeBalanced(pRoot,depth);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">JudgeBalanced</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp; depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            depth=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">        <span class="keyword">if</span>(JudgeBalanced(root-&gt;left,left)&amp;&amp;JudgeBalanced(root-&gt;right,right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> diff=left-right;</span><br><span class="line">            <span class="keyword">if</span>(diff&lt;=<span class="number">1</span>&amp;&amp;diff&gt;=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth=(left&gt;right)?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="56-1：数组中只出现一次的两个数字"><a href="#56-1：数组中只出现一次的两个数字" class="headerlink" title="56_1：数组中只出现一次的两个数字"></a>56_1：数组中只出现一次的两个数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> ORResult=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:data)</span><br><span class="line">            ORResult=ORResult^i;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(ORResult&amp;n))</span><br><span class="line">            n=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        *num1=*num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;n)</span><br><span class="line">                *num1^=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2^=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="56-2：数组中唯一只出现一次的数字，其他数字出现三次"><a href="#56-2：数组中唯一只出现一次的数字，其他数字出现三次" class="headerlink" title="56_2：数组中唯一只出现一次的数字，其他数字出现三次"></a>56_2：数组中唯一只出现一次的数字，其他数字出现三次</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNumberAppearingOnce</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitSum[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = numbers[i] &amp; bitMask;</span><br><span class="line">            <span class="keyword">if</span>(bit != <span class="number">0</span>)</span><br><span class="line">                bitSum[j] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            bitMask = bitMask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="57-1、和为s的两个数字"><a href="#57-1、和为s的两个数字" class="headerlink" title="57_1、和为s的两个数字"></a>57_1、和为s的两个数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> data=<span class="built_in">array</span>[left];</span><br><span class="line">            <span class="keyword">while</span>(data+<span class="built_in">array</span>[right]&gt;sum)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">if</span>(data+<span class="built_in">array</span>[right]==sum)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(data);</span><br><span class="line">                res.push_back(<span class="built_in">array</span>[right]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="57-2、和为s的连续正数序列"><a href="#57-2、和为s的连续正数序列" class="headerlink" title="57_2、和为s的连续正数序列"></a>57_2、和为s的连续正数序列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">1</span>,last=begin+<span class="number">1</span>,finish=(sum&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum=begin+last;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;finish)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum==sum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;=last;i++)</span><br><span class="line">                    temp.push_back(i);</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                last++;</span><br><span class="line">                curSum+=last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&gt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                curSum-=begin;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&lt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                last++;</span><br><span class="line">                curSum+=last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="58-1、翻转单词顺序"><a href="#58-1、翻转单词顺序" class="headerlink" title="58_1、翻转单词顺序"></a>58_1、翻转单词顺序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        ReverseString(str,<span class="number">0</span>,str.size()<span class="number">-1</span>);<span class="comment">//总体逆序</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ReverseString(str,j,i<span class="number">-1</span>);</span><br><span class="line">                j=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==str.size()<span class="number">-1</span>)</span><br><span class="line">                ReverseString(str,j,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="built_in">string</span> &amp; str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c=str[start];</span><br><span class="line">            str[start]=str[end];</span><br><span class="line">            str[end]=c;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="58-2：左旋转字符串"><a href="#58-2：左旋转字符串" class="headerlink" title="58_2：左旋转字符串"></a>58_2：左旋转字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReverseString方法与上题相同</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.size()!=<span class="number">0</span>&amp;&amp;n&gt;str.size())</span><br><span class="line">            n=n%str.size();</span><br><span class="line">        <span class="keyword">if</span>(str.size()&lt;=<span class="number">0</span>||n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        ReverseString(str,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        ReverseString(str,n,str.size()<span class="number">-1</span>);</span><br><span class="line">        ReverseString(str,<span class="number">0</span>,str.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="59-1、滑动窗口的最大值"><a href="#59-1、滑动窗口的最大值" class="headerlink" title="59_1、滑动窗口的最大值"></a>59_1、滑动窗口的最大值</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(num.size()&lt;=<span class="number">0</span>||size==<span class="number">0</span>||size&gt;num.size())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> maxIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;num[maxIndex])</span><br><span class="line">                maxIndex=i;</span><br><span class="line">        res.push_back(num[maxIndex]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num.size()-size+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxIndex&lt;i)</span><br><span class="line">            &#123;</span><br><span class="line">                maxIndex=i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">                    <span class="keyword">if</span>(num[i+j]&gt;num[maxIndex])</span><br><span class="line">                        maxIndex=i+j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(maxIndex&gt;=i&amp;&amp;num[i+size<span class="number">-1</span>]&gt;=num[maxIndex])</span><br><span class="line">                maxIndex=i+size<span class="number">-1</span>;</span><br><span class="line">            res.push_back(num[maxIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="60、n个骰子的点数"><a href="#60、n个骰子的点数" class="headerlink" title="60、n个骰子的点数"></a>60、n个骰子的点数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbability_Solution2</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pProbabilities[<span class="number">2</span>];</span><br><span class="line">    pProbabilities[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">    pProbabilities[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_maxValue * number + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pProbabilities[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        pProbabilities[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g_maxValue; ++i) </span><br><span class="line">        pProbabilities[flag][i] = <span class="number">1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= number; ++k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= g_maxValue * k; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= g_maxValue; ++j) </span><br><span class="line">                pProbabilities[<span class="number">1</span> - flag][i] += pProbabilities[flag][i - j];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> total = <span class="built_in">pow</span>((<span class="keyword">double</span>)g_maxValue, number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = number; i &lt;= g_maxValue * number; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)pProbabilities[flag][i] / total;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %e\n"</span>, i, ratio);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="61、扑克牌中的顺子"><a href="#61、扑克牌中的顺子" class="headerlink" title="61、扑克牌中的顺子"></a>61、扑克牌中的顺子</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size()!=<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(numbers.begin(),numbers.end());</span><br><span class="line">        <span class="keyword">int</span> zeroCnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ZeroNeededCnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;numbers[i]==numbers[i<span class="number">-1</span>]&amp;&amp;numbers[i]!=<span class="number">0</span>)<span class="comment">//有对子</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==<span class="number">0</span>)</span><br><span class="line">                zeroCnt++;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;numbers[i<span class="number">-1</span>]!=<span class="number">0</span>&amp;&amp;numbers[i]-numbers[i<span class="number">-1</span>]&gt;<span class="number">1</span>)<span class="comment">//计算需要用大小王代替的个数</span></span><br><span class="line">                ZeroNeededCnt+=numbers[i]-numbers[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zeroCnt&gt;=ZeroNeededCnt)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="62、圆圈中最后剩下的数字（约瑟夫环）"><a href="#62、圆圈中最后剩下的数字（约瑟夫环）" class="headerlink" title="62、圆圈中最后剩下的数字（约瑟夫环）"></a>62、圆圈中最后剩下的数字（约瑟夫环）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典环状链表解决</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            numbers.push_back(i);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator cur=numbers.begin();</span><br><span class="line">        <span class="keyword">while</span>(numbers.size()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cur++;</span><br><span class="line"><span class="keyword">if</span> (cur == numbers.end())</span><br><span class="line">cur = numbers.begin();</span><br><span class="line">&#125;</span><br><span class="line">cur = numbers.erase(cur);</span><br><span class="line"><span class="keyword">if</span> (cur == numbers.end())</span><br><span class="line">cur = numbers.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *cur;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运用数学的解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            last=(last+m)%i;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="63、股票的最大利润"><a href="#63、股票的最大利润" class="headerlink" title="63、股票的最大利润"></a>63、股票的最大利润</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxDiff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">unsigned</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> &amp;&amp; length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxDiff = numbers[<span class="number">1</span>] - min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i - <span class="number">1</span>] &lt; min)</span><br><span class="line">            min = numbers[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentDiff = numbers[i] - min;</span><br><span class="line">        <span class="keyword">if</span>(currentDiff &gt; maxDiff)</span><br><span class="line">            maxDiff = currentDiff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="64、求1-2-3-……-n"><a href="#64、求1-2-3-……-n" class="headerlink" title="64、求1+2+3+……+n"></a>64、求1+2+3+……+n</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=n;</span><br><span class="line">        sum&amp;&amp;(sum+=Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="65、不用加减乘除做加法"><a href="#65、不用加减乘除做加法" class="headerlink" title="65、不用加减乘除做加法"></a>65、不用加减乘除做加法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum,carry;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=num1^num2;</span><br><span class="line">            carry=(num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1=sum;</span><br><span class="line">            num2=carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="66、构建乘积数组"><a href="#66、构建乘积数组" class="headerlink" title="66、构建乘积数组"></a>66、构建乘积数组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">        <span class="keyword">if</span>(A.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> B;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)</span><br><span class="line">            B.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C(A.size(),<span class="number">1</span>),D(A.size(),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i]=C[i<span class="number">-1</span>]*A[i<span class="number">-1</span>];</span><br><span class="line">            D[D.size()<span class="number">-1</span>-i]=D[D.size()-i]*A[A.size()-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.size();i++)</span><br><span class="line">            B[i]=C[i]*D[i];</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="67、字符串转换成数字"><a href="#67、字符串转换成数字" class="headerlink" title="67、字符串转换成数字"></a>67、字符串转换成数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inputStatus=inputInvalid;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> minus=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'+'</span>)</span><br><span class="line">            str=str.substr(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            minus=<span class="literal">true</span>;</span><br><span class="line">            str=str.substr(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num=StrToInt(str,minus);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span>&amp; str,<span class="keyword">bool</span> minus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                num=num*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                inputStatus=inputInvalid;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((!minus&amp;&amp;num&gt;<span class="number">0x7fffffff</span>)||(minus&amp;&amp;num&lt;(<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minus)</span><br><span class="line">            num=<span class="number">0</span>-num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Status&#123;inputInvalid=<span class="number">0</span>,inputValid&#125;;<span class="comment">//记录输入是否有错</span></span><br><span class="line">    <span class="keyword">int</span> inputStatus=inputValid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="68、二叉树公共父节点"><a href="#68、二叉树公共父节点" class="headerlink" title="68、二叉树公共父节点"></a>68、二叉树公共父节点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetNodePath</span><span class="params">(TreeNode* root, TreeNode* node, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; path)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == node)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">path.push_back(root);</span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!found&amp;&amp;root-&gt;left)</span><br><span class="line">found = GetNodePath(root-&gt;left, node, path);</span><br><span class="line"><span class="keyword">if</span> (!found&amp;&amp;root-&gt;right)</span><br><span class="line">found = GetNodePath(root-&gt;right, node, path);</span><br><span class="line"><span class="keyword">if</span> (!found)</span><br><span class="line">path.pop_back();</span><br><span class="line"><span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNode</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;path1, <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;path2)</span></span>&#123;</span><br><span class="line">TreeNode *last = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; path1.size() &amp;&amp; j &lt; path2.size())&#123;</span><br><span class="line"><span class="keyword">if</span> (path1[i] == path2[j])</span><br><span class="line">last = path1[i];</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四个string函数"><a href="#四个string函数" class="headerlink" title="四个string函数"></a>四个string函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(str != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str)</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(str1 != <span class="literal">NULL</span>&amp;&amp;str2 != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str1 &amp;&amp; !(ret=*str1-*str2))</span><br><span class="line">&#123;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strcat</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span> * strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *add = strDest;</span><br><span class="line">assert((strDest != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span> (*strDest)</span><br><span class="line">strDest++;</span><br><span class="line"><span class="keyword">while</span> (*strDest++ = *strSrc++);</span><br><span class="line"><span class="comment">//*strDest = '\0';</span></span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *strDes, <span class="keyword">const</span> <span class="keyword">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert((strDes != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">char</span> *add = strDes;</span><br><span class="line"><span class="keyword">while</span> (*strSrc)</span><br><span class="line">&#123;</span><br><span class="line">*strDes = *strSrc;</span><br><span class="line">strDes++;</span><br><span class="line">strSrc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四个图算法"><a href="#四个图算法" class="headerlink" title="四个图算法"></a>四个图算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迪杰斯特拉算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DJS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis, <span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(dis.size(), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestDis(dis.size(), INT_MAX);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(dis.size(),<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (dis[v0][i] &lt; INT_MAX)&#123;</span><br><span class="line">shortestDis[i] = dis[v0][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shortestDis[v0] = <span class="number">0</span>;</span><br><span class="line">visited[v0] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="comment">// 主循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0)&#123;</span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; dis.size(); w++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line"><span class="keyword">if</span> (shortestDis[w]&lt;min)&#123;</span><br><span class="line">v = w;</span><br><span class="line">min = shortestDis[w];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visited[v] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; dis.size(); w++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[w] &amp;&amp; dis[v][w] != INT_MAX&amp;&amp; min + dis[v][w] &lt; shortestDis[w])</span><br><span class="line">&#123;</span><br><span class="line">shortestDis[w] = min + dis[v][w];</span><br><span class="line">path[w] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0)&#123;</span><br><span class="line"><span class="keyword">if</span> (shortestDis[i] == INT_MAX)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v0 &lt;&lt; <span class="string">"to"</span> &lt;&lt; i &lt;&lt; <span class="string">": no path"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v0 &lt;&lt; <span class="string">"to"</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span> &lt;&lt; shortestDis[i] &lt;&lt; <span class="string">" path:0 "</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="keyword">while</span> (j != <span class="number">-1</span>)&#123;</span><br><span class="line">p.push_back(j);</span><br><span class="line">j = path[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!p.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p[p.size() - <span class="number">1</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">p.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis2 = &#123;</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">11</span> &#125;,</span><br><span class="line">&#123; <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span> &#125;,</span><br><span class="line">&#123;<span class="number">3</span>, INT_MAX, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//弗洛伊德 ，其实 动规</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_FLOYD</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = dis2.size();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>));<span class="comment">//path[i][j]表示从i到j的最短路径之前的一个端点，-1表示两点直连</span></span><br><span class="line"><span class="comment">//dp[i][j][k]存的是从j到k中间顶点序号不超过i-1的最短路径</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">dp[<span class="number">0</span>][i][j] = dis2[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">//动规求解，递推公式如下</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t = dp[i - <span class="number">1</span>][j][i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][i - <span class="number">1</span>][k];</span><br><span class="line">dp[i][j][k] = dp[i - <span class="number">1</span>][j][k] &gt; t ? t : dp[i - <span class="number">1</span>][j][k];</span><br><span class="line"><span class="keyword">if</span> (t &lt; dp[i - <span class="number">1</span>][j][k])</span><br><span class="line">&#123;</span><br><span class="line">path[j][k] = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"shortest distance: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"path: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; path[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis3= &#123;</span><br><span class="line">&#123; INT_MAX,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,INT_MAX,INT_MAX &#125;,</span><br><span class="line">&#123; <span class="number">6</span>,INT_MAX,<span class="number">5</span>,INT_MAX,<span class="number">3</span>,INT_MAX&#125;,</span><br><span class="line">&#123; <span class="number">1</span>,<span class="number">5</span>,INT_MAX,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;,</span><br><span class="line">&#123; <span class="number">5</span>,INT_MAX,<span class="number">5</span>,INT_MAX,INT_MAX,<span class="number">2</span> &#125;,</span><br><span class="line">&#123; INT_MAX,<span class="number">3</span>,<span class="number">6</span>,INT_MAX,INT_MAX,<span class="number">6</span> &#125;,</span><br><span class="line">&#123; INT_MAX,INT_MAX,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,INT_MAX &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普里姆算法的时间复杂度 邻接矩阵：v2  邻接表：elogv，边数多选择普里姆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_PRIM</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis,<span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line"><span class="comment">// 初始化辅助数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; closeEdge(dis.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0)&#123;</span><br><span class="line">closeEdge[i][<span class="number">0</span>] = v0;</span><br><span class="line">closeEdge[i][<span class="number">1</span>] = dis3[v0][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closeEdge[v0][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//0表示节点v0被放入S集合中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0)&#123;</span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.size(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (closeEdge[j][<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; closeEdge[j][<span class="number">1</span>] &lt; min)&#123;</span><br><span class="line">min = closeEdge[j][<span class="number">1</span>];</span><br><span class="line">index = closeEdge[j][<span class="number">0</span>];</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; index&lt;&lt;<span class="string">" to "</span>&lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">closeEdge[k][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.size(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (closeEdge[j][<span class="number">1</span>] &gt; dis[k][j])</span><br><span class="line">&#123;</span><br><span class="line">closeEdge[j][<span class="number">0</span>] = k;</span><br><span class="line">closeEdge[j][<span class="number">1</span>] = dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//克鲁斯卡尔，对边按照权重排序，eloge，边数少选择这个</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_KRUSKAL</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis)</span></span>&#123;</span><br><span class="line"><span class="comment">//边初始化并按边长排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; dis.size(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (dis[i][j] != INT_MAX)&#123;</span><br><span class="line">Edge t = &#123; dis[i][j], i, j &#125;;</span><br><span class="line">edges.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(edges.begin(), edges.end(), [](Edge&amp; e1, Edge&amp; e2)&#123;</span><br><span class="line"><span class="keyword">return</span> e1.weight &lt; e2.weight;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化集合，同一个集合中的数字代表是最小值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father(dis.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)</span><br><span class="line">father[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (father[edges[i].start] != father[edges[i].end])&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"get edge: "</span> &lt;&lt; edges[i].start &lt;&lt; <span class="string">" to "</span> &lt;&lt; edges[i].end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//合并集合</span></span><br><span class="line"><span class="keyword">int</span> min = father[edges[i].start] &gt; father[edges[i].end] ? father[edges[i].end] : father[edges[i].start];</span><br><span class="line"><span class="keyword">int</span> max = father[edges[i].start] &lt; father[edges[i].end] ? father[edges[i].end] : father[edges[i].start];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (father[i] == max)&#123;</span><br><span class="line">father[i] = min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用排序算法总结"><a href="#常用排序算法总结" class="headerlink" title="常用排序算法总结"></a>常用排序算法总结</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i]&gt;A[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t=A[i];</span><br><span class="line">                    A[i]=A[j];</span><br><span class="line">                    A[j]=t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[k]&gt;A[j])</span><br><span class="line">                    k=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t=A[i];</span><br><span class="line">            A[i]=A[k];</span><br><span class="line">            A[k]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//插入排序：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//寻找插入点</span></span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i]&gt;=A[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入</span></span><br><span class="line">            <span class="keyword">int</span> t=A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&gt;j+<span class="number">1</span>;k--)</span><br><span class="line">                A[k]=A[k<span class="number">-1</span>];</span><br><span class="line">            A[j+<span class="number">1</span>]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//归并：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        mergeSortCore(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSortCore</span><span class="params">(<span class="keyword">int</span>* &amp;A,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(endIndex==startIndex)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid=startIndex+((endIndex-startIndex)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//分别处理左右，分治</span></span><br><span class="line">        mergeSortCore(A,startIndex,mid);</span><br><span class="line">        mergeSortCore(A,mid+<span class="number">1</span>,endIndex);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        Merge(A,startIndex,mid,endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* &amp;A,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> rbegin=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=left;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=mid&amp;&amp;rbegin&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[left]&lt;=A[rbegin])</span><br><span class="line">                temp[i++]=A[left++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[i++]=A[rbegin++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rbegin&lt;=right)</span><br><span class="line">            temp[i++]=A[rbegin++];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=mid)</span><br><span class="line">            temp[i++]=A[left++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            A[l+j] = temp[j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//快速排序：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(!A)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        quickSort(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* &amp;A,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index=Partition(A,start,end);</span><br><span class="line">        <span class="keyword">if</span>(index&gt;start)</span><br><span class="line">            quickSort(A,start,index<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;end)</span><br><span class="line">            quickSort(A,index+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* &amp;A,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=start+((end-start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index=A[mid]&lt;A[start]?(A[mid]&lt;A[end]?mid:end):(A[start]&lt;A[end]?start:end);</span><br><span class="line">        swap(A[index],A[start]);</span><br><span class="line">        <span class="keyword">int</span> p=A[start];</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从后往前找到第一个比p小的数字，说明该交换了</span></span><br><span class="line">            <span class="keyword">while</span>(start&lt;end&amp;&amp;A[end]&gt;=p)</span><br><span class="line">                end--;</span><br><span class="line">            A[start]=A[end];</span><br><span class="line">            <span class="comment">//从前往后找到第一个比p大的数字</span></span><br><span class="line">            <span class="keyword">while</span>(start&lt;end&amp;&amp;A[start]&lt;=p)</span><br><span class="line">                start++;</span><br><span class="line">            A[end]=A[start];</span><br><span class="line">        &#125;</span><br><span class="line">        A[start]=p;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">//构造最大堆</span></span><br><span class="line">        make_heap(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//堆排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=A[<span class="number">0</span>];</span><br><span class="line">            A[<span class="number">0</span>]=A[i];</span><br><span class="line">            A[i]=t;</span><br><span class="line">            make_heap(A,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//构造大根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span> start ,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index=i;</span><br><span class="line">            <span class="keyword">int</span> parentIndex=(i<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//父节点下标</span></span><br><span class="line">            <span class="keyword">while</span>(index<span class="number">-1</span>&gt;=<span class="number">0</span>)<span class="comment">//向上调整，直到头结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[parentIndex]&lt;A[index])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t=A[parentIndex];</span><br><span class="line">                    A[parentIndex]=A[index];</span><br><span class="line">                    A[index]=t;</span><br><span class="line">                    index=parentIndex;</span><br><span class="line">                    parentIndex=(parentIndex<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//希尔排序：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(!A|| n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> inc = n/<span class="number">2</span>;inc&gt;<span class="number">0</span>;inc = inc/<span class="number">2</span>)&#123;<span class="comment">//inc是步伐长度</span></span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=inc;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(index-inc&gt;=<span class="number">0</span>&amp;&amp;A[index]&lt;A[index-inc])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> t=A[index];</span><br><span class="line">                        A[index]=A[index-inc];</span><br><span class="line">                        A[index-inc]=t;</span><br><span class="line">                        index-=inc;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、编写赋值运算符&quot;&gt;&lt;a href=&quot;#1、编写赋值运算符&quot; class=&quot;headerlink&quot; title=&quot;1、编写赋值运算符&quot;&gt;&lt;/a&gt;1、编写赋值运算符&lt;/h1&gt;&lt;p&gt;四点：返回值、参数类型、释放已有内存、自身赋值特殊情况。&lt;br&gt;进阶：异常安全性。&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CMyString&amp;amp; CMyString::&lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CMyString&amp;amp; rhs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;!=&amp;amp;rhs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		CMyString temp(rhs);&lt;span class=&quot;comment&quot;&gt;//调用copy构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* ptemp=temp.m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		temp.m_pData=m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		m_pData=ptemp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>初次见面</title>
    <link href="http://yoursite.com/2018/05/22/My-First-Post/"/>
    <id>http://yoursite.com/2018/05/22/My-First-Post/</id>
    <published>2018-05-22T14:18:52.000Z</published>
    <updated>2018-05-31T02:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018年5月22日，晴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年5月22日，晴。&lt;/p&gt;

      
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
