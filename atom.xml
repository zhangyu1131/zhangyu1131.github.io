<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZRainy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-24T15:42:47.422Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZRainy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基金训练营笔记</title>
    <link href="http://yoursite.com/2019/09/16/%E5%9F%BA%E9%87%91%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/16/基金训练营笔记/</id>
    <published>2019-09-16T14:01:29.000Z</published>
    <updated>2019-09-24T15:42:47.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇笔记记录关于基金的一些学习笔记。</p><a id="more"></a><h1 id="2019-09-16"><a href="#2019-09-16" class="headerlink" title="2019/09/16"></a>2019/09/16</h1><h2 id="什么是基金"><a href="#什么是基金" class="headerlink" title="什么是基金"></a>什么是基金</h2><p>证券市场的基金指的是，由一家基金公司收集很多投资者的钱，汇聚在一起，按照一定规则，进行各种各样投资以获取收益的一种投资品。而通过投资获得的收益或者遭到的风险，则由投资人按投资比例共享或者共担。</p><p>简单概括就是——集合投资、收益共享、风险共担。</p><h2 id="基金优势"><a href="#基金优势" class="headerlink" title="基金优势"></a>基金优势</h2><ol><li>起手金额少；</li><li>有效地分散风险；</li><li>有专业的基金经理帮忙打理。</li></ol><h2 id="基金风险"><a href="#基金风险" class="headerlink" title="基金风险"></a>基金风险</h2><ol><li>不同基金的风险不同，同一只基金的风险，可能比债券高，但是比股票低，最主要的影响因素是基金投资产品的种类，基金投资产品的风险越高，这只基金的风险也就越高。所以基金的风险不能同一而论，只有最适合自己的基金才是好基金。</li><li>基金的资金量大小、基金经理的能力，也会影响基金的风险程度。</li></ol><h1 id="2019-09-17"><a href="#2019-09-17" class="headerlink" title="2019/09/17"></a>2019/09/17</h1><p>是不是闭着眼买基金都能赚？当然不是。</p><h2 id="基金分类"><a href="#基金分类" class="headerlink" title="基金分类"></a>基金分类</h2><p>基金可以按以下四个维度进行分类：</p><ol><li>按投资品种分；</li><li>按交易渠道分；</li><li>按运作方式分；</li><li>按投资方式分。</li></ol><h3 id="按投资品种分"><a href="#按投资品种分" class="headerlink" title="按投资品种分"></a>按投资品种分</h3><ol><li>货币基金</li><li>债券基金</li><li>股票基金</li><li>混合基金。</li></ol><h4 id="货币基金和债券基金"><a href="#货币基金和债券基金" class="headerlink" title="货币基金和债券基金"></a>货币基金和债券基金</h4><p>货币基金和债券基金放的都是国债、政府债、公司债等债券，但是债券基金中债券占比要达到80%以上，且是长期债券，其他比例还可以投股票，而货币基金中投资债券的占比没有要求，除了投资债券（1年以内），它还可以投资银行定期存款等其他收益比较稳定的有价证券。</p><p>货币基金更加安全，收益大概在3%~4%。</p><p>债券基金的收益大概在6%~7%。</p><h4 id="股票基金和混合基金"><a href="#股票基金和混合基金" class="headerlink" title="股票基金和混合基金"></a>股票基金和混合基金</h4><p>股票基金中至少80%是股票，20%是其他。</p><p>混合基金则既有股票又有债券，没有规定的占比。基金经理可以通过调整股票和债券的投资占比，实现收益与风险之间的平衡。</p><p>两种基金的收益大概15%~20%，甚至更高，但风险也比货币基金和债券基金大多了。</p><h3 id="按交易渠道分"><a href="#按交易渠道分" class="headerlink" title="按交易渠道分"></a>按交易渠道分</h3><ol><li>场内基金。</li><li>场外基金。</li></ol><h4 id="场内基金"><a href="#场内基金" class="headerlink" title="场内基金"></a>场内基金</h4><p>有股票账户，在证券交易市场内交易，和你交易的对象是其他的买卖家。</p><p>场内基金的价格是实时变化的。</p><h4 id="场外基金"><a href="#场外基金" class="headerlink" title="场外基金"></a>场外基金</h4><p>是在证券交易场外购买的基金，交易的对象是基金公司。</p><p>场外基金的价格每天以下午三点为分界线。</p><h3 id="按运作方式分"><a href="#按运作方式分" class="headerlink" title="按运作方式分"></a>按运作方式分</h3><ol><li>开放式基金</li><li>封闭式基金</li></ol><h4 id="开放式基金"><a href="#开放式基金" class="headerlink" title="开放式基金"></a>开放式基金</h4><p>开放式基金的资金是不固定的，可以随时买入或者卖出，份额可以增加或减少。</p><h4 id="封闭式基金"><a href="#封闭式基金" class="headerlink" title="封闭式基金"></a>封闭式基金</h4><p>在成立后的一段时间内份额是不变的，投资者只能在场内进行买卖。</p><h3 id="按投资方式分"><a href="#按投资方式分" class="headerlink" title="按投资方式分"></a>按投资方式分</h3><ol><li>主动型基金</li><li>被动型基金</li></ol><h4 id="主动型基金"><a href="#主动型基金" class="headerlink" title="主动型基金"></a>主动型基金</h4><p>基金经理拿了我们的钱来替我们投资，投资哪家的股票、哪家的债券，都由基金经理说了算，主动出击，寻求超越平均水平的超值回报。</p><p>相比较被动型基金来说，主动型基金非常依赖基金经理的能力，基金经理个人能力的好坏直接决定基金业绩，收益可能优于市场平均收益，也有可能低于平均收益。</p><h4 id="被动型基金"><a href="#被动型基金" class="headerlink" title="被动型基金"></a>被动型基金</h4><p>又叫指数基金，是说经理不主动寻求超越时长的表现，一般选取特定的股票作为投资的对象，视图复制整个市场的平均收益率。</p><h3 id="余额宝是什么？"><a href="#余额宝是什么？" class="headerlink" title="余额宝是什么？"></a>余额宝是什么？</h3><p>余额宝是货币基金，也是场外基金，也是开放式基金，并不矛盾，只是分类标准不同。</p><h2 id="基金招募说明书"><a href="#基金招募说明书" class="headerlink" title="基金招募说明书"></a>基金招募说明书</h2><p>是基金发行方提供给投资者关于基金说明的法律文件，很重要。</p><p>但是基金招募书太长了，堪比博士论文，没必要全部看完。</p><p>五分钟看懂基金招募书：</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol><li>巨潮资讯网，在基金公告下的搜索框中输入基金代码或名称，公告类别选择招募设立，很好找。</li><li>基金官网</li><li>上海或者深圳交易所</li></ol><h4 id="我买的是什么"><a href="#我买的是什么" class="headerlink" title="我买的是什么"></a>我买的是什么</h4><p>通过这一问，可以快速判断基金大概的风险程度。</p><p>找到基金募集这一章，可以看到是什么类型的基金。</p><h4 id="我的钱交给谁"><a href="#我的钱交给谁" class="headerlink" title="我的钱交给谁"></a>我的钱交给谁</h4><p>通过这一问，可以放心是否把资金交给他们大理。</p><p>找到基金管理人这一章，查看基金公司和基金经理。找到基金公司，搜索下过去是否有黑历史，无论是何种违规操作，都可以把它拉黑。</p><p>再看下基金经理，主要看他的从业时间，一般来说要3年以上的比较靠谱。至于基金经理的业绩水平后面再看。</p><h4 id="我的钱用在哪"><a href="#我的钱用在哪" class="headerlink" title="我的钱用在哪"></a>我的钱用在哪</h4><p>这一问可以帮助我们进一步指导这只基金的风险程度。</p><p>找到基金投资这一章，来看看消费的投资范围。</p><h1 id="2019-09-18"><a href="#2019-09-18" class="headerlink" title="2019/09/18"></a>2019/09/18</h1><h2 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h2><p>货币基金可以和信用卡一起使用来赚点小羊毛。</p><h3 id="如何筛选"><a href="#如何筛选" class="headerlink" title="如何筛选"></a>如何筛选</h3><p>有以下四点指标：</p><h4 id="成立时间"><a href="#成立时间" class="headerlink" title="成立时间"></a>成立时间</h4><p>货币基金的成立时间一般选3~5年以上的比较好，因为太年轻的基金没有历史收益率等数据作为参考，隐藏的风险相比较于老牌货币基金更大。</p><h4 id="基金规模"><a href="#基金规模" class="headerlink" title="基金规模"></a>基金规模</h4><p>货币基金的规模越大，意味着基金中的钱越多，有更充足的资金应对赎回，因为资金问题无法正常运转而被清盘的风险也会比较低。</p><p>一般在20亿~2000亿之间的规模比较好。太大也会降低收益，因为钱多了，但又要控制风险，可选择的投资品就变少了。</p><h4 id="流动性"><a href="#流动性" class="headerlink" title="流动性"></a>流动性</h4><p>流动性是指我们卖出后资金多久能回到我们的账上。</p><p>一般有T+0和T+1两种交割方式。</p><h4 id="收益率"><a href="#收益率" class="headerlink" title="收益率"></a>收益率</h4><p>货币基金的收益情况可以通过“每万份收益”和“7日年化”两个指标判断。</p><p>每万份收益：就是指按上一日或上一个交易日的收益率，一万块能够赚多少钱。</p><p>7日年化则是指，根据过去7天的收益总和，计算出的年化收益率。</p><p>一般来说，货币基金的万份收益在1左右，7日年化在3%左右。</p><p>货币基金主要是为了流动性，收益率都差不多，2%~3%左右，不会有太多区别，不用太在意收益率。</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>上天天基金网。</p><p>货币基金特点：流动性高、风险低、收益稳定。</p><p>主要用来存3~6个月间需要用到的钱。</p><h2 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h2><p>独有优势：由专业的基金经理和团队帮你投资，省心又省力；个人投资者资金有限，直接参与债券市场，会受到一些限制；个人投资者很难做到分散投资，降低风险。</p><p>债券基金的收益大概会在5%~6%左右。</p><p>五大指标：成立年限（3年~5年以上）、收益率（选高一些的）、规模（5~100亿）、费率（挑低的）以及基金经理是否频繁更换（最少半年）。</p><p>也是去天天基金网看。</p><p>可以用半年到一年都用不到的钱来买债券基金。</p><h1 id="2019-09-19"><a href="#2019-09-19" class="headerlink" title="2019/09/19"></a>2019/09/19</h1><h2 id="混合基金"><a href="#混合基金" class="headerlink" title="混合基金"></a>混合基金</h2><p>混合基金七大指标：</p><ol><li>基金规模</li><li>成立时间</li><li>收益率</li><li>手续费</li><li>基金公司的盈利能力</li><li>基金经理的更换频率</li><li>基金经理的选股择时能力</li></ol><p>其中五个相同的都和债券基金相似，规模在2亿~100亿之间。</p><p>基金公司的盈利能力：一是看他在同类基金公司中的排名，要选排名靠前的；二是看他的盈利是否跑赢沪深300指数（大致能代表大盘走势），如果能跑赢就好了。</p><p>基金经理的选股择时能力，主要作为排除指标，考察四个指标：从业情况（大于三年）、评分（高于50）、星级（越高越好，三星以下可以排除）和管理的经济收益排名（没有跑赢同类平均水平的也可以排除）。</p><p>去天天基金网熟悉熟悉操作。</p><h2 id="股票基金"><a href="#股票基金" class="headerlink" title="股票基金"></a>股票基金</h2><p>混合型基金可以随时调整股票的投资比例，而股票基金中股票占比必须80%以上。</p><p>七个指标和混合基金相同，筛选步骤也大致相同，多熟悉操作吧。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>在熊市里表现很烂，但牛市里表现强于大盘的基金要慎重。</li><li>ETF表示交易型开放式指数基金，是开放式基金的一种特殊类型，综合了开放式和封闭式基金的优点。</li></ol><h1 id="2019-09-21"><a href="#2019-09-21" class="headerlink" title="2019/09/21"></a>2019/09/21</h1><p>主动型基金，就是基金经理拿了我们的钱来替我们投资，具体可以看小白营笔记。</p><p>被动型基金，就是经理不主动寻求超越市场的表现，它的风险和收益不依赖基金经理，是由整个市场决定的。</p><p>长期来看，相比较主动型基金，被动型基金的收益更高更稳定。</p><h2 id="指数是什么"><a href="#指数是什么" class="headerlink" title="指数是什么"></a>指数是什么</h2><p>指数其实就是一个选股规则。它按照某个规则挑选出一篮子股票，由专业机构经过复杂的计算，得出一个代表这篮子股票的平均价格，然后用来反映市场上这一类股票的价格水平。</p><p>这个平均价格称为“指数点位”，把放在篮子里的这些股票称为这只指数的成份股。</p><p>指数的成份股是可以变化的，一旦某只股票不能满足原先的规则，就会被替换掉。</p><h2 id="A股是什么"><a href="#A股是什么" class="headerlink" title="A股是什么"></a>A股是什么</h2><p>A股可以简单地理解成中国大陆的股票市场。</p><p>除了A股之外，还有中国香港的港股，除了国内的股票市场外，还有美股，国内大部分公司选择在A股上市，但也有选择去香港或者美国上市的，比如腾讯和阿里。</p><h2 id="A股市场主要指数"><a href="#A股市场主要指数" class="headerlink" title="A股市场主要指数"></a>A股市场主要指数</h2><ol><li>上证50指数，主要是龙头。</li><li>沪深300指数，市值排名前300的上市公司。</li><li>中证500指数，市值排名前800名去掉前300的沪深300后留下的500个，代表中小型上市公司的平均水平。</li><li>创业板指数，100家小型企业，深证开发。</li><li>红利指数，是上证交易所上市的现金股息率高、分红比较稳定、具有一定规模及流动性的50只股票，是上证A股中真正的核心优质资源，上证开发。</li></ol><h2 id="其他市场主要指数"><a href="#其他市场主要指数" class="headerlink" title="其他市场主要指数"></a>其他市场主要指数</h2><p>美股：标普500（相当于沪深300），纳斯达克指数。</p><p>港股：恒生指数（港股上市公司50家，相当于上证50，是港股最重要的指数），H股指数（挑选了香港上市的、规模最大的33家大陆企业）。</p><h2 id="QDII基金"><a href="#QDII基金" class="headerlink" title="QDII基金"></a>QDII基金</h2><p>QDII又称为合格的境内投资者，简单的理解，就是我们可以用人民币投资海外股票市场，可以有效规避人民贬值风险。</p><h2 id="指数基金"><a href="#指数基金" class="headerlink" title="指数基金"></a>指数基金</h2><p>有点：灭绝人性、永垂不朽以及笑到最后。</p><h3 id="灭绝人性"><a href="#灭绝人性" class="headerlink" title="灭绝人性"></a>灭绝人性</h3><p>主动型基金最大的风险之一就是老鼠仓，也叫老鼠吃猫，是指无量的基金经理靠内幕消息帮自己赚钱。</p><p>指数基金是被动型基金，不用管基金经理的决策，可谓灭绝人性。</p><h3 id="永垂不朽"><a href="#永垂不朽" class="headerlink" title="永垂不朽"></a>永垂不朽</h3><p>铁打的指数，流水的公司。</p><p>就算有指数中几家公司倒闭了，也会有新公司补充进来。</p><h3 id="笑到最后"><a href="#笑到最后" class="headerlink" title="笑到最后"></a>笑到最后</h3><p>股市有一个”七亏二平一盈“的魔咒。</p><p>投资指数基金，是通过投资指数成份股，来获得和市场持平的收益。长期看来，只要经济是持续向好的，指数基金就有投资的价值。</p><h2 id="指数基金的风险"><a href="#指数基金的风险" class="headerlink" title="指数基金的风险"></a>指数基金的风险</h2><p>指数基金本质是股票型基金，它依然存在风险。</p><p>虽然指数基金是复制和跟踪指数，来调整篮子里面的股票组合。但是基金经理如果复制得有偏差，或者没有及时跟着指数调整，也会带来收益方面的误差风险。</p><p>指数基金的规模小，或者运作历史不长的话，也会有风险。</p><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>分级基金是把母基金分成A份额和B份额，进行不同的投资，是比较复杂的基金类型。</p><p>基金在发行前购买是认购，发行后购买是申购。</p><h1 id="2019-09-22"><a href="#2019-09-22" class="headerlink" title="2019/09/22"></a>2019/09/22</h1><h2 id="指数基金分类"><a href="#指数基金分类" class="headerlink" title="指数基金分类"></a>指数基金分类</h2><p>有的指数基金在挑选股票的时候并不限制所在的行业，它覆盖了各方各业，就是属于宽基指数基金，比如沪深300、上证50等。</p><p>有的指数基金在挑选股票的时候，会要求只投资某个行业的股票，这就是行业指数基金，比如上证消费80、中证医疗指数。</p><p>宽基指数基金的最大优势是覆盖的行业更多更广，分配更均匀，所以盈利也就更稳健。</p><p>而行业指数基金就需要考虑整个行业的发展特点，受行业影响大，风险高一些。</p><p>按复制方式分，指数基金可以分为完全复制型指数基金和增强型指数基金。</p><p>完全复制型指数基金指的是完全复制目标指数所包含的所有成份股，追求和指数持平的收益。</p><p>增强型指数基金就是除了复制目标指数外，基金经理还加入自己的一些主管投资，追超超过跟踪指数的收益。</p><p>综上，完全复制型宽基指数基金比较好。</p><h2 id="选基三部曲"><a href="#选基三部曲" class="headerlink" title="选基三部曲"></a>选基三部曲</h2><h3 id="确定想要投资的指数"><a href="#确定想要投资的指数" class="headerlink" title="确定想要投资的指数"></a>确定想要投资的指数</h3><p>选择指数基金的本质就是选择指数。</p><h3 id="竞选靠谱的基金公司"><a href="#竞选靠谱的基金公司" class="headerlink" title="竞选靠谱的基金公司"></a>竞选靠谱的基金公司</h3><p>基金公司的实力，对指数基金的表现有至关重要的作用。</p><p>公司规模是一个重要的衡量标准，目前国内一般资金规模超过1000亿的基金公司实力都不可小觑，低于1000亿的就暂时不要考虑。</p><h3 id="锁定指数基金"><a href="#锁定指数基金" class="headerlink" title="锁定指数基金"></a>锁定指数基金</h3><p>筛选指标有四个：跟踪误差率、基金规模、成立年限、费用成本。</p><h4 id="跟踪误差率"><a href="#跟踪误差率" class="headerlink" title="跟踪误差率"></a>跟踪误差率</h4><p>这个指标要低于同行平均水平，而且越低越好，低表示基金运作水平高。</p><h4 id="基金规模-1"><a href="#基金规模-1" class="headerlink" title="基金规模"></a>基金规模</h4><p>越大越好，规模越大，流动性越强。流动性是指能否顺利地卖出或者买入。不要低于2亿。</p><h4 id="成立年限"><a href="#成立年限" class="headerlink" title="成立年限"></a>成立年限</h4><p>超过三年的。</p><h4 id="费用成本"><a href="#费用成本" class="headerlink" title="费用成本"></a>费用成本</h4><p>越低越好。</p><p>基金的费用包括管理费、托管费、申购费和赎回费。</p><p>大部分在2%~3%，相对来说场内基金的管理费或交易费都远低于场外基金。</p><h2 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h2><p>天天基金网。这节课主要讲的是怎么买，下节会将如何找到买入的好时机。</p><h2 id="指数基金何时买"><a href="#指数基金何时买" class="headerlink" title="指数基金何时买"></a>指数基金何时买</h2><h3 id="大盘点数"><a href="#大盘点数" class="headerlink" title="大盘点数"></a>大盘点数</h3><p>一般的大盘点数指的是上证综合指数的点数，靠大盘点数决定入场时间是不靠谱的。</p><h3 id="市盈率和市净率"><a href="#市盈率和市净率" class="headerlink" title="市盈率和市净率"></a>市盈率和市净率</h3><p>市盈率（PE）：等于公司市值/净利润，指的是一笔钱投资进一只股票，需要多长时间能够回本。简单理解就是与一只股票的盈利能力相比，目前它的价格是不是够便宜。</p><p>可以通过市盈率初步判断一家公司是贵还是便宜，市盈率越低，公司越便宜，反之同理，但不同作为唯一指标。</p><p>PE作为估值指标，简单粗暴、快速有效是它的一大优点，但也有明显的缺陷。不同的国家地区、不同的指数，估值的波动区间不一样。</p><p>单靠市盈率也是不靠谱的。</p><p>市净率（PB），等于市值/净资产，体现的是公司的净资产是否被低估。市净率高，公司是高估。但紧靠它也不靠谱。</p><h3 id="长投温度"><a href="#长投温度" class="headerlink" title="长投温度"></a>长投温度</h3><p>长投温度经过了市场的验证，是个非常靠谱的估值指标。</p><p>温度越高，说明股市越火爆，风险越大，上涨的空间越小，反之同理。</p><p>0~10度之间：股市萎靡不振，股市韩东，但是是最佳的买入时机。</p><p>10~20度：初春绽放，股市开始回暖，仍是买入的良机。</p><p>20~30：春暖花开，可以继续买。</p><p>30~40：市场气氛热烈，可继续持有，但需提防风险。</p><p>40~50：高温预警，可考虑逐步卖出。</p><p>……</p><p>大于90：人间地狱。</p><p>长投温度=（PE温度+PB温度）/2</p><p>长投温度的高低与价格高低没有必然的联系。</p><p>长投温度的高低反映的是在历史中，低于当前估值出现的概率。</p><h3 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h3><p>理杏仁官网。</p><p>公众号直接看吧。</p><h1 id="2019-9-23"><a href="#2019-9-23" class="headerlink" title="2019/9/23"></a>2019/9/23</h1><h2 id="基金投资方式"><a href="#基金投资方式" class="headerlink" title="基金投资方式"></a>基金投资方式</h2><ol><li>一次性投资，简单省事，无脑操作，缺点也很明显，一次性投完了以后遇到合适的时机就没钱投了，不靠谱。</li><li>不定期投资，择时投资，找到合适时机才下手，缺点是很容易受到主观情绪的极大干扰，理论上拥有不错的选股择时能力时，确实可以自由选择买卖时间，但绝大多数人都做不到。</li><li>定期定额，固定时间投资固定金额，一般人用这种。</li><li>定期不定额，固定时间，金额不固定，根据估值调整金额，这才是最佳方式。</li></ol><h2 id="定投的好处"><a href="#定投的好处" class="headerlink" title="定投的好处"></a>定投的好处</h2><ol><li>强制储蓄、告别月光，也可以给自己实现资金增值。</li><li>避免主观情绪干扰，只要用了有效的定投策略，坚持定投，就能获得合力的投资收益。</li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>设置定投日提醒，定期不定额需要手动，所以设个闹钟；</li><li>千万不要在定投过程中加入自己的主观判断；</li><li>投资收益投入再利用。</li></ol><h1 id="2019-9-24"><a href="#2019-9-24" class="headerlink" title="2019/9/24"></a>2019/9/24</h1><p>指数基金怎么买？简投法四步走。</p><h2 id="第一步，确定每个月的投资金额"><a href="#第一步，确定每个月的投资金额" class="headerlink" title="第一步，确定每个月的投资金额"></a>第一步，确定每个月的投资金额</h2><h3 id="有投资目标时，每月投资金额的计算"><a href="#有投资目标时，每月投资金额的计算" class="headerlink" title="有投资目标时，每月投资金额的计算"></a>有投资目标时，每月投资金额的计算</h3><p>公式：<code>PMT(r/12,n*12,,FV,1)</code></p><p>r是预期收益率，n是投资年限，FV=预期收益+本金，算出来的钱是负数，代表支出。</p><h3 id="没有投资目标时，每月投资金额的计算"><a href="#没有投资目标时，每月投资金额的计算" class="headerlink" title="没有投资目标时，每月投资金额的计算"></a>没有投资目标时，每月投资金额的计算</h3><ul><li>首先，确定自己的存量金额</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">存款-应急金（3~6个月基本日常支出，平时放在货币基金）=总存量资金</span><br><span class="line"></span><br><span class="line">总存量资金/20个月 = 每个月的存量资金</span><br></pre></td></tr></table></figure><ul><li>然后，确定每月的增量资金</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工资-日常基本开支-保险/12 = 每月增量资金</span><br></pre></td></tr></table></figure><ul><li>最后，确定自己的风险系数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 - 年龄 = 风险系数%</span><br></pre></td></tr></table></figure><p>风险系数也就是高风险资产投资比例。</p><p>如果想对保守，可以把100换成80。</p><ul><li>算每月投资金额</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（每月存量资金+每月增量资金）* 风险系数 = 每月投资金额</span><br></pre></td></tr></table></figure><h2 id="第二步，如何选择指数基金"><a href="#第二步，如何选择指数基金" class="headerlink" title="第二步，如何选择指数基金"></a>第二步，如何选择指数基金</h2><p>长投温度</p><h3 id="第三步，根据长投温度进行定投"><a href="#第三步，根据长投温度进行定投" class="headerlink" title="第三步，根据长投温度进行定投"></a>第三步，根据长投温度进行定投</h3><p>买入时：</p><table><thead><tr><th style="text-align:center">长投温度</th><th style="text-align:center">投资占每月投资金额的比例</th></tr></thead><tbody><tr><td style="text-align:center">[0,10)</td><td style="text-align:center">100%</td></tr><tr><td style="text-align:center">[10,20)</td><td style="text-align:center">80%</td></tr><tr><td style="text-align:center">[20,25)</td><td style="text-align:center">60%</td></tr><tr><td style="text-align:center">[25,30)</td><td style="text-align:center">50%</td></tr><tr><td style="text-align:center">[30,40)</td><td style="text-align:center">停止投资，持有</td></tr></tbody></table><p>卖出时：</p><table><thead><tr><th style="text-align:center">长投温度</th><th style="text-align:center">卖出现有基金份额的比例</th></tr></thead><tbody><tr><td style="text-align:center">[40,50)</td><td style="text-align:center">50%</td></tr><tr><td style="text-align:center">[50,100]</td><td style="text-align:center">全卖了</td></tr></tbody></table><h3 id="第四步，指数切换"><a href="#第四步，指数切换" class="headerlink" title="第四步，指数切换"></a>第四步，指数切换</h3><p>出现另一只指数的长投温度低于当前指数2度以上的时候，我们就要迅速把这只指数对应的基金揽入怀中，重复第三步的买入策略。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>获利之后可以把钱先存在货币基金里，耐心等待温度降低，再出现投资机会时，再将这些钱当做存量资金，按照四步走重新开始一轮新的投资。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇笔记记录关于基金的一些学习笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="大杂烩" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="理财投资" scheme="http://yoursite.com/tags/%E7%90%86%E8%B4%A2%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>五险一金课程</title>
    <link href="http://yoursite.com/2019/09/12/%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91%E8%AF%BE%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/12/五险一金课程/</id>
    <published>2019-09-12T14:08:32.000Z</published>
    <updated>2019-09-12T15:49:59.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>小白训练营的课程结束了，但是投资理财的学习之路不能停止，再进一步学习之前，我决定先把每天签到领到的五险一金课程看一遍，本篇文章就是看学习该课程所做的笔记。</p><a id="more"></a><p>最基本的，五险一金指的是养老保险、医疗保险、生育保险、工伤保险、失业保险以及住房公积金。</p><h1 id="养老保险"><a href="#养老保险" class="headerlink" title="养老保险"></a>养老保险</h1><p>养老保险是社保的组成部分之一，顾名思义，养老保险的目标就是为了解决养老问题。</p><p>养老保险钱从哪里来？很简单，由个人和公司共同缴纳。</p><p>按照2019年上海的规定，养老保险个人缴纳工资的8%，公司缴纳工资的16%。</p><p>有些公司为了降低人力成本，会把员工的工资分为基本工资和奖金两部分，这样缴纳养老保险的基数就会变少，公司交的也就少了。</p><p>这些缴纳的钱，个人缴纳的部分会进入个人账户，这个钱就是你的。而公司缴纳的部分会进入统筹账户，这个账户的钱是统筹安排的。按照国家规定，只要缴纳养老保险15年，就可以再退休后领到退休金啦。如果没有缴纳满15年，那就只能领回个人缴纳的部分，也就是三分之一。</p><p>退休后能领到多少养老金呢？</p><p>公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">养老金 = 基础养老金 + 个人账户养老金</span><br><span class="line">基础养老金 = （全省上年度在岗职工月平均工资 + 本人指数化月平均缴费工资）/ 2 * 缴费年限 * 1%</span><br><span class="line">个人账户养老金 = 个人账户储蓄额 / 养老金计发月数</span><br></pre></td></tr></table></figure><p>上面的信息有不知道的可以询问当地社保局。</p><p>换工作不换城市的话养老保险可以转移回老家，但如果换城市的话只有个人账户可以全部转移，单位缴纳的部分不可以转移（这……emmm……）。</p><h1 id="医疗险"><a href="#医疗险" class="headerlink" title="医疗险"></a>医疗险</h1><p>医疗险是为了补偿疾病所带来医疗费用的一种保险。</p><p>同样是公司和个人各交一部分，公司交10%，个人交2%，个人部分全部进入医保卡，单位部分有1%左右进入医保卡，剩下的9%左右进入统筹医疗账户。</p><p>个人账户就是医保卡内的钱，可以用来在定点药店买药，支付门诊费用和住院费用中个人自付的部分；而统筹账户就要由医保中心统一管理了，只有发生符合当地医保报销的费用时才能由统筹账户支付。</p><p>如果得了大病，又能报销多少呢？</p><p>一般来说，平时去医院门诊治疗住院，报销的范畴分为三个部分：起付标准下的自付部分、医疗统筹报销和大病报销。</p><p>简单来说，住院治疗所产生的费用要报销分三种情况：</p><ol><li>医药费没有达到报销的标准，就不能报销了；</li><li>达到了报销标准，按照基本医疗报销标准直接给你报销；</li><li>已经按标准报销了，但是数额特别巨大，报销后还剩一个“大窟窿”，这个时候剩下的大窟窿才能按大病保险报销。</li></ol><h2 id="停缴"><a href="#停缴" class="headerlink" title="停缴"></a>停缴</h2><p>连续两个月没有按时足额缴纳医保，就会被暂停医疗保险待遇，需要及时补足余额及缴纳滞纳金；如果连续三个月及以上没按时足额缴纳医保，虽然账户里的余额不会被清零，但是连续缴纳年限会被清零，补缴之后要重新计算缴纳年限。</p><p>当然如果离职了短期不找新工作，可以把社保缴纳在社保局的个人流动窗口，但这种社保一般只包括养老和医疗两个险种；也可以选择当地的社保代缴公司办理挂靠业务。</p><h2 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h2><p>异地社保转移需要先问清楚社保接受地是否接受，如果可以接受的话，需要在转出地的社保缴纳中心打印自己的社保缴费证明。</p><p>具体手续比养老保险转移简单。</p><h2 id="退休"><a href="#退休" class="headerlink" title="退休"></a>退休</h2><p>职工医保需要缴满一定的年限，才能在退休后享受终身医疗保险待遇。</p><h2 id="异地"><a href="#异地" class="headerlink" title="异地"></a>异地</h2><p>截止到2018年，我国基本实现全国社保一卡通。</p><p>异地就医主要针对4类人群：</p><ol><li>异地安置退休人员；</li><li>异地长期居住人员；</li><li>常驻异地工作人员；</li><li>异地转诊人员。</li></ol><h1 id="生育险"><a href="#生育险" class="headerlink" title="生育险"></a>生育险</h1><p>生育险是和生孩子相关的险种。</p><p>标准定义：生育保险是国家通过立法，在怀孕和分娩的妇女劳动者暂时中断劳动时，由国家和社会提供医疗服务、生育津贴和产假的一种社会保险制度，国家或社会对生育的职工给予必要的经济补偿和医疗保健的社会保险制度。</p><p>生育险主要提供三部分内容：生育津贴、医疗服务和产假。</p><p><code>生育津贴的领取金额 = 企业当月平均缴纳工资金额 / 30 * 产假天数</code></p><p>虽然男性不能直接使用生育险，但如果老婆有工作的话，老公可以享受10日的护理假津贴。如果老婆没有工作没有生育保险，就可以使用老公的生育保险享受生育保险50%的待遇。</p><p>生育险全部由公司缴纳，不需要自己交钱，比例一般在0.5%~1%。</p><h1 id="工伤险"><a href="#工伤险" class="headerlink" title="工伤险"></a>工伤险</h1><p>工伤保险，也称职业伤害保险，是指劳动者在工作中或在规定的特殊情况下，遭受意外伤害或患职业病导致暂时或永久丧失劳动能力以及死亡时，劳动者或其遗属从国家和社会获得物质帮助的一种社会保险制度。</p><p>工伤的界定有严格要求的，具体再看，要记得一点，在非上下班时间上下班途中发生事故，不能算作工伤。</p><p>所以，不要加班！</p><p>工伤保险的钱是由企业或雇主按照国家规定的费率缴纳的，劳动者个人不用缴纳任何费用。</p><h1 id="失业险"><a href="#失业险" class="headerlink" title="失业险"></a>失业险</h1><p>失业保险的作用是那些因失业而暂时中断生活来源的人提供经济帮助、以保障基本生活得以维持。</p><p>失业保险申请条件：</p><ol><li>非本人意愿中断就业；</li><li>按规定缴纳失业保险满1年以上；</li><li>已办理失业登记，并且有求职要求。</li></ol><p>失业保险是由用人单位、个人缴费几国家财政补贴来共同支撑，我们每个月工资会有一部分被强制缴纳失业保险，同时公司也会再缴一部分。</p><p>个人和用人单位各缴0.5%。</p><h1 id="公积金"><a href="#公积金" class="headerlink" title="公积金"></a>公积金</h1><p>定义就不看了，这个还是知道一点的，主要是和房子相关的。</p><p>住房公积金由个人和单位按照同等比例统共缴纳，单位和隔热缴纳的部分全部进入个人账户。</p><p>如果打算全款买房，可以取公积金抵扣房款，不用白不用。</p><p>如果贷款买房，能用公积金贷款就用公积金贷款。</p><p>如果不买房，建造/翻修/大修住房也可以用，租房也可以用，符合低保或特困救助范围的伙伴可以用，治疗家庭成员重大疾病也可以用。</p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;小白训练营的课程结束了，但是投资理财的学习之路不能停止，再进一步学习之前，我决定先把每天签到领到的五险一金课程看一遍，本篇文章就是看学习该课程所做的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="大杂烩" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="理财投资" scheme="http://yoursite.com/tags/%E7%90%86%E8%B4%A2%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>leveldb源码学习1-slice</title>
    <link href="http://yoursite.com/2019/09/03/leveldb%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A01-slice/"/>
    <id>http://yoursite.com/2019/09/03/leveldb源码学习1-slice/</id>
    <published>2019-09-03T15:04:40.000Z</published>
    <updated>2019-09-03T15:06:46.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>长那么大还没看过开源项目源码，说出去太菜了，所以一直想找个C++开源项目学习一下。正好前阵子公司项目里用到了RocksDB，了解到它是leveldb的升级版，而且两个开源项目都是C++开发的，于是心动了。</p><p>本来想看RocksDB的，但看了下相比leveldb它升级了很多东西，源码多了很多，编译出来的静态库足有几百兆……所以退缩了，决定先看基础班leveldb，后面有机会再去了解RocksDB。</p><a id="more"></a><p>然而，看了几天leveldb……也好难啊……慢慢啃……</p><p>对于我这个没看过源码不知道阅读源码方法的本菜鸡来说，最好第一个阅读的项目能找到足够的解析文档来帮助学习。谷歌之后从网上找了阿里一位大佬写的《leveldb实现解析》，据说是分析leveldb比较好的文章，于是我也决定借助这篇文档来学习，希望也能学学如何看一个庞大的项目源码。</p><p>这是本次levedb系列学习的第一篇笔记，希望能坚持看完。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Slice（include-leveldb-slice-h）"><a href="#Slice（include-leveldb-slice-h）" class="headerlink" title="Slice（include/leveldb/slice.h）"></a>Slice（include/leveldb/slice.h）</h2><p>这其实就是leveldb中的string类。</p><p>leveldb没有使用<code>std::string</code>，不记得在哪看过，好像Google内部C++项目里都不使用标准库的string，而都是用slice类来代替，不知道是真是假。</p><p>slice.h其实就是字符串简单的封装，可以直接操控指针避免不必要的数据拷贝。</p><p>Note：感觉面试里让手写一个string类就可以参考这个，不过复制构造函数用的是default，尴尬了。</p><p>整体代码并不长，而且一目了然，陈列如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Slice</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create an empty slice.</span></span><br><span class="line">  Slice() : data_(<span class="string">""</span>), size_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to d[0,n-1].</span></span><br><span class="line">  Slice(<span class="keyword">const</span> <span class="keyword">char</span>* d, <span class="keyword">size_t</span> n) : data_(d), size_(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to the contents of "s"</span></span><br><span class="line">  Slice(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s) : data_(s.data()), size_(s.size()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a slice that refers to s[0,strlen(s)-1]</span></span><br><span class="line">  Slice(<span class="keyword">const</span> <span class="keyword">char</span>* s) : data_(s), size_(<span class="built_in">strlen</span>(s)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Intentionally copyable.</span></span><br><span class="line">  Slice(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Slice&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Slice&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a pointer to the beginning of the referenced data</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the length (in bytes) of the referenced data</span></span><br><span class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true iff the length of the referenced data is zero</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the ith byte in the referenced data.</span></span><br><span class="line">  <span class="comment">// REQUIRES: n &lt; size()</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</span><br><span class="line">    assert(n &lt; size());</span><br><span class="line">    <span class="keyword">return</span> data_[n];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change this slice to refer to an empty array</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data_ = <span class="string">""</span>;</span><br><span class="line">    size_ = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop the first "n" bytes from this slice.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    assert(n &lt;= size());</span><br><span class="line">    data_ += n;</span><br><span class="line">    size_ -= n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a string that contains the copy of the referenced data.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(data_, size_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Three-way comparison.  Returns value:</span></span><br><span class="line">  <span class="comment">//   &lt;  0 iff "*this" &lt;  "b",</span></span><br><span class="line">  <span class="comment">//   == 0 iff "*this" == "b",</span></span><br><span class="line">  <span class="comment">//   &gt;  0 iff "*this" &gt;  "b"</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true iff "x" is a prefix of "*this"</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="keyword">const</span> Slice&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">  <span class="keyword">size_t</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> ((x.size() == y.size()) &amp;&amp;</span><br><span class="line">          (<span class="built_in">memcmp</span>(x.data(), y.data(), x.size()) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123; <span class="keyword">return</span> !(x == y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Slice::compare(<span class="keyword">const</span> Slice&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_ &lt; b.size_)</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_)</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该文件本身没有什么值得说道的地方，唯一可以注意一下的是重载运算符<code>!=</code>方法的实现方法是调用重载运算符<code>==</code>，这种实现方式还是很多的，比如后缀<code>++</code>的实现中一般会调用前缀<code>++</code>的函数，然后解引用运算符<code>*</code>和下表运算符<code>[]</code>好像也用了类似的实现方法，不太记得了，可以看下stl实现里面。</p><p>接下来说一下该文件里类声明中包含的<code>LEVELDB_EXPORT</code>，该字段是一个宏，定义不在本文件中，而是在<code>include/leveldb/export.h</code>中，该文件内容如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STORAGE_LEVELDB_INCLUDE_EXPORT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORAGE_LEVELDB_INCLUDE_EXPORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(LEVELDB_EXPORT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LEVELDB_SHARED_LIBRARY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEVELDB_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEVELDB_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// defined(LEVELDB_COMPILE_LIBRARY)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LEVELDB_COMPILE_LIBRARY)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEVELDB_EXPORT __attribute__((visibility(<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">// defined(LEVELDB_SHARED_LIBRARY)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEVELDB_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// !defined(LEVELDB_EXPORT)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_INCLUDE_EXPORT_H_</span></span></span><br></pre></td></tr></table></figure></p><p>说实话看到这玩意我是真的晕了，虽然大致能明白意思，但看的还是很难受，宏定义真的又强大又麻烦。到这里又不得不说谷歌C++规范里提到的在<code>#endif</code>或者右括号<code>}</code>后面跟上对应的注释实在是太必要了，比如上面代码里就在<code>#else</code>和<code>#endif</code>后面添加了必要的注释，提高可读性（同样是不记得在哪里见过，预处理宏定义命令都建议顶格写，可能是因为这个原因所以这里没有缩进）。</p><p>其实还是第一次见到类似<code>#if defined</code>的写法，以前最多见过<code>#ifdef</code>，于是查了下资料，发现其实这两者很相似，唯一区别在于<code>#ifdef</code>是<code>#if defined</code>的缩写形式，前者只能判断单个宏是否定义，而后者可以组成更加复杂的预编译条件。</p><p>比如<code>#if defined(DEBUG) &amp;&amp; VERSION&gt;3</code>，而用<code>#ifdef</code>必须这么写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VERSION&gt;3</span></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>好了，解决了一些基本问题，可以来看最重要的有关<code>LEVELDB_EXPORT</code>的那几行。</p><p>这里涉及到几个之前没有接触过的函数，包括<code>__declspec(dllexport)</code>、<code>__declspec(dllimport)</code>以及<code>__attribute__((visibility(&quot;default&quot;)))</code>，接下来一一进行简单解释。</p><table><thead><tr><th>函数</th><th>用处</th></tr></thead><tbody><tr><td>__declspec(dllexport)</td><td>将一个函数声明为导出函数，可以省掉在DEF文件中手工定义导出哪些函数。当然如果DLL里都是C++的类的话，就只能导出类。</td></tr><tr><td>__declspec(dllimport)</td><td>相反，就是将一个函数声明为导入函数，是从其他动态库里引入的函数。一般情况下不使用该函数也能正确编译，但使用该函数可以使编译器生成更好的代码。不过当类中有静态变量的时候，必须要引入该函数，否则会报错。</td></tr><tr><td><strong>attribute</strong>((visibility(“default”)))</td><td>控制共享文件导出符号，<code>default</code>表示用它修饰的符号将被导出，动态库中的函数默认是可见的。<code>hidden</code>则意味不可见。其中gcc的visibility是说，如果编译的时候用了这个属性，那么动态库的符号都是hidden的，除非强制声明。</td></tr></tbody></table><p>综上，主要是为了一些导出符号考虑，暂时先了解一下，感觉就是为了让其他模块能够使用slice类吧，深层次的东西咱也不了解，知道就行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;长那么大还没看过开源项目源码，说出去太菜了，所以一直想找个C++开源项目学习一下。正好前阵子公司项目里用到了RocksDB，了解到它是leveldb的升级版，而且两个开源项目都是C++开发的，于是心动了。&lt;/p&gt;
&lt;p&gt;本来想看RocksDB的，但看了下相比leveldb它升级了很多东西，源码多了很多，编译出来的静态库足有几百兆……所以退缩了，决定先看基础班leveldb，后面有机会再去了解RocksDB。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="leveldb" scheme="http://yoursite.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>理财小白训练营笔记</title>
    <link href="http://yoursite.com/2019/09/01/%E7%90%86%E8%B4%A2%E5%B0%8F%E7%99%BD%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/01/理财小白训练营笔记/</id>
    <published>2019-09-01T08:14:26.000Z</published>
    <updated>2019-09-10T15:19:49.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>从去年在网易实习后半段开始我就陆续开始阅读理财投资方面的入门书籍，主要是《穷爸爸富爸爸》、《小狗钱钱》以及《财务自由之路》这三本书，感觉打开了新世界的大门，遂下决心也要抽空培养一下自己的“财商”，希望未来有一天也能实现被动赚钱（说财务自由太夸张了哈哈~但也要有点梦想~）</p><p>转眼毕业上班两个月了，越发觉得要整理下自己的资产，于是最近开始看《财务自由之路》第二遍。</p><a id="more"></a><p>上周正好看到一个9块钱14天的长投小白训练营课程，想着9块钱而已，报一下看看有没有收获，于是便报名参加了课程，每天可以在线上得到一些基础知识的分享，也能解答一些疑惑。目前看来还是有收获的，9块钱感觉很值。</p><p>本着学而不思则罔的原则，便决定用这篇笔记来记录一下这个9块钱课程的一些笔记，这里只记录本人觉得9块钱课程中重要的一些点，三本书里面的观点知识还请有兴趣的小伙伴自行阅读，当然课程和书籍中所谈及的内容是有不少重合的~</p><h1 id="20190827"><a href="#20190827" class="headerlink" title="20190827"></a>20190827</h1><h2 id="时间的金钱价值"><a href="#时间的金钱价值" class="headerlink" title="时间的金钱价值"></a>时间的金钱价值</h2><ul><li>每个人的时间是最宝贵的，你的时间是最有价值的。</li><li>时间大于金钱。尽量花时间去武装大脑，而不是为了节约开支而浪费大把时间。</li><li>理财的第一个思维，重视时间成本。</li></ul><h2 id="金钱的时间价值"><a href="#金钱的时间价值" class="headerlink" title="金钱的时间价值"></a>金钱的时间价值</h2><ul><li>金钱的时间价值，就是指当前所持有的一定数量的货币，比未来同等数量的货币具有更高的购买力，就是通货膨胀。</li><li>对于不同的人而言，金钱的时间价值是不同的，这取决于他们利用这笔钱的预期投资回报率。如果预期投资回报率低于通货膨胀，那肯定花钱啊，不花就亏了，但如果预期投资回报率高于通货膨胀，就可以牺牲即时消费而选择投资。</li><li>通货膨胀是最大的风险。</li></ul><h2 id="学习的时间成本"><a href="#学习的时间成本" class="headerlink" title="学习的时间成本"></a>学习的时间成本</h2><ul><li>人生前期越嫌麻烦，越懒得学，后面就越可能错过好的风景（所以蔡康永那句话还是有道理的）。</li></ul><h1 id="20190828"><a href="#20190828" class="headerlink" title="20190828"></a>20190828</h1><h2 id="两种思维"><a href="#两种思维" class="headerlink" title="两种思维"></a>两种思维</h2><ul><li>不是先有财再去理，而是先理才有财。</li><li>有负债也可以理财，不要妄想等到还清债务再去理，那你将永远还不清。</li><li>负债看消费，盈利靠理财。</li></ul><h2 id="资产与负债"><a href="#资产与负债" class="headerlink" title="资产与负债"></a>资产与负债</h2><ul><li>资产就是能把钱放进你口袋里的东西，它能不断给你带来收入。</li><li>相反，负债就是把钱从你的口袋里取走的东西。</li></ul><h2 id="成为富人的秘密"><a href="#成为富人的秘密" class="headerlink" title="成为富人的秘密"></a>成为富人的秘密</h2><ul><li>富人的第一个秘密是，在一生中不断地买入资产，并且资产品种丰富，给自己带来更多收入，不单一依靠工资。</li><li>富人的第二个秘密是乐意接受新鲜的事物，并在不断增长见识的过程中，提升自己辨别事物的能力，同时结交更多的朋友，扩展自己的全资，进行良性循环。</li><li>如果现在没有这些资产又穷该咋办？1、学会省钱、记账。2、学会花钱，投资自己。</li></ul><h2 id="怎么去致富"><a href="#怎么去致富" class="headerlink" title="怎么去致富"></a>怎么去致富</h2><ul><li>投资自己，提升自己的技能，把自己的单位时间卖的更贵。</li><li>发展副业，爱好也可以带来收入。</li><li>可以将自己的一份时间卖出多次，比如公号文、写书。</li><li>让自己的资产增值，增加被动收入，缓解生活压力。</li><li>节流很重要，但开源更重要。</li><li>培养自己的赚钱能力。</li></ul><h1 id="20190829"><a href="#20190829" class="headerlink" title="20190829"></a>20190829</h1><ul><li>余额宝跑不过通货膨胀，有很大的风险。</li><li>这个世界所谓的规则，都是由头脑好的人制定出来的，他们故意做得让人很难弄明白，这样的话就能从那些不懂得或者懒得思考的人手里多捞好处。</li><li>理财的优势：1、跑赢通货膨胀。2、带来被动收入。3、避免被人挖坑。</li><li>分清“必要”、“需要”和“想要”。“必要”是不花会死的。“需要”是稍微提高质量的，比如买牛奶啥的。”想要“就是欲望。</li></ul><h2 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h2><ul><li>CPI是居民消费价格指数，定义我也看不懂，反正翻译成人话就是用一些商品价格的变动率来反映整体的物价变化情况，CPI有八大类，其中食品占比最大，34%左右。</li><li>其他通货膨胀的案例和基本解释就不写了，主要就是流通的货币过多，超过经济运行的需求，导致钱不值钱。</li></ul><h2 id="投资陷阱"><a href="#投资陷阱" class="headerlink" title="投资陷阱"></a>投资陷阱</h2><ul><li>不投资等死，乱投资找死。</li><li>沉没成本：已经发生且不可收回的支出。</li><li>防范投资骗局：1、弄清楚每个投资背后的原理，你赚谁的钱？2、要先学习再投资。3、不要相信太高的无风险投资收益率。</li></ul><h1 id="20190830"><a href="#20190830" class="headerlink" title="20190830"></a>20190830</h1><ul><li>人生的财富终值取决于你是否有投资的理念，和你的收入等有一点关系，但关系不大。</li><li>生活变故、中年危机说来就来，我们要在危机之前做好准备。</li><li>决定一个人成功与否的不是学习、不是工作、不是关系，而是思维。</li></ul><h2 id="资产配置"><a href="#资产配置" class="headerlink" title="资产配置"></a>资产配置</h2><ul><li>第一个账户：要花的钱。这是我们的日常开销账户，一般占家庭资产的10%，用来满足我们的短期消费，另外预留3~6个月的生活费作为应急金、梦想相册基金、短期内需要用的钱。这些钱一般放在银行活期存款或者货币基金（余额宝就是其中一种），使用时第一时间就能支取使用。这个账户大家都有，但容易占比过高，后果就是无财可理，月光。</li><li>第二个账户：杠杆账户，用来实现风险的管理和转移，占20%。这个账户是保险，要点是专款专用，这是保命的钱。如果没有这个账户，那我们的资产就随时面临风险。要专款专用，医保的钱就治病，不能用作其他保险。</li><li>第三个账户：投资收益账户，用来追求收益，要点是为家庭创造收益，占30%。这个账户关键在于合理的占比，既要赚的起也要亏得起。细分之下，可以将投资钱一半投资与股票或股票型基金，另一半投资风险较低的固定收益类产品。</li><li>第四个账户：保本升值的钱，也就是长期收益账户，占40%。要点是这个钱用于养老、教育，一定要保证本金不能有损失，并要抵御通货膨胀的侵蚀。重要的有三点：1、不能随意使用。2、每年每月要有固定的钱进入这个账户，积少成多。3、长期来看收益是比较稳定上升的。</li><li>商保的一个原则：双十原则。保费占到收入的10%，保额达到收入的10倍。</li></ul><h1 id="20190831"><a href="#20190831" class="headerlink" title="20190831"></a>20190831</h1><ul><li>在年轻的日子里不对自己的头脑投资，那就是对未来投降。</li><li>每年确立一个以人为师计划，把牛人的优点都长在自己身上。</li><li>一个人的愿望会深刻影响着TA的消费观。</li><li>一切节省，归根到底地都是时间的节省；一切经济，归根到底都是时间经济。——马克思牛逼。</li><li>只说消费升级就能人生升级的都是扯淡，一定要强调两者之间生产升级的重要性。</li></ul><h1 id="20190901"><a href="#20190901" class="headerlink" title="20190901"></a>20190901</h1><ul><li>复利在刚开始的时候效应是很微小的，但它呈指数型增长，等它发展到一定阶段就会产生非常惊人的效果。</li><li>复利的三个因素：本金，收益率和时间。</li><li>本金越少越要注意交易成本。</li><li>复利的方向影响：通货膨胀以及投资成本。这话主要还是为了告诉我们投资要趁早，因为不趁早的话，通货膨胀对你造成的影响就越大，同样趁早投资的话，投资成本就可以小，时间带来的收益却更多。</li><li>阻碍穷人变成富人的很大一部分原因是懒惰。</li></ul><h1 id="20190902"><a href="#20190902" class="headerlink" title="20190902"></a>20190902</h1><ul><li>五险指的是养老保险、医疗保险、工伤保险、生育保险和失业保险。</li><li>社保只是最基本的保障，虽然必不可少，但是作用十分有限。</li><li>商业保险主要包括两大类：人身保险和财产保险。</li><li>人身保险主要分为四大类：意外险、重疾险、医疗险和寿险。意外险：理赔意外伤害而导致的死亡或残疾。重疾险：补偿重大疾病带来的经济损失。医疗险：理赔在医院看病产生的医疗费用。寿险：理赔人的死亡。</li><li>在一个家庭中，首先最应该配置保险的是一个家庭的经济支柱。</li><li>买保险买的是保障，应该关注需求多于产品。保险不能保平安也不能避免风险的发生，但是它能转移风险。</li><li>买保险，财务分析不能少，找专业理财师。</li><li>保险最重要的是保障，不是投资，应该学习其他投资方式。</li><li>目前关于保险的一些错误信息：1、第一个坑：几百种重疾。主要就是重疾险并不是听它覆盖的种类越多越好的，81号文件规定了25种重疾险必须包含的25种重大疾病，其中六种就占了百分之九十左右，所以在没有条件的时候根本不需要追求25种之外的其他重大疾病种类。2、第二个坑：不可抗辩条款。说的就是不要骗保，不要身体不太好的时候才想起来买保险，要提前一些，未雨绸缪吧，保险最大的原则是诚信。</li></ul><h1 id="20190903"><a href="#20190903" class="headerlink" title="20190903"></a>20190903</h1><ul><li>对股票的两种误解：1、认为买股票就是碰运气，盲目进场乱投资。要牢记“不懂的东西不要碰”的原则。2、一想到投资股票有风险，就对股票死心了。在通货膨胀面前，不投资不仅不安全，而且还是最大的不安全因素。</li><li>股票的本质就是公司拿出部分的所有权换取资金，用于后续的经营发展。</li><li>股票赚钱有两种方式：公司分红和低买高卖。</li><li>选择高回报的投资组合，是省心又省力的好方法。</li><li>作为长期品种，股票具有很强的投资价值。</li><li>任何一次投资决策的失误都是由于投资知识的不过关导致的。</li><li>选择高回报的投资组合，是省心又省力的好方法。</li><li>估值，是整个价值投资派的核心。</li><li>不论是做何种投资，都要有自己的独立思考，不能把希望压在别人的身上。选择价值投资，需要有分析市场的能力，也需要精妙的策略，并且有持有的耐心，最终才会收获收益。</li><li>价值投资的另一个好处：通过分析，你对行业能够有更深刻的了解，从而能够找到这个行业的痛点并寻找到风口。</li><li>要给自己设个目标。</li></ul><h1 id="20190904"><a href="#20190904" class="headerlink" title="20190904"></a>20190904</h1><p>投资千变万化，但也逃脱不了五种类型。</p><ul><li>第一类投资品：中间商倒买倒卖。代表有银行信托等。原理：汇集了很多人的钱，然后再把钱借给需要钱的人，以赚取中间差额。注意点：中间人的信用，看他们把钱借给了谁，那些借钱的人能不能还的了欠的钱和利息。</li><li>第二类投资品：无中间商赚差价。代表：债券。原理：把钱借给国家、地方政府或者企业，赚取利息。关注点：借款人的信用资质，看看他们还钱的几率大不大。</li><li>第三类投资品：拥有部分资产。代表：股票。原理：人们用自己的钱买公司的部分资产，与公司共同承担风险，亏盈共享。注意点：你出钱投资的这家公司赚不赚钱。</li><li>第四类投资品：成为资产所有人。代表：黄金、期货、艺术品、房地产等。原理：靠着外部信息，通过预测未来的涨跌赚钱，与自身价值无关。注意点：哪些因素会影响价格，然后综合判断。</li><li>第五类投资品：混合型投资品。代表：银行理财、基金等。原理：它投资的不是单一的东西，里面既有股票也有债券。注意点：高低风险投资品的成分占比。</li></ul><h1 id="20190905"><a href="#20190905" class="headerlink" title="20190905"></a>20190905</h1><ul><li>基金，就是基金公司收集投资者的钱，按照证监会规定的规则，进行各种各样的投资的一种投资品。</li><li>根据投资理念的不同，基金可以分为主动基金和被动型基金。被动型基金又叫指数型基金，指数基金就是基金经理不主动寻求超越市场的表现，复制别人的整个投资，不需要你自己花太多精力来做选择。</li><li>主动型基金的两个缺点是，过于依赖基金经理，交易成本偏高。</li><li>定投就是在固定的日期，投入固定的钱。基金定投的好处是：投资门槛很低；操作非常简单；摊薄投资成本；强制储蓄资金。</li><li>货币基金是专门投资于银行间存款，债券基金是专门投资债券，股票基金就是专门投资股票的基金，通常所说的股票基金就是主动型基金。</li><li>什么是指数？指数就是一个股票的榜单，复杂一点来讲指数就是加权平均值，用来反映市场平均水平。什么是指数基金？以沪深300为例，某基金公司设置某支理财产品，根据沪深300指数按比例买入对应的股票组成基金产品，就是指数基金。巴菲特说过买指数基金就是买国运，只要相信国家经济能继续发展，指数基金就能长期上涨。指数基金的特点为：灭绝人性、长生不老、永远上涨，买指数就是买国运。定投指数基金要选择微笑曲线，从而决定何时入场。</li><li>要学会估值，根据估值来决定是否进场。过去6年时间里指数点位大部分时间都在3000点以下，超过的话大部分就会亏损了。</li></ul><h1 id="2019-09-06"><a href="#2019-09-06" class="headerlink" title="2019/09/06"></a>2019/09/06</h1><ul><li>买基金共有四种渠道：1、证券公司。2、银行。3、基金公司。4、第三方代销平台，如天天基金，蚂蚁。第一种属于场内基金，其余的都是场外基金。</li><li>场内基金的一大好处是便宜。场内基金的交易叫买卖，对手是其他交易者，按照实时价格成交，类似股票交易。场内交易不会影响基金的整体份额。</li><li>场外基金的交易叫做申购赎回，对手是基金公司，按照净值申购赎回。在每天下午3点钱申赎的，按照当天的净值成交，下午3点以后申赎的，按照第二天的净值成交。场外交易会影响基金的整体份额。场外的优势：方便，不用开股票账户，可以自动定投。</li><li>开户中的坑：1、高佣金，开户时候的佣金越便宜，交易成本就越低越划算。股票和基金的佣金不相同，股票证监会规定佣金门槛最低5元，一般不超过万三。基金的手续费相似，万三左右，但华泰证券没有最低5元佣金的限制。2、杂费，主要指经手费和监管费，又被称为规费，有的有诚意的券商会把规费包含在佣金中，有些则不会，需要问清楚。3、叠加套餐，建议不要。</li></ul><h1 id="2019-09-07"><a href="#2019-09-07" class="headerlink" title="2019/09/07"></a>2019/09/07</h1><h2 id="信用卡"><a href="#信用卡" class="headerlink" title="信用卡"></a>信用卡</h2><ul><li>什么是信用卡？信用卡是一种个人、小额、短期、无息、消费贷款工具。</li><li>信用卡首先的特点就是免息期，信用卡持卡人在一个消费周期内使用信用卡消费是免息的。信用卡有两个比较重要的日子，一是账单日，二是还款日。</li><li>信用卡的第二个特点就是高利率，每日万分之五，使用不当就成了高利贷。以下情况信用卡会变成高利贷：1、逾期未还，步步紧会产生逾期费用，而且还会对征信造成污点。2、每月只还最低还款额。这不会影响征信，但会产生大量的高额利息支出。后续想要提额也就很难。3、分期付款。</li><li>信用卡的合理使用：1、合理用好免息期，可以在记账日的后一天买。2、巧用信用额度，多元化刷卡。3、合理利用积分以及各类银行不同的活动。</li><li>信用卡使用tips：1、尽可能利用免息还款期，即采用全额还款模式。2、利用免息还款期高阶玩法，可以办理不同银行的信用卡，并错开它们的账单日。3、将信用卡的免息期和货币基金搭配使用，很多货币基金都提供信用卡还款功能。</li></ul><h2 id="韭菜"><a href="#韭菜" class="headerlink" title="韭菜"></a>韭菜</h2><ul><li>纯韭菜的选股误区：1、以名取股。要知道买股票其实就是买公司。2、投资价格低的股票。我们要看的是市值有没有低于估值，而不是看单股的价格。3、听人推荐选股。跟风是非常危险的。最起码要知道买入卖出的逻辑，知道买点和卖点。4、不清楚股票买卖点。股市是有人买有人卖才能交易，如果你挂出一个价没有人买，也是无法成交的。</li><li>我们是上市公司的消费者，我们的生活和股票是分不开的。</li><li>要扩大格局视野，找到比自己目前高一级的圈子。</li></ul><h1 id="2019-09-08"><a href="#2019-09-08" class="headerlink" title="2019/09/08"></a>2019/09/08</h1><ul><li>如果真正想做一件事，就一定要尽早地融入到行业内部圈子，更加核心或者更加前端，圈外人只有等到变化了才行动，那太慢了。</li><li>道理不是明白了就一定能做到的。投资也不是一蹴而就的。</li><li>注意投入产出比。</li><li>高收益与高风险并存。</li><li>重视风险才能笑到最后。</li></ul><h1 id="2019-09-09"><a href="#2019-09-09" class="headerlink" title="2019/09/09"></a>2019/09/09</h1><ul><li>工资的增长模式是线性的，而互联网商业的增长模式是指数的。</li><li>互联网最大的作用，就是增大了个体的链接力和影响力，和未来不可预测的想象空间。</li><li>雇佣制会退出舞台，合伙制会成为主流。</li><li>虚拟社会大于实体社会；AI人工智能大于应用技能；资本大于劳动力。</li><li>理财第一步：树立正确投资理念。理财第二步：选择正确的方法。</li><li>系统地学习初级知识，然后在这个基础上，选择自己感兴趣的，适合自己的投资方向，构建属于自己的能力圈。</li><li>投资理财的不可能三角：收益性、安全性与流动性三者往往不可兼得，最多只能占两个。</li><li>投资机会不是一直都有的。不要等到错过了才哇哇叫。多学习不同的投资品种。</li><li>破发的两个方面原因：1、发行价的每股收益基数。2、发行市赢率。</li><li>A股是面向国内发行的股票，以人民币作为结算方式。B股则是面向国外发行，主要以美元或者港币作为结算方式。</li></ul><h1 id="2019-09-10"><a href="#2019-09-10" class="headerlink" title="2019/09/10"></a>2019/09/10</h1><h2 id="国债逆回购"><a href="#国债逆回购" class="headerlink" title="国债逆回购"></a>国债逆回购</h2><ul><li>国债逆回购说白了就是借钱给企业，是一种短期贷款。它利率高的时候，就是市场缺钱的时候。</li><li>安全。低风险高收益。操作方便。手续费低。</li><li>适合新手投资初期试水。</li><li>国债逆回购一共有18种，沪深各9种。</li><li>主要买短期的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;从去年在网易实习后半段开始我就陆续开始阅读理财投资方面的入门书籍，主要是《穷爸爸富爸爸》、《小狗钱钱》以及《财务自由之路》这三本书，感觉打开了新世界的大门，遂下决心也要抽空培养一下自己的“财商”，希望未来有一天也能实现被动赚钱（说财务自由太夸张了哈哈~但也要有点梦想~）&lt;/p&gt;
&lt;p&gt;转眼毕业上班两个月了，越发觉得要整理下自己的资产，于是最近开始看《财务自由之路》第二遍。&lt;/p&gt;
    
    </summary>
    
      <category term="大杂烩" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="理财投资" scheme="http://yoursite.com/tags/%E7%90%86%E8%B4%A2%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title> 《程序员修炼之道》读书笔记 </title>
    <link href="http://yoursite.com/2019/08/19/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/19/《程序员修炼之道》读书笔记/</id>
    <published>2019-08-19T14:03:41.000Z</published>
    <updated>2019-08-19T14:05:29.064Z</updated>
    
    <content type="html"><![CDATA[<p>偶然在组里书柜里看到了这本书，听说是新人程序员的圣经，正巧自己最近也在找这种培养思维和习惯的书看，所以就打算趁闲暇看下，希望对自己有所帮助。</p><p>PS：看了几页，很多都是寓意的小故事，没法精确地摘抄某几个句子来表达思想，所以可以的话还是买本书看一看吧。</p><a id="more"></a><h1 id="第一章-注重实效的哲学"><a href="#第一章-注重实效的哲学" class="headerlink" title="第一章 注重实效的哲学"></a>第一章 注重实效的哲学</h1><p>在前言里，书里提到了两个提示，就放在这里记录一下：</p><ul><li>提示1：关心你的技艺。除非你在乎能否漂亮地开发出软件，否则其他事情都是没有意义的。</li><li>提示2：思考！你的工作。在你做某件事情的时候思考你在做什么。</li></ul><h2 id="我的源码让猫给吃了"><a href="#我的源码让猫给吃了" class="headerlink" title="我的源码让猫给吃了"></a>我的源码让猫给吃了</h2><ul><li>提示3：提供各种选择，不要找蹩脚的借口。</li><li>负责，责任是你主动担负的东西。如果你确实同意要为某个结果负责，你就应切实负起责任。</li><li>在你问问题或者说做不到之前，先停下来，在头脑里预演一遍对话，想想其他人可能会说什么，把理由说给猫听，感觉理由是否合理，否则不要麻烦别人。</li></ul><h2 id="软件的熵"><a href="#软件的熵" class="headerlink" title="软件的熵"></a>软件的熵</h2><ul><li>熵是指某个系统中无序的总量。软件中的无序增长时，程序员们称之为“软件腐烂”。</li><li>提示4：不要容忍破窗户。即不要留着低劣的设计、错误决策、糟糕的代码而不去修理。发现一个就修一个。</li><li>置之不理会更快加速腐烂的进程。</li><li>简单来说，就是大家都不会愿意做第一个弄脏东西的人，但如果东西已经有地方脏了，那就无所谓了，所有人都不会再在乎。</li></ul><h2 id="石头汤与煮青蛙"><a href="#石头汤与煮青蛙" class="headerlink" title="石头汤与煮青蛙"></a>石头汤与煮青蛙</h2><ul><li>提示5：做变化的催化剂。在有些情况下，你可能确切地知道要什么，但需要去处理整个事件的时候就会遇到拖延和冷漠，事情会变复杂，每个人都会护卫自己的资源。这时就是你拿出石头的时候，因为人们会觉得参与正在发生的成功更容易，让他们看见未来，你就能让他们狙击在你周围。</li><li>提示6：记住大图景。不要像温水煮青蛙一样，要留心大图景，要持续不断地观察周围发生的事情，而不只是你自己在做的事情。</li></ul><h2 id="足够好的软件"><a href="#足够好的软件" class="headerlink" title="足够好的软件"></a>足够好的软件</h2><ul><li>让你的用户参与权衡。</li><li>提示7：我们所制作的系统的范围和质量应该作为系统需求的一部分规定下来。今天的了不起的软件常常比明天的完美软件更可取。</li><li>不要因为过度修饰和过于求精而毁损完好的程序。</li></ul><h2 id="你的知识资产"><a href="#你的知识资产" class="headerlink" title="你的知识资产"></a>你的知识资产</h2><ul><li>提示8：定期为你的知识资产投资。要点有定期投资、多元化、管理风险、低买高卖以及重新评估和平衡。</li><li>可以设定一些目标，比如一年学一门新语言、一季度看一本技术书……</li><li>提示9：批判地分析你读到的和听到的。要抓住学习机会，要批判地思考。</li></ul><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><ul><li>知道你想要说什么，规划想要说的东西。</li><li>了解你的听众。</li><li>选择时机。</li><li>选择风格。</li><li>让文档美观，并在制作过程中让听众参与。</li><li>做倾听者。把会议变成对话。</li><li>回复他人。</li><li>提示10：你说什么和你怎么说同样重要。</li></ul><h1 id="第2章-注重实效的途径"><a href="#第2章-注重实效的途径" class="headerlink" title="第2章 注重实效的途径"></a>第2章 注重实效的途径</h1><h2 id="重复的危害"><a href="#重复的危害" class="headerlink" title="重复的危害"></a>重复的危害</h2><ul><li>提示11：DRY-Don’t Repeat Yourself。系统中的每一项知识都必须具有单一、无歧义、权威的表示。</li><li>无意的重复里提到，即使重复了也要把重复限制在局部，不要暴露给外界。</li><li>提示12：让复用变得容易。</li></ul><h2 id="正交性"><a href="#正交性" class="headerlink" title="正交性"></a>正交性</h2><ul><li>在计算机技术里，正交是指某种不依赖性或解耦性，如果两个或更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。比如在设计良好的系统中，数据库代码和用户界面就是正交的。</li><li>提示13：消除无关事物之间的影响。</li><li>编写正交的系统，可以提高生产率并降低风险。</li><li>团队划分方面的一点建议就是将基础设施与应用分离，每个主要的基础设施组件（比如数据库、通信接口、中间件等）有自己的子团队。</li></ul><h2 id="可撤销性"><a href="#可撤销性" class="headerlink" title="可撤销性"></a>可撤销性</h2><ul><li>提示14：不存在最终决策。要考虑到决策的可撤销性。</li></ul><h2 id="曳光弹"><a href="#曳光弹" class="headerlink" title="曳光弹"></a>曳光弹</h2><ul><li>提示15：用曳光弹找到目标。</li><li>总有改动需要完成，总有功能需要增加。</li><li>曳光代码有很多优点：用户能够及早看到能工作的东西；开发者构建了一个他们能在其中工作的结构；你有了一个集成平台；你有了可用于演示的东西；你将更能够感觉到工作进展。</li><li>感觉就是先搭个架子，再步步逼近。</li><li>曳光和原型编程还有区别，原型编程是生成用过就扔的代码，而曳光代码虽然简约，却是完整的（当然我并没有理解……）。可以把原型制作视为在第一发曳光弹发射之前进行的侦查和情报搜集工作。</li></ul><h2 id="原型与便笺"><a href="#原型与便笺" class="headerlink" title="原型与便笺"></a>原型与便笺</h2><ul><li>建立原型的原因是为了分析和揭示风险，并以大大降低的带来来为修正提供机会，就像是汽车制造商造的某种模型，概念图，只是为了展示某一个方面，但却不是真正能用的（这么一想感觉原型和曳光弹确实有区别好像……）。</li><li>提示16： 为了学习而制作原型。原型的设计目的地是会大一些问题，可以忽略不重要的细节，比如制作GUI原型的时候就不要在意取到的数据正确与否。原型的价值不在于所产生的代码，而在于学习的经验教训。</li><li>构建原型时，可以忽略以下细节：正确性、完整性、健壮性、风格。</li></ul><h2 id="领域语言"><a href="#领域语言" class="headerlink" title="领域语言"></a>领域语言</h2><ul><li>提示17：靠近问题领域编程。</li><li>可以通过两种不同的方式使用你实现的语言：数据语言和命令语言。</li><li>没看太明白，感觉好像说的是写一串公用的话，然后利用这段话解析成所需代码。</li></ul><h2 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h2><ul><li>提示18：估算，以避免发生意外。</li><li>建议这样估算时间，十五天内用天，八周内用周，30周内用月，超出30周的时候请努力思考一下再估算。要选择能反映你想要传达的精度的单位。</li><li>理解提问内容，建立系统的模型，把模型分解成组件，给每个参数指定值，计算答案，追踪你的估算能力</li><li>提示19：通过代码对进度表进行迭代。</li></ul><h1 id="第3章-基本工具"><a href="#第3章-基本工具" class="headerlink" title="第3章 基本工具"></a>第3章 基本工具</h1><h2 id="纯文本的威力"><a href="#纯文本的威力" class="headerlink" title="纯文本的威力"></a>纯文本的威力</h2><ul><li>提示20：用纯文本保存知识。</li><li>纯文本有两个主要缺点：1、与压缩的二进制格式相比，存储纯文本所需空间更多；2、要解释及处理纯文本文件，计算上的代价可能更昂贵。</li><li>好处：保证不过时，杠杆作用，更易于测试。</li></ul><h2 id="shell游戏"><a href="#shell游戏" class="headerlink" title="shell游戏"></a>shell游戏</h2><ul><li>提示21：利用命令shell的力量。</li></ul><h2 id="强力编辑"><a href="#强力编辑" class="headerlink" title="强力编辑"></a>强力编辑</h2><ul><li>提示22：用好一种编辑器。</li><li>编辑器特性：可配置、可扩展、可编程</li><li>用好一款编辑器可以提高生产率。</li></ul><h2 id="源码控制"><a href="#源码控制" class="headerlink" title="源码控制"></a>源码控制</h2><ul><li>提示23：总是使用源码控制。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>要接受事实：调试就是解决问题，要据此发起进攻。</li><li>提示24：要修正问题，而不是发出指责。</li><li>提示25：不要恐慌。这是调试的第一准则。</li><li>如果你目睹bug或见到bug报告时的第一反应是“那不可能”，那你就错了，不要把脑细胞浪费在以“那不可能”起头的思路上，因为已经发生了。</li><li>要总是设法找出问题的根源，而不只是问题的特定表现。</li><li>从何处开始，在解决问题时，可能需要搜集所有的相关数据，比如可能需要观察报告bug用户的操作，以获取足够程度的细节。</li><li>测试策略，一旦你认为你知道了在发生什么，就到了找出程序认为在发生什么的时候了。</li><li>开始修正bug的最佳途径是让其可再现。使数据可视化。</li><li>调试器通常会聚焦于程序现在的状态，但有时需要更多的东西——可能需要观察程序或数据结构随时间变化的状态。</li><li>橡皮鸭</li><li>bug有可能存在于第三方库——但不应该是你的第一想法。提示26：”select”没有问题。</li><li>提示27：不要假定，要证明。</li><li>当遇到令人吃惊的bug时，除了只是修正它之外，还需要确定先前为什么没有找出这个故障。考虑是否需要改进单元测试。</li><li>如果bug是一些坏数据的结果，那是否能进行更好的参数检查来隔离它们。</li><li>考虑造成这个bug的条件是否存在于系统中的其他地方。</li></ul><h2 id="文本操纵"><a href="#文本操纵" class="headerlink" title="文本操纵"></a>文本操纵</h2><ul><li>提示28：学习一种文本操纵语言，比如Perl（这两天迁移代码的时候刚遇到过）。</li></ul><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><ul><li>提示29：编写能编写代码的代码。</li><li>分为被动代码生成器以及主动代码生成器。</li><li>被动代码生成器减少敲键次数，本质上是参数化模板，结果一旦生成，就变成项目中充分的源文件。</li><li>通过主动代码生成器，可以取某项知识的一种表现形式，将其转化为你的应用需要的所有形式。</li></ul><h1 id="第4章-注重实效的偏执"><a href="#第4章-注重实效的偏执" class="headerlink" title="第4章 注重实效的偏执"></a>第4章 注重实效的偏执</h1><ul><li>提示30：你不可能写出完美的软件。</li></ul><h2 id="按合约设计"><a href="#按合约设计" class="headerlink" title="按合约设计"></a>按合约设计</h2><ul><li>什么是正确的程序？不多不少，做它声明要做的事情的程序。用文档记载这样的声明，并进行校验，是按合约设计（DBC）的核心。</li><li>提示31：通过合约进行设计。</li><li>在设计时简单地列举输入域的范围是什么、边界条件是什么、例程允诺交付什么——或者更重要的，它不允诺交付什么——是向着编写更好的软件的一次飞跃。</li><li>如果要对参数进行任何显式的检查，就必须由调用者来完成。</li></ul><h2 id="死程序不说谎"><a href="#死程序不说谎" class="headerlink" title="死程序不说谎"></a>死程序不说谎</h2><ul><li>防卫性编程。</li><li>提示32：早崩溃。要崩溃，不要破坏。有很多时候，让你的程序崩溃是你的最佳选择。</li><li>基本的原则：但给你的代码发现，某件被认为是不可能的事情已经发生时，你的程序就不再有存活能力。</li></ul><h2 id="断言式编程"><a href="#断言式编程" class="headerlink" title="断言式编程"></a>断言式编程</h2><ul><li>提示33：如果它不可能发生，用断言确保它不会发生。不过绝不要把必须执行的代码放在assert中。不要用断言代替真正的错误处理，断言检查的是绝不应该发生的事情。</li><li>海森堡虫子：调试改变了被调试系统的行为。</li></ul><h2 id="何时使用异常"><a href="#何时使用异常" class="headerlink" title="何时使用异常"></a>何时使用异常</h2><ul><li>异常很少应该作为程序的正常流程的一部分使用，异常应该保留给意外事件。</li><li>提示34：将异常用于异常的问题。</li></ul><h2 id="怎样配平资源"><a href="#怎样配平资源" class="headerlink" title="怎样配平资源"></a>怎样配平资源</h2><ul><li>提示35：要有始有终。分配资源、使用它，然后解除分配。分配资源的例程也应该负责释放它。</li><li>在嵌套的分配情况下：有两点建议，一是以与资源分配的次序相反的次序解除资源的分配。二是在代码的不同地方分配同一组资源时，总是以相同的顺序分配它们。这会降低死锁的可能性。</li></ul><h1 id="第5章-弯曲，或折断"><a href="#第5章-弯曲，或折断" class="headerlink" title="第5章 弯曲，或折断"></a>第5章 弯曲，或折断</h1><h2 id="解耦与德墨忒尔法则"><a href="#解耦与德墨忒尔法则" class="headerlink" title="解耦与德墨忒尔法则"></a>解耦与德墨忒尔法则</h2><ul><li>提示36：使模块之间的耦合减至最少。</li><li>响应集的定义：类的各个方法直接调用的函数的数目。</li><li>得墨忒尔法则：某个对象的任何方法都应该只调用属于以下情形的方法：它自身、传入该方法的任何参数、该方法内new创建的任何对象以及任何直接持有的组件对象。</li><li>事实上，如果对得墨忒尔法则进行反转，使模块紧密耦合，有时就可以获得重大的性能改进。这就需要看情况来权衡。 </li></ul><h2 id="元程序设计"><a href="#元程序设计" class="headerlink" title="元程序设计"></a>元程序设计</h2><ul><li>动态配置，提示37：要配置，不要集成。</li><li>为一般情况编写程序，把具体情况放在别处——在编译的代码库之外。提示38：把抽象放进代码，细节放进元数据。</li><li>没有元数据，你的代码就不可能获得它应有的适应性与灵活性。</li></ul><h2 id="时间耦合"><a href="#时间耦合" class="headerlink" title="时间耦合"></a>时间耦合</h2><ul><li>在设计时间要素时，有两个方面对我们很重要：并发和次序。</li><li>我们需要容许并发，并考虑解除任何时间或次序上的依赖。</li><li>提示39：分析工作流，以改善并发性。</li><li>提示40：用服务进行设计。</li><li>提示41：总是为并发进行设计。</li></ul><h2 id="它只是视图"><a href="#它只是视图" class="headerlink" title="它只是视图"></a>它只是视图</h2><ul><li>模块或类的一个好定义就是，它具有单一的、定义良好的责任。</li><li>发布/订阅模式，Model-View-Controller模式：既让模型与表示模型的GUI分离，也让模型与管理视图的控件分离。提示42：使视图与模型分离。</li><li>模型：表示目标对象的抽象数据模型。模型对任何视图或控制器都没有直接的了解</li><li>视图：解释模型的方式，它订阅模型中的变化和来自控制器的逻辑事件。</li><li>控制器：控制视图、并向模型提供新数据的途径，它既向模型、也向视图发布时间。</li></ul><h2 id="黑板"><a href="#黑板" class="headerlink" title="黑板"></a>黑板</h2><ul><li>黑板系统让我们能够完全解除对象之间的耦合，并提供一个论坛，知识消费者和生产者可以在那里匿名、异步地交换数据。</li><li>提示43：用黑板协调工作流。</li></ul><h1 id="第6章：当你编码时"><a href="#第6章：当你编码时" class="headerlink" title="第6章：当你编码时"></a>第6章：当你编码时</h1><h2 id="靠巧合编程"><a href="#靠巧合编程" class="headerlink" title="靠巧合编程"></a>靠巧合编程</h2><ul><li>避免靠巧合编程——依靠运气和偶然的成功——而要深思熟虑地编程。</li><li>对于你的例程的调用，要只依靠记入了文档的行为。如果处于任何原因你无法做到这一点，那就充分地把你的各种假定记入文档。</li><li>提示44：不要靠巧合编程。并非以明确的事实为基础的假定是所有项目的祸害。</li><li>怎样深思熟虑地编程：1、总是意识到你在做什么。2、不要盲目地编程。3、按照计划行事。4、依靠可靠的事物。5、为你的假定建立文档。6、不要只是测试你的代码，还要测试你的假定。7、为你的工作划分优先级。8、不要做历史的奴隶，不要让已有的代码支配将来的代码。</li></ul><h2 id="算法速率"><a href="#算法速率" class="headerlink" title="算法速率"></a>算法速率</h2><ul><li>提示45：估算你的算法的阶。</li><li>不确定代码运行时间的时候可以试着运行它，并记录不同的输入和运行时间，把结果绘制成图标。</li><li>提示46：测试你的估算。</li></ul><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul><li>代码需要演化：它不是静态的事物。</li><li>无论代码具有下面的哪些特征，都应该考虑重构代码：重复、非正交的设计、过时的知识、性能。</li><li>提示47：早重构，常重构。</li><li>怎样进行利大于弊的重构：1、不要在重构的同时增加功能；2、在开始重构之前，确保拥有良好的测试，并尽可能经常地运行它们。3、采取短小、深思熟虑的步骤。</li></ul><h2 id="易于测试的代码"><a href="#易于测试的代码" class="headerlink" title="易于测试的代码"></a>易于测试的代码</h2><ul><li>我们需要从一开始就把可测试性构建进软件中，并且在把各个部分连接在一起之前对每个部分进行彻底的测试。</li><li>提示48：为测试而设计。</li><li>提示49：测试你的软件，否则你的用户就得测试。</li></ul><h2 id="邪恶的向导"><a href="#邪恶的向导" class="headerlink" title="邪恶的向导"></a>邪恶的向导</h2><ul><li>提示50：不要使用你不理解的向导代码。</li><li>感觉说的就是不要使用你不理解的自动生成的代码。</li></ul><h1 id="第7章：在项目开始之前"><a href="#第7章：在项目开始之前" class="headerlink" title="第7章：在项目开始之前"></a>第7章：在项目开始之前</h1><h2 id="需求之坑"><a href="#需求之坑" class="headerlink" title="需求之坑"></a>需求之坑</h2><ul><li>提示51：不要搜集需求——挖掘它们。</li><li>找出用户为何要做特定事情的原因、而不只是他们目前做这件事情的方式。</li><li>提示52：与用户一同工作，以像用户一样思考。</li><li>需求不是架构，不是设计，不是用户界面，而是需要。</li><li>提示53：抽象比细节活得更长久。</li><li>管理需求增长的关键是向项目出资人指出每项新特性对项目进度的影响。</li><li>要创建并维护项目词汇表。提示54：使用项目词汇表。</li></ul><h2 id="解开不可能解开的谜题"><a href="#解开不可能解开的谜题" class="headerlink" title="解开不可能解开的谜题"></a>解开不可能解开的谜题</h2><ul><li>提示55：不要在盒子外面思考——要找到盒子。在面对棘手的问题的时候，列出所有在你面前的可能途径。不要排除任何东西，不管它听起来有多无用或愚蠢。</li><li>所需要的只是真正的约束、令人误解的约束、还有区分它们的智慧。</li></ul><h2 id="等你准备好"><a href="#等你准备好" class="headerlink" title="等你准备好"></a>等你准备好</h2><ul><li>提示56：倾听反复出现的疑虑——等你准备好再开始。</li></ul><h2 id="规范陷阱"><a href="#规范陷阱" class="headerlink" title="规范陷阱"></a>规范陷阱</h2><ul><li>编写规范是一项重要职责。</li><li>提示57：对有些事情“做”胜于“描述”。</li><li>没有给编码者留下任何解释余地的设计剥夺了他们发挥技巧和艺术才能的权利。</li><li>越是把规范当做安乐毯，进入编码截断就会越困难。</li></ul><h2 id="圆圈与箭头"><a href="#圆圈与箭头" class="headerlink" title="圆圈与箭头"></a>圆圈与箭头</h2><ul><li>提示58：不要做形式方法的努力。</li><li>应该使用形式方法，但要记住它只是工具箱里的又一种工具。</li><li>提示59：昂贵的工具不一定能制作出更好的设计。</li></ul><h1 id="第8章：注重实效的项目"><a href="#第8章：注重实效的项目" class="headerlink" title="第8章：注重实效的项目"></a>第8章：注重实效的项目</h1><h2 id="注重实效的团队"><a href="#注重实效的团队" class="headerlink" title="注重实效的团队"></a>注重实效的团队</h2><ul><li>认为项目的各种活动——分析、设计、编码——会孤立地发生，这是一个错误。它们不会孤立发生。它们是看待同一问题的不同方式，人为地分隔它们会带来许多麻烦。</li><li>提示60：围绕功能、而不是工作职务进行组织。</li></ul><h2 id="无处不在的自动化"><a href="#无处不在的自动化" class="headerlink" title="无处不在的自动化"></a>无处不在的自动化</h2><ul><li>提示61：不要使用手工流程。</li></ul><h2 id="无情的测试"><a href="#无情的测试" class="headerlink" title="无情的测试"></a>无情的测试</h2><ul><li>提示62：早测试，常测试，自动测试。</li><li>提示63：要到通过全部测试，编码才算完成。</li><li>我们需要查看项目范围测试的三个主要方面：测试什么、怎样测试以及何时测试。</li><li>单元测试是对某个模块进行演练的代码。是所有其他形式的测试的基础。</li><li>集成测试说明组成项目的主要子系统能工作，并且能很好地协同。</li><li>验证和校验。</li><li>资源耗尽、错误及恢复。</li><li>性能测试，压力测试。</li><li>可用性测试。</li><li>怎样测试包括：回归测试、测试数据、演练GUI系统、对测试进行测试、彻底测试。</li><li>回归测试把当前测试的输出与先前值进行对比。 </li><li>提示64：通过“蓄意破坏”测试你的测试。</li><li>提示65：测试状态覆盖，而不是代码覆盖。</li><li>提示66：一个bug只抓一次。一旦测试人员找到了某个bug，就应该是最后一次发现这个bug。增加新的测试，从此每次都检查这个特定的bug。</li></ul><h2 id="全都是写"><a href="#全都是写" class="headerlink" title="全都是写"></a>全都是写</h2><ul><li>注重实效的程序员会把文档当做整个开发过程的完整组成部分加以接受。</li><li>提示67：把英语当做又一种编程语言。</li><li>提示68：把文档建在里面，不要拴在外面。</li><li>一般而言，注释应该讨论为何要做模式、它的目的和目标。</li><li>不应该出现在注释中的一些内容：文件中的代码导出的函数的列表、修行历史、该文件使用的其他文件的列表、文件名。</li><li>在源文件里应该出现的最重要的信息之一是作者的姓名。</li><li>文档和代码是同一底层模型的不同视图，但视图是唯一应该不同的东西。</li></ul><h2 id="极大的期望"><a href="#极大的期望" class="headerlink" title="极大的期望"></a>极大的期望</h2><ul><li>在现实中，项目的成功是由它在多大程度上满足了用户的期望来衡量的。</li><li>提示69：温和地超出用户的期望。</li></ul><h2 id="傲慢与偏见"><a href="#傲慢与偏见" class="headerlink" title="傲慢与偏见"></a>傲慢与偏见</h2><ul><li>提示70：在你的作品上签名。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶然在组里书柜里看到了这本书，听说是新人程序员的圣经，正巧自己最近也在找这种培养思维和习惯的书看，所以就打算趁闲暇看下，希望对自己有所帮助。&lt;/p&gt;
&lt;p&gt;PS：看了几页，很多都是寓意的小故事，没法精确地摘抄某几个句子来表达思想，所以可以的话还是买本书看一看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="职业素养" scheme="http://yoursite.com/tags/%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vim配置</title>
    <link href="http://yoursite.com/2019/08/04/Vim%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/08/04/Vim配置/</id>
    <published>2019-08-04T12:33:07.000Z</published>
    <updated>2019-08-04T12:42:33.559Z</updated>
    
    <content type="html"><![CDATA[<p>上周装了Ubuntu16.04，接下来打算在上面学习点C++开发，所以得先配个环境，打算配置一下Vim以及装一些插件，接下来就搞一下。</p><a id="more"></a><h1 id="Vim升级"><a href="#Vim升级" class="headerlink" title="Vim升级"></a>Vim升级</h1><p>用的时候发现ubuntu默认的Vim、g++和gcc版本都偏低了，先更新一下，把Vim升级到8以上，g++更新升级到4.8.5以上以支持c++11。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装依赖</span><br><span class="line">sudo apt-get install libncurses5-dev</span><br><span class="line">sudo apt-get install build-essential cmake</span><br><span class="line">sudo apt-get install python-dev python3-dev</span><br><span class="line">sudo apt-get install libgmp-dev libmpfr-dev libmpc-dev libisl-dev libcloog-isl-dev zlib1g-dev</span><br><span class="line">sudo apt-get install autogen</span><br><span class="line">sudo apt-get install libclang-dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 升级GCC</span><br><span class="line">wget ftp://ftp.gnu.org/gnu/gcc/gcc-4.9.2/gcc-4.9.2.tar.gz</span><br><span class="line">cd gcc-4.9.2</span><br><span class="line">./configure --prefix=/opt/gcc-4.9.2 --enable-languages=c,c++ --disable-multilib --disable-bootstrap --with-system-zlib</span><br><span class="line">make &amp;&amp; make check</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置好，如果之前有这两个链接文件的话就删掉重新链接就行了</span><br><span class="line">sudo ln -s /opt/gcc-4.9.2/bin/gcc /usr/bin/gcc</span><br><span class="line">sudo ln -s /opt/gcc-4.9.2/bin/g++ /usr/bin/g++</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 升级Vim</span><br><span class="line">sudo add-apt-repository ppa:jonathonf/vim</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install vim-nox-py2</span><br><span class="line">sudo mv /usr/local/bin/vim /usr/local/bin/vim.old</span><br><span class="line">sudo ln -s /usr/bin/vim.nox-py2 /usr/local/bin/vim</span><br><span class="line"><span class="meta">#</span> 参考 https://blog.csdn.net/yanjiee/article/details/76066936</span><br></pre></td></tr></table></figure><h1 id="Vim-Plug基本使用"><a href="#Vim-Plug基本使用" class="headerlink" title="Vim-Plug基本使用"></a>Vim-Plug基本使用</h1><p>Vim-plug 是一个自由、开源、速度非常快的、极简的 vim 插件管理器。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装很简单，执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>安装插件也很方便，主要有以下几步：</p><ul><li>在<code>~/.vimrc</code>中声明需要安装的插件，这里以<code>ligntline.vim</code>插件为例，如下图所示</li></ul><img src="/2019/08/04/Vim配置/addSetting.png"><p>配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let g:lightline = &#123;</span><br><span class="line">       \ 'colorscheme': 'wombat',</span><br><span class="line">       \ 'active': &#123;</span><br><span class="line">       \   'left': [ [ 'mode', 'paste' ],</span><br><span class="line">       \             [ 'readonly', 'filename', 'modified', 'helloworld' ] ]</span><br><span class="line">       \ &#125;,</span><br><span class="line">       \ 'component': &#123;</span><br><span class="line">       \   'helloworld': 'I am writing shit...'</span><br><span class="line">       \ &#125;,</span><br><span class="line">       \ &#125;</span><br><span class="line"> </span><br><span class="line">set laststatus=2</span><br></pre></td></tr></table></figure><ul><li>重新打开vim，使用<code>:PlugStatus</code>命令查看插件状态，如图：</li></ul><img src="/2019/08/04/Vim配置/notInstall.png"><ul><li>接着输入<code>:PlugInstall</code>完成插件安装</li></ul><img src="/2019/08/04/Vim配置/installDone.png"><h2 id="更新插件"><a href="#更新插件" class="headerlink" title="更新插件"></a>更新插件</h2><p>更新插件就运行<code>:PlugUpdate</code>即可，更新插件后，可以按<code>d</code>查看更改，或者也可以之后输入<code>:PlugDiff</code></p><h2 id="审查插件"><a href="#审查插件" class="headerlink" title="审查插件"></a>审查插件</h2><p>有时候更新的插件会有问题或不能正常工作，要解决这个问题就可以回滚，输入<code>:PlugDiff</code>的命令按回车键查看上次的更改，然后在每个段落上按<code>X</code>将每个插件回滚到前一个状态。</p><h2 id="删除插件"><a href="#删除插件" class="headerlink" title="删除插件"></a>删除插件</h2><ul><li>首先将<code>~/.vimrc</code>文件中对应的插件配置plug命令删除或者注释，然后重启Vim编辑器，如图：</li></ul><img src="/2019/08/04/Vim配置/delete.png"><ul><li>然后在Vim里输入<code>:PlugClean</code>命令，接着按<code>y</code>，就可以删除已经不存在配置文件中的插件了。</li></ul><img src="/2019/08/04/Vim配置/deletey.png"><h2 id="升级Vim-Plug本身"><a href="#升级Vim-Plug本身" class="headerlink" title="升级Vim-Plug本身"></a>升级Vim-Plug本身</h2><p>输入<code>:PlugUpgrade</code>就可以升级Vim-Plug本身了。</p><h1 id="安装ctags"><a href="#安装ctags" class="headerlink" title="安装ctags"></a>安装ctags</h1><p>需要重新安装ctags，使用Universal CTags，默认的Exuberant CTags太旧了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install autoconf</span><br><span class="line">cd /tmp</span><br><span class="line">git clone https://github.com/universal-ctags/ctags</span><br><span class="line">cd ctags</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure --prefix=PATH  # 安装路径,自己的情况调整。</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>在<code>.vimrc</code>里添加<code>set tags=./tags;,tags</code></p><p>然后再用<code>sudo apt install global</code>安装gtags，这时已经可以通过在项目根目录运行<code>ctags -R *</code>来生成tags文件，就可以用了。</p><h2 id="自动生成tags"><a href="#自动生成tags" class="headerlink" title="自动生成tags"></a>自动生成tags</h2><p>使用vim-gutentags插件。</p><p><code>.vimrc</code>里加入<code>Plug &#39;ludovicchabant/vim-gutentags&#39;</code></p><p>然后加入以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">" gutentags 搜索工程目录的标志，碰到这些文件/目录名就停止向上一级目录递归</span><br><span class="line">let g:gutentags_project_root = ['.root', '.svn', '.git', '.hg', '.project']</span><br><span class="line"></span><br><span class="line">" 所生成的数据文件的名称</span><br><span class="line">let g:gutentags_ctags_tagfile = '.tags'</span><br><span class="line"></span><br><span class="line">" 将自动生成的 tags 文件全部放入 ~/.cache/tags 目录中，避免污染工程目录</span><br><span class="line">let s:vim_tags = expand('~/.cache/tags')</span><br><span class="line">let g:gutentags_cache_dir = s:vim_tags</span><br><span class="line"></span><br><span class="line">" 配置 ctags 的参数</span><br><span class="line">let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']</span><br><span class="line">let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']</span><br><span class="line">let g:gutentags_ctags_extra_args += ['--c-kinds=+px']</span><br><span class="line"></span><br><span class="line">" 检测 ~/.cache/tags 不存在就新建</span><br><span class="line">if !isdirectory(s:vim_tags)</span><br><span class="line">   silent! call mkdir(s:vim_tags, 'p')</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>现在只要项目根目录里有<code>&#39;.root&#39;, &#39;.svn&#39;, &#39;.git&#39;, &#39;.hg&#39;, &#39;.project&#39;</code>这些文件，当使用vim编辑文件的时候就会自动生成.tag文件了，该文件可以在<code>~/.cache/tags</code>里看到。</p><p>现在就可以使用<code>ctrl+]</code>进行跳转了，但是建议使用<code>ctrl+w+]</code>用新窗口打开或者<code>ctrl+w+}</code>使用预览窗口，<code>:pclose</code>关闭预览窗口。</p><h1 id="安装AsyncRun"><a href="#安装AsyncRun" class="headerlink" title="安装AsyncRun"></a>安装AsyncRun</h1><p>Vim8以后，利用异步模式，可以让编译更方便，用AsyncRun插件，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Plug 'skywind3000/asyncrun.vim'</span><br><span class="line">let g:asyncrun_rootmarks = ['.svn', '.git', '.root', '_darcs', 'build.xml']</span><br><span class="line">" 自动打开 quickfix window ，高度为 6</span><br><span class="line">let g:asyncrun_open = 6</span><br><span class="line"></span><br><span class="line">" 任务结束时候响铃提醒</span><br><span class="line">let g:asyncrun_bell = 1</span><br><span class="line"></span><br><span class="line">" 设置 F10 打开/关闭 Quickfix 窗口</span><br><span class="line">nnoremap &lt;F10&gt; :call asyncrun#quickfix_toggle(6)&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">" 设置F7编译整个项目，注意makefile的目录，可以自行修改</span><br><span class="line">nnoremap &lt;silent&gt; &lt;F7&gt; :AsyncRun -cwd=&lt;root&gt;/src make &lt;cr&gt;</span><br></pre></td></tr></table></figure><h1 id="安装代码检查ALE"><a href="#安装代码检查ALE" class="headerlink" title="安装代码检查ALE"></a>安装代码检查ALE</h1><p>配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Plug 'dense-analysis/ale'</span><br><span class="line">let g:ale_linters_explicit = 1</span><br><span class="line">let g:ale_linters = &#123;</span><br><span class="line">  \   'csh': ['shell'],</span><br><span class="line">  \   'zsh': ['shell'],</span><br><span class="line">  \   'go': ['gofmt', 'golint'],</span><br><span class="line">  \   'python': ['flake8', 'mypy', 'pylint'],</span><br><span class="line">  \   'c': ['gcc', 'cppcheck'],</span><br><span class="line">  \   'cpp': ['gcc', 'cppcheck'],</span><br><span class="line">  \   'text': [],</span><br><span class="line">  \&#125;</span><br><span class="line">let g:ale_completion_delay = 500</span><br><span class="line">let g:ale_echo_delay = 20</span><br><span class="line">let g:ale_lint_delay = 500</span><br><span class="line">let g:ale_echo_msg_format = '[%linter%] %code: %%s'</span><br><span class="line">let g:ale_lint_on_text_changed = 'normal'</span><br><span class="line">let g:ale_lint_on_insert_leave = 1</span><br><span class="line">let g:airline#extensions#ale#enabled = 1</span><br><span class="line"></span><br><span class="line">let g:ale_c_gcc_options = '-Wall -O2 -std=c99'</span><br><span class="line">let g:ale_cpp_gcc_options = '-Wall -O2 -std=c++14'</span><br><span class="line">let g:ale_c_cppcheck_options = ''</span><br><span class="line">let g:ale_cpp_cppcheck_options = ''</span><br></pre></td></tr></table></figure><p>这个插件比较大，装的比较久，成功后如图：</p><img src="/2019/08/04/Vim配置/aleExample.png"><h1 id="安装YouCompleteMe"><a href="#安装YouCompleteMe" class="headerlink" title="安装YouCompleteMe"></a>安装YouCompleteMe</h1><p>这个也有点麻烦，走了不少坑，首先要对git做下设置，否则git clone的时候会不能获取到一些国外的repo，原因嘛……</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy 'socks5://127.0.0.1:1080'</span><br><span class="line"></span><br><span class="line">git config --global https.proxy 'socks5://127.0.0.1:1080'</span><br></pre></td></tr></table></figure><p>运行上述两条命令，结合之前已经搞好的科学上网，就可以正常clone啦，而且速度好快哦～</p><p>配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let g:ycm_global_ycm_extra_conf='~/.vim/plugged/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py'</span><br><span class="line">let g:ycm_add_preview_to_completeopt = 0</span><br><span class="line">let g:ycm_show_diagnostics_ui = 0</span><br><span class="line">let g:ycm_server_log_level = 'info'</span><br><span class="line">let g:ycm_min_num_identifier_candidate_chars = 2</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1</span><br><span class="line">let g:ycm_complete_in_strings=1</span><br><span class="line">let g:ycm_key_invoke_completion = '&lt;c-z&gt;'                    " 使用 Ctrl+Z 主动触发语义补全</span><br><span class="line">noremap &lt;c-z&gt; &lt;NOP&gt;</span><br><span class="line">set completeopt=menu,menuone</span><br></pre></td></tr></table></figure><p>应该没问题了，但如果出现<code>YouCompleteMe unavailable no module named builtins</code>错误，则cd到YouCompleteMe目录下运行<code>git submodule update --init --recursive</code>，这个问题应该是因为网速问题没下完整。</p><p>如果出现<code>The ycmd server SHUT DOWN (restart with &#39;:YcmRestartServer&#39;). Unexpected exit code 1.</code>类似问题，则cd到YouCompleteMe目录下运行<code>/usr/bin/python install.py</code>。</p><h1 id="NerdTree"><a href="#NerdTree" class="headerlink" title="NerdTree"></a>NerdTree</h1><p>目录树，配置如下，按F3就可以打开目录树：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Plug 'scrooloose/nerdtree'</span><br><span class="line"></span><br><span class="line">noremap &lt;F3&gt; :NERDTreeToggle&lt;cr&gt;</span><br></pre></td></tr></table></figure><h1 id="vim-cpp-enhanced-highlight"><a href="#vim-cpp-enhanced-highlight" class="headerlink" title="vim-cpp-enhanced-highlight"></a>vim-cpp-enhanced-highlight</h1><p>C++语法高亮插件，直接加入即可，不需多余配置。</p><p><code>Plug &#39;octol/vim-cpp-enhanced-highlight&#39;</code></p><h1 id="nerdcommerter"><a href="#nerdcommerter" class="headerlink" title="nerdcommerter"></a>nerdcommerter</h1><p>注释的插件，快捷键<code>&lt;leader&gt;cc</code>和<code>&lt;leader&gt;c&lt;space&gt;</code>。</p><h1 id="LeaderF"><a href="#LeaderF" class="headerlink" title="LeaderF"></a>LeaderF</h1><p>函数列表插件，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Plug 'Yggdroot/LeaderF', &#123; 'do': './install.sh' &#125;</span><br><span class="line">let g:Lf_ShortcutF = '&lt;c-p&gt;'</span><br><span class="line">let g:Lf_ShortcutB = '&lt;m-n&gt;'</span><br><span class="line">noremap &lt;c-n&gt; :LeaderfMru&lt;cr&gt;</span><br><span class="line">" 设置F2显示本文件的函数列表，这里Vim映射Alt键不成功，所以自己改成F2</span><br><span class="line">noremap &lt;F2&gt; :LeaderfFunction!&lt;cr&gt;</span><br><span class="line">noremap &lt;m-n&gt; :LeaderfBuffer&lt;cr&gt;</span><br><span class="line">noremap &lt;m-m&gt; :LeaderfTag&lt;cr&gt;</span><br><span class="line">let g:Lf_StlSeparator = &#123; 'left': '', 'right': '', 'font': '' &#125;</span><br><span class="line"></span><br><span class="line">let g:Lf_RootMarkers = ['.project', '.root', '.svn', '.git']</span><br><span class="line">let g:Lf_WorkingDirectoryMode = 'Ac'</span><br><span class="line">let g:Lf_WindowHeight = 0.30</span><br><span class="line">let g:Lf_CacheDirectory = expand('~/.vim/cache')</span><br><span class="line">let g:Lf_ShowRelativePath = 0</span><br><span class="line">let g:Lf_HideHelp = 1</span><br><span class="line">let g:Lf_StlColorscheme = 'powerline'</span><br><span class="line">let g:Lf_PreviewResult = &#123;'Function':0, 'BufTag':0&#125;</span><br></pre></td></tr></table></figure><h1 id="echodoc-vim"><a href="#echodoc-vim" class="headerlink" title="echodoc.vim"></a>echodoc.vim</h1><p>显示参数列表，配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Plug 'Shougo/echodoc.vim'</span><br><span class="line"></span><br><span class="line">set noshowmode</span><br></pre></td></tr></table></figure><p>当用YCM的tab补全函数名后，输入左括号即可显示参数信息，和YCM配合结果如图：</p><img src="/2019/08/04/Vim配置/ycm.png"><h1 id="Vim所有配置"><a href="#Vim所有配置" class="headerlink" title="Vim所有配置"></a>Vim所有配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">set number</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br><span class="line">set softtabstop =4         " Tab key indents by 4 spaces.</span><br><span class="line">set hidden                 " Switch between buffers without having to save first.</span><br><span class="line">set noshowmode</span><br><span class="line">" set cmdheight =2</span><br><span class="line">" 插件列表</span><br><span class="line"></span><br><span class="line">call plug#begin('~/.vim/plugged')</span><br><span class="line">Plug 'itchyny/lightline.vim'</span><br><span class="line">" Plug 'tenfyzhong/CompleteParameter.vim'</span><br><span class="line">Plug 'ludovicchabant/vim-gutentags'</span><br><span class="line">Plug 'skywind3000/asyncrun.vim'</span><br><span class="line">Plug 'octol/vim-cpp-enhanced-highlight'</span><br><span class="line">Plug 'dense-analysis/ale'</span><br><span class="line">Plug 'scrooloose/nerdtree'</span><br><span class="line">Plug 'scrooloose/nerdcommenter'     " 注释的插件 &lt;leader&gt;cc和&lt;leader&gt;c&lt;space&gt;</span><br><span class="line">Plug 'Yggdroot/LeaderF', &#123; 'do': './install.sh' &#125;</span><br><span class="line">Plug 'Valloric/YouCompleteMe', &#123; 'do': './install.py --clang-completer --go-completer' &#125;</span><br><span class="line">Plug 'Shougo/echodoc.vim'</span><br><span class="line">call plug#end()</span><br><span class="line"></span><br><span class="line">" ###################################################################</span><br><span class="line">" lightline</span><br><span class="line"></span><br><span class="line">let g:lightline = &#123;</span><br><span class="line">      \ 'colorscheme': 'wombat',</span><br><span class="line">      \ 'active': &#123;</span><br><span class="line">      \   'left': [ [ 'mode', 'paste' ],</span><br><span class="line">      \             [ 'readonly', 'filename', 'modified', 'helloworld' ] ]</span><br><span class="line">      \ &#125;,</span><br><span class="line">      \ 'component': &#123;</span><br><span class="line">      \   'helloworld': 'I am writing shit...'</span><br><span class="line">      \ &#125;,</span><br><span class="line">      \ &#125;</span><br><span class="line"></span><br><span class="line">set laststatus=2</span><br><span class="line">" ###################################################################</span><br><span class="line">" ctags</span><br><span class="line">set tags=./.tags;,.tags</span><br><span class="line">" gutentags 搜索工程目录的标志，碰到这些文件/目录名就停止向上一级目录递归</span><br><span class="line">let g:gutentags_project_root = ['.root', '.svn', '.git', '.hg', '.project']</span><br><span class="line"></span><br><span class="line">" 所生成的数据文件的名称</span><br><span class="line">let g:gutentags_ctags_tagfile = '.tags'</span><br><span class="line"></span><br><span class="line">" 将自动生成的 tags 文件全部放入 ~/.cache/tags 目录中，避免污染工程目录</span><br><span class="line">let s:vim_tags = expand('~/.cache/tags')</span><br><span class="line">let g:gutentags_cache_dir = s:vim_tags</span><br><span class="line"></span><br><span class="line">" 配置 ctags 的参数</span><br><span class="line">let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']</span><br><span class="line">let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']</span><br><span class="line">let g:gutentags_ctags_extra_args += ['--c-kinds=+px']</span><br><span class="line"></span><br><span class="line">" 检测 ~/.cache/tags 不存在就新建</span><br><span class="line">if !isdirectory(s:vim_tags)</span><br><span class="line">   silent! call mkdir(s:vim_tags, 'p')</span><br><span class="line">   endif</span><br><span class="line">" ###########################################################</span><br><span class="line"></span><br><span class="line">" asyncrun</span><br><span class="line"></span><br><span class="line">let g:asyncrun_rootmarks = ['.svn', '.git', '.root', '_darcs', 'build.xml']</span><br><span class="line">" 自动打开 quickfix window ，高度为 6</span><br><span class="line">let g:asyncrun_open = 6</span><br><span class="line"></span><br><span class="line">" 任务结束时候响铃提醒</span><br><span class="line">let g:asyncrun_bell = 1</span><br><span class="line"></span><br><span class="line">" 设置 F10 打开/关闭 Quickfix 窗口</span><br><span class="line">nnoremap &lt;F10&gt; :call asyncrun#quickfix_toggle(6)&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">" 设置F7编译整个项目，注意makefile的目录，可以自行修改</span><br><span class="line">nnoremap &lt;silent&gt; &lt;F7&gt; :AsyncRun -cwd=&lt;root&gt;/src make &lt;cr&gt;</span><br><span class="line">" ###########################################################</span><br><span class="line"></span><br><span class="line">" ALE</span><br><span class="line">let g:ale_linters_explicit = 1</span><br><span class="line">let g:ale_linters = &#123;</span><br><span class="line">  \   'csh': ['shell'],</span><br><span class="line">  \   'zsh': ['shell'],</span><br><span class="line">  \   'go': ['gofmt', 'golint'],</span><br><span class="line">  \   'python': ['flake8', 'mypy', 'pylint'],</span><br><span class="line">  \   'c': ['gcc', 'cppcheck'],</span><br><span class="line">  \   'cpp': ['gcc', 'cppcheck'],</span><br><span class="line">  \   'text': [],</span><br><span class="line">  \&#125;</span><br><span class="line">let g:ale_completion_delay = 500</span><br><span class="line">let g:ale_echo_delay = 20</span><br><span class="line">let g:ale_lint_delay = 500</span><br><span class="line">let g:ale_echo_msg_format = '[%linter%] %code: %%s'</span><br><span class="line">let g:ale_lint_on_text_changed = 'normal'</span><br><span class="line">let g:ale_lint_on_insert_leave = 1</span><br><span class="line">let g:airline#extensions#ale#enabled = 1</span><br><span class="line"></span><br><span class="line">let g:ale_c_gcc_options = '-Wall -O2 -std=c99'</span><br><span class="line">let g:ale_cpp_gcc_options = '-Wall -O2 -std=c++14'</span><br><span class="line">let g:ale_c_cppcheck_options = ''</span><br><span class="line">let g:ale_cpp_cppcheck_options = ''</span><br><span class="line"></span><br><span class="line">" ###########################################################</span><br><span class="line">" YouCompleteMe</span><br><span class="line">let g:ycm_global_ycm_extra_conf='~/.vim/plugged/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py'</span><br><span class="line">let g:ycm_add_preview_to_completeopt = 0</span><br><span class="line">let g:ycm_show_diagnostics_ui = 0</span><br><span class="line">let g:ycm_server_log_level = 'info'</span><br><span class="line">let g:ycm_min_num_identifier_candidate_chars = 2</span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings = 1</span><br><span class="line">let g:ycm_complete_in_strings=1</span><br><span class="line">let g:ycm_key_invoke_completion = '&lt;c-z&gt;'                    " 使用 Ctrl+Z 主动触发语义补全</span><br><span class="line">noremap &lt;c-z&gt; &lt;NOP&gt;</span><br><span class="line">set completeopt=menu,menuone</span><br><span class="line"></span><br><span class="line">" 修改补全列表配色</span><br><span class="line">highlight PMenu ctermfg=0 ctermbg=242 guifg=black guibg=darkgrey</span><br><span class="line">highlight PMenuSel ctermfg=242 ctermbg=8 guifg=darkgrey guibg=black</span><br><span class="line"></span><br><span class="line">" 对指定源文件，输入两个字母后即触发语义补全</span><br><span class="line">let g:ycm_semantic_triggers =  &#123;</span><br><span class="line">           \ 'c,cpp,python,java,go,erlang,perl': ['re!\w&#123;2&#125;'],</span><br><span class="line">           \ 'cs,lua,javascript': ['re!\w&#123;2&#125;'],</span><br><span class="line">           \ &#125;</span><br><span class="line"></span><br><span class="line">let g:ycm_filetype_whitelist = &#123; </span><br><span class="line">            \ "c":1,</span><br><span class="line">            \ "cpp":1, </span><br><span class="line">            \ "go":1,</span><br><span class="line">            \ "python":1,</span><br><span class="line">            \ "sh":1,</span><br><span class="line">            \ "zsh":1,</span><br><span class="line">            \ &#125;</span><br><span class="line"></span><br><span class="line">let g:ycm_filetype_blacklist = &#123;</span><br><span class="line">        \ 'markdown' : 1,</span><br><span class="line">        \ 'text' : 1,</span><br><span class="line">        \ 'pandoc' : 1,</span><br><span class="line">        \ 'infolog' : 1,</span><br><span class="line">        \&#125;</span><br><span class="line">" ###########################################################</span><br><span class="line"></span><br><span class="line">" LeaderF</span><br><span class="line">let g:Lf_ShortcutF = '&lt;c-p&gt;'</span><br><span class="line">let g:Lf_ShortcutB = '&lt;m-n&gt;'</span><br><span class="line">noremap &lt;c-n&gt; :LeaderfMru&lt;cr&gt;</span><br><span class="line">" 设置F2显示本文件的函数列表，这里Vim映射Alt键不成功，所以自己改成F2</span><br><span class="line">noremap &lt;F2&gt; :LeaderfFunction!&lt;cr&gt;</span><br><span class="line">noremap &lt;m-n&gt; :LeaderfBuffer&lt;cr&gt;</span><br><span class="line">noremap &lt;m-m&gt; :LeaderfTag&lt;cr&gt;</span><br><span class="line">let g:Lf_StlSeparator = &#123; 'left': '', 'right': '', 'font': '' &#125;</span><br><span class="line"></span><br><span class="line">let g:Lf_RootMarkers = ['.project', '.root', '.svn', '.git']</span><br><span class="line">let g:Lf_WorkingDirectoryMode = 'Ac'</span><br><span class="line">let g:Lf_WindowHeight = 0.30</span><br><span class="line">let g:Lf_CacheDirectory = expand('~/.vim/cache')</span><br><span class="line">let g:Lf_ShowRelativePath = 0</span><br><span class="line">let g:Lf_HideHelp = 1</span><br><span class="line">let g:Lf_StlColorscheme = 'powerline'</span><br><span class="line">let g:Lf_PreviewResult = &#123;'Function':0, 'BufTag':0&#125;</span><br><span class="line"></span><br><span class="line">" ###########################################################</span><br><span class="line">" nerdtree</span><br><span class="line"></span><br><span class="line">noremap &lt;F3&gt; :NERDTreeToggle&lt;cr&gt;</span><br><span class="line">" ###########################################################</span><br><span class="line">" echodoc</span><br><span class="line">let g:echodoc_enable_at_startup = 1</span><br><span class="line"></span><br><span class="line">" ###########################################################</span><br><span class="line">" CompleteParameter</span><br><span class="line">" inoremap &lt;silent&gt;&lt;expr&gt; ( complete_parameter#pre_complete("()")</span><br><span class="line">" smap &lt;c-j&gt; &lt;Plug&gt;(complete_parameter#goto_next_parameter)</span><br><span class="line">" imap &lt;c-j&gt; &lt;Plug&gt;(complete_parameter#goto_next_parameter)</span><br><span class="line">" smap &lt;c-k&gt; &lt;Plug&gt;(complete_parameter#goto_previous_parameter)</span><br><span class="line">" imap &lt;c-k&gt; &lt;Plug&gt;(complete_parameter#goto_previous_parameter)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周装了Ubuntu16.04，接下来打算在上面学习点C++开发，所以得先配个环境，打算配置一下Vim以及装一些插件，接下来就搞一下。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>win10安装Ubuntu16.04双系统记录</title>
    <link href="http://yoursite.com/2019/07/28/win10%E5%AE%89%E8%A3%85Ubuntu16-04%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/07/28/win10安装Ubuntu16-04双系统记录/</id>
    <published>2019-07-28T13:07:41.000Z</published>
    <updated>2019-07-28T15:03:36.111Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括以下内容：</p><ul><li>双系统安装</li><li>Ubuntu访问Google</li><li>Ubuntu下Tim和微信的安装使用</li><li>双系统互相访问文件</li><li>Ubuntu搜狗输入法安装</li></ul><a id="more"></a><p>由于目前工作主要用的语言是C++，且是在Linux上开发，所以便想在自己电脑上也搞个Linux系统用来平时学习，之前装过虚拟机也试过Win10下的Ubuntu子系统，但嫌弃虚拟机用起来太麻烦而且有时候会有点卡顿，子系统看网上又说IO性能不行，我又有点挑刺的毛病，所以便想要不要干脆整个双系统算了，但是我现在用的是128G的MagicBook，要整个双系统硬盘大小又有点尴尬。</p><p>其实……我想的最好的办法是买台Mac，但是……穷的一笔，而且这个问题还没法解决，真是太悲伤了，于是这个想法作罢。</p><p>最后在三个选择里纠结了一下，选择匀出20G装个Ubuntu双系统吧，版本16.04，自己还能学学装系统，万一以后要靠这个谋生呢……不过修电脑装系统也不是装Linux啊……awsl……</p><p>网上教程很多，我这里更多的是记录，如果有些细节没有的话可以看我贴出来的链接，那里面图多，但是看图更简单，所以可以第一遍看图操作，第二遍看我的文字操作再次加深记忆，然后我觉得就差不多记住了。</p><p>下面进入正题。</p><h1 id="安装Ubuntu双系统"><a href="#安装Ubuntu双系统" class="headerlink" title="安装Ubuntu双系统"></a>安装Ubuntu双系统</h1><ul><li>首先下载系统镜像文件，就是iso后缀文件，从<a href="https://ubuntu.com/download" target="_blank" rel="noopener">https://ubuntu.com/download</a>下载就行，我下的是桌面版，现在已经更新到19.04了，不过我很早以前就下过Ubuntu镜像，所以就用的以前的版本，即16.04,没有的话就可以下载新的，也可以找老版本下载，不过我一般下载东西的时候都不会下载最新版，我会下载次新或者第三新或者用的比较多的版本，因为最新版本必然网上资料不够多，遇到一些奇奇怪怪的问题不好解决（主要是我太菜）。下载好之后大概是这样：</li></ul><img src="/2019/07/28/win10安装Ubuntu16-04双系统记录/iso.jpg"><ul><li>下载好镜像文件后便制作U盘启动盘，下载Ultraiso软碟通软件，试用就行，无需付费，下载地址<a href="https://cn.ultraiso.net/" target="_blank" rel="noopener">https://cn.ultraiso.net/</a>。下载好插入U盘，打开软件，选择文件打开，选中iso镜像，然后点击菜单里的启动，写入硬盘映像，接着在弹出的窗口中硬盘驱动器一栏里选择U盘，注意这里不要选错了，一定要选U盘呀，要是不知道U盘的名字就看大小，一般U盘大小总不会比你的硬盘还大吧……选好之后写入方式选择<code>USB-HDD+</code>，然后写入。这种写入操作都会清空U盘的，所以你要是选错了，清空硬盘的话……那就有意思了。最后等待写入完成。</li><li>然后需要关闭Win10的快速启动（FastBoot）和安全启动（SecureBoot），快速启动可以按以下操作进行：<code>Win+x</code>，选择电源选项，出现下图。</li></ul><img src="/2019/07/28/win10安装Ubuntu16-04双系统记录/dianyuan1.jpg"><ul><li>选择<code>其他电源设置</code>，然后点击左侧<code>选择电源按钮的功能</code>，记着点击<code>更改当前不可用的设置</code>，最后把下面<code>启用快速启动</code>的勾给去掉，最后保存修改。</li><li>然后就需要在硬盘上分一部分空间留给后面要装的Ubuntu了，我的硬盘容量不多了，所以只分了20G，多的话随便你们分多少，不过我觉得不要低于20G比较好，因为我装完之后空间还剩7个多G的样子，我目前个人学习是够了，你们可以参考一下，建议有条件的情况下大一些，谁知道你会在Linux里装多少东西呢。</li><li><code>Win+x</code>，选择磁盘管理，在弹出的窗口里可以看到目前的磁盘分布情况，然后选择一个可用空间满足你要求的磁盘，右击，压缩卷，输入压缩空间量，这个压缩空间量其实就是你要留给Ubuntu的空间，看你自己情况而定，我记得我当时写的21000吧，然后点压缩，就会看到一个黑色的空闲未分配的磁盘块了，OK。</li><li>接下来要进入BIOS，我的MagicBook是按<code>F2</code>，另外说一句<code>F12</code>是进入Boot，一会儿也要用到，如果你的电脑型号和我不一样就得自己上网去查下这两个按键，不过大体就那几个键。</li><li>重启，在屏幕出现电脑商标的时候按<code>F2</code>进入BIOS，调整SecureBoot为Disable，然后保存并退出。</li><li>插入U盘，再次重启，这次在屏幕出现电脑商标的时候按<code>F12</code>进入Boot，选择USB启动，就可以进入Ubuntu安装步骤。当然，如果在上一步的时候就已经插了U盘，那就可以再保存完BIOS设置后出现商标时直接按<code>F12</code>进入Boot，省掉一次重启。</li><li>进入Ubuntu安装步骤之后正常来说就点下一步就行了，包括一些简单设置，什么要不要连网啊，时区选择啊，用户密码啊，语言选择啊，建议这里语言选英文吧，因为我一开始选的中文，但是到了命令行里发现要cd到中文目录的时候好麻烦啊，还是改回了英文。当然也可以像我一样先选中文后面再改回英文，因为在安装过程中看中文还是要舒服一点。</li><li>这里有几点要说明的，会出现一个选择安装方式的界面，第一个好像是什么多个系统共存，最后一个是其他选项，建议选择其他选项，这个其他选项就是要自己去分区（这才是Linux的精髓啊，可是这次弄得很简单），点击继续。</li><li>接下来的窗口里就会看到硬盘分布，你可以找到之前你预留出来的空闲区，可以根据大小来判断。选中空闲区，然后点击左下角的<code>+</code>号，对空闲区进行分配。这里简单起见，只分两个区：交换区和根目录<code>/</code>，交换区一般要比你电脑的内存大一些，比如8G内存就分8G到10G，我的电脑就是8G内存，但是因为硬盘不够，所以我这交换区分的并不多，你们自己看就行。</li><li>点击<code>+</code>号之后，勾选<code>逻辑分区</code>，<code>空间起始位置</code>，用于<code>交换空间</code>，确定。然后如法炮制，将剩下的空间都分配给<code>/</code>。</li><li>分好后，记得看下挂载点<code>/</code>在哪个设备上，显示应该是/dev/sdaX，然后在下面的<code>安装启动引导器的设备</code>中选择对应的sdaX，这表示会把启动引导器装在<code>/</code>里。</li><li>最后点击安装，确定，等待安装完毕。</li><li>完毕后重启，会进入grub2的选择界面，会让你选择是进入Windows还是Ubuntu，自行选择即可。</li><li>参考教程<a href="https://blog.csdn.net/jiajinrang93/article/details/63892208" target="_blank" rel="noopener">https://blog.csdn.net/jiajinrang93/article/details/63892208</a>，图比较多，第一遍可以照着来。</li></ul><h1 id="Ubuntu科学上网"><a href="#Ubuntu科学上网" class="headerlink" title="Ubuntu科学上网"></a>Ubuntu科学上网</h1><p>这块搞了我好长时间，昨天搞到三点也没好，明明都是按照别人的教程来的啊，为什么别人翻得我翻不得？</p><p>顺便吐槽百度，不能Google的情况下，Bing好用。</p><p>怀着深深怨念入睡，今天起床准备再战三百回合，结果就好了……好了……了……</p><p>你对得起我的黑眼圈吗！</p><p>不过能Google就行……咱大度，不计较。</p><p>当然，我是用的ShadowSocks，能翻墙的前提是你有对应的账号。</p><p>开始。</p><ul><li>首先下载ShadowSocks客户端，这有两种方法，一个是下载命令行客户端，另一个是下载图形化客户端，这里都简单介绍一下。</li><li>命令行客户端下载使用以下命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common -y</span><br><span class="line">sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev -y</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install shadowsocks-libev</span><br></pre></td></tr></table></figure><ul><li>图形化客户端ss-qt5下载方式如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure><ul><li>两者安装一个就好了，不过我因为被坑了，鼓捣的过程里把两个都装了。</li><li>接下来就是编写json配置文件，就是把你的账号服务器填一下，格式如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"server"</span>:<span class="string">"服务器 IP 或是域名"</span>,</span><br><span class="line"><span class="attr">"server_port"</span>:端口号,</span><br><span class="line"><span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line"><span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line"><span class="attr">"password"</span>:<span class="string">"密码"</span>,</span><br><span class="line"><span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line"><span class="attr">"method"</span>:<span class="string">"加密方式 (chacha20-ietf-poly1305 / aes-256-cfb)"</span>,</span><br><span class="line"><span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一般就去你买的服务商那里复制粘贴json格式保存文件就行了。</li><li>接下来启动客户端，命令行使用以下命令<code>ss-local -c ssconfig.json</code>，后面的<code>ssconfig.json</code>要填你自己编写的配置文件和路径。</li><li>如果是qt5客户端，就在命令行里输入<code>ss-qt5</code>启动客户端，然后为了下次启动方便可以直接把图标固定在开始栏，下次就可以直接单击启动了，接着按照图形化界面添加配置就行了，添加好后点击<code>connect</code>按钮进行连接，连接好后可以按<code>test latency</code>按钮测测延迟，如果不是error就说明连上了。</li><li>至此，shadowsocks都配好了，但Linux下比较麻烦的是还需要配置浏览器，我这用的是Chrome，也推荐用Chrome。</li><li>当然，不能访问谷歌的时候好像也下不了Chrome，这个自行解决吧，我是回到我的windows里下好Linux版本的Chrome再回到Ubuntu里安装的，安装好之后命令行输入<code>google-chrome</code>便可以启动浏览器。</li><li>然后安装<code>SwitchOmega</code>插件，当然，也没法从Chrome商店里安装，所以只能手动安装，去<a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases</a>下载.crx文件，接着将后缀crx改为zip，解压。然后打开Chrome浏览器，地址栏输入<code>chrome://extensions/</code>，打开右上角的开发者模式，接着点左上角的<code>加载已解压的扩展程序</code>，选择解压的文件夹，就OK了，虽然插件好像会有Error，但不影响。</li><li>最后就是配置SwitchOmega了，还有点麻烦，可以看<a href="https://www.qcgzxw.cn/2988.html#toc-2" target="_blank" rel="noopener">https://www.qcgzxw.cn/2988.html#toc-2</a>，这是我找了好久才找到的没有被屏蔽的配置教程，希望你们看的时候也没被屏蔽。如果屏蔽了……就看下我现在写的简单过程吧，先启动插件，右键选择options进入配置，左侧选择proxy，右侧选择协议SOCKS5，代理服务器填127.0.0.1，端口1080（这和你的json里一致），然后点左侧应用选项保存配置。接着还没好，选择auto switch继续配置自动切换规则，规则列表格式选择AutoProxy，规则列表网址填<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code>，然后点击下方的<code>立即更新情景模式</code>按钮，接着规则列表设置上面的部分，勾选<code>勾选列表规则</code>，上面的几条配置可以删了，只要在规则列表规则后面选择<code>proxy</code>就好了，简单说意思就是在规则列表里的网址就使用proxy，否则就直连，最后备别忘了保存。</li><li>最后在浏览器里右上角的插件里设置成<code>auto switch</code>就行了。</li><li>ok，正常可以访问Google了，但是我昨天搞到凌晨三点也不行，今天一觉起来就行了，很莫名其妙。最后可以看下这个连接<a href="https://zhuanlan.zhihu.com/p/47706985" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47706985</a>，是使用命令行客户端的一个教程，比较清晰。</li></ul><h1 id="Ubuntu下Tim和微信的安装使用"><a href="#Ubuntu下Tim和微信的安装使用" class="headerlink" title="Ubuntu下Tim和微信的安装使用"></a>Ubuntu下Tim和微信的安装使用</h1><p>主要参考<a href="https://www.lulinux.com/archives/1319" target="_blank" rel="noopener">https://www.lulinux.com/archives/1319</a>。</p><p>主要步骤：</p><ol><li>安装deepin-wine环境，上<a href="https://github.com/wszqkzqk/deepin-wine-ubuntu" target="_blank" rel="noopener">https://github.com/wszqkzqk/deepin-wine-ubuntu</a>，我是按照本地安装来安装的，正常装完即可。</li><li>安装容器，即QQ、Tim或者微信。</li></ol><ul><li>Tim：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/</a></li><li>QQ：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/</a></li><li>微信：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/</a></li></ul><h1 id="双系统互相访问文件"><a href="#双系统互相访问文件" class="headerlink" title="双系统互相访问文件"></a>双系统互相访问文件</h1><p>Linux可以直接访问Windows，不需要做任何操作，厉害呀。</p><p>Windows想要访问Liunx，下载一个叫做LinuxReader的软件即可，网上也有说别的软件的，但我下了不行，所以就用这个了。</p><p>下载链接<a href="https://www.diskinternals.com/linux-reader/" target="_blank" rel="noopener">https://www.diskinternals.com/linux-reader/</a>，try it free即可。</p><h1 id="Ubuntu搜狗输入法安装"><a href="#Ubuntu搜狗输入法安装" class="headerlink" title="Ubuntu搜狗输入法安装"></a>Ubuntu搜狗输入法安装</h1><p>参考<a href="https://jingyan.baidu.com/article/642c9d341b3ccb644a46f7ac.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/642c9d341b3ccb644a46f7ac.html</a>。</p><ul><li>下载搜狗输入法For Linux，一个.deb文件，用<code>dpkg -i file</code>来安装，但好像不需要这个命令了，可以直接看下一步（不过我没试过直接用下一步，毕竟我是装了之后不能用才去找教程的嘛）。</li><li>但现在还不能用，继续操作，输入<code>sudo apt-get install gdebi</code>安装Gdebi，然后cd到.deb文件目录，执行<code>sudo gdebi sogoupinyin.deb</code>，等待安装好。</li><li>重启电脑，就行了。</li></ul><p>最后可以愉快地用Ubuntu啦，当然还有听歌软件啊啥的没研究，回头再说，毕竟Vim还没配好。</p><p>慢慢来。</p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双系统安装&lt;/li&gt;
&lt;li&gt;Ubuntu访问Google&lt;/li&gt;
&lt;li&gt;Ubuntu下Tim和微信的安装使用&lt;/li&gt;
&lt;li&gt;双系统互相访问文件&lt;/li&gt;
&lt;li&gt;Ubuntu搜狗输入法安装&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vim学习记录</title>
    <link href="http://yoursite.com/2019/06/29/Vim%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/06/29/Vim学习记录/</id>
    <published>2019-06-29T08:20:07.000Z</published>
    <updated>2019-07-28T15:13:56.365Z</updated>
    
    <content type="html"><![CDATA[<p>因为工作中需要用到Vim，所以本文简单记录下学习Vim编辑器的一些笔记和技巧。</p><h1 id="Vimtutor"><a href="#Vimtutor" class="headerlink" title="Vimtutor"></a>Vimtutor</h1><p>Vimtutor是Vim的一个简易教程，前前后后做了两遍，记录一下一些实用的快捷键吧。</p><a id="more"></a><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">h/j/k/l</td><td style="text-align:center">左下上右</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">删除光标处的字母</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">切换至输入模式，在光标前输入</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">切换至输入模式，在行尾输入</td></tr><tr><td style="text-align:center">dw</td><td style="text-align:center">从光标处删除字符直到下个字开始</td></tr><tr><td style="text-align:center">de</td><td style="text-align:center">从光标处删除字符直到该字尾</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">撤销</td></tr><tr><td style="text-align:center">U</td><td style="text-align:center">撤销一整行的操作，使该行恢复到最初</td></tr><tr><td style="text-align:center">d&amp;</td><td style="text-align:center">从光标处删除字符直到行尾</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除该行，其实也可以理解成剪切一行</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">个人感觉类似复制</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">个人感觉类似于粘贴</td></tr><tr><td style="text-align:center">r+字符</td><td style="text-align:center">用新的字符替换光标所在位置的字符</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">替换多个字符</td></tr><tr><td style="text-align:center">ce</td><td style="text-align:center">将一个字从光标处开始直到字尾的字符进行替换</td></tr><tr><td style="text-align:center">ctrl+g</td><td style="text-align:center">显示当前位置在整个文档的位置占比</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">跳转到文档开头</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">跳转到文档结尾，number+G就跳转到第number行</td></tr><tr><td style="text-align:center">/+字符串</td><td style="text-align:center">往下搜索某字符串，搜到后n是下一个，N是上一个，Ctrl+o回到原处</td></tr><tr><td style="text-align:center">?+字符串</td><td style="text-align:center">往上搜索某字符串，搜到后n是下一个，N是上一个，Ctrl+o回到原处</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">寻找匹配的括号</td></tr><tr><td style="text-align:center">%s/old/new/g</td><td style="text-align:center">全文替换，用new替换old</td></tr><tr><td style="text-align:center">!+外部命令</td><td style="text-align:center">!后可以输入外部shell命令，如ls</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">在光标下方新增一行并进入插入模式，如果是大写的O则是在光标上方新增一行</td></tr><tr><td style="text-align:center">help+command</td><td style="text-align:center">打开help文档查看command命令的说明</td></tr></tbody></table><p>很多命令的格式都是<code>operation [number] motion</code>，比如<code>d2w</code>就是删除两个字。</p><p>在Vim里使用了<code>:</code>后，可以按<code>ctrl+d</code>来查看可以使用的命令。</p><h1 id="《Vim实用技巧》"><a href="#《Vim实用技巧》" class="headerlink" title="《Vim实用技巧》"></a>《Vim实用技巧》</h1><h1 id="一-Vim解决问题的方式"><a href="#一-Vim解决问题的方式" class="headerlink" title="一.Vim解决问题的方式"></a>一.Vim解决问题的方式</h1><h2 id="技巧1-结识-命令"><a href="#技巧1-结识-命令" class="headerlink" title="技巧1 结识.命令"></a>技巧1 结识<code>.</code>命令</h2><ul><li>首先要明确什么是修改，一次修改的单位可以是字符、整行，甚至是整个文件。当进入插入模式的那一刻起，直到返回普通模式为止，Vim会记录每一个操作，这些所有的操作在返回普通模式后被统称为一次修改，按<code>.</code>键即可重新执行一次所有操作。</li></ul><h2 id="技巧2-不要自我重复"><a href="#技巧2-不要自我重复" class="headerlink" title="技巧2 不要自我重复"></a>技巧2 不要自我重复</h2><ul><li>用<code>A</code>代替<code>$a</code></li><li>有一些复合命令可以代替等效的长命令（这里还是得多用多记吧，不过这些命令的共同处是都会把普通模式切换到插入模式，本来以为这会让多次连续使用<code>.</code>命令出现问题，但试验之后好像没有？比如按下<code>ko</code>会进入插入模式，但返回普通模式后按<code>.</code>，虽然也换行了但是并没有进入插入模式。）</li></ul><h2 id="技巧3-以退为进"><a href="#技巧3-以退为进" class="headerlink" title="技巧3 以退为进"></a>技巧3 以退为进</h2><ul><li><code>s</code>命令包含两个动作：删除光标处的字符，进入插入模式。</li><li><code>f{char}</code>命令查找该行下一处指定字符出现的位置，如果找到就直接把光标移到该处。而<code>;</code>命令可以重复上次的<code>f{char}</code>命令。</li></ul><h2 id="技巧4-执行、重复、回退"><a href="#技巧4-执行、重复、回退" class="headerlink" title="技巧4 执行、重复、回退"></a>技巧4 执行、重复、回退</h2><ul><li>类似于<code>u</code>可以回退<code>.</code>的修改，<code>,</code>也可以用来回退<code>;</code></li></ul><h2 id="技巧5-查找并手动替换"><a href="#技巧5-查找并手动替换" class="headerlink" title="技巧5 查找并手动替换"></a>技巧5 查找并手动替换</h2><ul><li><code>*</code>命令可以查找当前光标所在单词</li></ul><h2 id="技巧6-结识-范式"><a href="#技巧6-结识-范式" class="headerlink" title="技巧6 结识.范式"></a>技巧6 结识<code>.</code>范式</h2><ul><li>理想模式：一键移动，一键执行。（谨记！）</li></ul><h1 id="二、普通模式"><a href="#二、普通模式" class="headerlink" title="二、普通模式"></a>二、普通模式</h1><h2 id="技巧7-停顿时请移开画笔"><a href="#技巧7-停顿时请移开画笔" class="headerlink" title="技巧7 停顿时请移开画笔"></a>技巧7 停顿时请移开画笔</h2><ul><li>就像画家只花一小部分时间真正画画一样，程序员也只花一小部分时间编写代码，绝大多数时间用来思考，这个时候就是普通模式。（其实用作家码字来比喻可能我更喜欢~）</li></ul><h2 id="技巧8-把撤销单元切成块"><a href="#技巧8-把撤销单元切成块" class="headerlink" title="技巧8 把撤销单元切成块"></a>技巧8 把撤销单元切成块</h2><ul><li>在插入模式中移动光标会重置修改状态，即相当于切回普通模式使用了<code>hjkl</code>，只是看起来没退出插入模式罢了。</li></ul><h2 id="技巧9-构造可重复的修改"><a href="#技巧9-构造可重复的修改" class="headerlink" title="技巧9 构造可重复的修改"></a>技巧9 构造可重复的修改</h2><ul><li>当完成一个修改有多种方法的时候，可以考量不同方法的VimGolf，小者获胜，当VimGolf相同时则可以思考在不同的方法下，继续按<code>.</code>会各自有什么效果，选其中最有价值的那个，即将修改构造成了可重复性的修改。（真是太秀了，忍不住666）</li></ul><h2 id="技巧10-用次数做简单的算数运算"><a href="#技巧10-用次数做简单的算数运算" class="headerlink" title="技巧10 用次数做简单的算数运算"></a>技巧10 用次数做简单的算数运算</h2><ul><li><code>ctrl+a</code>表示+1，<code>ctrl+x</code>表示-1</li></ul><h2 id="技巧11-能够重复，就别用次数"><a href="#技巧11-能够重复，就别用次数" class="headerlink" title="技巧11 能够重复，就别用次数"></a>技巧11 能够重复，就别用次数</h2><ul><li>次数和<code>.</code>命令要斟酌着选择使用</li></ul><h2 id="技巧12-双剑合璧，天下无敌"><a href="#技巧12-双剑合璧，天下无敌" class="headerlink" title="技巧12 双剑合璧，天下无敌"></a>技巧12 双剑合璧，天下无敌</h2><ul><li>操作符 + 动作命令 = 操作</li><li>Vim语法只有一条额外规则，即当一个操作符命令被连续调用两次时，它会作用于当前行。</li></ul><h1 id="三、插入模式"><a href="#三、插入模式" class="headerlink" title="三、插入模式"></a>三、插入模式</h1><h2 id="技巧13-在插入模式下可即时更正错误"><a href="#技巧13-在插入模式下可即时更正错误" class="headerlink" title="技巧13 在插入模式下可即时更正错误"></a>技巧13 在插入模式下可即时更正错误</h2><ul><li><code>ctrl+h</code>删除前一个字符</li><li><code>ctrl+w</code>删除前一个单词</li><li><code>ctrl+u</code>删除至行首</li></ul><h2 id="技巧14-返回普通模式"><a href="#技巧14-返回普通模式" class="headerlink" title="技巧14 返回普通模式"></a>技巧14 返回普通模式</h2><p>可以使用<code>Esc</code>或<code>ctrl+[</code>来返回普通模式，还可以使用<code>ctrl+o</code>切换到插入-普通模式。在插入-普通模式中，可以执行一次普通模式下的命令然后自动变回插入模式。</p><h2 id="技巧15-不离开插入模式，粘贴寄存器中的文本"><a href="#技巧15-不离开插入模式，粘贴寄存器中的文本" class="headerlink" title="技巧15 不离开插入模式，粘贴寄存器中的文本"></a>技巧15 不离开插入模式，粘贴寄存器中的文本</h2><ul><li>看书上的描述，是可以把文本复制到寄存器中，然后再在指定位置把寄存器的文本粘贴出来。具体命令回头再看吧，也记不住。</li></ul><h2 id="技巧16-随时随地做运算"><a href="#技巧16-随时随地做运算" class="headerlink" title="技巧16 随时随地做运算"></a>技巧16 随时随地做运算</h2><ul><li>利用表达式寄存器我们可以做一些运算并把结果直接插入到文本中。输入<code>&lt;ctrl+r&gt;=</code>就可以访问该寄存器，然后输入表达式（如1+1）按回车就可以在光标处插入对应结果了（如2）。</li></ul><h2 id="技巧17-用字符编码插入非常用字符"><a href="#技巧17-用字符编码插入非常用字符" class="headerlink" title="技巧17 用字符编码插入非常用字符"></a>技巧17 用字符编码插入非常用字符</h2><ul><li>Vim可以用字符编码来插入任意字符，使用此功能可以很方便地输入键盘上找不到的符号，只要输入<code>&lt;ctrl+v&gt;{code}</code>即可。</li><li>另外如果想要知道光标处的字符的编码，按<code>ga</code>即可。</li></ul><h2 id="技巧18-用二合字母插入非常用字符"><a href="#技巧18-用二合字母插入非常用字符" class="headerlink" title="技巧18 用二合字母插入非常用字符"></a>技巧18 用二合字母插入非常用字符</h2><ul><li>感觉和技巧17类似，只不过技巧17需要用编码不方便记忆，使用二合字母似乎好记忆一些（它这么说的，我也不敢说啥），命令<code>&lt;ctrl+k&gt;{char1}{char2}</code>。比如<code>&lt;ctrl+k&gt;12</code>就可以输出分数1/2.  </li></ul><h2 id="技巧19-用替换模式替换已有文本"><a href="#技巧19-用替换模式替换已有文本" class="headerlink" title="技巧19 用替换模式替换已有文本"></a>技巧19 用替换模式替换已有文本</h2><ul><li><code>R</code>命令进入替换模式，<code>r</code>替换一个字符并返回普通模式。</li><li>当有制表符的时候用<code>R</code>进入替换模式替换时，会用一个字符替换掉整个制表符所占长度的字符，从而缩减行的长度，这可能不是我们所希望的，这时候可以使用<code>gR</code>命令进入虚拟替换模式来替换，就不会有这样的问题。</li></ul><h1 id="四、可视模式"><a href="#四、可视模式" class="headerlink" title="四、可视模式"></a>四、可视模式</h1><p>Vim具有三种不同的可视模式，分别用于操作字符文本、行文本或块文本。</p><h2 id="技巧20-深入理解可视模式"><a href="#技巧20-深入理解可视模式" class="headerlink" title="技巧20 深入理解可视模式"></a>技巧20 深入理解可视模式</h2><ul><li>在普通模式中，先触发修改命令再选中作用范围，但是在可视模式中是先选中选区，然后再触发命令。注意次序是颠倒的。</li></ul><h2 id="技巧21-选择高亮选区"><a href="#技巧21-选择高亮选区" class="headerlink" title="技巧21 选择高亮选区"></a>技巧21 选择高亮选区</h2><ul><li><code>v</code>切换到面向字符的可视模式，<code>V</code>切换到面向行的可视模式，而<code>&lt;ctrl+v&gt;</code>切换到面向列块的可视模式。<code>gv</code>命令可以重新选择上次可视模式选择的区域。</li><li>可视模式之间的切换也就是按对应的键就行了。</li><li>可视模式选择中可以利用<code>o</code>来切换选区的活动端。</li></ul><h2 id="技巧22-重复执行面向行的可视命令"><a href="#技巧22-重复执行面向行的可视命令" class="headerlink" title="技巧22 重复执行面向行的可视命令"></a>技巧22 重复执行面向行的可视命令</h2><ul><li>合适的场景下可以使用<code>.</code>命令来重复之前面向行的可视命令。</li></ul><h2 id="技巧23-只要可能，最好用操作符命令而不是可视命令"><a href="#技巧23-只要可能，最好用操作符命令而不是可视命令" class="headerlink" title="技巧23 只要可能，最好用操作符命令而不是可视命令"></a>技巧23 只要可能，最好用操作符命令而不是可视命令</h2><ul><li>如果想让<code>.</code>命令能够重复某些有用的工作的话，那么最好不要用可视模式，首选操作符命令。</li></ul><h2 id="技巧24-用面向列块的可视模式编辑表格数据"><a href="#技巧24-用面向列块的可视模式编辑表格数据" class="headerlink" title="技巧24 用面向列块的可视模式编辑表格数据"></a>技巧24 用面向列块的可视模式编辑表格数据</h2><ul><li>这个就是要多练了，熟悉命令就行。</li></ul><h2 id="技巧25-修改列文本"><a href="#技巧25-修改列文本" class="headerlink" title="技巧25 修改列文本"></a>技巧25 修改列文本</h2><h2 id="技巧26-在长短不一的高亮块后添加文本"><a href="#技巧26-在长短不一的高亮块后添加文本" class="headerlink" title="技巧26 在长短不一的高亮块后添加文本"></a>技巧26 在长短不一的高亮块后添加文本</h2><ul><li>从普通模式切换到插入模式时<code>i</code>和<code>a</code>分别表示把光标置于当前字符之前或之后，但是在可视模式或操作符待决模式中，这两个命令被当做一个文本对象的组成部分，想要进入插入模式需要按<code>I</code>或<code>A</code>。</li></ul><h1 id="五、命令行模式"><a href="#五、命令行模式" class="headerlink" title="五、命令行模式"></a>五、命令行模式</h1><p>初时，先有ed，ed为ex之父，ex为vi之父，vi为vim之父。</p><h2 id="技巧27-结识Vim的命令行模式"><a href="#技巧27-结识Vim的命令行模式" class="headerlink" title="技巧27 结识Vim的命令行模式"></a>技巧27 结识Vim的命令行模式</h2><ul><li>命令行模式会提示我们输入一条Ex命令、一个查找模式或一个表达式。</li><li>Ex命令影响相比普通模式下的命令范围更广而且距离更远。</li></ul><h2 id="技巧28-在一行或多个连续行上执行命令"><a href="#技巧28-在一行或多个连续行上执行命令" class="headerlink" title="技巧28 在一行或多个连续行上执行命令"></a>技巧28 在一行或多个连续行上执行命令</h2><ul><li>很多Ex命令可以用[rang]指定要操作的范围，可以用行号、位置标记或是查找模式来指定范围的开始位置及结束位置。</li><li>在Ex命令里，<code>.</code>代表当前行的地址，<code>%</code>代表当前文件的所有行。<code>&#39;&lt;</code>表示选区首行，<code>&#39;&gt;</code>表示选区末行。</li><li>可以用模式指定范围，也可以用偏移（如+1、-1）对地址进行修正。</li><li>总而言之，定义范围的语法很灵活。</li></ul><h2 id="技巧29-使用-t和-m命令复制和移动行"><a href="#技巧29-使用-t和-m命令复制和移动行" class="headerlink" title="技巧29 使用:t和:m命令复制和移动行"></a>技巧29 使用<code>:t</code>和<code>:m</code>命令复制和移动行</h2><ul><li>重复上次的Ex命令非常简单，只需使用<code>@:</code>命令即可。</li></ul><h2 id="技巧30-在指定范围上执行普通模式命令"><a href="#技巧30-在指定范围上执行普通模式命令" class="headerlink" title="技巧30 在指定范围上执行普通模式命令"></a>技巧30 在指定范围上执行普通模式命令</h2><ul><li>如果想在一系列连续行上执行一条普通模式命令，则可以使用<code>:normal</code>。</li><li>在执行普通模式命令之前，Vim会把光标移到行首，因此在执行命令时不需要担心光标的位置。</li></ul><h2 id="技巧31-重复上次的Ex命令"><a href="#技巧31-重复上次的Ex命令" class="headerlink" title="技巧31 重复上次的Ex命令"></a>技巧31 重复上次的Ex命令</h2><ul><li>重复上次的Ex命令非常简单，只需使用<code>@:</code>命令即可。</li><li><code>bnext</code>可以在缓冲区列表项中正向移动，而<code>bprevious</code>则是反向移动。</li></ul><h2 id="技巧32-自动补全Ex命令"><a href="#技巧32-自动补全Ex命令" class="headerlink" title="技巧32 自动补全Ex命令"></a>技巧32 自动补全Ex命令</h2><ul><li>如同在shell中一样，在命令行上也可以用<tab>键自动补全命令。</tab></li><li><code>&lt;ctrl+d&gt;</code>可以显示Vim可用的命令补全列表。</li></ul><h2 id="技巧33-把当前单词插入到命令行"><a href="#技巧33-把当前单词插入到命令行" class="headerlink" title="技巧33 把当前单词插入到命令行"></a>技巧33 把当前单词插入到命令行</h2><ul><li>在Vim的命令行下，<code>&lt;ctrl+r&gt;&lt;ctrl+w&gt;</code>会复制光标下的单词并把它插入到命令行中。</li></ul><h2 id="技巧34-回溯历史命令"><a href="#技巧34-回溯历史命令" class="headerlink" title="技巧34 回溯历史命令"></a>技巧34 回溯历史命令</h2><ul><li>历史命令不仅仅是为当前编辑会话记录的，这些记录即使在退出Vim再重启之后仍然存在。</li><li>输入<code>q:</code>可以打开命令行窗口。在命令行窗口里可以用任何习以为常的动作命令进行移动，也可以在高亮选区上操作，或是切换到插入模式中。可以按<code>:q</code>或者回车来关闭命令行窗口。具体要多练。</li><li>当我们在命令行窗口按回车时，该命令在活动窗口的上下文中执行。所谓活动窗口，指的是打开命令行窗口之前处于活动的那个窗口，要注意。</li></ul><h2 id="技巧35-运行Shell命令"><a href="#技巧35-运行Shell命令" class="headerlink" title="技巧35 运行Shell命令"></a>技巧35 运行Shell命令</h2><ul><li>不用离开Vim就可以方便地调用外部程序，还可以把缓冲区的内容当做标准输入发送给一个外部命令，或是把外部命令的标准输出导入到缓冲区中。</li><li>给命令加一个前缀<code>!</code>号就可以调用外部命令一次。</li><li>如果想要执行多次外部命令，则可以用<code>:shell</code>命令打开一个交互的shell，用<code>exit</code>退出。</li><li>当然也可以用<code>&lt;ctrl+z&gt;</code>把Vim进程挂起，运行完shell命令之后再用<code>jobs</code>和<code>fg</code>命令切换回来。</li><li>可以用<code>:read !{cmd}</code>把外部命令的输出读入到当前缓冲区中。而<code>:write !{cmd}</code>做相反的事，把缓冲区的内容作为外部命令的输入。但要注意的是在write中感叹号位置不同表示的含义有所不同，<code>:write! sh</code>会把缓冲区内容写入到一个名为sh的文件中，叹号表示无论如何都覆盖。</li><li><code>:[range]!{filter}</code>可以实现某个范围内的过滤，意思是把该范围内的内容作为标准输入，处理之后再把结果输出到该范围之内。</li></ul><h1 id="六、管理多个文件"><a href="#六、管理多个文件" class="headerlink" title="六、管理多个文件"></a>六、管理多个文件</h1><h2 id="技巧36-用缓冲区列表管理打开的文件"><a href="#技巧36-用缓冲区列表管理打开的文件" class="headerlink" title="技巧36 用缓冲区列表管理打开的文件"></a>技巧36 用缓冲区列表管理打开的文件</h2><ul><li>在一次的编辑会话中，可以打开多个文件，用Vim的缓冲区列表可以对这些文件进行管理。</li><li>Vim允许同时在多个缓冲区上工作，打开多个文件后可以用<code>:ls</code>命令查看所有被载入到内存中的缓冲区的列表，然后用<code>:bnext</code>命令切换到列表中的下一个缓冲区，<code>:bprev</code>切换到前一个，此外还有<code>:bfirst</code>和<code>:blast</code>两个命令也可以切换。</li><li>使用<code>:ls</code>命令时，#符号表示轮换文件，可以用<code>&lt;ctrl+^&gt;</code>来切换到#所指文件。</li></ul><h2 id="技巧37-用参数列表将缓冲区分组"><a href="#技巧37-用参数列表将缓冲区分组" class="headerlink" title="技巧37 用参数列表将缓冲区分组"></a>技巧37 用参数列表将缓冲区分组</h2><ul><li>参数列表易于管理，适用于对一批文件进行分组，使其更容易访问。用<code>:argdo</code>命令可以在参数列表中的每个文件上执行一条Ex命令。</li><li>可以用<code>:args {argList}</code>来填充参数列表，argList也可以使用模式来指定，还可以使用反引号。比如args  `cat .chapters` 就会先在shell中执行<code>cat .chapters</code>命令，然后将该命令的输出作为args的参数。</li></ul><h2 id="技巧38-管理隐藏缓冲区"><a href="#技巧38-管理隐藏缓冲区" class="headerlink" title="技巧38 管理隐藏缓冲区"></a>技巧38 管理隐藏缓冲区</h2><ul><li>打开多个缓冲区后，如果修改了某个缓冲区，再使用<code>:bnext</code>时会提醒当前缓冲区中有未保存的改动，可以加上<code>!</code>来强制切换，也可以保存后再切换。如果选择了强制切换，那么在退出时需要再次处理每个缓冲区，可以用<code>qa!</code>摒弃所有改动，也可以用<code>:wa!</code>把所有改动写入磁盘。</li><li>大多数情况下Vim提醒缓冲区改动未保存是一个好事，但是当涉及到<code>:argdo</code>或者<code>:bufdo</code>等命令时则很不方便，所以在使用这些命令前可以启动<code>hidden</code>选项，最后退出时再处理。</li></ul><h2 id="技巧39-将工作区切分成窗口"><a href="#技巧39-将工作区切分成窗口" class="headerlink" title="技巧39 将工作区切分成窗口"></a>技巧39 将工作区切分成窗口</h2><ul><li>Vim允许我们将工作区切分成多个若干窗口，在窗口里并排显示多个缓冲区。</li><li><code>&lt;ctrl+w&gt;s</code>水平切割窗口，<code>&lt;ctrl+w&gt;v</code>垂直切割窗口。</li><li><code>close</code>命令可以关闭活动窗口，<code>only</code>命令可以只保留活动窗口而关闭其他窗口。</li></ul><h2 id="技巧40-用标签页将窗口分组"><a href="#技巧40-用标签页将窗口分组" class="headerlink" title="技巧40 用标签页将窗口分组"></a>技巧40 用标签页将窗口分组</h2><ul><li>标签页的这部分看的不是特别明白，书中也没有给出好的例子。以后再说吧。</li></ul><h1 id="七、打开及保存文件"><a href="#七、打开及保存文件" class="headerlink" title="七、打开及保存文件"></a>七、打开及保存文件</h1><h2 id="技巧41-用-edit命令打开文件"><a href="#技巧41-用-edit命令打开文件" class="headerlink" title="技巧41 用:edit命令打开文件"></a>技巧41 用<code>:edit</code>命令打开文件</h2><ul><li>在Vim中，可以用<code>:edit</code>命令通过文件的绝对或相对路径来打开文件。</li><li><code>%</code>符号代表活动缓冲区的完整文件路径，按<code>Tab</code>键可以将其展开。<code>%:h</code>则可以显示去掉文件名的活动缓冲区完整文件路径。</li></ul><h2 id="技巧42-使用-find打开文件"><a href="#技巧42-使用-find打开文件" class="headerlink" title="技巧42 使用:find打开文件"></a>技巧42 使用<code>:find</code>打开文件</h2><ul><li>这个技巧里讲的主要是配置path，然后就可以用<code>find</code>命令来打开文件了。</li></ul><h2 id="技巧43-使用netrw管理文件系统"><a href="#技巧43-使用netrw管理文件系统" class="headerlink" title="技巧43 使用netrw管理文件系统"></a>技巧43 使用netrw管理文件系统</h2><ul><li>Vim还可以查看目录，netrw就是它自带的文件管理器插件。</li><li>可以用<code>:edit {path}</code>打开文件管理器窗口。此外，<code>:Explore</code>命令也可以打开文件管理器窗口，并显示活动缓冲区所在的目录。</li><li>可以与分割窗口协同工作</li></ul><h2 id="技巧44-把文件保存到不存在的目录中"><a href="#技巧44-把文件保存到不存在的目录中" class="headerlink" title="技巧44 把文件保存到不存在的目录中"></a>技巧44 把文件保存到不存在的目录中</h2><ul><li>当用<code>:edit {file}</code>命令打开未存在的目录中的未存在文件时，不能直接保存，需要先创建该目录，可以用<code>:!mkdir %:h</code>命令。</li></ul><h2 id="技巧45-以超级用户权限保存文件"><a href="#技巧45-以超级用户权限保存文件" class="headerlink" title="技巧45 以超级用户权限保存文件"></a>技巧45 以超级用户权限保存文件</h2><ul><li>这个就不管了，感觉不太会用到，记一下书中用到的命令好了<code>:w !sudo tee % &gt; /dev/null</code>。</li></ul><h1 id="八、用动作命令在文档中移动"><a href="#八、用动作命令在文档中移动" class="headerlink" title="八、用动作命令在文档中移动"></a>八、用动作命令在文档中移动</h1><ul><li>可以通过<code>:h motion.txt</code>获得完整的动作命令列表</li></ul><h2 id="技巧46-让手指保持在本位行上"><a href="#技巧46-让手指保持在本位行上" class="headerlink" title="技巧46 让手指保持在本位行上"></a>技巧46 让手指保持在本位行上</h2><ul><li>用<code>hjkl</code>移动，戒掉使用光标键的习惯，可以在vimrc里添加对应的辅助设置，p102</li></ul><h2 id="技巧47-区分实际行与屏幕行"><a href="#技巧47-区分实际行与屏幕行" class="headerlink" title="技巧47 区分实际行与屏幕行"></a>技巧47 区分实际行与屏幕行</h2><ul><li>所谓实际行说的是真正的行，屏幕行则是因为屏幕宽度限制而出现的行</li><li><code>hjkl0$</code>命令都是针对实际行的，前缀加<code>g</code>就能对应命令改为针对屏幕行的。</li></ul><h2 id="技巧48-基于单词移动"><a href="#技巧48-基于单词移动" class="headerlink" title="技巧48 基于单词移动"></a>技巧48 基于单词移动</h2><ul><li><code>wbe</code>是基于单词的移动动作，对应的<code>WBE</code>则是针对子串的移动动作。</li></ul><h2 id="技巧49-对字符进行查找"><a href="#技巧49-对字符进行查找" class="headerlink" title="技巧49 对字符进行查找"></a>技巧49 对字符进行查找</h2><ul><li><code>f{char}</code>是在Vim里移动最快的方式之一，它会在光标与行尾之间搜寻指定的字符，找到了就移过去。</li><li><code>;</code>可以重复上一次的<code>f{char}</code>命令，<code>,</code>可以反向跳。</li><li><code>t{char}</code>正向移动到下一个{char}所在之处的前一个字符上，<code>T{char</code>反向移动到char的后一个字符上。</li><li>使用这些命令的时候，要学会找到频率少的单词，这样才能提高移动效率。</li></ul><h2 id="技巧50-通过查找进行移动"><a href="#技巧50-通过查找进行移动" class="headerlink" title="技巧50 通过查找进行移动"></a>技巧50 通过查找进行移动</h2><ul><li>用<code>/</code>来进行查找并移动光标</li><li>还可以将操作文本的动作和查找结合在一起。</li></ul><h2 id="技巧51-用精确的文本对象选择选区"><a href="#技巧51-用精确的文本对象选择选区" class="headerlink" title="技巧51 用精确的文本对象选择选区"></a>技巧51 用精确的文本对象选择选区</h2><ul><li>文本对象允许操作括号、被引用的文本、XML标签以及其他文本中的常见结构。</li><li>Vim的文本对象由两个字符组成，第一个字符永远是<code>i</code>或者<code>a</code>。以<code>i</code>开头的文本对象会选择分隔符内部的文本，而以<code>a</code>开头的文本对象则会选择包括分隔符在内的整个文本。具体可以用到的时候再说吧。</li></ul><h2 id="技巧52-删除周边，修改内部"><a href="#技巧52-删除周边，修改内部" class="headerlink" title="技巧52 删除周边，修改内部"></a>技巧52 删除周边，修改内部</h2><ul><li>除了被括号或引号括起来的分隔符文本对象，还有另外一种范围文本对象，可以操作一个单词、一个子串、一个句子、一个段落。具体命令可以看书p117</li></ul><h2 id="技巧53-设置位置标记，以便快速跳回"><a href="#技巧53-设置位置标记，以便快速跳回" class="headerlink" title="技巧53 设置位置标记，以便快速跳回"></a>技巧53 设置位置标记，以便快速跳回</h2><ul><li>可以用<code>m{a-zA-Z}</code>标记当前光标所在位置，然后用`{a-zA-Z}命令跳回来。</li></ul><h2 id="技巧54-在匹配括号间跳转"><a href="#技巧54-在匹配括号间跳转" class="headerlink" title="技巧54 在匹配括号间跳转"></a>技巧54 在匹配括号间跳转</h2><ul><li><code>%</code>命令可以在成对的括号间跳转</li><li>Vim在发布时携带一个名为matchit的插件，可以用来在配对的关键字之间跳转，还有个Surround.vim的插件，可以很容易地给选中的文本加分隔符。</li></ul><h1 id="九-在文件间跳转"><a href="#九-在文件间跳转" class="headerlink" title="九 在文件间跳转"></a>九 在文件间跳转</h1><h2 id="技巧55-遍历跳转列表"><a href="#技巧55-遍历跳转列表" class="headerlink" title="技巧55 遍历跳转列表"></a>技巧55 遍历跳转列表</h2><ul><li>可以用<code>jumps</code>查看跳转列表的内容</li><li>大于等于句子级别的动作命令会被当做跳转，小范围的动作命令则只是移动。</li></ul><h2 id="技巧56-遍历改变列表"><a href="#技巧56-遍历改变列表" class="headerlink" title="技巧56 遍历改变列表"></a>技巧56 遍历改变列表</h2><ul><li>每当对文档做出修改后，Vim都会记录当时光标所在的位置。</li><li><code>changes</code>命令可以查看改变列表的内容。可以用<code>g;</code>和<code>g,</code>命令来反向或正向遍历改变列表。</li><li>`.总会跳到指向上次修改的地方。</li><li>`^标记指向上次插入的地方。</li></ul><h2 id="技巧57-跳转到光标下的文件"><a href="#技巧57-跳转到光标下的文件" class="headerlink" title="技巧57 跳转到光标下的文件"></a>技巧57 跳转到光标下的文件</h2><ul><li>Vim会把文档中的文件名当成一个超链接，在进行了正确的配置之后，就可以用<code>gf</code>命令跳转到光标下的文件了。</li><li>跳转列表和改变列表允许我们原路返回，而<code>gf</code>和<code>&lt;ctrl+]&gt;</code>则像虫洞，可以把我们从代码的一个地方传送到另一个文件地方。</li></ul><h2 id="技巧58-用全局位置标记在文件间快速跳转"><a href="#技巧58-用全局位置标记在文件间快速跳转" class="headerlink" title="技巧58 用全局位置标记在文件间快速跳转"></a>技巧58 用全局位置标记在文件间快速跳转</h2><ul><li><code>m{A-Z}</code>可以设置一个全局标签，这对使用vimgrep等命令跳转到其他地方后想要再跳回来很有帮助，要养成在跳转前考虑是否需要全局标签的习惯。</li></ul><h1 id="十、复制与粘贴"><a href="#十、复制与粘贴" class="headerlink" title="十、复制与粘贴"></a>十、复制与粘贴</h1><ul><li>Vim的寄存器是一组用于保存文本的简单容器。它们既可以像剪贴板那样，剪切、复制和粘贴文本；也可以记录一系列按键操作，把它们录制成宏。</li></ul><h2 id="技巧59-用无名寄存器实现删除、复制与粘贴操作"><a href="#技巧59-用无名寄存器实现删除、复制与粘贴操作" class="headerlink" title="技巧59 用无名寄存器实现删除、复制与粘贴操作"></a>技巧59 用无名寄存器实现删除、复制与粘贴操作</h2><ul><li>在Vim的术语里，当提到剪切、复制与粘贴时，指的不是剪贴板而是寄存器。比如<code>xp</code>命令，先删除光标下的字符，然后粘贴到下一个字符之后，连起来的作用就是将光标下的字符和下一个字符交换位置。同理，<code>ddp</code>命令可以用来交换两行的顺序。</li></ul><h2 id="技巧60-深入理解Vim寄存器"><a href="#技巧60-深入理解Vim寄存器" class="headerlink" title="技巧60 深入理解Vim寄存器"></a>技巧60 深入理解Vim寄存器</h2><ul><li>Vim不使用单一的剪贴板进行剪切、复制和粘贴，而是为这些操作提供了多组寄存器。</li><li>Vim的删除、复制和粘贴命令都会用到众多寄存器中的一个，可以通过给命令加<code>&quot;{register}</code>前缀的方式指定要用的寄存器，若不指定则默认使用无名寄存器。</li><li>显式调用无名寄存器时要用<code>&quot;&quot;</code></li><li>复制专用寄存器<code>&quot;0</code>，要复制的文本不仅会被拷贝到无名寄存器中，而且也会被拷贝到复制专用寄存器中，仅当使用<code>y{motion}</code>命令时才会被赋值。使用<code>:reg &quot;0</code>则可以查看该寄存器的内容。</li><li>有名寄存器(“a-“z)。用小写字母引用有名寄存器，会覆盖该寄存器的原有内容，而换用大写字母时，则会将新内容append到原内容后面。</li><li>黑洞寄存器(_ )可以真正删除文本，命令如<code>&quot;_dd</code>可以删除整行而不复制到寄存器里去。黑洞寄存器是个有去无回的地方。</li><li>系统剪贴板<code>&quot;+</code>，如果要从Vim复制文本到外部程序（反之亦然），则需要使用系统剪贴板。还有一个<code>&quot;*</code>表示X11主剪贴板，用鼠标中键操作（Win和MacOS没有）。</li><li>表达式寄存器<code>&quot;=</code>，其他寄存器通常被认为是保存一段文本的容器，然后通过表达式寄存器是个例外。从表达式寄存器获取内容时，Vim将跳转到命令行模式，并显示提示符<code>=</code>，这时可以输入一段Vim脚本表达式执行，将会返回结果。</li><li>还有几组可被隐式赋值的寄存器，只读。当前文件名<code>&quot;%</code>。轮换文件名<code>&quot;#</code>。上次插入的文本<code>&quot;.</code>。上次执行的Ex命令<code>&quot;:</code>。上次查找的模式<code>&quot;/</code>。技术上讲/寄存器并非只读，可以用<code>:let</code>命令赋值，但为方便仍归于此类。</li></ul><h2 id="技巧61-用寄存器的内容替换高亮选区的文本"><a href="#技巧61-用寄存器的内容替换高亮选区的文本" class="headerlink" title="技巧61 用寄存器的内容替换高亮选区的文本"></a>技巧61 用寄存器的内容替换高亮选区的文本</h2><ul><li>Vim的粘贴命令在可视模式下使用时，会体现出一些不同寻常的特性。在可视模式下使用p，将用我们指定的寄存器来替换高亮选区的文本。</li><li>使用p命令的时候，会先从寄存器里取出内容，然后把高亮选区的内容存入无名寄存器。</li></ul><h2 id="技巧62-把寄存器的内容粘贴出来"><a href="#技巧62-把寄存器的内容粘贴出来" class="headerlink" title="技巧62 把寄存器的内容粘贴出来"></a>技巧62 把寄存器的内容粘贴出来</h2><ul><li>面向行的复制或删除操作将创建面向行的寄存器，而面向字符的复制或者删除操作则会创建面向字符的寄存器。</li></ul><h2 id="技巧63-与系统剪贴板进行交互"><a href="#技巧63-与系统剪贴板进行交互" class="headerlink" title="技巧63 与系统剪贴板进行交互"></a>技巧63 与系统剪贴板进行交互</h2><ul><li>在Vim里使用系统粘贴版粘贴的时候往往缩进会出问题，为了解决这个问题，可以使用<code>:set paste</code>命令，然后切换到插入模式下进行粘贴，粘贴完再用<code>:set paste!</code>切换回来。</li><li>可以用<code>:set pastetoggle=&lt;F5&gt;</code>来做个映射，以后按F5就可以切换paste。</li></ul><h1 id="十一、宏"><a href="#十一、宏" class="headerlink" title="十一、宏"></a>十一、宏</h1><ul><li>可以用宏来把任意数目的按键操作录制到寄存器，用于之后的回放。<h2 id="技巧64-宏的读取与执行"><a href="#技巧64-宏的读取与执行" class="headerlink" title="技巧64 宏的读取与执行"></a>技巧64 宏的读取与执行</h2></li><li><code>q</code>是录制宏的开始与结束。比如<code>qa</code>会把接下来的一组命令保存在有名寄存器a里面。</li><li>可以使用<code>reg a</code>来查看寄存器a的内容。</li><li>可以使用<code>@{register}</code>来调用对应寄存器里保存的宏，用<code>@@</code>来重复上次调用过的宏命令。</li><li>在多次执行某个宏的时候有串行和并行两种方式，串行是一次一次执行，报错则停止，并行并不是真正的并行，只是说有一次执行出错的时候不会影响其他的宏。</li></ul><h2 id="技巧65-规范光标位置、直达目标以及中止宏"><a href="#技巧65-规范光标位置、直达目标以及中止宏" class="headerlink" title="技巧65 规范光标位置、直达目标以及中止宏"></a>技巧65 规范光标位置、直达目标以及中止宏</h2><ul><li>黄金法则：在录制一个宏时，要确保每条命令都可被重复执行。</li><li>一旦开始录制宏，就要问自己几个问题：我在哪？我从哪里来？我要去哪里？</li><li>规范光标的位置</li><li>用可重复的动作命令直达目标</li><li>当动作命令失败时，宏将中止。这种实现的好处在于在执行宏时，可以不顾忌执行的次数。</li></ul><h2 id="技巧66-加次数回放宏"><a href="#技巧66-加次数回放宏" class="headerlink" title="技巧66 加次数回放宏"></a>技巧66 加次数回放宏</h2><ul><li>对于次数不多的工作，可以用点范式，但它不能指定执行的次数。为了克服该限制，我们可以录制一个廉价的一次性的宏，然后再加次数进行回放。</li><li>不是每个宏都能用估算次数的方法调用。</li></ul><h2 id="技巧67-在连续的文本上重复修改"><a href="#技巧67-在连续的文本上重复修改" class="headerlink" title="技巧67 在连续的文本上重复修改"></a>技巧67 在连续的文本上重复修改</h2><ul><li>将下一个单词的首字母变为大写：<code>w~</code></li><li>以串行方式执行宏，类似于数字方法：<code>3@a</code></li><li>以并行方式执行宏，利用高亮选区，然后调用宏，在每一行上进行宏操作，这样就是并行方式，在书中的例子里，会比串行方式少一个j操作。p157</li></ul><h2 id="技巧68-给宏追加命令"><a href="#技巧68-给宏追加命令" class="headerlink" title="技巧68  给宏追加命令"></a>技巧68  给宏追加命令</h2><ul><li><code>q</code>后面跟大写字母，Vim会把后续的的按键操作附加到对应小写寄存器的内容后面。可以用这种方式来修正录制的宏的错误（但一般只能弥补结尾漏命令的情况）。</li></ul><h2 id="技巧69-在一组文件中执行宏"><a href="#技巧69-在一组文件中执行宏" class="headerlink" title="技巧69 在一组文件中执行宏"></a>技巧69 在一组文件中执行宏</h2><ul><li>利用<code>argdo</code>一系列命令，串行就是在宏里面录制一个next命令，使命令得以串行执行下去，而并行就是对选择的所有文件执行同一个命令，就是这个意思吧……具体命令还是以后再说吧。</li></ul><h2 id="技巧70-用迭代求值的方式给列表编号"><a href="#技巧70-用迭代求值的方式给列表编号" class="headerlink" title="技巧70 用迭代求值的方式给列表编号"></a>技巧70 用迭代求值的方式给列表编号</h2><ul><li>技巧10里提到过<code>&lt;ctrl+a&gt;</code>和<code>&lt;ctrl+x&gt;</code>两个简单计算方式</li><li>通过使用<code>:let i=0</code>命令，可以创建一个名为i的变量，并给其赋值0。</li></ul><h2 id="技巧71-编辑宏的内容"><a href="#技巧71-编辑宏的内容" class="headerlink" title="技巧71 编辑宏的内容"></a>技巧71 编辑宏的内容</h2><ul><li>为了修改宏的内容，可以先跳到文档最后，使用类似<code>:put a</code>的命令把某个寄存器中的值复制到文本里，然后对该文本进行就该，最后再把文本考回寄存器中，使用<code>0</code>和<code>&quot;ay$</code>命令将该行命令整个重新复制到寄存器a中，之所以不用<code>&quot;add</code>是因为这会把该行最后的回车符也拷贝进寄存器，而这有时候会产生问题。</li></ul><h1 id="十一、按模式匹配及按原义匹配"><a href="#十一、按模式匹配及按原义匹配" class="headerlink" title="十一、按模式匹配及按原义匹配"></a>十一、按模式匹配及按原义匹配</h1><h2 id="技巧72-调整查找模式的大小写敏感性"><a href="#技巧72-调整查找模式的大小写敏感性" class="headerlink" title="技巧72 调整查找模式的大小写敏感性"></a>技巧72 调整查找模式的大小写敏感性</h2><ul><li>既可以全局性地调整Vim查找功能的大小写敏感性，也可以在每次查找时进行局部调整。</li><li>如果启用<code>ignorecase</code>，Vim将不会区分大小写。</li><li>通过使用元字符\c或者\C则可以在本次查找中覆盖Vim的全局设置，\c忽略大小写，\C强制大小写。</li><li>Vim还有一个更智能的大小写敏感性设置，就是<code>smartcase</code>，当该选项被启用时，只要在查找模式中输入了大写字母，<code>ignorecase</code>设置就不再生效。换句话说，如果查找模式全是小写的，则忽略大小写，但只要有一个大写字母，就会区分大小写。</li></ul><h2 id="技巧73-按正则表达式查找时，使用-v模式开关"><a href="#技巧73-按正则表达式查找时，使用-v模式开关" class="headerlink" title="技巧73 按正则表达式查找时，使用\v模式开关"></a>技巧73 按正则表达式查找时，使用\v模式开关</h2><ul><li>正则表达式学得不咋地，以后再看。</li></ul><h2 id="技巧74-按照原义查找文本时，使用-V原义开关"><a href="#技巧74-按照原义查找文本时，使用-V原义开关" class="headerlink" title="技巧74 按照原义查找文本时，使用\V原义开关"></a>技巧74 按照原义查找文本时，使用\V原义开关</h2><ul><li>比如<code>/ \Va.k.a.</code>查找命令只会匹配a.k.a，不会再利用.的特殊含义去匹配类似backward的词。</li></ul><h2 id="技巧75-使用圆括号捕获子匹配"><a href="#技巧75-使用圆括号捕获子匹配" class="headerlink" title="技巧75 使用圆括号捕获子匹配"></a>技巧75 使用圆括号捕获子匹配</h2><ul><li><code>\_s</code>会匹配空白字符</li></ul><h2 id="技巧76-界定单词的边界"><a href="#技巧76-界定单词的边界" class="headerlink" title="技巧76 界定单词的边界"></a>技巧76 界定单词的边界</h2><ul><li>在very magic搜索模式下，用&lt;和&gt;符号表示单词定界符。</li><li>可以在圆括号前面加上%来匹配却不将其内容捕获保存给寄存器。</li></ul><h2 id="技巧77-界定匹配的边界"><a href="#技巧77-界定匹配的边界" class="headerlink" title="技巧77 界定匹配的边界"></a>技巧77 界定匹配的边界</h2><ul><li>有时候我们想指定一个范围较广的模式，但只对匹配结果的一部分感兴趣。Vim中的元字符\zs和\ze可以帮助我们处理这种情况。</li><li>比如查找模式为：<code>/Practical \zsVim\ze</code>，则只有跟在Practical后面的Vim会被高亮查到。</li></ul><h2 id="技巧78-转义问题字符"><a href="#技巧78-转义问题字符" class="headerlink" title="技巧78 转义问题字符"></a>技巧78 转义问题字符</h2><ul><li>‘\?/‘等字符需要手动转义，也可以使用vim自带的函数escape和getcmdtype，并借助表达式寄存器来解决，知道就行了。</li><li>在VIM脚本中，<code>.</code>操作符用来连接字符串。</li></ul><h1 id="十三、查找"><a href="#十三、查找" class="headerlink" title="十三、查找"></a>十三、查找</h1><h2 id="技巧79-结识查找命令"><a href="#技巧79-结识查找命令" class="headerlink" title="技巧79 结识查找命令"></a>技巧79 结识查找命令</h2><ul><li>如果只想在当前光标位置至文档结尾的范围内查找，而不想循环绕回去的话，可以关闭<code>wrapscan</code>选项。</li><li>如果不提供模式而直接查找，Vim将重用上一次查找的模式。</li></ul><h2 id="技巧80-高亮查找匹配"><a href="#技巧80-高亮查找匹配" class="headerlink" title="技巧80 高亮查找匹配"></a>技巧80 高亮查找匹配</h2><ul><li>启用<code>hlsearch</code>选项可以高亮</li></ul><h2 id="技巧81-在执行查找前预览第一处匹配"><a href="#技巧81-在执行查找前预览第一处匹配" class="headerlink" title="技巧81 在执行查找前预览第一处匹配"></a>技巧81 在执行查找前预览第一处匹配</h2><ul><li><code>incsearch</code>选项可以让Vim在真正执行查找命令前预览第一处匹配。</li><li>该技巧也可以用来检查是否存在一处匹配。</li><li>快捷键<code>&lt;ctrl+r&gt;&lt;ctrl+w&gt;</code>会根据当前预览的匹配结果对查找域进行自动补全。不过如果使用了元字符\v则该快捷键会有些瑕疵。</li></ul><h2 id="技巧82-统计当前模式的匹配个数"><a href="#技巧82-统计当前模式的匹配个数" class="headerlink" title="技巧82 统计当前模式的匹配个数"></a>技巧82 统计当前模式的匹配个数</h2><ul><li><code>:%s///gn</code>可以统计次数，查找域用的是上次的查找模式，n会抑制正常的替换作用，改为简单的技术，所以替换域留空即可。</li></ul><h2 id="技巧83-将光标偏移到查找匹配的结尾"><a href="#技巧83-将光标偏移到查找匹配的结尾" class="headerlink" title="技巧83 将光标偏移到查找匹配的结尾"></a>技巧83 将光标偏移到查找匹配的结尾</h2><ul><li>查找模式后面跟/e可以将光标偏移到匹配的结尾处。</li></ul><h2 id="技巧84-对完整的查找匹配进行操作"><a href="#技巧84-对完整的查找匹配进行操作" class="headerlink" title="技巧84 对完整的查找匹配进行操作"></a>技巧84 对完整的查找匹配进行操作</h2><ul><li>感觉就是在查找模式中利用\e、f{char}之类的标志位或命令选中完整的匹配。</li></ul><h2 id="技巧85-利用查找历史，迭代完成复杂的模式"><a href="#技巧85-利用查找历史，迭代完成复杂的模式" class="headerlink" title="技巧85 利用查找历史，迭代完成复杂的模式"></a>技巧85 利用查找历史，迭代完成复杂的模式</h2><ul><li><code>q/</code>可以唤出命令历史。</li><li>需要捕获引号括起来的内容的时候就记得可以用\1这种寄存器。</li></ul><h2 id="技巧86-查找当前高亮选区中的文本"><a href="#技巧86-查找当前高亮选区中的文本" class="headerlink" title="技巧86 查找当前高亮选区中的文本"></a>技巧86 查找当前高亮选区中的文本</h2><ul><li>这个目前可以忽略吧。</li></ul><h1 id="十四、替换"><a href="#十四、替换" class="headerlink" title="十四、替换"></a>十四、替换</h1><h2 id="技巧87-结识substitute命令"><a href="#技巧87-结识substitute命令" class="headerlink" title="技巧87 结识substitute命令"></a>技巧87 结识substitute命令</h2><ul><li>基本的替换语法如下：<code>:[range]s[ubstitute]/{pattern}/{string}/[flags]</code></li></ul><h2 id="技巧88-在文件范围内查找并替换每一处匹配"><a href="#技巧88-在文件范围内查找并替换每一处匹配" class="headerlink" title="技巧88 在文件范围内查找并替换每一处匹配"></a>技巧88 在文件范围内查找并替换每一处匹配</h2><ul><li>缺省情况下，substitute命令只会作用于当前行且只修改第一处匹配。</li><li>/g标志位可以使替换命令修改一整行的所有匹配，range域填%即可使其作用于所有每一行，两者结合就是全局替换。</li></ul><h2 id="技巧89-手动控制每一次替换操作"><a href="#技巧89-手动控制每一次替换操作" class="headerlink" title="技巧89 手动控制每一次替换操作"></a>技巧89 手动控制每一次替换操作</h2><ul><li>/c标志位让我们可以控制每一次匹配的地方是否需要进行替换。</li></ul><h2 id="技巧90-重用上次的查找模式"><a href="#技巧90-重用上次的查找模式" class="headerlink" title="技巧90 重用上次的查找模式"></a>技巧90 重用上次的查找模式</h2><ul><li>将查找域留空，可以使Vim重用上次的查找模式。</li><li>需要注意，把查找域留空，会在命令历史中留下一项不完整的记录。这在有些时候会带来不便，因为查找模式的命令和替换操作的命令所保存的地方不一样。</li></ul><h2 id="技巧91-用寄存器的内容替换"><a href="#技巧91-用寄存器的内容替换" class="headerlink" title="技巧91 用寄存器的内容替换"></a>技巧91 用寄存器的内容替换</h2><ul><li>如果某段文本已经在当前文档中出现过，我们可以先把它复制到寄存器，再通过传值或引用的方式将寄存器的内容应用到替换域。</li><li>假设我们已经复制了多行文本到寄存器0中，现在需要在替换域中使用这份内容，则可以使用<code>:%s//\=@0/g</code>。<code>\=</code>表示Vim将执行一段表达式脚本。</li></ul><h2 id="技巧92-重复上一次的substitute命令"><a href="#技巧92-重复上一次的substitute命令" class="headerlink" title="技巧92 重复上一次的substitute命令"></a>技巧92 重复上一次的substitute命令</h2><ul><li>假如我们刚刚执行完一条替换命令，突然意识到了失误，应该加上%才对，这时可以使用<code>g&amp;</code>，这条命令等价于<code>:%s//~/&amp;</code>，即可在整个文件的范围内重复该条命令。</li><li>总是可以指定一个新的范围，并使用<code>:&amp;&amp;</code>命令重新执行替换操作。</li><li>&amp;命令是:s命令的同义词，用于重复上一次的替换操作。但遗憾的是，不论上次使用的是什么标志位，&amp;命令都将忽略他们。所以我们会用:&amp;&amp;，后一个&amp;命令会保留标志位。</li></ul><h2 id="技巧93-使用子匹配重排CSV文件的字段"><a href="#技巧93-使用子匹配重排CSV文件的字段" class="headerlink" title="技巧93 使用子匹配重排CSV文件的字段"></a>技巧93 使用子匹配重排CSV文件的字段</h2><ul><li>可以在查找模式中利用()捕获子匹配，并在替换域中引用它们。</li></ul><h2 id="技巧94-在替换过程中执行算术运算"><a href="#技巧94-在替换过程中执行算术运算" class="headerlink" title="技巧94 在替换过程中执行算术运算"></a>技巧94 在替换过程中执行算术运算</h2><ul><li>替换域中的内容不一定非得是简单的字符串，我们可以执行一段Vim脚本表达式，然后用其结果充当字符串使用。</li><li>一般是先用正则表达式匹配我们要替换的区域，然后使用表达式寄存器，调用函数submatch(0)进行操作。</li></ul><h2 id="技巧95-交换两个或更多的单词"><a href="#技巧95-交换两个或更多的单词" class="headerlink" title="技巧95 交换两个或更多的单词"></a>技巧95 交换两个或更多的单词</h2><ul><li>越来越复杂了，有点搞不定了。选择，替换。</li></ul><h2 id="技巧96-在多个文件中执行查找与替换"><a href="#技巧96-在多个文件中执行查找与替换" class="headerlink" title="技巧96 在多个文件中执行查找与替换"></a>技巧96 在多个文件中执行查找与替换</h2><ul><li>Vim没有直接提供这样的功能，只能通过一些简单命令的组合，间接来实现这种功能。</li><li>有一种方法可以用<code>:argdo</code>命令，先打开所有文件，然后用该命令去替换。</li><li>但这会打开很多多余文件，还有一种方法，可以先选择匹配查找模式的文件，然后再在这些文件上执行命令。涉及到什么quickfix列表、copen命令，暂时不用管吧。</li></ul><h1 id="十五、global命令"><a href="#十五、global命令" class="headerlink" title="十五、global命令"></a>十五、global命令</h1><h2 id="技巧97-结识global命令"><a href="#技巧97-结识global命令" class="headerlink" title="技巧97 结识global命令"></a>技巧97 结识global命令</h2><ul><li><code>:global</code>命令结合了Ex命令和Vim的模式匹配两种功能，允许我们在某个指定模式的所有匹配行上执行Ex命令，语法如下<code>:[range] global[!] /{pattern}/ [cmd]</code></li><li>缺省情况下，global命令的作用范围是整个文件。</li><li>global!或者vglobal命令表示反转，会在没有匹配到模式的行上执行cmd命令。</li></ul><h2 id="技巧98-删除所有包含模式的文本行"><a href="#技巧98-删除所有包含模式的文本行" class="headerlink" title="技巧98 删除所有包含模式的文本行"></a>技巧98 删除所有包含模式的文本行</h2><ul><li>将<code>:global</code>和<code>:delete</code>命令一起组合使用，可快速剪裁文本。</li><li>用<code>:g/re/d</code>可以删除匹配的所有行，相反<code>:v/re/d</code>可以删除不匹配的所有行。</li><li>其实grep命令即是<code>:g/re/p</code>，这样就能记住了。</li></ul><h2 id="技巧99-将TODO项收集至寄存器"><a href="#技巧99-将TODO项收集至寄存器" class="headerlink" title="技巧99 将TODO项收集至寄存器"></a>技巧99 将TODO项收集至寄存器</h2><ul><li>和上条相似，将<code>:global</code>和<code>:yank</code>一起组合使用，就可以把匹配项文本行收集到某个寄存器中。</li><li><code>:t</code>命令见技巧29，主要是把一些内容显示到文本结尾，不想影响寄存器内容的时候可以用。</li></ul><h2 id="技巧100-将CSS文件中所有规则的属性按照字母排序"><a href="#技巧100-将CSS文件中所有规则的属性按照字母排序" class="headerlink" title="技巧100 将CSS文件中所有规则的属性按照字母排序"></a>技巧100 将CSS文件中所有规则的属性按照字母排序</h2><ul><li><code>:global</code>的广义模式<code>:g/{start}/ .,{finish} [cmd]</code>，可以理解成从start开始，到finish结束的所有行进行指定的cmd操作。<code>.</code>在这里表示当前行。</li></ul><h1 id="十六、通过ctags建立索引，并引用其浏览源代码"><a href="#十六、通过ctags建立索引，并引用其浏览源代码" class="headerlink" title="十六、通过ctags建立索引，并引用其浏览源代码"></a>十六、通过ctags建立索引，并引用其浏览源代码</h1><h2 id="技巧101-结识ctags"><a href="#技巧101-结识ctags" class="headerlink" title="技巧101 结识ctags"></a>技巧101 结识ctags</h2><ul><li>例如在Ubuntu上，可以通过<code>sudo apt-get install exuberant-ctags</code>的方式安装该程序</li><li>标签文件的前几行由元数据组成，而后每一行文本均有关键字、文件名以及关键字在源代码中的位置这3项内容构成。关键字会按照字母顺序排列。</li><li>用模式定位关键字，而不是用行号。</li><li>用元数据标记关键字</li></ul><h2 id="技巧102-配置Vim使用ctags"><a href="#技巧102-配置Vim使用ctags" class="headerlink" title="技巧102 配置Vim使用ctags"></a>技巧102 配置Vim使用ctags</h2><ul><li><code>:set tags?</code>可以查看ctags缺省配置</li><li>通过<code>:!ctags -R</code>可以在Vim中直接调用生成tags文件。</li><li>还可以使用映射项以及<code>:autocmd BufWritePost * call system(&quot;ctags -R&quot;)</code>命令实现在每次保存文件时自动调用ctags。</li><li>还有一种策略可以实现在每次提交代码改动时自动更新代码库的索引，详见p239。</li></ul><h2 id="技巧103-使用Vim的标签跳转命令，浏览关键字的定义"><a href="#技巧103-使用Vim的标签跳转命令，浏览关键字的定义" class="headerlink" title="技巧103 使用Vim的标签跳转命令，浏览关键字的定义"></a>技巧103 使用Vim的标签跳转命令，浏览关键字的定义</h2><ul><li><code>&lt;ctrl+]&gt;</code>可以跳转到关键字的定义处。此时<code>&lt;ctrl+t&gt;</code>会充当后退到原处的功能。</li><li><code>g&lt;ctrl+]&gt;</code>可以在有多次匹配定义的时候让我们自行挑选需要跳转的地方。</li><li>其实不必非得将光标移到关键字上才能进行标签跳转，也可以用Ex命令达到同样的目的，例如<code>:tag {keyward}</code>与<code>:tjump {keyward}</code>分别等同于上述两个命令。</li></ul><h1 id="十七、编译代码，并通过Quickfix列表浏览错误信息"><a href="#十七、编译代码，并通过Quickfix列表浏览错误信息" class="headerlink" title="十七、编译代码，并通过Quickfix列表浏览错误信息"></a>十七、编译代码，并通过Quickfix列表浏览错误信息</h1><h2 id="技巧104-不用离开Vim也能编译代码"><a href="#技巧104-不用离开Vim也能编译代码" class="headerlink" title="技巧104 不用离开Vim也能编译代码"></a>技巧104 不用离开Vim也能编译代码</h2><ul><li>在Vim中可以直接使用<code>:make</code>编译代码，不止会显示make命令的结果以外，还会解析每一行内容，对于每一条错误信息都会在quickfix列表中为其创建一项纪录，运行后会跳转到quickfix列表的第一项纪录。</li><li>如果不想跳转到第一项纪录，可以<code>:make!</code>。</li></ul><h2 id="技巧105-浏览Quickfix列表"><a href="#技巧105-浏览Quickfix列表" class="headerlink" title="技巧105 浏览Quickfix列表"></a>技巧105 浏览Quickfix列表</h2><ul><li>quickfix列表会保存一组针对单个或多个文件内容的位置信息，这些信息来自于<code>:make</code>、<code>:grep</code>以及<code>:vimgrep</code>。</li><li>对于每一条用于填充quickfix列表的命令，前面加个l都能操作对应的位置列表。位置列表可以理解成每个缓冲区的局部变量，而quickfix列表是全局变量。</li><li><code>:cnext</code>和<code>:cprevios</code>两个命令用来操作最基本的quickfix列表前后移动。<code>:copen</code>可以打开包含quickfix列表内容的窗口。</li></ul><h2 id="技巧106-回溯以前的Quickfix列表"><a href="#技巧106-回溯以前的Quickfix列表" class="headerlink" title="技巧106 回溯以前的Quickfix列表"></a>技巧106 回溯以前的Quickfix列表</h2><ul><li>更新quickfix列表时，Vim并不会覆盖之前的内容，而是将使用过的quickfix列表结果保存起来，方便回溯。</li><li><code>:colder</code>命令可以回溯quickfix列表之前的某个版本（Vim保存最近10个）。为了从旧的回到新一版的，则可以运行<code>:cnewer</code>。</li></ul><h2 id="技巧107-定制外部编译器"><a href="#技巧107-定制外部编译器" class="headerlink" title="技巧107 定制外部编译器"></a>技巧107 定制外部编译器</h2><ul><li>Vim的<code>:make</code>不仅限于调用外部的make程序，也可以调用任何安装在你机器上的编译器。</li><li>这节主要写了个例子，讲述如何在vim里配置别的编译器，没有细看</li><li>在Vim的术语中，编译器是指任何可以针对文档进行处理，并生成错误警告的外部程序。而<code>:make</code>命令指负责调用外部编译器，并对其输出进行解析，以此构建一个可供浏览的quickfix列表。</li><li><code>vim -u NONE -N file</code></li></ul><h1 id="十八-通过grep、vimgrep以及其他工具对整个工程进行查找"><a href="#十八-通过grep、vimgrep以及其他工具对整个工程进行查找" class="headerlink" title="十八 通过grep、vimgrep以及其他工具对整个工程进行查找"></a>十八 通过grep、vimgrep以及其他工具对整个工程进行查找</h1><h2 id="技巧108-不必离开Vim也能调用grep"><a href="#技巧108-不必离开Vim也能调用grep" class="headerlink" title="技巧108 不必离开Vim也能调用grep"></a>技巧108 不必离开Vim也能调用grep</h2><ul><li>-n选项会在grep的结果中加入行号信息</li><li>Vim中外部grep命令进行了封装，可以直接调用。Vim会解析grep的输出并根据输出创建一个quickfix列表，然后我们可以通过quickfix列表进行跳转，内部的grep命令会自动封装-n选项。如果要忽略大小写，需要手动加-i选项。</li></ul><h2 id="技巧109-定制grep"><a href="#技巧109-定制grep" class="headerlink" title="技巧109 定制grep"></a>技巧109 定制grep</h2><ul><li>Vim中的grep命令是外部grep程序的包装器，通过配置<code>grepprg</code>和<code>grepformat</code>两个选项来对Vim查找的行为进行定制。</li><li>主要可以安装一个ack命令来用，暂时没有细看。</li></ul><h2 id="技巧110-使用Vim内部的grep"><a href="#技巧110-使用Vim内部的grep" class="headerlink" title="技巧110 使用Vim内部的grep"></a>技巧110 使用Vim内部的grep</h2><ul><li><code>:vimgrep</code>命令允许我们使用Vim自带的正则表达式引擎，实现跨文件的查找功能。此命令可以缩写成<code>:vim</code>。格式如<code>:vim[grep][!] /{pattern}/[g][j] {file} ...</code></li><li>通配符<code>*</code>会匹配某个目录下的任意文件，而通配符<code>**</code>会匹配指定目录以及所有子目录文件。<code>##</code>会被扩展成参数列表中的所有文件。</li><li>如果模式域为空，则会匹配所有行。</li><li>如果想使用最近一次的查找模式，必须通过<code>&lt;ctrl+r&gt;/</code>将其直接粘贴到查找域才行。</li></ul><h1 id="十九-自动补全"><a href="#十九-自动补全" class="headerlink" title="十九 自动补全"></a>十九 自动补全</h1><h2 id="技巧111-结识Vim的关键字自动补全"><a href="#技巧111-结识Vim的关键字自动补全" class="headerlink" title="技巧111 结识Vim的关键字自动补全"></a>技巧111 结识Vim的关键字自动补全</h2><ul><li>Vim的自动补全功能可以在插入模式下被触发。</li><li>通过<code>&lt;ctrl+p&gt;</code>和<code>&lt;ctrl+n&gt;</code>可以实现普通关键字自动补全，可以在插入模式下触发Vim的自动补全，还可以利用他们在补全列表里正向或反向寻找。</li><li>除了最常用的<code>&lt;ctrl+p&gt;&lt;ctrl+n&gt;</code>两个命令外还有一些其他的补全命令，见表19-1，p263。</li></ul><h2 id="技巧112-与自动补全的弹出式菜单进行交互"><a href="#技巧112-与自动补全的弹出式菜单进行交互" class="headerlink" title="技巧112 与自动补全的弹出式菜单进行交互"></a>技巧112 与自动补全的弹出式菜单进行交互</h2><ul><li>有几个重要的快捷键记忆一下。<code>&lt;ctrl+y&gt;</code>确认使用当前选中的匹配行，<code>&lt;ctrl+e&gt;</code>还原最早输入的文本，即退出自动补全。<code>&lt;ctrl+h&gt;</code>从当前匹配项中删除一个字符，<code>&lt;ctrl+l&gt;</code>从当前匹配项中增加一个字符。</li><li>建议浏览补全列表的时候不要用上下键，因为还需要按回车才能选中，而且手指得从本位行上移开。</li><li>连续输入<code>&lt;ctrl+p&gt;&lt;strl+n&gt;</code>可以实现实时过滤补全列表，很好用。</li></ul><h2 id="技巧113-掌握关键字的来龙去脉"><a href="#技巧113-掌握关键字的来龙去脉" class="headerlink" title="技巧113 掌握关键字的来龙去脉"></a>技巧113 掌握关键字的来龙去脉</h2><ul><li>普通关键字自动补全会把来自多个来源的内容编入其补全列表，我们可以对生成补全列表项的来源加以限定。</li><li><code>:!ls</code>可以用来查看缓冲区列表。</li><li><code>&lt;ctrl+x&gt;&lt;ctrl+i&gt;</code>可以补全一些来自其他代码里的单词，就像include的一样。还有比如<code>&lt;ctrl+x&gt;&lt;ctrl+]&gt;</code>可以补全ctags生成的文件里的单词。总的来说，普通关键字补全是最全的，但如果嫌多想要特定来源的补全的话，就用<code>&lt;ctrl+x&gt;</code>加特定的快捷键来实现，见表19-1。</li></ul><h2 id="技巧114-使用字典中的单词进行自动补全"><a href="#技巧114-使用字典中的单词进行自动补全" class="headerlink" title="技巧114 使用字典中的单词进行自动补全"></a>技巧114 使用字典中的单词进行自动补全</h2><ul><li><code>&lt;ctrl+x&gt;&lt;ctrl+k&gt;</code>可以实现自动补全某个字典单词功能。为了激活该功能，我们需要为Vim提供一份合适的单词列表，最简单的办法就是运行<code>:set spell</code>激活Vim的拼写检查功能。</li></ul><h2 id="技巧115-自动补全整行文本"><a href="#技巧115-自动补全整行文本" class="headerlink" title="技巧115 自动补全整行文本"></a>技巧115 自动补全整行文本</h2><ul><li><code>&lt;ctrl+x&gt;&lt;ctrl+l&gt;</code>面向行自动补全。</li></ul><h2 id="技巧116-自动补全文件名"><a href="#技巧116-自动补全文件名" class="headerlink" title="技巧116 自动补全文件名"></a>技巧116 自动补全文件名</h2><ul><li><code>&lt;ctrl+x&gt;&lt;ctrl+f&gt;</code>可以自动补全文件名。</li><li>Vim的文件名自动补全功能只能相对于工作目录的路径进行扩展，而不是相对于当前编辑文件的路径。</li><li><code>:cd -</code>可以在Vim中切换到之前的工作目录。</li></ul><h2 id="技巧117-根据上下文自动补全"><a href="#技巧117-根据上下文自动补全" class="headerlink" title="技巧117 根据上下文自动补全"></a>技巧117 根据上下文自动补全</h2><ul><li><code>&lt;ctrl+x&gt;&lt;ctrl+o&gt;</code>实现该功能，全能补全。</li><li><p>实际上，该功能由专用的文件类型插件实现，需要下载以下配置行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">filetype plugin on</span><br></pre></td></tr></table></figure></li><li><p>此外还需要安装一个为所用语言实现了全能补全功能的插件。</p></li></ul><h1 id="二十-利用Vim的拼写检查器，查找并更正拼写错误"><a href="#二十-利用Vim的拼写检查器，查找并更正拼写错误" class="headerlink" title="二十 利用Vim的拼写检查器，查找并更正拼写错误"></a>二十 利用Vim的拼写检查器，查找并更正拼写错误</h1><h2 id="技巧118-对你的工作进行拼写检查"><a href="#技巧118-对你的工作进行拼写检查" class="headerlink" title="技巧118 对你的工作进行拼写检查"></a>技巧118 对你的工作进行拼写检查</h2><ul><li>使用<code>:set spell</code>可以对所有未在拼写文件中出现过的单词进行高亮标记。</li><li>可以使用<code>[s</code>和<code>]s</code>命令在拼写错误的单词间进行跳转。当光标位于某个拼错的单词上时，可以使用<code>z=</code>命令来获取Vim提供的更正建议列表。</li></ul><h2 id="技巧119-使用其他拼写字典"><a href="#技巧119-使用其他拼写字典" class="headerlink" title="技巧119 使用其他拼写字典"></a>技巧119 使用其他拼写字典</h2><ul><li>修改配置<code>spelllang</code>选项可以更改缺省的拼写字典，要注意的是这不是全局性的，永远只在本地缓冲区生效。这意味着可以在编辑两个或多个文档时采用不同的拼写字典。</li><li>可以使用spellfile.vim的插件安装其他所需的语言拼写字典，为了激活这个功能，需要在vimrc中添加两行，具体看p276吧。</li></ul><h2 id="技巧120-将单词添加到拼写文件中"><a href="#技巧120-将单词添加到拼写文件中" class="headerlink" title="技巧120 将单词添加到拼写文件中"></a>技巧120 将单词添加到拼写文件中</h2><ul><li>我们可以自定义拼写文件里的词。</li><li><code>zg</code>命令可以把光标下的单词添加到拼写文件中，<code>zw</code>则是相反功能，将单词从拼写文件中删除，<code>zug</code>则是撤销光标所在单词执行过的<code>zg</code>或者<code>zw</code>。</li></ul><h2 id="技巧121-在插入模式下更正拼写错误"><a href="#技巧121-在插入模式下更正拼写错误" class="headerlink" title="技巧121 在插入模式下更正拼写错误"></a>技巧121 在插入模式下更正拼写错误</h2><ul><li>插入模式下使用<code>&lt;ctrl+x&gt;s</code>或者<code>&lt;ctrl+x&gt;&lt;ctrl+s&gt;</code>可以使用拼写自动补全功能。其中<code>&lt;ctrl+x&gt;s</code>会有点特殊，它会使Vim从光标所在位置开始方向扫描，直到发现一处拼写错误为止，然后再根据更正建议创建单词列表并显示在弹出菜单里，适合写完一行修正这一行的所有错误时使用。</li></ul><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><ul><li>动态改变Vim的设置项：以<code>ignorecase</code>为例，其可被缩写成<code>ic</code>。</li></ul><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>:set ignorecase</td><td>开启ignorecase</td></tr><tr><td>:set noignorecase</td><td>关闭ignorecase</td></tr><tr><td>:set ignorecase!</td><td>反转</td></tr><tr><td>:set ignorecase?</td><td>获取当前设置的状态</td></tr><tr><td>:set ignorecase&amp;</td><td>恢复默认状态</td></tr></tbody></table><ul><li>在Vim里内使用<code>:edit $MYVIMRC</code>可以打开vimrc。</li><li>可以为特定类型的文件应用个性化设置。</li></ul><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为工作中需要用到Vim，所以本文简单记录下学习Vim编辑器的一些笔记和技巧。&lt;/p&gt;
&lt;h1 id=&quot;Vimtutor&quot;&gt;&lt;a href=&quot;#Vimtutor&quot; class=&quot;headerlink&quot; title=&quot;Vimtutor&quot;&gt;&lt;/a&gt;Vimtutor&lt;/h1&gt;&lt;p&gt;Vimtutor是Vim的一个简易教程，前前后后做了两遍，记录一下一些实用的快捷键吧。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题记录</title>
    <link href="http://yoursite.com/2019/04/16/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/04/16/LeetCode刷题记录/</id>
    <published>2019-04-16T06:32:34.000Z</published>
    <updated>2019-07-28T15:13:08.628Z</updated>
    
    <content type="html"><![CDATA[<p>想养成刷题的习惯，之前刷过一点，但校招之后就断了，现在想捡起来，定个小目标，从头开始刷题吧，看能坚持多久。</p><h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><p>2019/4/16，易。</p><p>这题以前做过，记得第一次做的时候应该是用的最蠢的两重遍历方法相加求解，毫无疑问超时了，隐约记得可以使用查找<code>目标值-某个值</code>是否存在该vector中来反向求解，简单写了一下，通过了。其实是一个反向思维的题，正面求解超时，则反向来求。仍然属于蛮力法的范畴，n<sup>2</sup>时间复杂度，1空间复杂度，LeetCode平台耗时136ms。</p><p>尝试降低时间复杂度，想到以空间换时间，在查找<code>目标值-某个值</code>的时候，上述蛮力法使用<code>std::find</code>方法，说白了也是一层遍历，这层遍历目的是为了查找差值是否存在于vector中并返回下标，自然可以想到用哈希表来代替这一层遍历。当然，事先需要遍历一次原数组构建哈希表。如此时间复杂度n，空间复杂度n。</p><a id="more"></a><p>最终代码如下，本版本耗时仅16ms。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;<span class="comment">//哈希表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=nums.begin();it!=nums.end();it++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> com=<span class="built_in">map</span>.find(target-*it);</span><br><span class="line">            <span class="keyword">if</span>(com!=<span class="built_in">map</span>.end()&amp;&amp;com-&gt;second!=it-nums.begin())&#123;</span><br><span class="line">                res.push_back(it-nums.begin());</span><br><span class="line">                res.push_back(com-&gt;second);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-Add-Two-Numbers（again）"><a href="#2-Add-Two-Numbers（again）" class="headerlink" title="2. Add Two Numbers（again）"></a>2. Add Two Numbers（again）</h1><p>2019/4/19，中。</p><p>平心而论是个比较简单的链表题了，但是太久不做题竟然觉得很难理清楚，这也说明了常做题保持手感很重要。</p><p>本题也没啥特别的方法，注意循环进位即可，另外链表的题往往一开始会定义两个变量，一个用于最后返回，一个用来遍历处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* res=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p=res;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1||l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>; </span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2)</span><br><span class="line">            &#123;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">1</span>)</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-Longest-Substring-Without-Repeating-Characters（again）"><a href="#3-Longest-Substring-Without-Repeating-Characters（again）" class="headerlink" title="3. Longest Substring Without Repeating Characters（again）"></a>3. Longest Substring Without Repeating Characters（again）</h1><p>2019/4/21，中。</p><p>一道经典dp题，准备找工作的时候刷过，以为很简单，但写的时候却发现细节又已经遗忘了，虽然最后还是一遍过了，但还是感慨得要经常刷题保持手感啊，忘性太大了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[s[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=m.find(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(it==m.end())&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-it-&gt;second&gt;dp[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i]=i-m[s[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m[s[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max)</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="4-Median-of-Two-Sorted-Arrays（again）"><a href="#4-Median-of-Two-Sorted-Arrays（again）" class="headerlink" title="4.Median of Two Sorted Arrays（again）"></a>4.Median of Two Sorted Arrays（again）</h1><p>2019/4/22，难。</p><p>想法一开始就很明确，将两个有序数组Merge成一个新的有序数组就是了，然后直接返回中间值即可。后来稍微改进了下代码，因为Merge其实只需要Merge到中间数即可，后面的数并不需要处理了，所以去除了冗余排序，感觉时间复杂度是n+m，空间复杂度也是n+m。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length1=nums1.size(),length2=nums2.size();</span><br><span class="line">        <span class="keyword">int</span> sumLen=length1+length2;</span><br><span class="line">        <span class="keyword">int</span> midIndex=(length1+length2)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(res.size()&lt;midIndex+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == length2 || (i &lt; nums1.size() &amp;&amp; nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">    res.push_back(nums1[i]);</span><br><span class="line">    i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == length1 || (j&lt;nums2.size() &amp;&amp; nums1[i] &gt;= nums2[j])) &#123;</span><br><span class="line">    res.push_back(nums2[j]);</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sumLen%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res.back();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> r=(res[res.size()<span class="number">-1</span>]+res[res.size()<span class="number">-2</span>])/<span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但后来发现题目要求的时间复杂度是log(n+m)，才感觉到为什么这道题目难度级别是hard，不过我习惯从这个要求的时间复杂度就得到该题应该要使用二分查找或者是二分查找的变形，看了网上的解答，应该是查找第K小数字的变体，最后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1=nums1.size(),length2=nums2.size();</span><br><span class="line">        <span class="keyword">int</span> sumLen=length1+length2;</span><br><span class="line">        <span class="keyword">if</span>(sumLen%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> FindKth(nums1,length1,nums2,length2,sumLen/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (FindKth(nums1,length1,nums2,length2,sumLen/<span class="number">2</span>)+</span><br><span class="line">                    FindKth(nums1,length1,nums2,length2,sumLen/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">FindKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1,<span class="keyword">int</span> length1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">int</span> length2,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length1&gt;length2)</span><br><span class="line">            <span class="keyword">return</span> FindKth(nums2,length2,nums1,length1,k);</span><br><span class="line">        <span class="keyword">if</span>(length1==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums2[k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> min(nums1[<span class="number">0</span>],nums2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> pa=min(k/<span class="number">2</span>,length1),pb=k-pa;</span><br><span class="line">        <span class="keyword">if</span>(nums1[pa<span class="number">-1</span>]&lt;nums2[pb<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(nums1.begin()+pa,nums1.end());</span><br><span class="line">            <span class="keyword">return</span> FindKth(tmp,length1-pa,nums2,length2,k-pa);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[pa<span class="number">-1</span>]&gt;nums2[pb<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(nums2.begin()+pb,nums2.end());</span><br><span class="line">            <span class="keyword">return</span> FindKth(nums1,length1,tmp,length2-pb,k-pb);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[pa<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考<a href="https://blog.csdn.net/lis_12/article/details/53128594" target="_blank" rel="noopener">https://blog.csdn.net/lis_12/article/details/53128594</a></p><h1 id="5-Longest-Palindromic-Substring（again）"><a href="#5-Longest-Palindromic-Substring（again）" class="headerlink" title="5.Longest Palindromic Substring（again）"></a>5.Longest Palindromic Substring（again）</h1><p>2019/4/23，中。</p><p>求最长回文子串，看到题目之后我感觉这是一道dp题，但是太菜了，还是写不出来，查了解析后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size(),<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(),<span class="literal">true</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s.size();i++)&#123;<span class="comment">//i表示子串长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> leftIdx=<span class="number">0</span>;leftIdx&lt;=s.size()-i;leftIdx++)&#123;<span class="comment">//j表示子串起始坐标</span></span><br><span class="line">                <span class="keyword">int</span> rightIdx=leftIdx+i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[leftIdx]==s[rightIdx]&amp;&amp;dp[leftIdx+<span class="number">1</span>][rightIdx<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[leftIdx][rightIdx]=<span class="literal">true</span>;</span><br><span class="line">                    max=i;</span><br><span class="line">                    start=leftIdx;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[leftIdx][rightIdx]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度n<sup>2</sup>，空间复杂度n<sup>2</sup>。</p><p>利用中心扩展法可以将空间复杂度降低到1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1=expandAroundCenter(s,i,i);<span class="comment">//奇数</span></span><br><span class="line">            <span class="keyword">int</span> len2=expandAroundCenter(s,i,i+<span class="number">1</span>);<span class="comment">//偶数</span></span><br><span class="line">            <span class="keyword">int</span> len=max(len1,len2);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;end-start)&#123;</span><br><span class="line">                start=i-(len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,end-start+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">    <span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;len &amp;&amp; s[left] == s[right]) </span><br><span class="line">    &#123;</span><br><span class="line">    left--;</span><br><span class="line">    right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right-left<span class="number">-1</span>;<span class="comment">//返回长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后还有一种Manacher方法，能将时间复杂度降到n，同时空间复杂度也是n，没看得太明白，以后再说。<a href="http://www.cnblogs.com/bitzhuwei/p/Longest-Palindromic-Substring-Part-II.html" target="_blank" rel="noopener">http://www.cnblogs.com/bitzhuwei/p/Longest-Palindromic-Substring-Part-II.html</a></p><h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6.ZigZag Conversion"></a>6.ZigZag Conversion</h1><p>2019/4/24，中。</p><p>之字形排列字符串然后按行打印。</p><p>刚看到时候第一种办法就是自己定义一个二维数组排一下然后按行输出得了，蛮力法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//蛮力法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="comment">//构建一个二维字符数组存数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">array</span>(numRows,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(s.size()/<span class="number">2</span>+<span class="number">1</span>,<span class="string">"null"</span>));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> direction=<span class="literal">true</span>;<span class="comment">//记录方向，ture表示向下，false向上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>;idx&lt;s.size();idx++)&#123;</span><br><span class="line">            <span class="built_in">array</span>[i][j]=s[idx];</span><br><span class="line">            <span class="keyword">if</span>(direction)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(i==numRows)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    i=i<span class="number">-2</span>;</span><br><span class="line">                    direction=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">-1</span>)&#123;</span><br><span class="line">                    i=i+<span class="number">2</span>;</span><br><span class="line">                    j--;</span><br><span class="line">                    direction=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;numRows;p++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;s.size()/<span class="number">2</span>+<span class="number">1</span>;q++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[p][q]!=<span class="string">"null"</span>)&#123;</span><br><span class="line">                   res+=<span class="built_in">array</span>[p][q]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交后虽然通过了，但花费时间560ms，空间占有400MB，感觉效率太低了，于是尝试另一种方法。</p><p>另一种方法也很好想到，既然是按某种规律排列并输出，那自然把规律找出来就好了，多在草稿纸上排了几个用例后发现每一行的间隔都是有规律的，主要规律是2*numRows-2，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//找规律直接输出</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxInterval=<span class="number">2</span>*numRows<span class="number">-2</span>;<span class="comment">//最大间隔</span></span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> startIdx=i;</span><br><span class="line">            <span class="keyword">int</span> interval=maxInterval<span class="number">-2</span>*i;</span><br><span class="line">            <span class="keyword">if</span>(i==numRows<span class="number">-1</span>)</span><br><span class="line">                interval=maxInterval;</span><br><span class="line">            <span class="keyword">while</span>(startIdx&lt;s.size())&#123;</span><br><span class="line">                res+=s[startIdx];</span><br><span class="line">                startIdx+=interval;</span><br><span class="line">                interval=(maxInterval-interval!=<span class="number">0</span>)?maxInterval-interval:interval;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交后时间降到16ms，空间占有降低到10MB，效率提升还是很明显的。</p><p>这道题算是这几天做的比较顺利的题了，阿弥陀佛。</p><h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7.Reverse Integer"></a>7.Reverse Integer</h1><p>2019/4/25，易。</p><p>反转一个整数，本来以为挺简单的，但是却没有注意大数越界，又琢磨了一会儿，要注意大数问题啊。</p><p>两种差不多的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意要转换类型，否则大数会出错</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> absX = <span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>)x);</span><br><span class="line">    <span class="built_in">string</span> tmp = to_string(absX);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> a = tmp[i];</span><br><span class="line">    tmp[i] = tmp[tmp.size() - <span class="number">1</span> - i];</span><br><span class="line">    tmp[tmp.size() - <span class="number">1</span> - i] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">    res = res * <span class="number">10</span> + (tmp[i]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(res&gt;INT_MAX)<span class="comment">//注意要比较是否越界，因为这里已经是绝对值了，所以只需和INT_MAX比较</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x &lt; <span class="number">0</span>) ? (<span class="number">-1</span> * res) : res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查了下其他人的方法，可以有第二种写法，更为简单，如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res=res*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(res&gt; INT_MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;INT_MIN)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两种代码耗时都是4ms，空间占有也差不多，整体效率相仿。</p><h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h1><p>2019/4/26，中。</p><p>字符串转整数，需要注意大数问题、正负号、空格，题目里已经写得很清楚了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//去除前面的空格</span></span><br><span class="line">    str.erase(<span class="number">0</span>, str.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">    <span class="comment">//处理返回0的情况</span></span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(str[<span class="number">0</span>]) &amp;&amp; str[<span class="number">0</span>] != <span class="string">'-'</span>&amp;&amp;str[<span class="number">0</span>] != <span class="string">'+'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span> || str[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.size() &lt;= <span class="number">1</span> || !<span class="built_in">isdigit</span>(str[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非0</span></span><br><span class="line">    <span class="keyword">bool</span> positive = str[<span class="number">0</span>] == <span class="string">'-'</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span> || str[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">    str = str.substr(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;str.size() &amp;&amp; <span class="built_in">isdigit</span>(str[i])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (positive)</span><br><span class="line">    res = res * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    res = res * <span class="number">10</span> - (str[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; INT_MAX)</span><br><span class="line">    <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; INT_MIN)</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">    i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了下其他提交，方法都大同小异，只不过大佬们写的C++代码要简洁一些，不像我写的那么臃肿，大佬们的代码就是在原字符串的基础上往后遍历处理，而我的代码里还用erase/substr方法把原字符串改来改去，导致时间上慢了几ms，慢慢练吧~</p><h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9.Palindrome Number"></a>9.Palindrome Number</h1><p>2019/4/27，易。</p><p>判断一个整数是否是回文数，最简单的方法就是转化成字符然后前后循环判断，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> str=to_string(x);</span><br><span class="line">        <span class="keyword">if</span>(str.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=str[str.size()<span class="number">-1</span>-i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行时间32ms，内存8.4MB。</p><p>后来看到题目里的扩展，如何不转换成string进行判断？</p><p>想到回文数字其实就是前后读相同，那么将该数字对半分后应该能分成两个相同数字，比如1221，就分成12和12（后一个12从右往左读），而131就可以同样分成13和13（3用两次），根据这种想法写出以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//1、算出整数位数</span></span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t=x;</span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="number">0</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            t/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、拆分数字</span></span><br><span class="line">        t=x;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len/<span class="number">2</span>)&#123;</span><br><span class="line">            tmp=tmp*<span class="number">10</span>+t%<span class="number">10</span>;</span><br><span class="line">            t/=<span class="number">10</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、注意如果是奇数位数的整数，还需要将中间数重复利用一次</span></span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            tmp=tmp*<span class="number">10</span>+t%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp==t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样是32ms，内存8.2MB。</p><p>后来看了下大佬们的提交，大致思路和上述第二种方法相似，但大佬的代码更加精炼，把我代码中很多直白的部分都进一步浓缩了，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>|| (x!=<span class="number">0</span> &amp;&amp;x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里精炼后不需要再计算整数位数，直接用x&gt;sum来循环</span></span><br><span class="line">        <span class="keyword">while</span>(x&gt;sum)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (x==sum)||(x==sum/<span class="number">10</span>);<span class="comment">//位数是偶数，则x==sum；位数是奇数，则x==sum/10，不需</span></span><br><span class="line">            <span class="comment">//要像我代码中奇数位数的整数多进行一次处理，实在高呀~</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="10-Regular-Expression-Matching（again"><a href="#10-Regular-Expression-Matching（again" class="headerlink" title="10.Regular Expression Matching（again)"></a>10.Regular Expression Matching（again)</h1><p>2019/4/29，难。</p><p>一开始以为这道题和《剑指offer》上的某道题一样，遂用那道题的解法来进行求解，后发现有点问题，经过修补后写下如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s!=<span class="string">""</span>&amp;&amp;p==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//先进行一下简单的检查，这部分代码就是修补，很丑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]!=<span class="string">'.'</span>&amp;&amp;p[i]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.find(p[i])==<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==p.size()<span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(p[i+<span class="number">1</span>]!=<span class="string">'*'</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchCore(s,p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>&amp;&amp;p==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s!=<span class="string">""</span>&amp;&amp;p==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==p[<span class="number">0</span>]||(p[<span class="number">0</span>]==<span class="string">'.'</span>&amp;&amp;s!=<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(s.substr(<span class="number">1</span>),p)<span class="comment">//*表示多个</span></span><br><span class="line">                    ||matchCore(s.substr(<span class="number">1</span>),p.substr(<span class="number">2</span>))<span class="comment">//*表示1个</span></span><br><span class="line">                    ||matchCore(s,p.substr(<span class="number">2</span>));<span class="comment">//*表示0个</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//不等，则*只能表示0个还有机会</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(s,p.substr(<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>]==p[<span class="number">0</span>]||(p[<span class="number">0</span>]==<span class="string">'.'</span>&amp;&amp;s!=<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> matchCore(s.substr(<span class="number">1</span>),p.substr(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最终通过了，但是代码很丑，效率很低，整体用了五百多毫秒，内存占用17.5MB左右，效率太差了。</p><p>然后发现可以用DP来求解，研究后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代码中因为定义dp数组的时候默认值就是false，所以代码中对数组元素赋值false的语句都可删除，</span></span><br><span class="line">        <span class="comment">//但这里仍然写出来，是为了便于理解。</span></span><br><span class="line">        <span class="comment">//1、定义dp数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.size()+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        <span class="comment">//2、赋值初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)<span class="comment">//空模式不会匹配非空字符串</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//非空模式想要匹配空字符串，最后一个字符必须是*</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=p.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i<span class="number">-1</span>]==<span class="string">'*'</span>&amp;&amp;dp[<span class="number">0</span>][i<span class="number">-2</span>])</span><br><span class="line">                dp[<span class="number">0</span>][i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[<span class="number">0</span>][i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==p[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=p[j<span class="number">-2</span>]&amp;&amp;p[j<span class="number">-2</span>]!=<span class="string">'.'</span>)<span class="comment">//不匹配，*只能表示0次</span></span><br><span class="line">                            dp[i][j]=dp[i][j<span class="number">-2</span>];</span><br><span class="line">                        <span class="keyword">else</span><span class="comment">//匹配，*表示0/1/多次</span></span><br><span class="line">                            dp[i][j]=dp[i][j<span class="number">-2</span>]||dp[i<span class="number">-1</span>][j]||dp[i<span class="number">-1</span>][j<span class="number">-2</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()][p.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用DP解法耗时降到8ms，内存占用降低到9.1MB，主要思路参考<a href="https://zhuanlan.zhihu.com/p/40294596" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40294596</a>，但个人认为该链接里dp最后一种情况推导公式有误，应该是我代码中写的<code>dp[i][j]=dp[i][j-2]||dp[i-1][j]||dp[i-1][j-2]</code>，且该链接给出的最后代码感觉有点问题，应该不能直接用，只是个伪代码吧，不过主要思路是阐述得很清楚了。</p><h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h1><p>2019/4/30，中。</p><p>一开始看到这道题的时候想的是用最直接的暴力法——挨个遍历，但是可以预料到耗时肯定会超出限制，所以想着改进该方法。想到在暴力遍历中其实有很多种情况是重复的，所以想到用DP数组先存前一种情况的值，再根据已知情况的值来进行当前情况的求解，能够省去一重循环，遂写出下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(height.size(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;height.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max=dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> volume=(i-j)*min(height[i],height[j]);</span><br><span class="line">                <span class="keyword">if</span>(volume&gt;max)</span><br><span class="line">                    max=volume;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[height.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交，通过测试，但效率极低，耗时1300ms左右，占用内存10MB左右，仍需改进，该方法的时间复杂度是n<sup>2</sup>，所以考虑是否有时间复杂度为n的方法，看到一年前做这道题时用的是前后双指针法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.size()&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> currentSize=(j-i)*min(height[i],height[j]);</span><br><span class="line">            <span class="keyword">if</span>(currentSize&gt;maxSize)</span><br><span class="line">                maxSize=currentSize;</span><br><span class="line">            height[i]&lt;height[j]?(++i):(--j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>耗时20ms，效率提升明显，主要重点在<code>height[i]&lt;height[j]?(++i):(--j)</code>，即每次收缩的时候都收缩边界较小的那一侧，因为这样就可以省去很多冗余情况的判断。</p><h1 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h1><p>2019/5/2，中。</p><p>整数转换成罗马数字，整数范围1~3999。</p><p>按部就班就行，首先写出的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; intToString=&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="string">"I"</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>,<span class="string">"V"</span>&#125;,</span><br><span class="line">            &#123;<span class="number">10</span>,<span class="string">"X"</span>&#125;,</span><br><span class="line">            &#123;<span class="number">50</span>,<span class="string">"L"</span>&#125;,</span><br><span class="line">            &#123;<span class="number">100</span>,<span class="string">"C"</span>&#125;,</span><br><span class="line">            &#123;<span class="number">500</span>,<span class="string">"D"</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1000</span>,<span class="string">"M"</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=num;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">1</span>;<span class="comment">//表示数位</span></span><br><span class="line">        <span class="keyword">for</span>(;tmp!=<span class="number">0</span>;tmp/=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> digit=tmp%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digit&gt;=<span class="number">1</span>&amp;&amp;digit&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digit;i++)&#123;</span><br><span class="line">                    res=intToString[p]+res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(digit==<span class="number">4</span>)&#123;</span><br><span class="line">                res=intToString[p]+intToString[<span class="number">5</span>*p]+res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(digit&gt;=<span class="number">5</span>&amp;&amp;digit&lt;=<span class="number">8</span>)&#123;</span><br><span class="line">                <span class="built_in">string</span> s=intToString[p*<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digit<span class="number">-5</span>;i++)</span><br><span class="line">                    s=s+intToString[p];</span><br><span class="line">                res=s+res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(digit==<span class="number">9</span>)&#123;</span><br><span class="line">                res=intToString[p]+intToString[<span class="number">10</span>*p]+res;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>耗时24ms，空间占用12.2MB。</p><p>提交后看了下其他人的代码，基本上思想没什么变化，只不过初始化的时候如果初始化的更具体一点，转换耗时就会更快，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> table[<span class="number">4</span>][<span class="number">10</span>] = &#123;&#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">                           &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">                           &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">                           &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;</span><br><span class="line">                          &#125;;</span><br><span class="line">    <span class="built_in">string</span> result;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num % <span class="number">10</span>;</span><br><span class="line">        result = table[count][temp] + result;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>耗时16ms，占用空间8.4MB。</p><h1 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h1><p>2019/5/3，易。</p><p>罗马数字转整数，很笨的办法就行，<code>if</code>语句看起来有点乱，但能通过，耗时16ms，8.3MB内存，可以转成<code>switch</code>语句，我这就没有转了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'I'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;s.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'V'</span>)&#123;</span><br><span class="line">                        res+=<span class="number">4</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'X'</span>)&#123;</span><br><span class="line">                        res+=<span class="number">9</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res+=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'V'</span>)&#123;</span><br><span class="line">                res+=<span class="number">5</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'X'</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i&lt;s.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                        res+=<span class="number">40</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'C'</span>)&#123;</span><br><span class="line">                        res+=<span class="number">90</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res+=<span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res+=<span class="number">10</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                res+=<span class="number">50</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'C'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;s.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'D'</span>)&#123;</span><br><span class="line">                        res+=<span class="number">400</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'M'</span>)&#123;</span><br><span class="line">                        res+=<span class="number">900</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res+=<span class="number">100</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res+=<span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'D'</span>)&#123;</span><br><span class="line">                res+=<span class="number">500</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">'M'</span>)&#123;</span><br><span class="line">                res+=<span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h1><p>2019/5/5，易。</p><p>求一组字符串的最长公共前缀，直接暴力解就行了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> pre=strs[<span class="number">0</span>];<span class="comment">//最长公共前缀最长不会超过第一个元素的长度，所以先把前缀设为第一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;strs.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pre.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre[j]!=strs[i][j])<span class="comment">//一旦有字符不等，表示最长前缀结束了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pre=pre.substr(<span class="number">0</span>,j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="string">""</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="15-3Sum（again）"><a href="#15-3Sum（again）" class="headerlink" title="15. 3Sum（again）"></a>15. 3Sum（again）</h1><p>2019/5/8，中。</p><p>求数组中三个数和为0的子集。</p><p>一开始自己用的回溯法，虽然结果能对，但是超时了，代码还是暂时列在这里，这代码里去掉了一些无用的迭代，然而还是没啥用，还是超时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            p.push_back(nums[i]);</span><br><span class="line">            backTracking(nums,i,p,res);</span><br><span class="line">            p.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;int&gt;&gt; resVec(res.size());</span></span><br><span class="line">        <span class="comment">//std::copy(res.begin(), res.end(), resVec.begin());</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.size()==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[<span class="number">0</span>]+p[<span class="number">1</span>]+p[<span class="number">2</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="comment">// vector&lt;int&gt; tmp = p;//不能直接对p排序，会导致p发生变化，后续回溯出错</span></span><br><span class="line"><span class="comment">//sort(tmp.begin(), tmp.end());</span></span><br><span class="line">res.push_back(p);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            p.push_back(nums[j]);</span><br><span class="line">            backTracking(nums,j,p,res);</span><br><span class="line">            p.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后面看了其他提交者的代码，采用的是先排序再利用前后指针的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i&gt;<span class="number">0</span>) &amp;&amp; (nums[i]==nums[i<span class="number">-1</span>]))<span class="comment">//防止重复</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = i+<span class="number">1</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = nums[i]+nums[l]+nums[r];</span><br><span class="line">                <span class="keyword">if</span> (s&gt;<span class="number">0</span>) r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s&lt;<span class="number">0</span>) l++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                    <span class="comment">//剔除重复</span></span><br><span class="line">                    <span class="keyword">while</span> (l&lt;r&amp;&amp;nums[l]==nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                    <span class="keyword">while</span> (l&lt;r&amp;&amp;nums[r]==nums[r<span class="number">-1</span>]) r--;</span><br><span class="line">                    l++; r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16.3Sum Closest"></a>16.3Sum Closest</h1><p>2019/5/9，中。</p><p>和15很类似，这题求的是和给定值target最近的三个数的和，方法类似，也是用两个指针从前后向中间逼近，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> min_bias = INT8_MAX;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = (<span class="keyword">int</span>)nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (s == target)</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">                <span class="keyword">int</span> tmp=<span class="built_in">abs</span>(s-target);</span><br><span class="line">                <span class="keyword">if</span>(tmp&lt;min_bias)&#123;</span><br><span class="line">                    min_bias=tmp;</span><br><span class="line">                    res=s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s&gt;target)</span><br><span class="line">                    r--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h1><p>2019/5/10，中。</p><p>一道简单的回溯题，没有啥特别的地方，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(digits==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; chas=&#123;&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125;,&#123;<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>&#125;,&#123;<span class="string">"g"</span>,<span class="string">"h"</span>,<span class="string">"i"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"j"</span>,<span class="string">"k"</span>,<span class="string">"l"</span>&#125;,&#123;<span class="string">"m"</span>,<span class="string">"n"</span>,<span class="string">"o"</span>&#125;,&#123;<span class="string">"p"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"s"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="string">"t"</span>,<span class="string">"u"</span>,<span class="string">"v"</span>&#125;,&#123;<span class="string">"w"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">string</span> tmp=<span class="string">""</span>;</span><br><span class="line">        backTracking(digits,chas,res,tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="built_in">string</span>&amp; digits,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; chas,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res,<span class="built_in">string</span>&amp; tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size()==digits.size())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chas[digits[tmp.size()]-<span class="string">'0'</span><span class="number">-2</span>].size();i++)&#123;</span><br><span class="line">            tmp+=chas[digits[tmp.size()]-<span class="string">'0'</span><span class="number">-2</span>][i];</span><br><span class="line">            backTracking(digits,chas,res,tmp);</span><br><span class="line">            tmp=tmp.substr(<span class="number">0</span>,tmp.size()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h1><p>2019/5/11，中。</p><p>和前面的2Sum以及3Sum是一个系列的，使用和3Sum一样的思想即可，AC，耗时8ms左右。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">4</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//以下两个判断可以剔除很多无效循环，没有这两个判断的话也能AC，但是耗时会在40ms左右</span></span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">3</span>&lt;nums.size()&amp;&amp;nums[i] + nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] + nums[i+<span class="number">3</span>] &gt; target) </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[nums.size()<span class="number">-1</span>] + nums[nums.size()<span class="number">-2</span>] + nums[nums.size()<span class="number">-3</span>] &lt; target) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> l=j+<span class="number">1</span>,r=nums.size()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[i]+nums[j]+nums[l]+nums[r];</span><br><span class="line">                    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                        res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i],nums[j],nums[l],nums[r]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l+<span class="number">1</span>]==nums[l])</span><br><span class="line">                            l++;</span><br><span class="line">                        <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r<span class="number">-1</span>]==nums[r])</span><br><span class="line">                            r--;</span><br><span class="line">                        l++;r--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)</span><br><span class="line">                        r--;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                        l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h1><p>2019/5/12，中。</p><p>移除链表中倒数第N个元素，做过，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一个节点并且要删除这个节点</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>&amp;&amp;n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pre=head;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!pre&amp;&amp;n!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre)&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除的是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur==head)&#123;</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要删除的不是最后一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next)&#123;</span><br><span class="line">            cur-&gt;val=cur-&gt;next-&gt;val;</span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//删除最后一个节点</span></span><br><span class="line">            pre=head;</span><br><span class="line">            <span class="keyword">while</span>(pre-&gt;next!=cur)</span><br><span class="line">                pre=pre-&gt;next;</span><br><span class="line">            pre-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h1><p>2019/5/13，易。</p><p>判断括号是否有效，用一个栈即可，没什么难度，自己是用ifelse写的，另外找了一个看起来清爽一些但意思一样的代码放在这里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; paren;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'('</span>: </span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#123;'</span>: </span><br><span class="line">                <span class="keyword">case</span> <span class="string">'['</span>: paren.push(c); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">')'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&#125;'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span> (paren.empty() || paren.top()!=<span class="string">'['</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> paren.pop(); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: ; <span class="comment">// pass</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paren.empty() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h1><p>2019/5/15，易。</p><p>合并两个有序数组，简单题，最常用的方法就是循环依次比较，这里就不放这种方法的代码了，放一个递归的代码，《剑指offer》里也是这种递归代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1&amp;&amp;!l2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        ListNode* node=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            node=l1;</span><br><span class="line">            node-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node=l2;</span><br><span class="line">            node-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="22-Generate-Parentheses（again）"><a href="#22-Generate-Parentheses（again）" class="headerlink" title="22. Generate Parentheses（again）"></a>22. Generate Parentheses（again）</h1><p>2019/5/16，中。</p><p>生成括号，用递归解法。</p><p>总结出来三点，就是选择、限制、结束条件是这种递归和回溯的主要部分，本题代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        recursion(res,<span class="string">""</span>,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res,<span class="built_in">string</span> s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">            recursion(res,s+<span class="string">"("</span>,left<span class="number">-1</span>,right+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;<span class="number">0</span>)</span><br><span class="line">            recursion(res,s+<span class="string">")"</span>,left,right<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h1><p>2019/5/17，难。</p><p>第21题的升级版，最容易想到的方法就是循环调用第21题的代码，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* res;</span><br><span class="line">        res=lists[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//循环调用21题的方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lists.size();i++)&#123;</span><br><span class="line">            res=mergeTwoLists(res,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode*&amp; l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1&amp;&amp;!l2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* tmp;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">            tmp=l1;</span><br><span class="line">            tmp-&gt;next=mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp=l2;</span><br><span class="line">            tmp-&gt;next=mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后提交发现该方法可以AC，但耗时240ms，占内存11MB左右，效率不是特别好。</p><p>为提高效率，采用分治法的思想，两两合并再合并，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* res;</span><br><span class="line">        <span class="keyword">int</span> n=lists.size();</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">                lists[i]=mergeTwoLists(lists[i],lists[i+k]);</span><br><span class="line">            n=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode*&amp; l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...此函数相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该方法耗时24ms，效率提升很多。</p><h1 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h1><p>2019/5/21，中。</p><p>链表题，主要就是搞清楚指针的变换和空指针的情况，循环遍历下去即可，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur=head,*next=head-&gt;next;</span><br><span class="line">        ListNode* newHead=next;<span class="comment">//记录新的头结点</span></span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="literal">NULL</span>)</span><br><span class="line">                pre=cur;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre-&gt;next=next;</span><br><span class="line">            cur-&gt;next=next-&gt;next;</span><br><span class="line">            next-&gt;next=cur;</span><br><span class="line">            </span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(cur)</span><br><span class="line">                next=cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next=<span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h1><p>2019/5/26，难。</p><p>最近等毕业论文审核通知，心烦意乱，没有什么心情，所以做题耽搁了些。</p><p>这是题24的升级版，题24是两两反转，而本题是按数字k来反转，变成了更一般的情况，我的想法是按段分割整个链表，对每一段链表分别进行反转，注意好节点指针，还是比较容易漏的，测试了好久，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//1 计算链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        ListNode* res=<span class="literal">NULL</span>;<span class="comment">//记录最后返回的头结点</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;len||k==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> i=len/k;<span class="comment">//2 计算反转链表的循环次数</span></span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">bool</span> first=<span class="literal">true</span>;<span class="comment">//记录是否是第一次，用来保存调整后的头结点</span></span><br><span class="line">        ListNode* last=<span class="literal">NULL</span>;<span class="comment">//记录上一次调整的最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> n=k;</span><br><span class="line">            ListNode* tail=cur;</span><br><span class="line">            <span class="comment">//得到本次需要调整的最后一个节点</span></span><br><span class="line">            <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                tail=tail-&gt;next;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* tmp=tail-&gt;next,*tmp1=cur;<span class="comment">//tmp记录下一次调整的头结点，tmp1记录本次调整的头结点，也就是本次调整完的最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(first)<span class="comment">//如果是第一次调整则记录最终头结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                res=reverseList(last,cur,tail,k);</span><br><span class="line">                first=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                reverseList(last,cur,tail,k);</span><br><span class="line">            last=tmp1;</span><br><span class="line">            cur=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//反转部分链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode*&amp; last,ListNode*&amp; head,ListNode*&amp; tail,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ListNode* pre=tail-&gt;next;</span><br><span class="line">        ListNode* next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            next=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>&amp;&amp;last)</span><br><span class="line">            &#123;</span><br><span class="line">                last-&gt;next=head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后耗时20ms，内存9.7MB左右。</p><h1 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h1><p>2019/5/27，易。</p><p>去除排序数组中的重复数组。</p><p>本题本来以为是需要将重复数字删掉，但题目的意思其实是只需要让单独的数字出现在前面，超出单独数字长度后的数字可以不用删除，因为不用删除所有可以省很多时间，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[index])</span><br><span class="line">            &#123;</span><br><span class="line">                index++;</span><br><span class="line">                nums[index]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过一开始我以为是需要删除元素，所以用了迭代器来删除数组元素，最后也可以跑通，只是耗时会比较多，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//检查的过程中删除元素，改变了原数组的长度，耗时较长</span></span><br><span class="line">        <span class="keyword">int</span> cur=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=nums.begin()+<span class="number">1</span>;it!=nums.end();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*it==cur)</span><br><span class="line">            &#123;</span><br><span class="line">                it=nums.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur=*it;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h1><p>2019/5/31，易。</p><p>删除数组中指定元素，很简单的一道题，可以用vector的erase方法来删除，但联想到上一题，觉得题目要求应该只需要将非指定值的元素放在数组前面部分即可，所以最后写出的代码也没删除，只是替换了一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&gt;=<span class="number">0</span>&amp;&amp;nums[end]==val)</span><br><span class="line">            end--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=nums[i];</span><br><span class="line">                nums[i]=nums[end];</span><br><span class="line">                nums[end]=tmp;</span><br><span class="line">                <span class="keyword">while</span>(end&gt;=<span class="number">0</span>&amp;&amp;nums[end]==val)</span><br><span class="line">                    end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正常AC了，后来看别人的提交，其实连替换都不用，若有指定数字直接覆盖就行了，不过大同小异，不去深究。</p><h1 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28. Implement strStr()"></a>28. Implement strStr()</h1><p>2019/6/1，易。</p><p>判断是否是子串，由于这道题难度是简单，所以用最简单的遍历查找即可，至于KMP算法可以参见另一篇文章《剑指Offer+常用手写算法(C++)》。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最简单的遍历比较法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=haystack.size(),n=needle.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m-n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack[i+j]!=needle[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="29-Divide-Two-Integers-again"><a href="#29-Divide-Two-Integers-again" class="headerlink" title="29. Divide Two Integers(again)"></a>29. Divide Two Integers(again)</h1><p>2019/6/3，中。</p><p>不用乘法、除法以及模运算完成两个整数的除法，主要想法是使用移位运算，每次双倍，再做操作和累加，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">0</span>||(dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(divisor==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">int</span> sign = ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? <span class="number">-1</span> : <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dvd = <span class="built_in">labs</span>(dividend);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dvs = <span class="built_in">labs</span>(divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp = dvs , m = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (dvd &gt;= (tmp &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dvd -= tmp;</span><br><span class="line">            res += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign==<span class="number">1</span> ? res : -res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="30-Substring-with-Concatenation-of-All-Words（again）"><a href="#30-Substring-with-Concatenation-of-All-Words（again）" class="headerlink" title="30. Substring with Concatenation of All Words（again）"></a>30. Substring with Concatenation of All Words（again）</h1><p>2019/6/5，难。</p><p>有点难度的一道题，不过基本方法很好想，就依次遍历n*len的子串，针对每个子串进行验证是否成立，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="comment">//主要步骤，先找出所有n*len长度的子串，再一一验证</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">""</span>||words.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(words.size()&gt;<span class="number">0</span>)</span><br><span class="line">            len=words[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> lenOfSubstr=len*words.size();</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;lenOfSubstr)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; wordCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;word : words) </span><br><span class="line">            ++wordCnt[word];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s.size()-lenOfSubstr;i++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; strCnt;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; words.size(); ++j) &#123;</span><br><span class="line">                <span class="built_in">string</span> t = s.substr(i + j * len, len);</span><br><span class="line">                <span class="keyword">if</span> (!wordCnt.count(t)) <span class="keyword">break</span>;</span><br><span class="line">                ++strCnt[t];</span><br><span class="line">                <span class="keyword">if</span> (strCnt[t] &gt; wordCnt[t]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == words.size()) </span><br><span class="line">                res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>能够通过，只是效率比较低，看网上还有一种利用滑动窗口的方法，能够提高效率，可以百度看看。</p><h1 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h1><p>2019/6/10，中。</p><p>求字符数组按照字典序的下一个排列。</p><p>研究了几个排列后发现了一些规律，写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尝试思路：从右往左找第一个逆序对（idx1,idx2），交换位置，对idx1后面的数字重新排序，若没有逆序对则说明是最后一个排列，返回第一个排序即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//1 从右往左找第一个逆序对</span></span><br><span class="line">        <span class="keyword">int</span> idx1=<span class="number">-1</span>,idx2=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                idx1=i<span class="number">-1</span>;</span><br><span class="line">                idx2=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2 往右寻找比该数大的最小值</span></span><br><span class="line">        <span class="keyword">if</span>(idx1!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=idx1+<span class="number">1</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[idx1]&amp;&amp;nums[j]&lt;nums[idx2])</span><br><span class="line">                    idx2=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3 交换排序或者直接排序</span></span><br><span class="line">        <span class="keyword">if</span>(idx1!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=nums[idx1];</span><br><span class="line">            nums[idx1]=nums[idx2];</span><br><span class="line">            nums[idx2]=tmp;</span><br><span class="line">            sort(nums.begin()+idx1+<span class="number">1</span>,nums.end());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sort(nums.begin(),nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交通过了。</p><p>当然，C++本身还有一个<code>next_permutation</code>函数，直接用的话本题也能通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        next_permutation( nums.begin(), nums.end() ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="32-Longest-Valid-Parentheses（again）"><a href="#32-Longest-Valid-Parentheses（again）" class="headerlink" title="32. Longest Valid Parentheses（again）"></a>32. Longest Valid Parentheses（again）</h1><p>2019/6/13，难。</p><p>求最长有效括号子串，一开始就想到应该用动态规划或者栈的方法来做，但自己编程水平还是太菜，写了半天没写出来，看了网上的解答后觉得自己很蠢，虽然难度是难，但本题其实感觉并不难，给出代码吧，头疼。</p><p>不过这题有个技巧，栈的话会先在栈里放一个-1，动态规划的话则会在原字符串前加一个<code>)</code>，都是为了使处理更加方便，可能这就是自己没想到的地方吧，值得重视。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        st.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">                    res = max(res, i-st.top());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    st.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//dp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        s=<span class="string">')'</span>+s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.length(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>-dp[i<span class="number">-1</span>]]==<span class="string">'('</span>) dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>;<span class="comment">//累加本次的长度</span></span><br><span class="line">                dp[i]+=dp[i-dp[i]];<span class="comment">//和前面已经计算过的长度再做一次累加得到最后的数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            result=max(result,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="33-Search-in-Rotated-Sorted-Array-again"><a href="#33-Search-in-Rotated-Sorted-Array-again" class="headerlink" title="33. Search in Rotated Sorted Array(again)"></a>33. Search in Rotated Sorted Array(again)</h1><p>2019/6/21，中。</p><p>这两天奔波找房子参加毕业典礼啥的就没刷题，这道题之前做过类似的，主要使用二分法，并且在排除的过程中注意根据有序的部分数组来进行判断，以便决定去除左右哪一部分无效数据。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用二分法</span></span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;=nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])</span><br><span class="line">                    right=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h1><p>2019/6/26，中。</p><p>《剑指Offer》上有类似的题，又复习了一遍，提交的时候发现之前在LeetCode上做过这道题，用的是比较笨的办法，但在LeetCode上的执行效率却比递归方法高，有点意思，给出下面两种代码，核心思想仍然是二分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res=&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i=mid,j=mid;</span><br><span class="line">                <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]==target)</span><br><span class="line">                    i--;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;nums.size()&amp;&amp;nums[j]==target)</span><br><span class="line">                    j++;</span><br><span class="line">                res[<span class="number">0</span>]=i+<span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>]=j<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//递归方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//利用递归</span></span><br><span class="line">        res[<span class="number">0</span>]=getFirst(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>,target);</span><br><span class="line">        res[<span class="number">1</span>]=getLast(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==<span class="number">0</span>||(mid&gt;<span class="number">0</span>&amp;&amp;nums[mid<span class="number">-1</span>]!=target))</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> getFirst(nums,left,right,target);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid&lt;nums.size()<span class="number">-1</span>&amp;&amp;nums[mid+<span class="number">1</span>]!=target)||mid==nums.size()<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> getLast(nums,left,right,target);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h1><p>2019/7/6，易。</p><p>本题相对简单，写的时候也一次通过了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//不等</span></span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> &amp;&amp; nums[mid] &gt; target)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid == nums.size()<span class="number">-1</span> &amp;&amp; nums[mid] &lt; target)</span><br><span class="line">                <span class="keyword">return</span> nums.size();</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target &amp;&amp; nums[mid<span class="number">-1</span>] &lt; target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[mid+<span class="number">1</span>] &gt; target)</span><br><span class="line">                <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是后来看别人提交的代码的时候发现自己又把问题复杂化了，根本就不是二分查找的变种，而是最基本的二分法！要说变化也就是最后返回的值变成了left！还是对问题的理解程度太弱了，所谓寻找插入的下标，说白了原来就是返回left就行了，试验几次就会看出这个规律了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) r = middle - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) l = middle + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a>36. Valid Sudoku</h1><p>2019/7/7，中。</p><p>这道题我还记得之前第一次做的时候以为要把整个数独都填完呢，后来发现自己还是把问题复杂化了（似乎我的思维有这个毛病，得改），本题的意思其实只是判断input里每一行每一列每个九宫格有没有重复数字而已，并不用填充整个数独。</p><p>所以最简单的办法就是遍历判断好了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//即检查每一行每一列每一个九宫格内是否有重复数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; m1;   <span class="comment">//负责检查行</span></span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; m2;   <span class="comment">//负责检查列</span></span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; m3;   <span class="comment">//负责检查九宫格</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//分别检查第i行，第i列，第i个九宫格中的九个数，j表示第j个数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//每一行的坐标，不需要转换</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(m1[board[i][j]] == <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    m1[board[i][j]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每一列的坐标，横纵坐标互换即可</span></span><br><span class="line">                <span class="keyword">if</span>(board[j][i] != <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(m2[board[j][i]] == <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    m2[board[j][i]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//九宫格内坐标转换</span></span><br><span class="line">                <span class="keyword">if</span>(board[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][i%<span class="number">3</span>*<span class="number">3</span>+j%<span class="number">3</span>] != <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(m3[board[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][i%<span class="number">3</span>*<span class="number">3</span>+j%<span class="number">3</span>]] == <span class="literal">true</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    m3[board[i/<span class="number">3</span>*<span class="number">3</span>+j/<span class="number">3</span>][i%<span class="number">3</span>*<span class="number">3</span>+j%<span class="number">3</span>]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看别人的代码后发现有很精简的代码，但逻辑内核不变，这里也就不贴了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想养成刷题的习惯，之前刷过一点，但校招之后就断了，现在想捡起来，定个小目标，从头开始刷题吧，看能坚持多久。&lt;/p&gt;
&lt;h1 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1. Two Sum&quot;&gt;&lt;/a&gt;1. Two Sum&lt;/h1&gt;&lt;p&gt;2019/4/16，易。&lt;/p&gt;
&lt;p&gt;这题以前做过，记得第一次做的时候应该是用的最蠢的两重遍历方法相加求解，毫无疑问超时了，隐约记得可以使用查找&lt;code&gt;目标值-某个值&lt;/code&gt;是否存在该vector中来反向求解，简单写了一下，通过了。其实是一个反向思维的题，正面求解超时，则反向来求。仍然属于蛮力法的范畴，n&lt;sup&gt;2&lt;/sup&gt;时间复杂度，1空间复杂度，LeetCode平台耗时136ms。&lt;/p&gt;
&lt;p&gt;尝试降低时间复杂度，想到以空间换时间，在查找&lt;code&gt;目标值-某个值&lt;/code&gt;的时候，上述蛮力法使用&lt;code&gt;std::find&lt;/code&gt;方法，说白了也是一层遍历，这层遍历目的是为了查找差值是否存在于vector中并返回下标，自然可以想到用哈希表来代替这一层遍历。当然，事先需要遍历一次原数组构建哈希表。如此时间复杂度n，空间复杂度n。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Effeciteve Modern C++笔记</title>
    <link href="http://yoursite.com/2019/03/18/Effeciteve-Modern-C-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/18/Effeciteve-Modern-C-笔记/</id>
    <published>2019-03-18T13:03:08.000Z</published>
    <updated>2019-07-28T15:12:34.556Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录下阅读《Effective Modern C++》的一些笔记，列出本书的一些提纲，但不给出解释，希望后续复习时直接看提纲就能回忆起相关内容。</p><h1 id="条款1：理解模板型别推导"><a href="#条款1：理解模板型别推导" class="headerlink" title="条款1：理解模板型别推导"></a>条款1：理解模板型别推导</h1><p>针对以下代码，分为三种情况讨论。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure><ol><li>ParamType是个指针或引用，但不是个万能引用；</li><li>ParamType是个万能引用，又分为实参是左值还是右值；</li><li>ParamType不是指针也不是引用，又会分为实参具有引用或者指针特性或者什么都没有；</li></ol><p>除此之外还有一些参数会退化成指针的情况出现，比如数组实参、函数实参。</p><a id="more"></a><h1 id="条款2：理解auto型别推导"><a href="#条款2：理解auto型别推导" class="headerlink" title="条款2：理解auto型别推导"></a>条款2：理解auto型别推导</h1><p>对于条款1中的代码，auto=T，变量的型别修饰则是ParamType，其余规则除了一种特殊情况外则和条款1一致。</p><p>特殊情况：当用于auto声明变量的初始化表达式是用大括号括起来的时候，推导的型别就属于<code>std::initializer_list</code>。</p><p>根本原因在于，auto会假定用大括号括起来的初始化表达式代表一个<code>std::initializer_list</code>，但模板型别推导却不会。</p><p>注意：在C++14中auto可能用于函数返回值或lambda表达式的形参声明中，在这两种情况下auto进行的模板型别推导而不是正常的auto型别推导。</p><h1 id="条款3：理解decltype"><a href="#条款3：理解decltype" class="headerlink" title="条款3：理解decltype"></a>条款3：理解decltype</h1><p>C++11中，decltype的主要作用大概就在于声明那些返回值型别依赖于形参型别的函数模板。</p><p>绝大多数情况下，decltype会得出变量或表达式的型别而不作任何修改。</p><p>C++14会有些特殊。</p><h1 id="条款4：掌握查看型别推导结果的方法"><a href="#条款4：掌握查看型别推导结果的方法" class="headerlink" title="条款4：掌握查看型别推导结果的方法"></a>条款4：掌握查看型别推导结果的方法</h1><p>IDE、编译器等工具会有帮助，但理解条款1~3更重要。</p><h1 id="条款5：优先选用auto，而非显式型别声明"><a href="#条款5：优先选用auto，而非显式型别声明" class="headerlink" title="条款5：优先选用auto，而非显式型别声明"></a>条款5：优先选用auto，而非显式型别声明</h1><h1 id="条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法"><a href="#条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法" class="headerlink" title="条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法"></a>条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法</h1><p>隐形代理类和auto无法和平共处。</p><p>解决方案不应该放弃auto，而是强制进行另一次性别转换，即带显式型别的初始化物习惯用法。</p><p>还有一个好处是有时这样做可以强调程序员意在创建一个型别有异于初始化表达式型别的变量的场合。</p><h1 id="条款7：在创建对象时注意区分-和"><a href="#条款7：在创建对象时注意区分-和" class="headerlink" title="条款7：在创建对象时注意区分{}和()"></a>条款7：在创建对象时注意区分{}和()</h1><p>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析与法免疫。</p><p>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本更合适。</p><h1 id="条款8：优先选用nullptr，而非0或NULL"><a href="#条款8：优先选用nullptr，而非0或NULL" class="headerlink" title="条款8：优先选用nullptr，而非0或NULL"></a>条款8：优先选用nullptr，而非0或NULL</h1><p>可以避免在整型和指针型别之间重载。</p><h1 id="条款9：优先选用别名声明，而非typedef"><a href="#条款9：优先选用别名声明，而非typedef" class="headerlink" title="条款9：优先选用别名声明，而非typedef"></a>条款9：优先选用别名声明，而非typedef</h1><p>typedef不支持模板化，但别名声明支持。</p><p>别名模板可以让人免写“::type”后缀，并且在模板内，对于内嵌typedef的引用经常要加typename前缀。</p><h1 id="条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"><a href="#条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别" class="headerlink" title="条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"></a>条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h1><p>用<code>enum class</code>来定义枚举类，即使限定作用域的枚举型别。</p><h1 id="条款11：优先选用删除函数，而非private未定义函数"><a href="#条款11：优先选用删除函数，而非private未定义函数" class="headerlink" title="条款11：优先选用删除函数，而非private未定义函数"></a>条款11：优先选用删除函数，而非private未定义函数</h1><p>任何函数都可以删除，包括非成员函数和模板具现。</p><h1 id="条款12：为意在改写的函数添加override声明"><a href="#条款12：为意在改写的函数添加override声明" class="headerlink" title="条款12：为意在改写的函数添加override声明"></a>条款12：为意在改写的函数添加override声明</h1><h1 id="条款13：优先选用const-iterator，而非iterator"><a href="#条款13：优先选用const-iterator，而非iterator" class="headerlink" title="条款13：优先选用const_iterator，而非iterator"></a>条款13：优先选用const_iterator，而非iterator</h1><h1 id="条款14：只要函数不会发射异常，就为其加上noexcept声明"><a href="#条款14：只要函数不会发射异常，就为其加上noexcept声明" class="headerlink" title="条款14：只要函数不会发射异常，就为其加上noexcept声明"></a>条款14：只要函数不会发射异常，就为其加上noexcept声明</h1><h1 id="条款15：只要有可能使用constexpr，就使用它"><a href="#条款15：只要有可能使用constexpr，就使用它" class="headerlink" title="条款15：只要有可能使用constexpr，就使用它"></a>条款15：只要有可能使用constexpr，就使用它</h1><p>constexpr对象都具备const属性，并由编译期已知的值完成初始化。</p><p>constexpr函数在调用时若传入的实参值是编译期已知的，则会产出编译期结果。</p><h1 id="条款16：保证const成员函数的线程安全性"><a href="#条款16：保证const成员函数的线程安全性" class="headerlink" title="条款16：保证const成员函数的线程安全性"></a>条款16：保证const成员函数的线程安全性</h1><p>利用<code>std::mutex</code>或<code>std::atomic</code></p><h1 id="条款17：理解特种成员函数的生成机制"><a href="#条款17：理解特种成员函数的生成机制" class="headerlink" title="条款17：理解特种成员函数的生成机制"></a>条款17：理解特种成员函数的生成机制</h1><p>特种成员函数是指C++会自行生成的成员函数：默认构造函数、析构函数、复制操作以及移动操作。</p><p>自行生成的移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才会生成。</p><h1 id="条款18：使用std-unique-ptr管理具备专属所有权的资源"><a href="#条款18：使用std-unique-ptr管理具备专属所有权的资源" class="headerlink" title="条款18：使用std::unique_ptr管理具备专属所有权的资源"></a>条款18：使用std::unique_ptr管理具备专属所有权的资源</h1><p><code>std::unique_ptr</code>是小巧、高速的、具备只移型别的智能指针，对托管资源实施专属所有权语义。</p><h1 id="条款19：使用std-shared-ptr管理具备共享所有权的资源"><a href="#条款19：使用std-shared-ptr管理具备共享所有权的资源" class="headerlink" title="条款19：使用std::shared_ptr管理具备共享所有权的资源"></a>条款19：使用std::shared_ptr管理具备共享所有权的资源</h1><p><code>std::shared_ptr</code>是提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。</p><h1 id="条款20：对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr"><a href="#条款20：对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr" class="headerlink" title="条款20：对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr"></a>条款20：对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr</h1><h1 id="条款21：优先选用std-make-unique和std-make-shared，而非直接使用new"><a href="#条款21：优先选用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="条款21：优先选用std::make_unique和std::make_shared，而非直接使用new"></a>条款21：优先选用std::make_unique和std::make_shared，而非直接使用new</h1><p>相比于直接私用new表达式，make系列函数消除了重复代码、改进了异常安全性，并提升性能。</p><h1 id="条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"></a>条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h1><h1 id="条款23：理解std-move和std-forward"><a href="#条款23：理解std-move和std-forward" class="headerlink" title="条款23：理解std::move和std::forward"></a>条款23：理解std::move和std::forward</h1><p><code>std::move</code>只做一件事，就是把实参强制转换成右值，并不做移动。</p><p><code>std::forward</code>是有条件的强制型别转换：仅当其实参是使用右值完成初始化时，它才会执行向右值型别的强制型别转换。</p><p>在运行期，<code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p><h1 id="条款24：区分万能引用和右值引用"><a href="#条款24：区分万能引用和右值引用" class="headerlink" title="条款24：区分万能引用和右值引用"></a>条款24：区分万能引用和右值引用</h1><p>如果函数模板形参具备T&amp;&amp;型别，并且T的型别系推导而来，或如果对象使用auto&amp;&amp;声明其型别，则该形参或对象就是个万能引用。</p><h1 id="条款25：针对右值引用实施std-move，针对万能引用实施std-forward"><a href="#条款25：针对右值引用实施std-move，针对万能引用实施std-forward" class="headerlink" title="条款25：针对右值引用实施std::move，针对万能引用实施std::forward"></a>条款25：针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></h1><p>编译器若要在一个按值返回的函数里省略对局部对象的复制（或者移动），则需要满足两个前提条件：1局部对象型别和函数返回值型别相同；2返回的就是局部对象本身。</p><p>若局部对象可能适用于返回值优化，则请勿针对其实施std::move或std::forward。</p><h1 id="条款26：避免依万能指针型别进行重载"><a href="#条款26：避免依万能指针型别进行重载" class="headerlink" title="条款26：避免依万能指针型别进行重载"></a>条款26：避免依万能指针型别进行重载</h1><h1 id="条款27：熟悉依万能引用型别进行重载的替代方案"><a href="#条款27：熟悉依万能引用型别进行重载的替代方案" class="headerlink" title="条款27：熟悉依万能引用型别进行重载的替代方案"></a>条款27：熟悉依万能引用型别进行重载的替代方案</h1><p>SFINAE：substitution failure is not an error，替换失败不是错误。利用<code>std::enable_if</code>。</p><p>万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势。</p><h1 id="条款28：理解引用折叠"><a href="#条款28：理解引用折叠" class="headerlink" title="条款28：理解引用折叠"></a>条款28：理解引用折叠</h1><p>引用折叠：如果任一引用为左值引用，则结果就是左值引用，否则结果是右值引用。</p><p>引用折叠会在四中语境中发生：模板实例化、auto型别生成、创建和运用typedef和别名声明，以及decltype。</p><h1 id="条款29：假定移动操作不存在、成本高、未使用"><a href="#条款29：假定移动操作不存在、成本高、未使用" class="headerlink" title="条款29：假定移动操作不存在、成本高、未使用"></a>条款29：假定移动操作不存在、成本高、未使用</h1><p>对于那些型别或对于移动语义的支持情况已知的代码，则无需做以上假定。</p><h1 id="条款30：熟悉完美转发的失败情形"><a href="#条款30：熟悉完美转发的失败情形" class="headerlink" title="条款30：熟悉完美转发的失败情形"></a>条款30：熟悉完美转发的失败情形</h1><p>论及一般意义上的转发时，都是在处理形参为引用型别的情形。</p><ol><li>大括号初始化物</li><li>0和NULL用作空指针</li><li>仅有生命的整型static const成员变量</li><li>重载的函数名字和模板名字</li><li>位域：非const引用不得绑定到位域。</li></ol><h1 id="条款31：避免默认捕获模式"><a href="#条款31：避免默认捕获模式" class="headerlink" title="条款31：避免默认捕获模式"></a>条款31：避免默认捕获模式</h1><p>按引用的默认捕获会导致空悬指针问题。</p><p>按值的默认捕获极易受空悬指针影响，并会误导人们认为lambda式是自恰的。</p><h1 id="条款32：使用初始化捕获将对象移入闭包"><a href="#条款32：使用初始化捕获将对象移入闭包" class="headerlink" title="条款32：使用初始化捕获将对象移入闭包"></a>条款32：使用初始化捕获将对象移入闭包</h1><p>初始化捕获又称广义lambda捕获。</p><p>使用C++14的初始化捕获将对象移入闭包。</p><p>在C++11中，经由手工实现的类或std::bind去模拟初始化捕获。</p><h1 id="条款33：对auto-amp-amp-型别的形参使用decltype，以std-forward之"><a href="#条款33：对auto-amp-amp-型别的形参使用decltype，以std-forward之" class="headerlink" title="条款33：对auto&amp;&amp;型别的形参使用decltype，以std::forward之"></a>条款33：对auto&amp;&amp;型别的形参使用decltype，以std::forward之</h1><h1 id="条款34：优先使用lambda式，而非std-bind"><a href="#条款34：优先使用lambda式，而非std-bind" class="headerlink" title="条款34：优先使用lambda式，而非std::bind"></a>条款34：优先使用lambda式，而非std::bind</h1><p>C++14已经不需要用std::bind了</p><p>C++11中，std::bind仅在实现移动捕获、或是绑定到具备模板化的函数调用运算符的对象的场合中可能尚有余热可以发挥。</p><h1 id="条款35：优先选用基于任务而非基于线程的程序设计"><a href="#条款35：优先选用基于任务而非基于线程的程序设计" class="headerlink" title="条款35：优先选用基于任务而非基于线程的程序设计"></a>条款35：优先选用基于任务而非基于线程的程序设计</h1><p>std::thread 基于线程</p><p>std::async 基于任务</p><h1 id="条款36：如果异步是必要的，则指定std-launch-async"><a href="#条款36：如果异步是必要的，则指定std-launch-async" class="headerlink" title="条款36：如果异步是必要的，则指定std::launch::async"></a>条款36：如果异步是必要的，则指定std::launch::async</h1><p>std::async的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行。</p><p>正因为这种弹性，所以当以默认启动策略使用std::async的时候要考虑一些不确定性。</p><h1 id="条款37：使std-thread型别对象在所有路径皆不可联结"><a href="#条款37：使std-thread型别对象在所有路径皆不可联结" class="headerlink" title="条款37：使std::thread型别对象在所有路径皆不可联结"></a>条款37：使std::thread型别对象在所有路径皆不可联结</h1><p>在成员列表的最后声明std::thread型别对象。</p><h1 id="条款38：对变化多端的线程句柄析构函数行为保持关注"><a href="#条款38：对变化多端的线程句柄析构函数行为保持关注" class="headerlink" title="条款38：对变化多端的线程句柄析构函数行为保持关注"></a>条款38：对变化多端的线程句柄析构函数行为保持关注</h1><p>期值的析构函数在常规情况下，仅仅会析构期值的成员变量。</p><p>指涉到经由std::aysnc启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束。</p><h1 id="条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值"><a href="#条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值" class="headerlink" title="条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值"></a>条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值</h1><h1 id="条款40：对并发使用std-atomic，对特种内存使用volatile"><a href="#条款40：对并发使用std-atomic，对特种内存使用volatile" class="headerlink" title="条款40：对并发使用std::atomic，对特种内存使用volatile"></a>条款40：对并发使用std::atomic，对特种内存使用volatile</h1><p>注：一般地，编译器可以将不相关的赋值语句重新排序。</p><p>volatile的用处是告诉编译器，正在处理的内存是特种内存，不具备常规行为，即读写操作不可以被优化。</p><p>最常见的特种内存就是用于内存映射I/O的内存。</p><h1 id="条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"><a href="#条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递" class="headerlink" title="条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"></a>条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h1><p>经由构造复制形参的成本可能比经由赋值复制形参高出很多。</p><p>按值传递肯定会导致切片问题，所以基类型别特别不适用于按值传递。</p><h1 id="条款42：考虑置入而非插入"><a href="#条款42：考虑置入而非插入" class="headerlink" title="条款42：考虑置入而非插入"></a>条款42：考虑置入而非插入</h1><p>从原理上说，置入函数（emplace）应该有时比对应的插入函数（insert、push）高效，而且不应该有更低效的可能。</p><p>但从实践上说，置入函数在以下几个前提成立时，极有可能会运行的更快：</p><ol><li>待添加的值是以构造而非赋值方式加入容器；</li><li>传递的实参型别与容器持有之物的型别不同；</li><li>容器不会由于存在重复值而拒绝待添加的值。</li></ol><p>置入函数可能会执行在插入函数中会被拒绝的型别转换，如隐式型别转换构造函数。</p><p>置入函数使用的是直接初始化，而插入函数使用的复制初始化。</p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录下阅读《Effective Modern C++》的一些笔记，列出本书的一些提纲，但不给出解释，希望后续复习时直接看提纲就能回忆起相关内容。&lt;/p&gt;
&lt;h1 id=&quot;条款1：理解模板型别推导&quot;&gt;&lt;a href=&quot;#条款1：理解模板型别推导&quot; class=&quot;headerlink&quot; title=&quot;条款1：理解模板型别推导&quot;&gt;&lt;/a&gt;条款1：理解模板型别推导&lt;/h1&gt;&lt;p&gt;针对以下代码，分为三种情况讨论。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ParamType param)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f(expr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;ParamType是个指针或引用，但不是个万能引用；&lt;/li&gt;
&lt;li&gt;ParamType是个万能引用，又分为实参是左值还是右值；&lt;/li&gt;
&lt;li&gt;ParamType不是指针也不是引用，又会分为实参具有引用或者指针特性或者什么都没有；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除此之外还有一些参数会退化成指针的情况出现，比如数组实参、函数实参。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>未完待续-叁</title>
    <link href="http://yoursite.com/2019/02/04/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E5%8F%81/"/>
    <id>http://yoursite.com/2019/02/04/未完待续-叁/</id>
    <published>2019-02-04T10:51:59.000Z</published>
    <updated>2019-07-28T15:15:15.738Z</updated>
    
    <content type="html"><![CDATA[<p>（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。全文一万字左右，慎读。本文写于己亥年春节前夕。）</p><p>人们高兴，人们悲哀。</p><p>人们憧憬，人们缅怀。</p><p>一左一右的时间，握在手里放不开。</p><p>人啊，</p><p>总是不愿承认，</p><p>现在的境遇，</p><p>有时候已经是最好的安排。</p><p>……</p> <a id="more"></a><p>决定要不要写这篇《叁》用了很久时间，从2017年1月到2018年6月，本科毕业了，连硕士毕业都已在眼前。</p><p>而从决定了到真正动笔，又花费了半年，半年里我走过了江浙沪。</p><p>最终真正写下第一个字的时候，家里又添置了不少衣服，除了不少尘灰。</p><p>所以啊，人生很长，许多事都在做；人生很短，有些事做不完。</p><p>时光一去如梭，两天不见的、两月不见的、两年不见的、甚至更久未见的各位，你们过得怎么样？</p><p>我觉得我过得还不算太坏。</p><p>过去的《壹》和《贰》里，大多数写的都是和朋友间的往事，但今年实习以来，更多的时间是和自己在一起，所以这篇文字里可能关于自己的内容会多一些，这是自我总结的一篇文章。</p><p>《贰》的结束时间点在2018年春节，这个系列不是小说，我没法直接打出“XX年后”这样的字段跳到最近来叙述，所以还得按顺序来。</p><p>先来后到，很好。</p><p>插句题外话，之前有段时间动不动发朋友圈发说说好像被视为一种没事找事，所以我也没有发太多怕打扰到别人更怕看不懂的人说些煞风景的话，但后来我发现这样会导致一系列的遗忘，我已经想不起来太多太多生活中细小的喜怒哀乐了，而这是令我很不喜甚至是不能容忍的，所以我捡回发朋友圈的习惯。（好像插得有点多，对不起对不起，不能再插了，哈哈哈哈哈哈哈哈哈啊哈~~~）</p><p>但不好意思，还得再插一句，因为刚刚拉朋友圈近两年列表的时候突然发现，这一年和女票去的最多的那家勿相忘串串，这家我自以为和它一见钟情的串串店，原来早在2017年4月的时候就和它有过邂逅，这不朋友圈里还留着当时到店转发文章集赞的记录吗？这种感觉就很美好，以为是一见倾心，原来早已相逢。（这次题外话真的结束了。）</p><p>17年春节后，第一件大事自然是考研成绩出榜，我记得那天我正好和表弟逛完街回来，到点之后倒也没有特别得着急，说起来可能有的时候人就是知道自己付出了多少努力和应该得到怎样的结果，所以所谓的狂喜都是出现在你知道你的努力配不上结果的时候。</p><p>我走进自己卧室，坐在床沿上，对着面前那张很多年前买的、廉价的、随意用细胶带粘住四个角的、有点破损卷边的火影海报，用我的第三台手机——VIVO X5查出了成绩。</p><p>三位数，四开头，和我预估的分数甚至只误差1分。</p><p>那便够了。</p><p>说一点不开心那太装了，当然开心，心里确实也很轻松，但更多的却是庆幸。</p><p>那天晚上，夜深人静的时候我还坐在家中阳台上，望着寂静的夜空，没有什么星星，但我知道那里真的有。</p><p>然后我在知乎上写了篇回答，回答的是那天刚刚刷出来的热门问题“考研出成绩后，你有什么感受？”。</p><p>每打出一句话就是一层剥离，那半年里将我牢牢捆绑的层层束缚与强压都在回答中褪去了。</p><p>那是于我而言第一次真正的救赎。</p><p>后来也有几个人在回答下留言，有恭喜的，有加油的，当然也有跟我说自身经历和我相似的，告诉我战胜自己的不是我一个人。</p><p>其中有一个2017年九月左右的评论者似乎比我小一届，她说经历一样，她说希望三个月也能逆袭，她说她会努力的。</p><p>我说加油，成功后会感受到不一样。</p><p>我不常看知乎消息，因为没什么存在感，看到她的再次留言已经是2018年年初的事情。</p><p>她说她成功了，成绩比我要更好，她说她反反复复查了好几次，因为不敢相信，她说她这几个月每次撑不下去的时候就会来看看，给自己鼓劲。</p><p>努力的人都能有回报，真好。</p><p>自己能给别人以力量，更好。</p><p> ……</p><p>开学之后，便是忙活毕设和准备答辩，转眼就到了要告别那座生活了四年的学校，现在想来竟然至今都不曾好好在笔下和它说声再见，但若现在再太郑重其事地来说这事的话又难免显得有些不合时宜，所以我说有些话该说的时候就要说，有些事该做的时候就要做，因为过了此时此刻此情此景，就都是他年他月他人他事，而当年的爱又最难提。</p><p>不记得是哪一天从科协收拾东西离开的，只记得那天科协里人挺多，大家都在聊天。</p><p>头顶的日光灯自然是没修好的。</p><p>把东西都塞进书包里，桌上就只剩下那只绿色乌龟玩偶，我喜欢借着它的长脖子把它挂在办公桌的挡板上。</p><p>我把它拿给了ZY，她觊觎此物很久了。</p><p>她可能刚开始没注意到我在收东西，从脑袋上拿下乌龟的时候意识到了啥，伸长脖子看了我的座位一眼，立马炸了。</p><p>“雨哥，你干嘛？”</p><p>“走了啊，你看SSM也收得差不多了。”我笑着摊了摊双手，笑容的弧度保持得很刻意，既不清浅，也不肆意。</p><p>她走到我俩位置前，好像没说啥。</p><p>我伸手把桌上的名牌撕了下来，故作随意地扔给她：“诺，还给你。”</p><p>她一甩手，重新塞到我手里，看着我：“你们的东西你们不留着，给我干嘛？”</p><p>那一刻我也不知哪来的怪脾气做犯，一把拿起名牌，撕了。</p><p>所有人都安静了。</p><p>纸张撕裂的声音惊醒了我，我也不知道自己那一刻是为什么，但我后悔了，可是已经撕了，能咋办？</p><p>所以我继续撕了下去，一至二，二至四，四至八……直到那两个字支离破碎再也拼不回来。</p><p>我望着手里的纸屑，脸上开始烧得滚烫，却不敢抬头。</p><p>那时候我竟有些害怕看到ZY的眼睛，甚至连身边其他人都不敢去看。</p><p>“我靠。”我听到面前女孩压着愠怒的低音。</p><p>我猛然抬起头，眯着眼挤出笑容，强作出一副无所谓的模样：“我也不想留着，就撕了呗。”</p><p>说什么不想留着，还不是一时没想好怎么接话。</p><p>有时候男人要面子的臭毛病真是更加要命。</p><p>她看了我一眼，甩头走了，只抛下一句：“随你。”</p><p>后来真是有点难受，本来按照我的性子这种名牌肯定是要留着的，我甚至连高中第5考场20桌的准考证都留着只为了当时凑个“520”，那天却不知发了什么疯，还惹得别人生气。</p><p>不过好在后来ZY没太生气，请她吃顿饭，小事化了。</p><p>那只绿色乌龟也随着一年后ZY她自己考研成功被带去了南大，可惜她是在仙林校区。</p><p>只不过名牌是真的没了，撒进垃圾桶后，如今恐怕早已腐烂，南农回了几次，但那间小屋子，是再也没进去过了。</p><p>或者应该找个机会，重新让ZY给我做张一模一样的？</p><p>……</p><p>那年初到杭州。</p><p>烟雨江南，满池荷花常开不败。</p><p>匆匆路过，一瞥流连。</p><p>刚到时下雨，我坐在公车上，绕西湖而行，隔着厚厚的玻璃和更厚的雨帘，想要看清朦胧灰白中的西子湖。</p><p>“前面要到于谦祠了。”二公子说。</p><p>啧，有文化的人就是不一样，“岳王庙”、“于谦祠”、“南屏晚钟”、“花港观鱼”，这些词二公子都信手拈来呀！</p><p>我就只知道雷峰塔，里面有法海，镇着一条白蛇，还有个书生叫许仙，人与妖爱得死去活来，却还是没能感动老和尚法海。</p><p>哦，还有断桥残雪，不管是传说还是歌曲都很早就吸引我去走一走，可真等到雨停了走上断桥的时候，我却插着耳机在QQ群里进行党课学习……</p><p>那时苏堤白堤还分不清，后来知道短的是白堤，长的是苏堤，我从断桥走下去的那一道长堤，是白堤。</p><p>即使只是较短的白堤，对我而言走下来也累得不行，实在没有勇气再去挑战苏堤。</p><p>歇脚的时候，我对身边的三公子和四公子说：“这次就走个白堤吧，苏堤明年再来走。”</p><p>“明年雨哥还来杭州？”三公子问。</p><p>“那是。”我也不知道哪来的自信，兴许是眼前粼粼的湖水晃了心神，不要脸说道，“明年我不就去网易实习了？”</p><p>“666！”三公子对着湖风鼓掌。</p><p>四公子更夸张，几乎要当场给我跪下了：“雨哥，带我啊，我也想去网易！”</p><p>翻白眼……</p><p>一年后，我真的去了网易实习，和二公子三公子再次在西湖聚首，但直到离开，也没有去过苏堤。</p><p>西湖是去过不少次，有事没事都爱去走走，但有意无意，每次都没能去苏堤看看。</p><p>暂且不提。</p><p>除了西湖，毕业旅行还和他们一起去了西溪湿地和灵隐寺，西溪湿地是自然，灵隐寺是人文，具体行程已经记不太清了，而且我读书少，不能像二公子一样把游记写得那么好，所以便简笔带过。</p><p>去西溪湿地的时候下着微雨，所以偌大的湿地景区里并没有多少游人，这便便宜了我们几个，倚栏走桥，穿雨过花，不用在意他人目光，摆尽了poss，搞尽了古怪，沾得一身雨露，快哉快哉。</p><p>去灵隐寺的时候是晴天，爬了飞来峰，在山顶的小亭子里坐了会儿，重新下山，下山的时候遇到溪涧，于是只能趟水而过，湿了整双鞋，倒也凉快去乏。</p><p>临走前还去了趟六和塔，爬到塔顶的时候将四周青山绿水收于眼底，清风拂面，铃铛轻响，于是我特意找了个角度拍了张照，想了半天配了首小小诗发了个朋友圈。</p><p>青山朱座，</p><p>替时间上锁。</p><p>天地蹉跎，</p><p>等你遇见我。<br><img src="/2019/02/04/未完待续-叁/psb.jpg"></p><p>哎呀，文字的滋味，有时候真是贪之不厌，即使写得再差也爱。</p><p>……</p><p>临回学校前，又去了一次西湖，想要弥补之前没能好好欣赏盛大音乐喷泉的遗憾，西湖周围的人是真的多——用二公子的话说，“不是溜对象就是溜孩子遛狗的”——而音乐喷泉又是其中数一数二的地方，自然吸引了源源不绝的人，甚至能感受到早晚高峰地铁的热情。</p><p>七点整，音乐起，喷泉开始升起。</p><p>而和喷泉一同升起的，是千千万万只手臂，手臂上是手掌，手掌里有手机。</p><p>这么漂亮的喷泉，自己看不到是可以的，但是一定要给手机那端的他/她看到。</p><p>分享是一件很快乐的事情，而如果你分享的对象也愿意和你分享的话，那快乐就会变成幸福。</p><p>喷泉只有两三曲音乐的时间，有梁祝，也有泰坦尼克号，悠扬的曲调从音响里传出来，被漫天起伏、旋转、挥舞的水流裹挟着飞舞，最后洒进满池湖水，波光粼粼，灯光渺渺。</p><p>和每次都没去成的苏堤相对比，音乐喷泉每次来西湖都会来看，倒是件有些奇怪的事，想来比较靠谱的解释应该是音乐喷泉往后走不远就是商城，吃饭聚餐首选，自然每次都会走到这里来。</p><p>离开杭州的时候，还不知道后来到底能不能再去，所以留了些未竟的心愿，而如今杭州是去过了并生活了半年，但那些想去的地方，却也没真的都走完。</p><p>可能有时候就是这样，明明只是想见你，所以故意落些东西在你家，好成为下次去的借口。</p><p>东西可以不要，但你不能不见。</p><p> ……</p><p>回到学校没歇几天，又去了一次常州恐龙园，这次是和高中挚友们一起，算是整个大学聚得最齐的一次，当然祖国的担当、伟大的军医同志XS照旧缺席。</p><p>说来这还是我第一次去游乐园，可惜女票没空，没有能一起来，她的缺席本就是遗憾，而因为少了她我没有足够的胆子坐上跳楼机过山车，又是更大的遗憾，所以归根结底还是要把锅甩给她，都是她的错！（跪搓衣板可真香！）</p><p>时间过得久了，很多细节都忘了，想要依靠照片寻回一些记忆的时候又发现手机换了，照片零零碎碎不成体统，真是有些让人抓狂，但好在还有人保存着，在此感谢提供老照片的各位，下次不会犯同样的错了。</p><p>去恐龙园的前一晚去了趟环球港，那里有一座摩天轮，如果她在的话，我想那天晚上我可以离星空更近一些。</p><p>吃了一顿避风塘，其他的菜都忘了，唯独记得那份榴莲春卷不错，炸得金黄的皮又脆又酥，榴莲夹心也是回味无穷。</p><img src="/2019/02/04/未完待续-叁/chunjuan.jpg"><p>去过游乐园的人都知道，排队两小时，玩命两分钟，第一次去还是有些放不开，只玩了趟疯狂毒龙钻，emmmm，是叫这个名字吗，还是我……</p><p>常恐：我真的是正经游乐园啊！！！</p><p>总之就是那个左右一百八十度摇摆的大摆锤就对了。</p><p>玩过之后我只能说，失重的感觉真的太难受了，感觉下面漏了，还有就是……活着真好。</p><p>你知道我在上面的时候心里在念叨啥吗？</p><p>“麻痹，你来啊，你还能整死老子不？”</p><p>“卧槽你真的来？”</p><p>“稳住，我们能赢……”</p><p>……</p><p>所以后来看着SYY和CSB两个人坐跳楼机的时候在那玩“落耶落耶”的，我可真是佩服得不行。</p><p>所以他俩后来出了恐龙园要去隔壁玩蹦极的时候我内心十分平静。</p><p>诶，等等，那个摇摆着跟过去的小胖子是什么鬼啊？</p><p>TY？</p><p>你不要命啦！</p><p>刚才在鬼屋里鬼哭狼嚎的时候忘啦！？</p><p>那绳子拴不住你的……</p><p>完了完了……</p><p>她真的跟他们一起上去了……</p><p>……</p><p>我抱头坐在下面的椅子里，想着这个世界一定是疯了。</p><p> ……</p><p>再后来学校里就开始了一系列的散伙饭，班级的、社团的、宿舍的，二公子和五公子整天不见人影，流连于各种酒席，烧烤啤酒旧事，饺子学妹余情。</p><p>用二公子的话说，是真的要吃到吐了。</p><p>但还是餐餐必去，顿顿皆到。</p><p>我倒是没去过几次，毕竟小透明，于是也乐得清闲，和宿舍其余三位公子在宿舍拍了不少合照，吃过一顿烧烤，也曾在午夜沿着中山陵漆黑的山道闲逛，走过下马坊、明孝陵，用手机的流光模式在小路上舞出绚烂的五角星。</p><p>毕业照自然是拍了不少的，古墙青苔的主楼下、大气巍峨的大鼎旁，都有都有。</p><p>拍照的那天是不是还下着小雨？不过部门的小孩们还是都来了，一个个拉着我拍了不少照片，不枉我对他们一年悉心“教导”呀。</p><p>转眼他们现在都要毕业了，而我竟然也又要毕业了，突然觉得自己辈分低了是怎么回事？要绷住要绷住。</p><p>小孩子们，以后也都要一直好好生活下去。<br><img src="/2019/02/04/未完待续-叁/xing.jpg" title="没找到五角星的图，就放这张了"></p><p>那些日子里，女票来了很多次，穿着我的学士服，拍了更多更多的照片。</p><p>和我不同，南农曾经是她想考的大学，只是错过了，但还好，我牵住了她，没让她走太远。</p><p>所以你要是想拍，就拍个够。</p><p>我都替你存着。</p><p> ……</p><p>那四年，终于还是划下了句号。</p><p>起点不算太完美，但终点的句号，好像还算圆润。</p><p>那么，就此别过。</p><p> ……</p><p>2017年9月，南京大学鼓楼校区。</p><p>同一座城市，离南农也不算远，ZSK两年前也搬到了这里，但却偏偏不曾真的来过。</p><p>其实，四年前就想来的啊，只是自己不够争气，倒在了半路。</p><p>真是走得很慢啊，但好在终于还是走到了这里，晚一点到，总比没到过强。</p><p>初来乍到，面对宿舍两尊本土巨佬，我和四公子（他保研也选了南大）一开始是处于瑟瑟发抖的状态的，常常听二佬交流而悟道，唯唯诺诺，晃晃不可终日。</p><p>但后来，发现二佬其实也是二皮脸大逗比，ZSK虽自幼相识，但六年级之后倒也没有再次同班过，印象里可能还保留着小时候的模样，但其实早已蜕变成了逗比中的战斗逼，一口骚话简直难辨雌雄；另一位WKS大佬，那可是能和四公子WJY试比高的资源小王子，足球迷，生活作息算是我见过最规律的——每晚十点必拉屎，拉完屎必洗澡，洗完澡必与父母通个电话，有时后两者会交换顺序，但前者，雷打不动，实乃律己之辈。</p><p>另外还认识了位其他宿舍的大佬，大名JXD，形容他也比较简单——gay逼，还好这货后来找到了女票，要不然还真不敢深交……深交……好像哪里怪怪的……</p><p>阿弥陀佛，我还是直的。</p><p> ……</p><p>当然除此之外还有幸结实了很多其他优秀的同学，真是很庆幸能和你们相识，每个人都有太多值得我学习的地方。</p><p>求学的过程没什么特别值得说的，无非是上了人生中第一堂全英文授课的课，无非又是熬夜复习一夜一门，转眼就到去年春节。</p><p>实习的压力倏忽来到面前，打量自己似乎也就比写“helloworld”强一些，这样怎么有机会找到好实习呢？</p><p>所以当机立断好好学习，一边和JXD互相监督学习一边收快递，最后当当送快递的大叔把书递到我手里的时候看着我意味深长地说道：“小伙子很认真啊！”</p><p>好吧大叔，我知道你是在问我同是当当自营为什么就不能一起买？非要一本本买，你都连续给我送一个礼拜了！</p><p>我也没办法……谁让一会儿觉得看不完一会儿又觉得先买了再说呢……</p><p>总之去年春节似乎回到了考研的状态，看了不少书，刷了不少题，现在想来今年能去网易、能有现在，实实在在要感谢曾经努过力的自己。</p><p>时间，总不会骗人的。</p><p> ……</p><p>如果说2017年的主题是救赎，那么2018年的主题必然是前进了，这一年里几乎一直在求职，从三月份的开始春招找实习，直到十一月份最终选择阅文作为毕业后的第一份工作，大半年来整个人真的体会到了很多很多。</p><p>春招面试的时候，大大小小经历了几十场面试，从紧张到寻常，从定位不准到渐渐明白自己的水平与价值，与其说是面试，倒不如说更像是一次对自己的不断探索、不断寻找。</p><p>就像《猎场》里面，郑秋冬刚刚利用覃飞的身份的时候，也是经过一系列面试来让自己对这个身份更加熟悉，来检验自己的伪装是否到位。</p><p>面试确实是一种对自己很好的锻炼，虽然也曾在面试里回答不出问题痛不欲生，但事后想来终究还是自身太菜的原因，怨不得其他。</p><p>不管是春招还是秋招，我最后选择的竟然都是最后一个面试的公司，也都是在一定意义上面试的时候不抱希望的公司，甚至最后放弃了杭州而选择了魔都这座之前从未考虑过的可怕城市。</p><p>所以人生有时候真是玄之又玄，不可说，不可说。</p><p>时至今日我还记得网易HR告诉我面试通过的那个下午，那时我还在召唤师峡谷里玩个女警苟活发育，哪里也不敢冒头。</p><p>电话来得很突然，像平湖起惊雷，那阵子对浙江杭州的来电简直有一种迷一样的感觉。</p><p>按B回城，连忙接起电话走到阳台上，深深吸气，余光看到刚起床的ZSK坐到我位置上，开始操作我的撸啊撸。</p><p>……</p><p>等我回到座位上的时候，好嘛，这货已经送了两人头在玩黑白游戏。</p><p>局势一度陷入丢龙丢塔丢高地的境地，即使一起开黑的三公子奋力凯瑞似乎也要无力回天。</p><p>然后我有无尽了。</p><p>那时的无尽还没有改版。</p><p>那时的女警还没有成为下水道。</p><p>那时的我心情爆表。</p><p>那时的我们还没有放弃。</p><p>……</p><p>辅助开团。</p><p>上单打野跟上。</p><p>三公子小鱼人侧面切入。</p><p>我拉开距离开始输出。</p><p>枪枪爆头，瞬间吞没敌方四人。</p><p>只剩一人闪现逃窜。</p><p>然而皮城女警最爱的就是追杀。</p><p>微微半蹲，瞄准，红色的准星已经锁定，拉动扳机，让子弹飞一会儿。</p><p>“我？Miss？怎么可能？”</p><p>成功翻盘。</p><p>电子竞技不要放弃。</p><p>人生也不要。</p><p> ……</p><p>再到杭州，这次我不是过客。</p><p>RNG在MSI上摘下奖杯，那五个年轻人相拥着怒吼咆哮，金色的雨从天而降。</p><p>那时我正站在网易门前，耳机里充斥着“恭喜RNG”的声音，一门之隔的网易大厦灯火通明，人来人往，没人会注意到路旁树下持伞独立的男孩。</p><p>可那时的我就敢认为，这一年属于我也属于RNG。</p><p>可惜最后证明我错了，RNG倒在世界赛八强，沦为笑柄，我也没有选择一直在这里待下去。</p><p>刚收到offer的时候我和JXD说这下子我真的没有什么好烦恼的事情了，他说不可能，我这样的人总会有各种各样的烦心事。</p><p>你说的可真特么对，我可谢谢你。</p><p>才实习没几天，自己的积极性就被挫败感冲击得一败涂地，开始陷入阴暗的自我否定中。</p><p>那真是段难熬的日子，而且还孤单一人在陌生的城市，虽然那时候二公子还没去美国还在杭州工作，但毕竟相距颇远，有些感受经过信息电子流发送之后总觉得情不对意，索然无味。</p><p>于是倒头就睡。</p><p>但房间毗邻街道，楼层又高，马路上时不时驶过一辆大货车，就能清晰地感受到自己在晃动，惊得我连忙抱紧我的狗头抱枕。</p><p>房间里不知什么时候飞进来一直苍蝇，“嗡嗡嗡”从耳边飞过，甚至还降落在我的脸上。</p><p>我一个激灵坐起来，靠在床头大口喘气。</p><p>有时候人真是脆弱，黑夜里一只苍蝇都能使之崩溃。</p><p>无奈之下只能起床开灯，把书卷成卷，誓要把那只苍蝇打死以报心头之患。</p><p>于是往往要一直折腾到后半夜才勉强入睡。</p><p>女票来了几次，每晚下班回来走到楼下抬头看到房间里的灯亮着，心情就会稍微好一些。</p><p>第一次她来，走的时候我还在上班，晚上回到家打开房门……这货平时懒得要死，这次却偏偏把房间收拾得既干净又整齐，被子方方正正地叠在床上，门边属于她的那双粉色小拖鞋并排依偎着，灯光只照亮了房间一半，明暗分明。</p><p>只一瞬间我就没能绷住，她肯定是故意的。</p><p>等到艰难地慢慢熟悉了公司环境和工作节奏，终于不再像之前一样整日担惊受怕。</p><p>也是在那个时候，开始反思一些事情。</p><p>被挫败感吞没的时候，会想说如果没来这里，会不会就开心一些？每天上班下班，万家灯火看得太多，真的只会更寂寞。</p><p>但是后来想想，就算没来这，我总归会去一个其他地方实习，到时候恐怕也是一样吧？</p><p>就连ZSK他们刚开始实习的时候也会觉得自己啥也不会。</p><p>那或许情况并没有我想象地那么糟，说不定只是每个人到达一个新环境，每个学生初次工作都会经历的事情呢。</p><p>这里可是网易，是我最想来的地方，难道会更开心？</p><p>应该不会。</p><p>而恰好又在这个时候读文章看到了开头那句话。</p><p>“人总是不愿承认，现在的境遇，就是最好的安排。”</p><p>像是溺水者抓住的最后一根稻草，像是盛夏里最后一丝清风拂过面颊，像是黑夜里最后一丝光芒闪耀。</p><p>人们有时候总是幻想得到更好的，嫌弃自己当下拥有的，却忘了自己现在拥有的很多就是自己过去渴望的最好的，然后越贪婪，然后越埋怨，然后越失去。</p><p> ……</p><p>这半年初步体验了工作赚钱的不易，越发觉得众生皆苦，路上、地铁上、公司里，遇到的每一个成年人，我都忍不住去猜想他们身上都背负着怎样外人看不到的压力。</p><p>隔壁房间的室友有一次空调坏了，需要修外机，空调师傅说需要从我的房间窗户爬出去比较方便。</p><p>于是在接近四十度的大太阳下，男人从十楼的窗户翻了出去，只在腰间绑了根从厨房里好不容易找出来的细绳，用“根”来形容都不免有夸大之嫌，还是用“条”比较合适。</p><p>我和隔壁房间的室友把绳子抓得很紧，心里有些紧张，汗水瞬间湿透衣背，这尼玛要掉下去指不定能不能抓得住啊！</p><p>我建议把绳子绑在类似窗沿或者什么其他的固定物上固定一下，空调师傅摆手大笑：“不用，这才十楼，四十楼的空调不是一样修？你们两年轻力壮小伙子还抓不住？”</p><p>我更慌了，您从我身上是从哪看出年轻力壮来的……</p><p>没办法，我只能在手上把绳子饶了一圈又一圈，生怕有个意外没抓稳。</p><p>但还好一切顺利，空调师傅很快就翻了回来，比了个手势：“搞定。”</p><p>我走到窗前往下看了一眼，十楼的高度瞬间让我感觉有点晕，我缩回脑袋，想着每个人都在为生计奔波，这样的高危职业又能赚到几个钱？</p><p>真是说不出值还是不值。</p><p>空调师傅还在那跟我们侃大山，一边收拾家伙一边说他修空调的经历，有的时候被户主坑了耍了，有的时候修一次空调要跑好多次，有的时候从楼上摔下去，最可怕的一次就是从四十楼摔下去，头上脚下地在空中挂了半个小时，直到救护车赶来。</p><p>他都是笑着说这些事的，生活已经在男人身上留下很多粗糙的痕迹，眼角眉边皱纹隐现，老旧的白背心染了很多油渍灰尘，套上工作服便算完事。</p><p>“还有你的空调，我也顺手看了下，除了点灰。”男人看了我一眼说。</p><p>“哦哦那太感谢了。”</p><p>“不算事，走了。”男人拎起工具箱走了。</p><p>门口楼道里有闪灯一闪一闪，直到我离开也人来修。</p><p>男人站在灯下，黝黑的脸庞一明一暗。</p><p>他忽然抬头，开口骂道：“什么破灯？老子找根棍给你捅灭咯！”</p><p>……</p><p>有时候想着若是把空调师傅他们的压力换到我身上，恐怕就是片刻也会压得我喘不过气来，可他们却依然能在这种平凡甚至是沉重的生活中找到快乐。前阵子看到快手上有个跑运输的司机似乎挺火，三十几岁便已两鬓斑白，抬头纹深到能塞进整条河流。</p><p>他们一样在这地球上生活着，没有光鲜，甚至没有太多钱，他们的苦痛比我不知多出多少，可他们比苦痛更坚强、更坚韧，所以他们依然拥有快乐与幸福。</p><p>这世上的苦难没法击倒人的，能击倒人的只有人。</p><p>实在是太佩服。</p><p>众生皆苦，但众生也都在苦中作乐，并且真的能寻到快乐，这才是众生最值得敬佩的地方，因此他们才活在这世上，因此这世界才太精彩。</p><p>The one与众生，太多人想成为the one，但太多人都只是众生。</p><p>我好像却不是很想成为the one，我偏爱众生。</p><p>有人说明知道生活的残酷并且还热爱它的人就是英雄。</p><p>那众生皆是英雄。</p><p>我希望我也能尽快成为这样的众生、这样的英雄。</p><p> ……</p><p>在网易实习了半年时光，最后却选择了离开，不是说不喜欢它了，而只是自己想换条路去走一走，想看一看别处的风景，即使相比下来可能更加路远水长。</p><p>二公子结束了杭州的工作，转而奔向了美国进修，临行前吃了顿饭，之后也多次进行友好的跨洋交流，二公子还是牛逼的，虽然晚了一年时间，但就像我前面说的，想去的地方，只要最后能去，总比从没去过强。</p><p>半年里女票来了几次，有时会带她去一些地方逛逛；XS和CX也来找我玩过，去的地方也都是西湖沿岸，重复描述没什么必要，只是和女票走了趟九溪十八涧，在走到倒数第二个溪涧的时候没保住“节操”，一脚踏进了冰凉的溪水中，于是彻底放开，嬉闹了很久；和XSCX登了雷峰塔，重温了那段凄美的神话爱情传说。</p><p>除此之外，研究生宿舍三位大佬秋招来网易面试的时候各见了一面，ZSK从北京赶高铁过来，到的时候已经要午夜十二点，下车一甩车门，隔着一条马路就气沉丹田地喊“雨狗”，我可真是去你的。</p><p>最后的时候，JXD也来了杭州，他秋招最终还是选择了杭州的公司，临行前必然要约一波，本来说要他请客，然而又拖了过去，没事，拖到年后开学档次就该上升到水林间了。去了趟APPLE体验店，JXD和WKS已经没救，扑到新款ipad上就是一阵口水与屏幕摩擦的声音，我反正没钱，所以成功地没做一只舔狗。</p><p>离开杭州的那天也在下雨，这座城市似乎整年笼罩在雨水中，太阳只难得几天才有幸露个脸。</p><p>刚开始实习的时候想着要实习半年，觉得那可是一段很长的时间啊。</p><p>可等到离开的时候才发现，半年时光竟然也就这么一晃而过了，还记得第一次在食堂吃免费午餐、在天台吃露天烧烤、组内团建……竟都已一去不复返了。</p><p>离开网易的时候，RNG也正好倒了下来，在一场全年度最不该输的BO5里输了，金色的丰碑坍塌，寂静无声。</p><p>离开网易之后，没休息几天就来了上海，加入了阅文集团，对于一个有写作梦的人来说，最后选择这里好像也没什么太出人意料的地方。</p><p>在这里认识了更多优秀有趣的人，也感觉到自己在做的事好像有点意思，虽然还有很多很多东西要学，但不着急，慢慢学，摆正心态才是正确的，毕竟现在这一切是我自己选的，自己选的就是最好的。</p><p>转眼又是两个月过去，在阅文的实习也快结束了。</p><p>而2019年的春节，就要到了。</p><p>时间永远是这么温柔的杀手。</p><p>这一年，李敖走了；</p><p>这一年，霍金走了；</p><p>这一年，李咏走了；</p><p>这一年，计春华走了；</p><p>这一年，单田芳走了；</p><p>这一年，蓝洁瑛走了；</p><p>这一年，金庸也走了；</p><p>还有太多其他人离我们而去了，把名字都列出来的话估计比这篇文章的字数还多。当然，离开的更多的是你我这样没有名字的众生。</p><p>我们永远不知道和某人某地的相聚会不会是最后一次，所以每一次的相聚都应该用力一些，每一次告别也都应该深情一些。</p><p> ……</p><p>似乎每次落笔都是在看过某部电影之后，《未完待续2》是在看了《驴得水》之后几天写的，而在写这篇文字的第一字时，刚好从《无名之辈》的汹涌情感里抽出身来，可能是因为最近感悟的缘故，我觉得《无名之辈》拍的挺不错，我们都是这个世界上的无名之辈，过着自己的喜怒哀乐，孤独却也相互扶持。</p><p>人类的悲欢虽不相通，但我们还可以相遇、相知、相爱、相拥。</p><p>和我落笔前想的差不多，这一篇《叁》没有写太多的人和事，主要写的是自己今年的一些总结体会，也不知道有没有说清楚说全，但既然是同一个系列，字数也不该差太多，一万字可以了。</p><p>很多人没提到，提到的人也大多都只是一笔带过，我知道这个系列有很多人是为了看我写你写我写他，但这篇有些抱歉，有很多事情没有写，有很多人没出现。</p><p>但请相信，我没有将你们遗忘。</p><p>现在没钱，所以只能你们请我吃饭。</p><p>等我有钱了，就还让你们请我吃饭！</p><p>如果说每个人都是一个点，那么人与人之间的联系便是一根线，这根线会沿着某条轨迹蜿蜒或者笔直地延伸出去，有时候会断，有时候不会，有时候是寻常颜色，有时候它们会加深或变淡，有时候还可能有一条会变成红色。</p><p>这些线条彼此之间有时独立，有时相互影响，最后绘制成一幅恢弘的图画。</p><p>而对于我们，这幅图画还远没有结束。</p><p>既然没有结束，那自然就有未完待续。</p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。全文一万字左右，慎读。本文写于己亥年春节前夕。）&lt;/p&gt;
&lt;p&gt;人们高兴，人们悲哀。&lt;/p&gt;
&lt;p&gt;人们憧憬，人们缅怀。&lt;/p&gt;
&lt;p&gt;一左一右的时间，握在手里放不开。&lt;/p&gt;
&lt;p&gt;人啊，&lt;/p&gt;
&lt;p&gt;总是不愿承认，&lt;/p&gt;
&lt;p&gt;现在的境遇，&lt;/p&gt;
&lt;p&gt;有时候已经是最好的安排。&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux下C++基础篇</title>
    <link href="http://yoursite.com/2019/01/26/Linux%E4%B8%8BC-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2019/01/26/Linux下C-基础篇/</id>
    <published>2019-01-26T06:31:12.000Z</published>
    <updated>2019-07-28T15:13:21.282Z</updated>
    
    <content type="html"><![CDATA[<p>以前没系统学过linux下C++的一些基本开发方法，所以抽空在网易云课堂上听了个课程简单学习一下基础，本文记录一下听课中的笔记。</p><p>课程前几章介绍开发环境、linux基础操作、配置SAMBA共享目录啥的就不进行记录了，毕竟听这个课是为了补一下linux下如何进行C++编程的基础知识。</p><p>最简单的两个命令记录一下：</p><p><code>g++ -c main.cpp -o main.o</code>：表示将main.cpp编译成main.o中间文件。</p><p><code>g++ main.o -o helloworld</code>：表示将main.o链接成可执行文件helloworld。</p><p>也可直接：</p><p><code>g++ main.cpp -o helloworld</code></p><a id="more"></a><h1 id="第五章-makefile"><a href="#第五章-makefile" class="headerlink" title="第五章 makefile"></a>第五章 makefile</h1><p>makefile的基本规则在另一篇笔记里记录了，这里只记录几个新的点。</p><h2 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h2><p>增量编译其实在记录makefile的那篇笔记里也提过，就是当某个文件改变时，只增量编译受影响的文件，而不是把整个项目重新编译。</p><p>增量编译是靠文件时间来判断的，查看文件时间可以用：<code>ls -ls --full-time</code></p><p>所谓的比较时间，规则如下：</p><ol><li>如果target不存在，则执行make，否则转2；</li><li>如果dependencies的时间比target时间新，则执行make，否则转3；</li><li>输出已经是最新的了，不执行规则。</li></ol><h2 id="优化makefile"><a href="#优化makefile" class="headerlink" title="优化makefile"></a>优化makefile</h2><p>这个教程里的优化写的比较简单，但也可以学习：</p><ul><li>使用变量、通配符</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">g++  ‐c <span class="variable">$&lt;</span>  ‐o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li>自动罗列*.o文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CXX_SOURCES=$(wildcard*.cpp)</span><br><span class="line">CXX_OBJECTS=$(patsubst%.cpp,%.o,<span class="variable">$(CXX_SOURCES)</span>)</span><br></pre></td></tr></table></figure><ul><li>头文件依赖</li></ul><p>使用编译选项-MMD，比如<code>g++ -c -MMD main.cpp -o main.o</code>则会在生成main.o的同时生成main.d文件，该文件里的内容就是所需要的依赖，然后如下操作:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEP_FILES=$(patsubst%.o,%.d,<span class="variable">$(CXX_OBJECTS)</span>)</span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">g++  ‐c‐MMD <span class="variable">$&lt;</span>  ‐o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用‐include指令，将所有的.d文件包含进来</span></span><br><span class="line">‐<span class="keyword">include</span><span class="variable">$(DEP_FILES)</span></span><br></pre></td></tr></table></figure><ul><li>利用foreach函数进行对子目录的支持</li></ul><p>该章节最终的makefile如下，能支持简单使用了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">######### 标准Makefile Lv1.0 ########</span></span><br><span class="line">EXE=helloworld</span><br><span class="line">SUBDIR=src object</span><br><span class="line"><span class="comment">#CXX_SOURCES=$(wildcard  *.cpp)</span></span><br><span class="line">CXX_SOURCES =<span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.cpp)</span>)</span><br><span class="line">CXX_OBJECTS=<span class="variable">$(<span class="built_in">patsubst</span>  %.cpp, %.o, <span class="variable">$(CXX_SOURCES)</span>)</span></span><br><span class="line">DEP_FILES  =<span class="variable">$(<span class="built_in">patsubst</span>  %.o,  %.d, <span class="variable">$(CXX_OBJECTS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(EXE)</span>: <span class="variable">$(CXX_OBJECTS)</span></span><br><span class="line">g++  <span class="variable">$(CXX_OBJECTS)</span> -o <span class="variable">$(EXE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">g++  -c  -MMD <span class="variable">$&lt;</span>  -o  <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEP_FILES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">rm  -rf  <span class="variable">$(CXX_OBJECTS)</span>  <span class="variable">$(DEP_FILES)</span>  <span class="variable">$(EXE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">echo <span class="variable">$(CXX_OBJECTS)</span></span><br></pre></td></tr></table></figure><h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><p>在compile这一步添加选项-g，如果没有用-g选项生成的可执行文件虽然也可以gdb运行，但是调试过程中不会显示调试信息，没什么用。</p><p><code>g++ -g main.cpp -o hello</code></p><p>b：添加断点</p><p>r：从头开始运行</p><p>n：下一步</p><p>c：程序继续运行直到下一处断点</p><p>p：显示表达式的值</p><p>info break：显示断点信息</p><p>del break n：删除编号n的断点</p><p>q：退出gdb</p><p>disp：监视变量的值</p><p>x：显示内存：x/16xb n，看16个单元，x表示16进制看，b表示每个单元多少字节，b是1个字节，h是2个字节，w是4个字节，g是8个字节。</p><p>bt：显示堆栈。</p><h2 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h2><p>在Linux下，程序中如果进行了不正确的指针操作(如空指针访问、野指针访问)，那么程序会崩溃，发生段错误(Segment Fault)。</p><p>很容易复现的话就可以直接用GDB来调试。</p><p>当错误不容易复现的时候，可以使用内存转储的手段。</p><p>内存转储步骤如下：</p><ol><li>ulimit -c unlimited</li><li>运行程序，程序发生段错误退出时会将信息转储到core.*文件中</li><li>用gdb来查看段错误的代码位置<code>gdb exe core.*</code>。</li></ol><p>一个程序生成时用了-g选项的话，生成的可执行文件会更大一些，因为包含了可调式信息。</p><p>如果要判断一个程序是否包含可调式信息，可以用<code>objdump -h helloworld</code>来判断，有debug就是有调试信息。</p><h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><ul><li>单元测试</li><li>段错误的定位</li></ul><h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><ul><li>大型程序</li><li>多线程</li></ul><h1 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h1><h2 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h2><p>编译：<code>g++ -c -fPIC example.cpp -o example.o</code></p><p>链接：<code>g++ -shared example.o -o libexample.so</code></p><p>PIC：position independent code位置无关代码</p><p>动态库命名规范：libxxx.so</p><p>可以使用nm命令查看库中的符号。</p><h2 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h2><p>包含头文件，调用里面的函数即可。</p><p>编译：<code>g++ -c main.cpp -o main.o</code></p><p>链接：<code>g++ main.o -o helloworld -L. -leample</code></p><p>-L.：指定库文件的位置</p><p>-leample：使用libexample.so这个动态库。</p><p>操作系统默认从标准位置寻找相应的库：/lib /usr/lib /usr/local/lib</p><p>如果没有就会去LD_LIBRARY_PATH环境变量里找。</p><p>所以要想使用自己的库，得做好上述设置。</p><h3 id="查看依赖的库"><a href="#查看依赖的库" class="headerlink" title="查看依赖的库"></a>查看依赖的库</h3><p><code>readelf -d helloworld</code></p><p>通常目录结构是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libxxx/</span><br><span class="line">-lib/</span><br><span class="line">-include/</span><br></pre></td></tr></table></figure><p>常用CXXFLAGS表示C++编译选项，LDFLAGS表示链接选项。</p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>命名标准：libxxx.a</p><p>第一步，编译得到.o文件</p><p>第二步，打包<code>ar -rcs libxxx.a file1.o file2.o...</code></p><p>静态库本质就是将.o文件打个包而已，因此可以像.o文件一样使用。</p><p>当静态库和动态库同时存在的时候，会优先选择动态库进行链接，若要使用静调库，泽科使用全路径方式指定静态库。</p><h2 id="c-兼容c的库"><a href="#c-兼容c的库" class="headerlink" title="c++兼容c的库"></a>c++兼容c的库</h2><p>以前就学过，用external “C”即可，但比较好的做法是在.h文件中就写好兼容C和C++的版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="动态库的手工加载"><a href="#动态库的手工加载" class="headerlink" title="动态库的手工加载"></a>动态库的手工加载</h2><p>使用dl库中的函数</p><p>#include&lt;unistd.h&gt;</p><p>#include&lt;dlfcn.h&gt;</p><p>具体再看教程吧，感觉用的不多，主要用dlopen、dlsym和dlclose方法。</p><h1 id="Linux文件读写"><a href="#Linux文件读写" class="headerlink" title="Linux文件读写"></a>Linux文件读写</h1><p>简单来说有两种方式：</p><ol><li>ANSI C，使用stdio.h里的函数fopen、fclose、fwrite、fread。</li><li>Linux API，open、close、write、read</li></ol><p>推荐使用第一种吧，能被各平台支持。</p><p>使用第一种的时候，文件路径使用/，换行符Linux和windows下不同，linux是\n，windows是\n\r。</p><p>普通情况下均推荐使用ANSIC来操作文件。</p><p>仅当该文件表示一个外部设备时，才用LinuxAPI来操作。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>在Linux下，使用pthread库来创建和操作线程，pthread是Linux系统自带的一个库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(&amp;handle,<span class="comment">//指代一个线程对象，pthreat_t类型的实例</span></span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">               function,<span class="comment">//线程入口函数，用函数指针</span></span><br><span class="line">               context<span class="comment">//线程参数</span></span><br><span class="line">              )</span><br></pre></td></tr></table></figure><p>线程主函数退出时，线程自然终止。</p><p>pthread_join（handle，NULL）：等待B线程自然退出，在B线程退出后回收B线程的系统资源。</p><p>pthread_cancel：用于终止取消一个正在运行的线程，不推荐使用。</p><h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><p>pthread_mutex_t hMutex；</p><p>pthread_mutex_init（&amp;hMutext，NULL）；</p><p>pthread_mutext_destroy（&amp;hMutext）；</p><p>pthread_mutext_lock(&amp;hMutex);//不能获取锁的时候会阻塞，但trylock不能获取锁的时候就会直接返回。</p><p>pthread_mutext_unlock(&amp;hMutex);</p><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> hSem;</span><br><span class="line">sem_init(&amp;hSem,<span class="number">1</span>,initial_value);</span><br><span class="line">sem_destroy(&amp;hSem);</span><br><span class="line">sem_wait(&amp;hSem);</span><br><span class="line">sem_post(&amp;hSem);</span><br></pre></td></tr></table></figure><h1 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h1><p>何为进程？</p><p>当helloworld文件被运行后，在操作系统内部创建一个进程对象。</p><p>查看进程：ps。</p><p>top：实时查看进程。</p><p>kill强制杀死进程。</p><h2 id="前台进程和后台进程"><a href="#前台进程和后台进程" class="headerlink" title="前台进程和后台进程"></a>前台进程和后台进程</h2><p>关闭终端时会关闭前台进程。</p><p>以后台进程运行，在命令行后面加一个&amp;符号。</p><p>前后台进程切换：ctrl+z暂停任务，bg将任务送到后台继续任务，fg将任务拿到前台运行。</p><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>IPC：inter-process communicating。</p><p>四种方式：管道、消息队列、共享内存、网络套接字。</p><p>管道：pipe，是Linux操作系统提供的一个消息传递机制。</p><ol><li>系统中创建一个文件，其文件类型为管道<code>mkfifo message</code></li><li>进程A打开该文件写入数据</li><li>进程B打开该文件读取数据</li></ol><p>open是阻塞的，read也是阻塞的，管道是单向的，和普通文件有区别。</p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>查看可用的系统调用<code>man syscalls</code></p><p>如果找不到对应的系统调用，可以在代码里直接调用命令行，用system().</p><p><code>int ret = system(&quot;rm -rf *.txt&quot;);</code></p><p>该函数会阻塞。</p><p>也可以用popen（）：调用某个命令行，并获取其标准输出。</p><p>该函数是linux特有的，windows下对应的叫_popen/_pclose</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = popen(<span class="string">"ifconfig"</span>,<span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">int</span> n = fread(buf,<span class="number">1</span>,<span class="number">512</span>,fp);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><p>尽量使用标准函数/类型/语法</p><p>可以用条件编译。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前没系统学过linux下C++的一些基本开发方法，所以抽空在网易云课堂上听了个课程简单学习一下基础，本文记录一下听课中的笔记。&lt;/p&gt;
&lt;p&gt;课程前几章介绍开发环境、linux基础操作、配置SAMBA共享目录啥的就不进行记录了，毕竟听这个课是为了补一下linux下如何进行C++编程的基础知识。&lt;/p&gt;
&lt;p&gt;最简单的两个命令记录一下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;g++ -c main.cpp -o main.o&lt;/code&gt;：表示将main.cpp编译成main.o中间文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;g++ main.o -o helloworld&lt;/code&gt;：表示将main.o链接成可执行文件helloworld。&lt;/p&gt;
&lt;p&gt;也可直接：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;g++ main.cpp -o helloworld&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>makefile学习</title>
    <link href="http://yoursite.com/2019/01/13/makefile%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/13/makefile学习/</id>
    <published>2019-01-13T08:07:47.000Z</published>
    <updated>2019-07-28T15:13:32.961Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录下对Makefile学习的一些笔记。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_38391755/article/details/80380786" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38391755/article/details/80380786</a></p><h1 id="makefile简介和例子"><a href="#makefile简介和例子" class="headerlink" title="makefile简介和例子"></a>makefile简介和例子</h1><p>个人感觉makefile就是整个项目工程的一个编译规则，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p><p>该文章是基于GNU make的。</p><a id="more"></a><h2 id="makefile介绍"><a href="#makefile介绍" class="headerlink" title="makefile介绍"></a>makefile介绍</h2><p>makefile主要规则：</p><ol><li>如果一个工程没有编译过，那么我们的所有源文件都要编译并链接；</li><li>如果一个工程的某几个源文件被修改过，那么我们只编译被修改的源文件，并链接目标程序；</li><li>如果头文件改变，那么需要编译引用了该头文件的源文件，并链接目标程序。</li></ol><h2 id="makefile规则"><a href="#makefile规则" class="headerlink" title="makefile规则"></a>makefile规则</h2><p>核心规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">command</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>target是一个目标文件，可以是objectfile，也可以是执行文件，还可以是一个标签。</p><p>prerequisites是要生成target所需的文件或是目标。</p><p>command就make需要执行的命令，即任意的shell命令。</p><p>说白了，所有makefile的东西就是这个规则，但具体还有很多细节。</p><p>【注】在别人的makefile文件中，有时会遇到以下三个变量：$@/$^/$&lt;，含义分别如下：</p><p>$@：目标文件</p><p>$^：所有依赖文件</p><p>$&lt;：第一个依赖文件</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>原文中的示例如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">           insert.o search.o files.o utils.o</span><br><span class="line">            cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">                       insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">    main.o : main.c defs.h</span><br><span class="line">            cc -c main.c</span><br><span class="line">    kbd.o : kbd.c defs.h command.h</span><br><span class="line">            cc -c kbd.c</span><br><span class="line">    command.o : command.c defs.h command.h</span><br><span class="line">            cc -c command.c</span><br><span class="line">    display.o : display.c defs.h buffer.h</span><br><span class="line">            cc -c display.c</span><br><span class="line">    insert.o : insert.c defs.h buffer.h</span><br><span class="line">            cc -c insert.c</span><br><span class="line">    search.o : search.c defs.h buffer.h</span><br><span class="line">            cc -c search.c</span><br><span class="line">    files.o : files.c defs.h buffer.h command.h</span><br><span class="line">            cc -c files.c</span><br><span class="line">    utils.o : utils.c defs.h</span><br><span class="line">            cc -c utils.c</span><br><span class="line">    clean :</span><br><span class="line">            rm edit main.o kbd.o command.o display.o /</span><br><span class="line">               insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>反斜杠（/）是换行符的意思。</p><p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，<strong>一定要以一个Tab键</strong>作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。</p><p>clean不是一个文件，只不过是一个动作名字，有点像C语言中的label一样，其冒号后什么也没有，那么make就不会自动去找文件的依赖性，也不会自动执行其后定义的命令。要执行该命令，就要在make命令后显式指出该label的名字，比如make clean。</p><h2 id="makefile使用变量"><a href="#makefile使用变量" class="headerlink" title="makefile使用变量"></a>makefile使用变量</h2><p>makefile中可以定义变量，变量是一个字符串，用$(name)即可使用。</p><p>所以改良版makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">              insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">    edit : <span class="variable">$(objects)</span></span><br><span class="line">            cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">    main.o : main.c defs.h</span><br><span class="line">            cc -c main.c</span><br><span class="line">    kbd.o : kbd.c defs.h command.h</span><br><span class="line">            cc -c kbd.c</span><br><span class="line">    command.o : command.c defs.h command.h</span><br><span class="line">            cc -c command.c</span><br><span class="line">    display.o : display.c defs.h buffer.h</span><br><span class="line">            cc -c display.c</span><br><span class="line">    insert.o : insert.c defs.h buffer.h</span><br><span class="line">            cc -c insert.c</span><br><span class="line">    search.o : search.c defs.h buffer.h</span><br><span class="line">            cc -c search.c</span><br><span class="line">    files.o : files.c defs.h buffer.h command.h</span><br><span class="line">            cc -c files.c</span><br><span class="line">    utils.o : utils.c defs.h</span><br><span class="line">            cc -c utils.c</span><br><span class="line">    clean :</span><br><span class="line">            rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><h2 id="让make自动推导"><a href="#让make自动推导" class="headerlink" title="让make自动推导"></a>让make自动推导</h2><p>GNU的make很强大，他可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个.o文件后都写上类似的命令。</p><p>只要make看到一个.o文件，它就会自动的把.c文件加入到依赖关系中，比如make找到一个a.o，那么a.c就会是a.o的依赖文件，并且<code>cc -c a.c</code>也会被推导出来，于是我们的makefile又可以更新如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">              insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">    edit : <span class="variable">$(objects)</span></span><br><span class="line">            cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">    main.o : defs.h</span><br><span class="line">    kbd.o : defs.h command.h</span><br><span class="line">    command.o : defs.h command.h</span><br><span class="line">    display.o : defs.h buffer.h</span><br><span class="line">    insert.o : defs.h buffer.h</span><br><span class="line">    search.o : defs.h buffer.h</span><br><span class="line">    files.o : defs.h buffer.h command.h</span><br><span class="line">    utils.o : defs.h</span><br><span class="line"></span><br><span class="line">    .PHONY : clean</span><br><span class="line">    clean :</span><br><span class="line">            rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><p>.PHNOY表示clean是个伪目标文件。</p><h2 id="另类风格的makefile"><a href="#另类风格的makefile" class="headerlink" title="另类风格的makefile"></a>另类风格的makefile</h2><p>如果觉得看到那堆[.o]和[.h]的依赖有点不爽，则可以把重复的.h收拢，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">              insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">    edit : $(objects)</span><br><span class="line">            cc -o edit $(objects)</span><br><span class="line"></span><br><span class="line">    $(objects) : defs.h</span><br><span class="line">    kbd.o command.o files.o : command.h</span><br><span class="line">    display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">    .PHONY : clean</span><br><span class="line">    clean :</span><br><span class="line">            rm edit $(objects)</span><br></pre></td></tr></table></figure><p>不过这样依赖关系就不是那么清楚了，看喜欢哪种了，我觉得还是依赖关系看的清楚些好。</p><h2 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h2><p>每个makefile都应该写一个清空目标文件的规则，clean的规则不要放在开头，应该放在最后。</p><p>稳健的做法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">        clean :</span><br><span class="line">                -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><p>rm前加-表示也许某些文件会出问题，但不要管，继续做后面的事。</p><h1 id="makefile总述"><a href="#makefile总述" class="headerlink" title="makefile总述"></a>makefile总述</h1><h2 id="makefile里有什么"><a href="#makefile里有什么" class="headerlink" title="makefile里有什么"></a>makefile里有什么</h2><p>makefile主要包含五个东西：显式规则、隐晦规则、变量定义、文件指示和注释</p><ol><li>显式规则。显式规则说明了，如何生成一个或多个的目标文件，这是由makefile的书写者显式指出要生成的文件、文件的依赖文件以及生成的命令。</li><li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写makefile。</li><li>变量定义。</li><li>文件指示。其包含了三个部分，一个是在一个makefile中引用另一个makefile，就像C中的include一样；另一个是指根据某些情况指定makefile中的有效部分，就像C中的预编译#if一样；还有就是定义一个多行的命令。</li><li>注释。只有行注释，用#字符。</li></ol><h2 id="makefile文件名"><a href="#makefile文件名" class="headerlink" title="makefile文件名"></a>makefile文件名</h2><p>默认情况下，make命令会在当前目录下按顺序查找文件名为”GNUmakefile”、“makefile”和“Makefile”的文件，找到就解释该文件。最好不要用“GNUmakefile”。</p><p>如果要用其他文件名书写，则可以使用如下命令：</p><p><code>make -f yourmake</code>或<code>make --file yourmake</code></p><h2 id="引用其他makefile"><a href="#引用其他makefile" class="headerlink" title="引用其他makefile"></a>引用其他makefile</h2><p>使用include关键字可以把其他makefile包含进来。</p><p><code>include&lt;filename&gt;</code></p><p>在include前可以有空字符，但不能是Tab键，多个文件之间可以用空格隔开。</p><p>include前加-表示无论include过程中出现什么错误，都不要报错，继续执行。</p><p>如果文件没有指定路径的话，make会先在当前目录下找，如果没有找到，那么make还会去以下目录中找：</p><ol><li>若make执行时有参数-I或–include-dir，那么make会去参数指定目录下找</li><li>一般也会去/user/local/bin 或/usr/include中找，如果这些目录存在的话。</li></ol><h2 id="环境变量MAKEFILES"><a href="#环境变量MAKEFILES" class="headerlink" title="环境变量MAKEFILES"></a>环境变量MAKEFILES</h2><p>如果你的当前环境中定义了环境变量MAKEFILES，那么make会把这个变量中的值做一个类似于include的动作。</p><p>不建议设置，如果遇到问题可以去看看这个变量是否被定义了。</p><h2 id="make的工作方式"><a href="#make的工作方式" class="headerlink" title="make的工作方式"></a>make的工作方式</h2><p>make执行步骤如下：</p><ol><li>读入所有makefile</li><li>读入被include的其他makefile</li><li>初始化文件中的变量</li><li>推导隐晦规则，并分析所有规则</li><li>为所有目标文件创建依赖关系链</li><li>根据依赖关系决定哪些目标要重新生成</li><li>执行命令。</li></ol><h1 id="makefile书写规则"><a href="#makefile书写规则" class="headerlink" title="makefile书写规则"></a>makefile书写规则</h1><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p><p>规则的顺序是很重要的，因为makefile中只应该有一个最终目标。</p><p>规则语法之前已经讲过了。</p><p>规则中可以使用通配符，通配符也可以用在变量里。</p><p>比如<code>objects=*.o</code>，但要注意的是通配符并不会展开，objects的值就是“<em>.o”，如要要让通配符在变量中展开，那么可以这样写：`objects=$(wildcard </em>.o)`</p><h2 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h2><p>在大工程中，有大量源文件，通常会把这许多源文件分类存放到不同目录中，所以当make需要去寻找文件的依赖关系时，可以在文件前加上路径，但最好的方法是把路径告诉make，让它自动去找。</p><p>makefile中的特殊变量VPATH就是用来完成该功能的，如果没有声明该变量，那make只会在当前的目录中去找，如果声明了，那当前目录找不到就会去VPATH所指定的目录中找了，多个目录由<strong>冒号</strong>分开。</p><p><code>VPATH = src:../headers</code></p><p>另一个方法是使用make的vpath(全小写)关键字，它和VPATH类似，但更灵活，使用方法有三种：</p><ol><li><code>vpath &lt;pattern&gt; &lt;dirs&gt;</code>为符合pattern的文件指定目录</li><li><code>vpath &lt;patter&gt;</code>清空pattern模式的文件搜索目录</li><li><code>vpath</code>清空所有已经设置好的文件搜索目录</li></ol><p><pattern>中需要包含%通配符，表示匹配零个或若干个字符。</pattern></p><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>在最早的例子里，有一个clean目标，这就是一个伪目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean :</span><br><span class="line">rm *.o temp</span><br></pre></td></tr></table></figure><p>伪目标的取名不能和文件名重名，为了避免这种情况，可以使用特殊标记<code>.PHONY</code>来指明一个目标时伪目标。</p><p><code>.PHONY : clean</code></p><p>makefile的第一个目标会被作为其默认目标。</p><p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性。</p><h2 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h2><p>makefile的规则中的目标可以不止一个，其支持多目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">            generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 等价于如下makefile</span></span><br><span class="line">bigoutput : text.g</span><br><span class="line">            generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">            generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure><p>-$(subst output,,$@)中的$表示执行一个makefile的函数，函数名为subst，后面是参数。</p><p>$@表示目标的集合，就像一个数组，依次取出目标执行命令。</p><h2 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h2><p>静态模式可以更加容易地定义多目标的规则，先看语法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">            &lt;commands&gt;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p><p>target-parrtern是指明了targets的模式，也就是的目标集模式。</p><p>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p><h2 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h2><p>在makefile中，我们的依赖关系可能会需要包含一系列的头文件，但如果是一个大工程，你必须清楚哪些C文件包含了哪些头文件，并且在加入或删除头文件时也需要小心地修改makefile，这就很麻烦。</p><p>但大多数编译器都支持一个-M的选项，即自动找寻源文件中包含的头文件并生成一个依赖关系。</p><p>如果使用的是GNU的C++编译器，则使用-MM参数，否则会把标准库头文件也输出。</p><p>有点复杂，没看太明白。</p><h1 id="makefile书写命令"><a href="#makefile书写命令" class="headerlink" title="makefile书写命令"></a>makefile书写命令</h1><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以<strong>Tab</strong>键开头，除非命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p><h2 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h2><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。</p><p>当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来。</p><p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile。</p><p>而make参数“-s”或“–slient”则是全面禁止命令的显示。</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。</p><h2 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h2><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p><p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p><p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p><p>clean:<br>           -rm -f *.o</p><p>   还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p><p>还有一个要提一下的make的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p><h2 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h2><p> 在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p><p>如果要传递参数到下级makefile，则使用这样的声明<code>export &lt;variable ...&gt;</code></p><p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：<code>unexport &lt;variable ...&gt;</code></p><p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p><p>还有很多参数，具体看原文吧。</p><h2 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h2><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line"></span><br><span class="line">   yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line"></span><br><span class="line">   mv y.tab.c <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">endef</span></span><br></pre></td></tr></table></figure><p>run-yacc就是命令包的名字，像下面这样使用：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line"></span><br><span class="line">          $(run-yacc)</span><br></pre></td></tr></table></figure><h1 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h1><p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。但和宏不同的是，你可以在makefile中改变其值。</p><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等），且大小写敏感。</p><h2 id="变量的基础"><a href="#变量的基础" class="headerlink" title="变量的基础"></a>变量的基础</h2><p>变量在声明时需要给予初值，使用时加上$符号，如果你要使用真实的“$”字符，那么你需要用“$$”来表示。</p><h2 id="变量中的变量"><a href="#变量中的变量" class="headerlink" title="变量中的变量"></a>变量中的变量</h2><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p><p>第一种就是用等号。</p><p>第二种用“:=”，推荐用这种，但用这种方式下，前面定义的变量不能用后面定义的变量，等号可以.</p><p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p><pre><code>nullstring :=space := $(nullstring) # end of the line</code></pre><p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p><pre><code>dir := /foo/bar    # directory to put the frobs in</code></pre><p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p><p>还有一个比较有用的操作符是“?=”，先看示例：</p><pre><code>FOO ?= bar</code></pre><p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p><pre><code>ifeq ($(origin FOO), undefined)  FOO = barendif</code></pre><h2 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h2><p>第一种是变量值的替换.</p><p>我们可以替换变量中共有的部分,其格式是<code>$(var: a=b)</code>或<code>${var : a=b}</code>。其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p><p>变量替换的还有一种技术是在静态模式中定义的，如：</p><p>foo := a.o b.o c.o<br>​        bar := $(foo:%.o=%.c)</p><p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。</p><p>第二种高级用法是把变量的值再变成变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure><h2 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h2><p>可以使用+=给变量追加值。</p><h2 id="override指示符"><a href="#override指示符" class="headerlink" title="override指示符"></a>override指示符</h2><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; = &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt; := &lt;value&gt;</span><br></pre></td></tr></table></figure><h2 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h2><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令。</p><p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p><h2 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h2><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p><p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p><p>其语法是：</p><pre><code>&lt;target ...&gt; : &lt;variable-assignment&gt;&lt;target ...&gt; : overide &lt;variable-assignment&gt;</code></pre><p><variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</variable-assignment></p><h2 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h2><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p><p><code>%.o : CFLAGS = -O</code></p><h1 id="使用条件判断"><a href="#使用条件判断" class="headerlink" title="使用条件判断"></a>使用条件判断</h1><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p><p>ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>条件表达式的语法为：</p><pre><code>&lt;conditional-directive&gt;&lt;text-if-true&gt;endif</code></pre><p>以及：</p><pre><code>&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif</code></pre><p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个：ifeq、ifneq、ifdef、ifndef。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。</conditional-directive></p><p>在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以[Tab]键开始就行了。</conditional-directive></p><p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p><p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p><h1 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h1><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p><h2 id="函数的调用语法"><a href="#函数的调用语法" class="headerlink" title="函数的调用语法"></a>函数的调用语法</h2><p>函数调用很像变量的使用，也是以$来标识    ，其语法如下：</p><p><code>$(&lt;function&gt; &lt;arguments&gt; )</code>或是<code>${&lt;function&gt; &lt;arguments&gt;}</code>.</p><h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>  <code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; )</code></p><p>名称：字符串替换函数——subst。</p><p>功能：把字串<text>中的<from>字符串替换成<to>。</to></from></text></p><p>返回：函数返回被替换过后的字符串。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p> <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt; )</code></p><p>名称：模式字符串替换函数——patsubst。</p><p>功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。</pattern></replacement></replacement></pattern></replacement></pattern></text></p><p><code>$(var:&lt;pattern&gt;=&lt;replacement&gt; )</code>相当于<code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><code>$(strip &lt;string&gt; )</code></p><p>名称：去空格函数——strip。</p><p>功能：去掉<string>字串中开头和结尾的空字符。</string></p><p>返回：返回被去掉空格的字符串值。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p><code>$(findstring &lt;find&gt;,&lt;in&gt; )</code></p><p>名称：查找字符串函数——findstring。</p><p>功能：在字串<in>中查找<find>字串。</find></in></p><p>返回：如果找到，那么返回<find>，否则返回空字符串。</find></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><code>$(filter &lt;pattern...&gt;,&lt;text&gt; )</code></p><p>名称：过滤函数——filter。</p><p>功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。</pattern></text></pattern></p><p>返回：返回符合模式<pattern>的字串。</pattern></p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p><code>$(filter-out &lt;pattern...&gt;,&lt;text&gt; )</code></p><p>名称：反过滤函数——filter-out。</p><p>功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可<br>以有多个模式。</pattern></text></pattern></p><p>返回：返回不符合模式<pattern>的字串。</pattern></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p><code>$(sort &lt;list&gt; )</code></p><p>名称：排序函数——sort。</p><p>功能：给字符串<list>中的单词排序（升序）。</list></p><p>返回：返回排序后的字符串。</p><p>备注：sort函数会去掉<list>中相同的单词。</list></p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p><code>$(word &lt;n&gt;,&lt;text&gt; )</code></p><p>名称：取单词函数——word。</p><p>功能：取字符串<text>中第<n>个单词。（下标从一开始）</n></text></p><p>返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空<br>字符串。</text></n></n></text></p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p><code>$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt; )</code></p><p>名称：取单词串函数——wordlist。</p><p>功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。</e></s></e></s></text></p><p>返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那<br>么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单<br>词串。</text></s></text></e></text></s></e></s></text></p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p><code>$(words &lt;text&gt; )</code></p><p>名称：单词个数统计函数——words。</p><p>功能：统计<text>中字符串中的单词个数。</text></p><p>返回：返回<text>中的单词数。</text></p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p><code>$(firstword &lt;text&gt; )</code></p><p>名称：首单词函数——firstword。</p><p>功能：取字符串<text>中的第一个单词。</text></p><p>返回：返回字符串<text>的第一个单词。</text></p><h2 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h2><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是<br>一系列的文件名来对待。</p><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p><code>$(dir &lt;names...&gt; )</code></p><p>名称：取目录函数——dir。</p><p>功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。</names></p><p>返回：返回文件名序列<names>的目录部分。</names></p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p><code>$(notdir &lt;names...&gt; )</code></p><p>名称：取文件函数——notdir。</p><p>功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”<br>）之后的部分。</names></p><p>返回：返回文件名序列<names>的非目录部分。</names></p><h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><p><code>$(suffix &lt;names...&gt; )</code></p><p>名称：取后缀函数——suffix。</p><p>功能：从文件名序列<names>中取出各个文件名的后缀。</names></p><p>返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。</names></p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h3><p><code>$(basename &lt;names...&gt; )</code></p><p>名称：取前缀函数——basename。</p><p>功能：从文件名序列<names>中取出各个文件名的前缀部分。</names></p><p>返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。</names></p><h3 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h3><p><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt; )</code></p><p>名称：加后缀函数——addsuffix。</p><p>功能：把后缀<suffix>加到<names>中的每个单词后面。</names></suffix></p><p>返回：返回加过后缀的文件名序列。</p><h3 id="6-1"><a href="#6-1" class="headerlink" title="6"></a>6</h3><p><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt; )</code></p><p>名称：加前缀函数——addprefix。</p><p>功能：把前缀<prefix>加到<names>中的每个单词后面。</names></prefix></p><p>返回：返回加过前缀的文件名序列。</p><h3 id="7-1"><a href="#7-1" class="headerlink" title="7"></a>7</h3><p><code>$(join &lt;list1&gt;,&lt;list2&gt; )</code></p><p>名称：连接函数——join。</p><p>功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比&lt;<br>list2&gt;的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比</list2></list1></list1></list1></list2></p><p><list1>多，那么，<list2>多出来的单词将被复制到<list2>中。</list2></list2></list1></p><p>返回：返回连接过后的字符串。</p><p>示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。</p><h2 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h2><p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的<br>foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin<br>/csh）中的foreach语句而构建的。它的语法是：</p><p><code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt; )</code></p><p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。  </text></text></text></text></var></list></p><p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var></var></text></list></var></p><h2 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h2><p><code>$(if &lt;condition&gt;,&lt;then-part&gt; )</code>或<code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt; )</code></p><p>  可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。</else-part></then-part></condition></p><p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part="">会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</else-part></else-part></condition></then-></condition></p><p>所以，<then-part>和<else-part>只会有一个被计算。  </else-part></then-part></p><h2 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h2><p>  call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是</p><p><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code></p><p>当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。  </expression></parm3></parm2></parm1></expression></p><h2 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h2><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的。</p><p><code>$(origin &lt;variable&gt; )</code></p><p>如果variable没有被定义过，返回undefined</p><p>如果是一个默认定义，就返回default</p><p>如果是环境变量，返回environment</p><p>如果是被定义在makefile中，返回file</p><p>如果是命令行定义的，返回command line</p><p>如果是被override指示符重新定义的，返回override</p><p>如果是一个命令运行中的自动化变量，返回automatic。</p><h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号”`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。</p><h2 id="控制make的函数"><a href="#控制make的函数" class="headerlink" title="控制make的函数"></a>控制make的函数</h2><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p><p>  <code>$(error &lt;text ...&gt; )</code></p><p>产生一个致命的错误，<text ...="">是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。</text></p><p><code>$(warning &lt;text ...&gt; )</code></p><p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。  </p><h1 id="make的运行"><a href="#make的运行" class="headerlink" title="make的运行"></a>make的运行</h1><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。</p><h2 id="make的退出码"><a href="#make的退出码" class="headerlink" title="make的退出码"></a>make的退出码</h2><p>make命令执行后有三个退出码：</p><p>0——成功</p><p>1——make运行时出现任何错误，其返回1</p><p>2——如果使用了make的-q选项，并且make使得一些目标不需要更新，那么返回2。</p><h2 id="指定makefile"><a href="#指定makefile" class="headerlink" title="指定makefile"></a>指定makefile</h2><p>除了按照默认规则寻找makefile，也可以指定特殊名字的makefile。</p><p><code>make -f filename</code>或者<code>make --file filename</code></p><p>如果在make的命令行时，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p><h2 id="指定目标"><a href="#指定目标" class="headerlink" title="指定目标"></a>指定目标</h2><p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。</p><p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p><p>具体可以看原文，比如常见的有“all”、“clean”、“install”等等。</p><h2 id="检查规则"><a href="#检查规则" class="headerlink" title="检查规则"></a>检查规则</h2><p>  有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p><p>“-n”</p><p>“–just-print”</p><p>“–dry-run”</p><p>“–recon”</p><p>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。  </p><p>“-t”</p><p>“–touch”</p><p>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p><p>“-q”</p><p>“–question”</p><p>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p><p>“-W <file>”</file></p><p>“–what-if=<file>”</file></p><p>“–assume-new=<file>”</file></p><p>“–new-file=<file>”</file></p><p>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p><h2 id="make的参数"><a href="#make的参数" class="headerlink" title="make的参数"></a>make的参数</h2><p>  “-b”</p><p>“-m”</p><p>这两个参数的作用是忽略和其它版本make的兼容性。</p><p>“-B”</p><p>“–always-make”</p><p>认为所有的目标都需要更新（重编译）。  </p><p>“-C <dir>”</dir></p><p>“–directory=<dir>”</dir></p><p>指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p><p>“–debug[=<options>]”</options></p><p>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。</p><p>-i”</p><p>“–ignore-errors”</p><p>在执行时忽略所有的错误。</p><p>“-I <dir>”</dir></p><p>“–include-dir=<dir>”</dir></p><p>指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p><p>还有看原文吧，感觉不用的话看了也记不住，就不搬过来了。</p><h1 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h1><p>  在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p><p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。  </p><h2 id="使用隐含规则"><a href="#使用隐含规则" class="headerlink" title="使用隐含规则"></a>使用隐含规则</h2><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。</p><h2 id="隐含规则一览"><a href="#隐含规则一览" class="headerlink" title="隐含规则一览"></a>隐含规则一览</h2><p>这里列一下隐含规则，当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p><ol><li>编译C的隐含规则。</li><li>编译C++的隐含规则。</li><li>编译Pascal的隐含规则。</li><li>编译Fortran/Ratfor程序的隐含规则。</li><li>预处理Fortran/Ratfor程序的隐含规则。</li><li>编译Modula-2程序的隐含规则。</li><li>汇编和汇编预处理的隐含规则。</li><li>链接Object文件的隐含规则。“<n>” 目标依赖于“<n>.o”。</n></n></li><li>Yacc C程序时的隐含规则。</li><li>Lex C程序时的隐含规则。</li><li>Lex Ratfor程序时的隐含规则。</li><li>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</li></ol><h2 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h2><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p><p>具体看原文吧。</p><h2 id="隐含规则链"><a href="#隐含规则链" class="headerlink" title="隐含规则链"></a>隐含规则链</h2><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p><p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。</p><p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p><h2 id="定义模式规则"><a href="#定义模式规则" class="headerlink" title="定义模式规则"></a>定义模式规则</h2><p>  你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p><p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。  </p><h3 id="模式规则介绍"><a href="#模式规则介绍" class="headerlink" title="模式规则介绍"></a>模式规则介绍</h3><p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。</p><h3 id="模式规则示例"><a href="#模式规则示例" class="headerlink" title="模式规则示例"></a>模式规则示例</h3><p>把所有的.c文件都编译成.o文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><p>  在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p><p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p><p>$@：表示规则中的目标文件集。 </p><p>$%：仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p><p>$&lt;：依赖目标中的第一个目标名字。</p><p>$?：所有比目标新的依赖目标的集合。以空格分隔。</p><p>$^：所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p><p>$+：这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p><p>$*：这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，”$*”的值就是”dir/a.foo”。</p><p>  最后想提醒一下的是，对于”$&lt;”，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，”$(&lt; )”就要比”$&lt;”要好一些。</p><p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。  </p><h3 id="模式的匹配"><a href="#模式的匹配" class="headerlink" title="模式的匹配"></a>模式的匹配</h3><p>  一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。</p><p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat” 匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）  </p><h3 id="重载内建隐含规则"><a href="#重载内建隐含规则" class="headerlink" title="重载内建隐含规则"></a>重载内建隐含规则</h3><p>你可以重载内建的隐含规则（或是定义一个全新的）。</p><h3 id="老式风格的后缀规则"><a href="#老式风格的后缀规则" class="headerlink" title="老式风格的后缀规则"></a>老式风格的后缀规则</h3><p>  后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。</p><p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o : %c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”% : %.c”。</p><p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c” 是源文件的后缀，”.o”是目标文件的后缀。  </p><p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p><p>而要让make知道一些特定的后缀，我们可以使用伪目标”.SUFFIXES”来定义或是删除。</p><h3 id="隐含规则搜索算法"><a href="#隐含规则搜索算法" class="headerlink" title="隐含规则搜索算法"></a>隐含规则搜索算法</h3><p>比如有一个目标T，下面列出搜索目标T的规则的算法：</p><ul><li><p>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）</p></li><li><p>创建所有匹配于T或是N的模式规则列表。</p></li><li><p>如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。</p></li><li><p>移除列表中没有命令的规则。</p></li><li><p>对于第一个在列表中的模式规则：</p><ol><li>推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。</li><li>计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li><li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）</li><li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li></ol></li><li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<ol><li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li><li>计算依赖文件。（同第5步）</li><li>测试所有的依赖文件是否存在或是理当存在。</li><li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li><li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li></ol></li><li>如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。</li></ul><p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p><h1 id="使用make更新函数库文件"><a href="#使用make更新函数库文件" class="headerlink" title="使用make更新函数库文件"></a>使用make更新函数库文件</h1><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p><h2 id="函数库文件的成员"><a href="#函数库文件的成员" class="headerlink" title="函数库文件的成员"></a>函数库文件的成员</h2><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p><p><code>archive(member)</code></p><p>  这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o) : hack.o</span><br><span class="line">ar cr foolib hack.o</span><br></pre></td></tr></table></figure><h2 id="函数库成员的隐含规则"><a href="#函数库成员的隐含规则" class="headerlink" title="函数库成员的隐含规则"></a>函数库成员的隐含规则</h2><p>当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o” 的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o。</p><h2 id="函数库文件的后缀规则"><a href="#函数库文件的后缀规则" class="headerlink" title="函数库文件的后缀规则"></a>函数库文件的后缀规则</h2><p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line"><span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。</p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单记录下对Makefile学习的一些笔记。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/weixin_38391755/article/details/80380786&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weixin_38391755/article/details/80380786&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;makefile简介和例子&quot;&gt;&lt;a href=&quot;#makefile简介和例子&quot; class=&quot;headerlink&quot; title=&quot;makefile简介和例子&quot;&gt;&lt;/a&gt;makefile简介和例子&lt;/h1&gt;&lt;p&gt;个人感觉makefile就是整个项目工程的一个编译规则，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;
&lt;p&gt;该文章是基于GNU make的。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="Makefile" scheme="http://yoursite.com/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>C++编程规范笔记</title>
    <link href="http://yoursite.com/2018/12/27/C-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/27/C-编程规范笔记/</id>
    <published>2018-12-27T15:19:08.000Z</published>
    <updated>2019-08-19T14:04:54.865Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：</p><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/</a></p><a id="more"></a><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="Self-contained-头文件"><a href="#Self-contained-头文件" class="headerlink" title="Self-contained 头文件"></a>Self-contained 头文件</h2><p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code>.h</code> 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code> 头文件的做法.</p><h2 id="define保护"><a href="#define保护" class="headerlink" title="#define保护"></a>#define保护</h2><p>所有头文件都应该使用 <code>#define</code> 来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code> ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef FOO_BAR_BAZ_H_</span><br><span class="line">#define FOO_BAR_BAZ_H_</span><br><span class="line">...</span><br><span class="line">#endif // FOO_BAR_BAZ_H_</span><br></pre></td></tr></table></figure><h2 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h2><p>尽可能地避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p><h2 id="include-的路径及顺序"><a href="#include-的路径及顺序" class="headerlink" title="#include 的路径及顺序"></a><code>#include</code> 的路径及顺序</h2><p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>鼓励在 <code>.cc</code> 文件内使用匿名命名空间或 <code>static</code> 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。且要在命名空间的最后注释出命名空间的名字。</p><h2 id="匿名命名空间和静态变量"><a href="#匿名命名空间和静态变量" class="headerlink" title="匿名命名空间和静态变量"></a>匿名命名空间和静态变量</h2><p>在 <code>.cc</code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p><p>匿名命名空间的声明和具名的格式相同，在最后注释上 <code>namespace</code></p><h2 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h2><p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p><p>【注】有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</p><h2 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h2><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数的职责"><a href="#构造函数的职责" class="headerlink" title="构造函数的职责"></a>构造函数的职责</h2><p>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p><p>如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式.</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 <code>explicit</code> 关键字.</p><p>一个例外是, 拷贝和移动构造函数不应当被标记为 <code>explicit</code>, 因为它们并不执行类型转换.</p><h2 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h2><p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p><p>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <code>public virtual Clone()</code> 和一个 <code>protected</code> 的拷贝构造函数以供派生类实现.</p><h2 id="结构体-VS-类"><a href="#结构体-VS-类" class="headerlink" title="结构体 VS. 类"></a>结构体 VS. 类</h2><p>当只有数据成员时使用 <code>struct</code>, 其它一概使用 <code>class</code>.</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 <code>public</code> 继承.</p><p>必要的话, 析构函数声明为 <code>virtual</code>. 如果你的类有虚函数, 则析构函数也应该为虚函数，数据成员都必须是私有的。</p><p>对于重载的虚函数或虚析构函数, 使用 <code>override</code>, 或 (较不常用的) <code>final</code> 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 <code>virtual</code> 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 <code>override</code>, <code>final</code> 或 <code>virtual</code> 的其中之一进行标记. 标记为 <code>override</code> 或 <code>final</code> 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code>Interface</code>为后缀的纯接口类</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是指满足特定条件的类, 这些类以 <code>Interface</code> 为后缀 (不强制).</p><p>当一个类满足以下要求时, 称之为纯接口:</p><ul><li>只有纯虚函数 (“<code>=0</code>”) 和静态函数 (除了下文提到的析构函数).</li><li>没有非静态数据成员.</li><li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 <code>protected</code>.</li><li>如果它是一个子类, 也只能从满足上述条件并以 <code>Interface</code> 为后缀的类继承.</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p><h2 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h2><p>将 <em>所有</em> 数据成员声明为 <code>private</code>, 除非是 <code>static const</code> 类型成员</p><p>存取函数一般内联在头文件中。</p><h2 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h2><p>将相似的声明放在一起, 将 <code>public</code> 部分放在最前.</p><p>类定义一般应以 <code>public:</code> 开始, 后跟 <code>protected:</code>, 最后是 <code>private:</code>. 省略空部分.</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数顺序"><a href="#函数顺序" class="headerlink" title="函数顺序"></a>函数顺序</h2><p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p><h2 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h2><p>我们倾向于编写简短, 凝练的函数.</p><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须加上 <code>const</code>.</p><p>总而言之, 大多时候输入形参往往是 <code>const T&amp;</code>. 若用 <code>const T*</code> 则说明输入另有处理. 所以若要使用 <code>const T*</code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p><p>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code>std::vector</code> 以便使用者可以用列表初始化指定参数.</p><h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#function-overloading" target="_blank" rel="noopener">函数重载</a> 遵循同样的规则. 一般情况下建议使用函数重载。</p><h2 id="函数返回类型后置语法"><a href="#函数返回类型后置语法" class="headerlink" title="函数返回类型后置语法"></a>函数返回类型后置语法</h2><p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p><h1 id="来自Google的奇技"><a href="#来自Google的奇技" class="headerlink" title="来自Google的奇技"></a>来自Google的奇技</h1><h2 id="所有权与智能指针"><a href="#所有权与智能指针" class="headerlink" title="所有权与智能指针"></a>所有权与智能指针</h2><p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p><p>不要使用 <code>std::auto_ptr</code>, 使用 <code>std::unique_ptr</code> 代替它.</p><h2 id="Cpplint"><a href="#Cpplint" class="headerlink" title="Cpplint"></a>Cpplint</h2><p>使用 <code>cpplint.py</code> 检查风格错误，可以单独下载使用。</p><h1 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h1><h2 id="引用参数-1"><a href="#引用参数-1" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须加上 <code>const</code>.</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 <code>std::forward</code>.</p><h2 id="变长数组和-alloca"><a href="#变长数组和-alloca" class="headerlink" title="变长数组和 alloca()"></a>变长数组和 alloca()</h2><p>我们不允许使用变长数组和 <code>alloca()</code>，改用更安全的分配器（allocator），就像 <code>std::vector</code> 或 <code>std::unique_ptr&lt;T[]&gt;</code>.</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>我们允许合理的使用友元类及友元函数.</p><p>某些情况下, 相对于将类成员声明为 <code>public</code>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>我们不使用 C++ 异常.</p><h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><p>我们禁止使用 RTTI。</p><p>RTTI允许程序员在运行时识别C++类对象的类型，通过使用typeid或者dynamic_cast完成。</p><p>在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免.</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用 <code>int y = (int)x</code> 或 <code>int y = int(x)</code> 等转换方式</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>只在记录日志时使用流.</p><p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code> 之类的代替.</p><h2 id="前置自增和自减"><a href="#前置自增和自减" class="headerlink" title="前置自增和自减"></a>前置自增和自减</h2><p>对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</p><h2 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a><code>const</code> 用法</h2><p>我们强烈建议你在任何可能的情况下都要使用 <code>const</code>. 此外有时改用 C++11 推出的 constexpr 更好。</p><h2 id="constexpr-用法"><a href="#constexpr-用法" class="headerlink" title="constexpr 用法"></a><code>constexpr</code> 用法</h2><p>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>C++ 内建整型中, 仅使用 <code>int</code>. 如果程序中需要不同大小的变量, 可以使用 <code>&lt;stdint.h&gt;</code> 中长度精确的整型, 如 <code>int16_t</code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 <code>int64_t</code>. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。</p><p>不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p><h2 id="64位下的可移植性"><a href="#64位下的可移植性" class="headerlink" title="64位下的可移植性"></a>64位下的可移植性</h2><p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记。</p><h2 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h2><p>使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p><ul><li>不要在 <code>.h</code> 文件中定义宏.</li><li>在马上要使用时才进行 <code>#define</code>, 使用后要立即 <code>#undef</code>.</li><li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li><li>不要用 <code>##</code> 处理函数，类和变量的名字。</li></ul><h2 id="0-nullptr-和-NULL"><a href="#0-nullptr-和-NULL" class="headerlink" title="0, nullptr 和 NULL"></a>0, <code>nullptr</code> 和 <code>NULL</code></h2><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>&#39;\0&#39;</code>.</p><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 这一点是毫无争议的.</p><p>对于指针 (地址值), 到底是用 <code>0</code>, <code>NULL</code> 还是 <code>nullptr</code>. C11 项目用 <code>nullptr</code>; C03 项目则用 <code>NULL</code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 <code>NULL</code> 的定义比较特殊，可以输出有用的警告，特别是 <code>sizeof(NULL)</code> 就和 <code>sizeof(0)</code> 不一样。</p><p>字符 (串) 用 <code>&#39;\0&#39;</code>, 不仅类型正确而且可读性好.</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</p><p>使用 <code>sizeof(varname)</code> 是因为当代码中变量类型改变时会自动更新. 您或许会用 <code>sizeof(type)</code> 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>用 <code>auto</code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>你可以用列表初始化。但千万别直接列表初始化 auto 变量。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p><h2 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h2><p>不要使用复杂的模板编程</p><h2 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h2><p>只使用 Boost 中被认可的库.</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>适当用 C11（前身是 C0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。</p><h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="通用命令规则"><a href="#通用命令规则" class="headerlink" title="通用命令规则"></a>通用命令规则</h2><p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p><h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p><p>可接受的文件命名示例:</p><ul><li><code>my_useful_class.cc</code></li><li><code>my-useful-class.cc</code></li><li><code>myusefulclass.cc</code></li></ul><h2 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h2><p>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>.</p><h2 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h2><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int kDaysInAWeek = 7;</span><br></pre></td></tr></table></figure><h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>.</p><p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>).</p><h2 id="命名空间命名"><a href="#命名空间命名" class="headerlink" title="命名空间命名"></a>命名空间命名</h2><p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p><h2 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h2><p>枚举的命名应当和常量或宏一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>.</p><h2 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h2><p>如果你一定要用宏, 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p><h2 id="命名规则的特例"><a href="#命名规则的特例" class="headerlink" title="命名规则的特例"></a>命名规则的特例</h2><p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h2><p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p><h2 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h2><p>在每一个文件开头加入版权公告.</p><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p><h2 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h2><p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p><p>如果变量可以接受 <code>NULL</code> 或 <code>-1</code> 等警戒值, 须加以说明.</p><h2 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h2><p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p><h2 id="标点-拼写和语法"><a href="#标点-拼写和语法" class="headerlink" title="标点, 拼写和语法"></a>标点, 拼写和语法</h2><p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p><h2 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h2><p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释.</p><h2 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h2><p>通过弃用注释（<code>DEPRECATED</code> comments）以标记某接口点已弃用.</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>每一行代码字符数不超过 80.</p><h2 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h2><p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p><h2 id="空格还是制表符"><a href="#空格还是制表符" class="headerlink" title="空格还是制表符"></a>空格还是制表符</h2><p>只使用空格, 每次缩进 2 个空格.</p><p>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</p><h2 id="函数声明与定义"><a href="#函数声明与定义" class="headerlink" title="函数声明与定义"></a>函数声明与定义</h2><p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用一致.</p><p>注意以下几点：</p><ul><li>使用好的参数名.</li><li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li><li>如果返回类型和函数名在一行放不下, 分行.</li><li>如果返回类型与函数声明或定义分行了, 不要缩进.</li><li>左圆括号总是和函数名在同一行.</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li><li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li><li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li><li>右圆括号和左大括号间总是有一个空格.</li><li>所有形参应尽可能对齐.</li><li>缺省缩进为 2 个空格.</li><li>换行后的参数保持 4 个空格的缩进.</li></ul><h2 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p><p>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格。</p><p>参数也可以放在次行, 缩进四格。</p><h2 id="列表初始化格式"><a href="#列表初始化格式" class="headerlink" title="列表初始化格式"></a>列表初始化格式</h2><p>您平时怎么格式化函数调用, 就怎么格式化列表初始化。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.</p><p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格</p><h2 id="循环和开关选择语句"><a href="#循环和开关选择语句" class="headerlink" title="循环和开关选择语句"></a>循环和开关选择语句</h2><p><code>switch</code> 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 <code>{}</code> 或 <code>continue</code>，而不是一个简单的分号.</p><h2 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h2><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>) 之后不能有空格.</p><p>在多重声明中不能使用 &amp; 或 *。</p><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>如果一个布尔表达式超过 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#line-length" target="_blank" rel="noopener">标准行宽</a>, 断行方式要统一一下.</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>不要在 <code>return</code> 表达式里加上非必须的圆括号.</p><h2 id="变量及数组初始化"><a href="#变量及数组初始化" class="headerlink" title="变量及数组初始化"></a>变量及数组初始化</h2><p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可.</p><p>请务必小心列表初始化 <code>{...}</code> 用 <code>std::initializer_list</code> 构造函数初始化出的类型. 非空列表初始化就会优先调用 <code>std::initializer_list</code>, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用 <code>std::initializer_list</code> 构造函数, 请改用括号.</p><p>此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</p><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>预处理指令不要缩进, 从行首开始.</p><p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p><h2 id="类格式"><a href="#类格式" class="headerlink" title="类格式"></a>类格式</h2><p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p><ul><li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li><li>关键词 <code>public:</code>, <code>protected:</code>, <code>private:</code> 要缩进 1 个空格.</li><li>除第一个关键词 (一般是 <code>public</code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li><li>这些关键词后不要保留空行.</li><li><code>public</code> 放在最前面, 然后是 <code>protected</code>, 最后是 <code>private</code>.</li></ul><h2 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h2><p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p><h2 id="命名空间格式化"><a href="#命名空间格式化" class="headerlink" title="命名空间格式化"></a>命名空间格式化</h2><p>命名空间内容不缩进.</p><h2 id="水平留白"><a href="#水平留白" class="headerlink" title="水平留白"></a>水平留白</h2><p>水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p><p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉。</p><h2 id="垂直留白"><a href="#垂直留白" class="headerlink" title="垂直留白"></a>垂直留白</h2><p>垂直留白越少越好.</p><p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p><h1 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h1><h2 id="现有不合规范的代码"><a href="#现有不合规范的代码" class="headerlink" title="现有不合规范的代码"></a>现有不合规范的代码</h2><p>对于现有不符合既定编程风格的代码可以网开一面.</p><h2 id="Windows代码"><a href="#Windows代码" class="headerlink" title="Windows代码"></a>Windows代码</h2><p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>运用常识和判断力, 并且 <em>保持一致</em>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="职业素养" scheme="http://yoursite.com/tags/%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>《Redis设计与实现》笔记</title>
    <link href="http://yoursite.com/2018/12/09/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/</id>
    <published>2018-12-09T08:33:16.000Z</published>
    <updated>2019-07-28T15:11:53.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h1><p>在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8</p><a id="more"></a><h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sds.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用该结构比直接使用C字符串有以下好处：</p><ol><li>获取字符串长度的复杂度从O（n）降低到O（1）；</li><li>杜绝缓冲区溢出，SDS在进行字符串操作时会先检查是否有足够的空间p11；</li><li>减少修改字符串时带来的内存重分配次数，通过free字段，SDS实现了空间预分配和惰性空间释放两种优化策略。对于空间预分配策略而言，如果对SDS修改后len小于1MB，则将分配和len相同长度的未使用空间，如果修改后len大于1MB，则分配1MB的未使用空间；对于惰性空间释放，则是说缩短字符串长度时，并没有真正释放空间，而是将free值增大而已，便于将来可能有的增长操作。另外SDS也提供了相应的API用来真正释放未使用空间。</li><li>C字符串中不能包含空字符，所以也不能保存像图片、音频等二进制数据，但SDS可以，它是二进制安全的。</li><li>兼容部分C字符串函数，如strcasecamp、strcat。</li></ol><p>主要API见p17。</p><h1 id="第三章-链表"><a href="#第三章-链表" class="headerlink" title="第三章 链表"></a>第三章 链表</h1><p>当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除此以外，发布与订阅、慢查询、监视器等功能也用到了链表。</p><h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//adlist.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode* head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode* tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> * ptr,<span class="keyword">void</span> * key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>双端</li><li>无环</li><li>有头尾节点</li><li>有链表长度计数器</li><li>多态，链表节点使用void*指针保存节点值，所以可以保存各种不同类型的值</li></ul><p>API见p21</p><h1 id="第四章-字典"><a href="#第四章-字典" class="headerlink" title="第四章 字典"></a>第四章 字典</h1><p>Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查也是构建在对字典的操作之上的。当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h/dictht</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;<span class="comment">//dictEntry定义也在dict.h中，每个dictEntry保存一个键值对</span></span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">//指向下个hash表节点，形成链表，解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;distEntry;</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引，当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*keyDup)(<span class="keyword">void</span> * privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*valDup)(<span class="keyword">void</span> privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span>* key1,<span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure><p>一般情况下，字典只使用ht[0]哈希表，ht[1]只会在对ht[0]进行rehash时使用。</p><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>Redis计算哈希值和索引值的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字典设置的哈希函数计算键key的哈希值</span></span><br><span class="line">hash=dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">//使用哈希表的sizemask属性和哈希值计算出索引值，根据情况不同，ht[x]可以是ht[0] 或 //ht[1]</span></span><br><span class="line">index=hash&amp;dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>因为dictEntry节点组成的链表没有指向链表尾部的指针，所以在哈希冲突的时候为了速度考虑，程序总是将新节点添加到链表的表头位置（O（1）），排在已有元素前面。</p><p>当字典呗用作数据库或哈希键的底层实现时，Redis使用MurmurHash2算法来计算哈希值。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会增多或减少，为了保证负载因子在一个合理的范围内，则需要对哈希表的大小进行相应的扩展或者收缩，这可以通过rehash来完成。</p><p>步骤如下：</p><ol><li>为ht[1]分配空间，如果是扩展操作，则大小等于第一个大于等于ht[0].used*2的2^n，如果是收缩操作，则大小等于第一个大于等于ht[0].used的2^n；</li><li>将ht[0]中的所有键值对重新计算哈希值和索引值放入ht[1]中；</li><li>释放ht[0]，并将ht[1]置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次做准备。</li></ol><p>当以下条件之一满足时，会开始扩展：</p><ol><li>服务器没有执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于1；</li><li>服务器在执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于5；</li></ol><p>当负载因子小于0.1时，或进行收缩操作。</p><h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>为了避免一次性rehash对服务器性能造成影响，服务器分多次、渐进地将ht[0]慢慢rehash到ht[1]。</p><p>步骤如下：</p><ol><li>为ht[1]分配空间；</li><li>在字典中维持一个索引计数器变量rehashidx，并将它赋值为0，标志rehash开始；</li><li>在rehash期间，每次对字典执行增删改查时，除了执行该操作外，还会顺带将ht[0]中rehashidx上的所有键值对rehash到ht[1]上，当rehash完成后，rehashidx++；</li><li>当ht[0]所有键值对都rehash到ht[1]上时，rehashidx置为-1，结束rehash。</li></ol><p>在rehash期间，删改查会在两个哈希表上进行，而增操作只会在ht[1]上进行。</p><p>主要API见p36.</p><h1 id="第五章-跳跃表"><a href="#第五章-跳跃表" class="headerlink" title="第五章 跳跃表"></a>第五章 跳跃表</h1><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>查找效率平均水平O（logN），最坏O（N），大部分情况下，跳跃表的效率可以和平衡树媲美，所以有些程序可以用跳跃表来代替平衡树。</p><p>Redis使用跳跃表来作为有序集合键的底层实现之一，也被用在集群节点中，其余地方没有再用。</p><p>如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会用跳跃表来作为有序集合键的底层实现。</p><h2 id="跳跃表实现"><a href="#跳跃表实现" class="headerlink" title="跳跃表实现"></a>跳跃表实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点 redis.h/zskiplistNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//层，程序可以通过层来加快访问其他节点的速度，一般来说</span></span><br><span class="line">    <span class="comment">//层越多，访问其他节点的速度就越快</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针，用于从表头向表尾方向访问节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度，跨度越大，相距越远，与遍历操作无关，是用来计算排位的，排位就是在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来的值</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值，可相同</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象，不可相同</span></span><br><span class="line">    robj* obj;</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure><p>多个跳跃表节点就可以组成一个跳跃表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量，不算表头节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> longn length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数，每个层高都是1至32之间的随机数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure><p>API见p45</p><h1 id="第六章-整数集合"><a href="#第六章-整数集合" class="headerlink" title="第六章 整数集合"></a>第六章 整数集合</h1><p>整数集合（intset）时候集合键的底层实现之一，当一个集合只包含整数值元素，并且集合元素数量不多时，Redis就会使用整数集合来作为集合键的底层实现。</p><h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并保证不会重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intset.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组，各个项在数组中升序排列，虽然声明写的是int8_t，但真正保存的类型取决于encoding属性的值，分别能存16/32/64位的整数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长的时候，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。</p><p>升级分三步：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间；</li><li>将原来的所有元素都转换成新类型，注意这里扩展空间后原来的元素是从后往前被重新放到正确的位置上的</li><li>添加新元素</li></ol><p>向整数集合中添加新元素的时间复杂度是O（n）</p><p>升级的好处：</p><ol><li>提升灵活性</li><li>节约内存</li></ol><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>要注意的是，整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><p>API见p51</p><h1 id="第七章-压缩列表"><a href="#第七章-压缩列表" class="headerlink" title="第七章 压缩列表"></a>第七章 压缩列表</h1><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且每个列表项要么是小整数要么是长度比较短的字符串，Redis就会使用压缩列表来做列表键的底层实现。哈希键同理。</p><h2 id="压缩列表构成"><a href="#压缩列表构成" class="headerlink" title="压缩列表构成"></a>压缩列表构成</h2><p>压缩列表各个组成部分以及书名</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">长度（字节）</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">zlbytes</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4</td><td style="text-align:center">整个压缩表占用的内存字节数</td></tr><tr><td style="text-align:center">zltail</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4</td><td style="text-align:center">压缩表表尾节点距离起始地址有多少字节</td></tr><tr><td style="text-align:center">zllen</td><td style="text-align:center">uint16_t</td><td style="text-align:center">2</td><td style="text-align:center">压缩列表包含的节点数量，当该值等于UINT16_MAX时，节点真实数量需要遍历整个压缩列表得出</td></tr><tr><td style="text-align:center">entryX</td><td style="text-align:center">列表节点</td><td style="text-align:center">不定</td><td style="text-align:center">各个节点长度由保存的内容决定</td></tr><tr><td style="text-align:center">zlend</td><td style="text-align:center">uint8_t</td><td style="text-align:center">1</td><td style="text-align:center">0xFF，标志末尾</td></tr></tbody></table><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中字节数组可以是以下三种长度中的一种：</p><ol><li>长度小于（2^6-1）</li><li>长度小于2^14-1</li><li>长度小于2^32-1</li></ol><p>而整数值可以是六种长度中的一种：</p><ol><li>4位长，介于0至12之间的无符号整数；</li><li>1字节长有符号整数</li><li>3字节长有符号整数</li><li>int16_t</li><li>int32_t</li><li>int64_t</li></ol><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。</p><p>previous_entry_length可以是1字节或5字节长，如果前一节点的长度小于254字节，则previous_entry_length是1字节，保存前一个节点的长度，如果前一节点的长度大于等于254字节，则previous_entry_length长度是五字节，其中第一字节被置为0xFE，而后四个字节用来保存前一节点的长度。这个属性可以用来逆序遍历节点。</p><p>encoding属性记录节点的conten属性所存数据的类型和长度，具体可以看p56，简单来说以11开头表示整数编码，content存的是整数，而以00/01/10开头则表示content存的是字节数组，后面几位存的是长度。</p><h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>添加和删除节点都可能导致连锁更新的现象，所谓连锁更新，简单来说就是原来e1…eN存的都是250~253字节的数据，那么它们的previous_entry_length只需要1字节，但如果这时在e1之前插入一个大于等于254长度的数据，那么e1的previous_entry_length就不够了，就要从1字节扩充成5字节，但这就导致e1长度超过253字节，导致后续所有节点都要重新分配内存，这就是连锁更新，最坏时间复杂度将达到O（n^2）。</p><p>但要注意的是，连锁更新真正造成性能问题的几率是很低的，因为O（n^2）的时间复杂度是在很极端的情况下达到的，所以平均复杂度只是线性的。</p><p>具体API见p59</p><h1 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章 对象"></a>第八章 对象</h1><p>前面介绍了Redis用到的主要数据结构，但Redis并没有直接使用这些数据结构，而是基于这些数据结构创建了一个对象系统。</p><p>Redis对象系统实现了基于引用计数的内存回收机制，还通过引用计数实现了对象共享机制，最后对象带有访问时间记录信息。</p><h2 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h2><p>每当在Redis数据中新创建一个键值对时，都至少会创建两个对象，每个对象都由一个redisObject表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisObject;</span><br></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对象的type属性记录了对象的类型，type属性对应REDIS_STRING/REDIS_LIST/REDIS_HASH/REDIS_SET/REDIS_ZSET五中类型中的一种。</p><h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，一共有八种。。</p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码。</p><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，则字符串对象会将字符串对象的编码设置为int。</p><p>如果一个字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，则用一个SDS来保存，编码设置为raw。</p><p>如果一个字符串对象保存的是一个字符串值，并且长度小于等于32字节，则使用embstr编码的方式来保存。</p><p>int和embstr编码的字符串对象会在某些情况下转换为raw编码，比较特殊的一点是embstr编码的字符串对象实际上时只读的，当修改值的时候就会变成raw。</p><h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>当列表对象同时满足以下两个条件的时候，使用ziplist编码：</p><ol><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；</li></ol><p>否则使用linkedlist编码。</p><h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>当哈希对象同时满足以下两个条件时，使用ziplist编码：</p><ol><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个。</li></ol><p>否则使用hashtable编码。</p><h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是intset或者hashtable。</p><p>当集合对象同时满足以下两个对象时，使用intset编码：</p><ol><li>集合对象保存的所有元素都是整数；</li><li>集合对象保存的元素数量不超过512个。</li></ol><p>否则使用hashtable编码。</p><h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist。</p><p>skiplist编码的有序结合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist* zsl;<span class="comment">//按分值从小到大保存了所有集合元素</span></span><br><span class="line">    dict* dict;<span class="comment">//创建了一个从成员到分值的映射</span></span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure><p>当有序集合对象同时满足以下两个条件时，可以使用ziplist编码：</p><ol><li>有序集合保存的元素数量小于128个；</li><li>有序集合保存的所有元素成员的长度都小于64字节；</li></ol><p>否则使用skiplist编码。</p><h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>在Redis中，有些命令可以在多种类型上执行，但有些则不行。</p><p>为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入建的类型是否正确，然后再决定是否执行该命令。</p><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>每个对象的引用计数信息由redisObject结构的refcount属性记录，即是基于引用计数的内存回收机制。</p><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>除了用于实现内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p><p>目前来说，Redis会在初始化服务器时创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当需要用到的时候，服务器就会使用这些共享对象。</p><h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>Redis中的RedisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。</p><p>利用OBJECT IDLETIME命令可以打印出给定键的空转时长，即当前时间减去lru时间算出的值。</p><h1 id="第九章-数据库"><a href="#第九章-数据库" class="headerlink" title="第九章 数据库"></a>第九章 数据库</h1><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每一个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中所有数据库</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>默认情况下，客户端的目标数据库为0号数据库，但可以通过SELECT命令切换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录客户端当前正在使用的数据库库</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p>目前Redis没有可以返回客户端目标数据库的命令。</p><h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//数据库建空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict* dict;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure><p>在读取一个键之后，服务器会根据键是否存在来更新键的hit次数和miss次数，这两个值可以在INFO stats命令的keyspace_hits和keyspace_misses属性中查看。</p><h2 id="设置生存时间或过期时间"><a href="#设置生存时间或过期时间" class="headerlink" title="设置生存时间或过期时间"></a>设置生存时间或过期时间</h2><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，过期后就会自动删除生存时间为0的键。</p><p>而EXPIREAT或PEXPIREAT命令则以秒或毫秒给数据库中的某个键设置过期时间，过期时间是一个UNIX时间戳，当该时间来临时服务器自动删除该键。</p><p>其中EXPIRE、PEXPIRE、EXPIREAT三个命令最后都是转换成PEXPIREAT一样。</p><p>redisDb结构中会有一个名为expires的字典，该字典中保存了数据库中所有键的过期时间，这个字典也被称作过期字典。</p><p>过期字典的键是一个指针，这个指针指向键空间中的某个键对象，值是一个longlong类型的整数。</p><p>PERSIST命令可以移除一个键的过期时间，即将该键值对从过期字典中移除。</p><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>有三种不同的删除策略：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。【对CPU不友好，内存友好】</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键，如果没有过期就返回该键。【CPU友好，内存不友好】</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。【结合】</li></ul><h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>使用的是惰性删除和定期删除两种策略。</p><p>惰性删除在db.c/expireIfNeeded方法中。</p><p>定期删除策略在redis.c/activeExpireCycle方法中。周期性执行，每次执行的时候，则在规定时间内分多次遍历服务器中的各个数据库，随机检查一部分键的过期时间并删除过期的。</p><h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><h3 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h3><p>在执行SAVE命令或者BGSAVE创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件中。</p><h3 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h3><p>如果服务器以主服务器模式运行，那么在载入RDB文件时会进行检查，过期键会被忽略。</p><p>如果以从服务器模式运行，那么不会检查，所有键都被载入。但因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以一般也不会有影响。</p><h3 id="AOF写入"><a href="#AOF写入" class="headerlink" title="AOF写入"></a>AOF写入</h3><p>如果数据库中的某个键已经过期但还没有被惰性删除或定期删除，那么AOF文件不会因此而有任何影响，但当过期键被惰性删除或者定期删除之后，程序就会向AOF文件追加一条DEL命令，显示记录该键被删除。</p><p>AOF重写和RDB类似，不会管已过期的键。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li>主服务器删除一个键后，会向所有从服务器发送一个del命令，通知从服务器删除该键；</li><li>从服务器本身不会删除键，即使该键已经过期，也仍然按未过期处理，该get还是能get到，只有在收到主服务器的del命令时才进行删除。</li></ul><h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>该功能可以让客户端通过订阅给定的频道或者模式，来获取数据库中键的变化，以及数据库中命令的执行情况。</p><p>分为两种：</p><ul><li>键空间通知：某个键执行了什么命令</li><li>键事件通知：某个命令被什么键执行了</li></ul><p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型。</p><h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现，具体实现见p120.</p><h1 id="第十章-RDB持久化"><a href="#第十章-RDB持久化" class="headerlink" title="第十章 RDB持久化"></a>第十章 RDB持久化</h1><h2 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h2><p>Save和BGSAVE两个命令都可以生成RDB文件，但又有不同，save是阻塞的，而BGSAVE则是生成一个子进程创建RDB文件，父进程继续处理命令请求。</p><p>实际工作由rdb.c/rdbSave函数完成，上述两个命令都是调用该函数的，载入时实际调用的函数是rdb.c/rdbLoad函数。</p><p>在执行BGSAVE命令期间，客户端发送的SAVE和GBSAVE命令会被服务器拒绝，而对于BGREWRITEAOF则会等到BGSAVE写完后再调用。</p><p>如果BGREWRITEAOF执行期间调用了BGSAVE，则BGSAVE会被拒绝。</p><p>载入RDB文件期间，服务器会一直处于阻塞状态。</p><h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>Redis会定期使用BGSAVE命令，当Redis服务器启动时，用户可以指定配置文件或传入启动参数设置save选项，若用户没有指定则使用默认的。</p><p>save 900 1</p><p>save 300 10</p><p>save 60 10000</p><p>接着设置服务器状态redisServer结构的saveparams属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>* <span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//修改计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="comment">//上一次执行bgsave的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">//修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务器会以100ms为周期周期性执行函数serverCron，该函数用于对正在运行的服务器进行维护，它会检查save属性中设置的条件是否已经满足，满足就执行BGSAVE。</p><h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p>Redis文件所包含的各个部分：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">REDIS</td><td style="text-align:center">db_version</td><td style="text-align:center">databases</td><td style="text-align:center">EOF</td><td style="text-align:center">check_num</td></tr></tbody></table><p>RDB文件的最开头是REDIS部分，长度5字节，保存“REDIS”五个字符，用来判断文件是否是RDB文件。</p><p>db_version长度为4字节，记录RDB文件的版本号。</p><p>databases包含着另个或多个数据库，以及各个数据库中的键值对数据。</p><p>EOF长度为1字节，标志着RDB文件正文内容的结束。</p><p>check_num是一个8字节的无符号整数，保存一个检验和。</p><h3 id="database部分"><a href="#database部分" class="headerlink" title="database部分"></a>database部分</h3><p>database部分可以保存任意多个非空数据库，每个非空数据库在RDb文件中可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读的是一个数据库号码。</p><p>db_number保存一个数据库号码，根据号码大小不同，长度可以是1字节、2字节或5字节。</p><p>当程序读入该部分后，服务器会调用SELECT命令切换到对应数据库。</p><p>key_value_pairs部分保存该数据库中所有键值对数据。</p><h3 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h3><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成。</p><p>带有过期时间的键值对的结构由五部分组成：EXPIRETIME_MS、ms、TYPE、key以及value。</p><p>根据TYPE不同，不同类型的值对象在RDB文件中的保存结构都不相同，详细见p128起的叙述，这里只简单记录一下。</p><ul><li>字符串对象，有两种编码：REDIS_ENCODING_INT或者REDIS_ENCODING_RAW，如果是前者则按照ENCODING和integer两部分保存，若是后者，则又有压缩或不压缩两种方式保存。</li><li>列表对象，TYPE的值为REDIS_RDB_TYPE_LIST，则表示value存的是REDIS_ENCODING_LINKEDLIST编码对象，RDB中保存结构分为list_length、item1、item2…itemN。</li><li>集合对象，编码REDIS_ENCODING_HT，也是分为长度和元素集合存储。</li><li>哈希表对象，也是长度，后面跟各个kv对。</li><li>有序集合对象，也一样，长度跟上分值和成员本身值。</li><li>INTSET编码的集合，存的时候整数转换成字符串存，取的时候再转换回整数。</li><li>ZIPLIST编码的列表、哈希表或者有序集合，存的时候是把压缩列表转换成了一个字符串对象。</li></ul><h2 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h2><p>od命令可以打印RDB文件</p><p><code>od -c dump.rdb</code></p><p>具体可看这一节书中的例子。</p><p>Redis本身带有RDB检查工具redis-check-dump。</p><p>od命令加上-c参数和-x参数可以同时以ASCII编码和十六进制显示，便于查看检验和。</p><h1 id="第十一章-AOF持久化"><a href="#第十一章-AOF持久化" class="headerlink" title="第十一章 AOF持久化"></a>第十一章 AOF持久化</h1><p>AOF(Append Only File)</p><p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p>是纯文本格式。</p><h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>AOF持久化功能的实现可以分为命令追加append、文件写入、文件同步sync三个步骤。</p><p>服务器配置的appendfsync选项有三个值：always、everysec和no。</p><table><thead><tr><th>appendfsync的值</th><th>flushAppendOnlyFile的行为</th></tr></thead><tbody><tr><td>always</td><td>将aof_buf缓冲区的所有内容写入并同步到AOF文件</td></tr><tr><td>everysec</td><td>将aof_buf缓冲区的所有内容写入到AOF文件，但每隔一秒才同步一次</td></tr><tr><td>no</td><td>只写，不同步，什么时候同步由操作系统控制</td></tr></tbody></table><h2 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h2><ol><li>创建一个不带网络连接的微客户端；</li><li>从AOF文件中分析并读取一条写命令；</li><li>使用伪客户端执行读出的写命令；</li><li>重复步骤2和3，直到AOF文件中所有写命令都被处理完毕。</li></ol><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>随着时间流逝，AOF文件内容会越来越多，为了解决AOF文件体积膨胀的问题，Redis提供了AOF重写功能，新AOF文件中不会包含任何浪费空间的冗余命令，所以体积要小很多。</p><p>虽然功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读写操作，真正操作时读取服务器当前的数据库状态来实现的。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写时会先检查元素数量，如果超过<code>redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>值时，就分成多条命令来写，所以并不是简单的一个键值对数据用一条命令来代替，具体见p147。</p><p>为了避免AOF操作重写造成线程长时间阻塞，会让子进程执行重写，这就是AOF后台重写，但这样又会导致子进程在重写的时候父进程执行了新的写操作，使得子进程重写后的AOF文件并不一致。</p><p>为了解决这个问题，Redis设置了一个AOF重写缓冲区，这个缓冲区在子进程被创建之后开始使用，当Redis执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程接收到该信号之后会调用一个信号处理函数，并执行以下两步：</p><ol><li>将AOF重写缓冲区的所有内容写入到新AOF文件中；</li><li>对新的AOF文件进行改命，原子地覆盖原有的AOF文件。</li></ol><p>完成这两步后，父进程就可以正常接收命令请求了。</p><p>整个步骤里，父进程只有在最后调用信号处理函数的时候会阻塞。</p><p>这就是AOF后台重写，也是命令BGREWRITEAOF命令的实现原理。</p><h1 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章 事件"></a>第十二章 事件</h1><p>Redis服务器是一个事件驱动程序，需要处理以下两类事件：</p><ol><li>文件事件（file event）：服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象，完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作需要在给定的时间点执行，时间事件就是对这类定时操作的抽象。</li></ol><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>使用I/O多路复用来同时监听多个套接字。</p><p>是基于Reactor模式实现的网络通信程序。</p><p>文件事件处理器有四个组成部分：套接字、I/O多路复用程序、文件时间分派器（dispatcher）以及事件处理器。</p><p>尽管多个文件事件可能会并发出现，但I/O多路复用程序总是将所有产生事件的套接字都放在一个队列里，然后通过这个队列以有序地、同步地、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后，再进行下一个。</p><p>I/O多路复用程序的实现中包装了常见的select、epoll、evport和kqueue。</p><p>有两类事件：AE_READABLE和AE_WRITABLE。</p><p>如果一个套接字同时产生了这两种事件，那么文件事件分派器优先处理AE_READABLE事件。</p><p>文件事件有多个处理器，最常用的是连接应答处理器、命令请求处理器和命令回复处理器。</p><p>具体看p156.</p><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类：</p><ul><li>定时事件</li><li>周期性事件</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id，全局唯一，新的比旧的大</li><li>when：毫秒精度unix时间戳，记录时间事件的到达时间</li><li>timeProc：时间事件处理器，一个函数。如果该函数返回值为AE_NOMORE，则为定时事件，否则是周期性事件。</li></ul><p>书上说目前版本的Redis只使用了周期事件。</p><p>在实现方面，服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表找到所有已到达的时间事件，并调用相应的事件处理器。</p><p>【注】在目前的版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，在benchmark模式下也只有两个时间事件，所以用无序链表不会影响性能。</p><h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>事件的调度和执行由<code>ae.c/aeProcessEvents</code>函数负责，大致逻辑如下：</p><ol><li>获取到达时间离当前时间最近的时间事件，最计算出距离还有多少毫秒赋值给remaind_ms</li><li>如果剩余时间小于0，则将remaind_ms更新为0</li><li>根据remaind_ms创建一个timeval结构</li><li>根据timeval结构阻塞并等待文件事件产生，如果remaind_ms==0，则不阻塞</li><li>处理所有产生的文件事件</li><li>处理所有已到达的时间事件</li></ol><p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数。<br><img src="/2018/12/09/《Redis设计与实现》笔记/redisServerMainLoop.png" title="Redis服务器主循环"></p><h1 id="第十三章-客户端"><a href="#第十三章-客户端" class="headerlink" title="第十三章 客户端"></a>第十三章 客户端</h1><p>Redis服务器是典型的一对多服务器程序。</p><p>对于每个与服务器进行连接的客户端，服务器都会其建立了相应的<code>redis.h/redisClient</code>结构，该结构保存了客户端当前的状态信息以及相关数据结构。</p><p>Redis服务器状态结构的clients属性是一个链表，保存了所有与服务器相连的客户端的状态结构。</p><h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><p>客户端属性可以分为两类：</p><ol><li>一类是比较通用的属性；</li><li>另一类是和特定功能相关的属性，比如操作数据库时用到的db属性等等。</li></ol><h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>fd属性的值是-1或者大于-1的整数，-1表示伪客户端，其他表示普通客户端。</p><h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><p>name属性一般是空，但可以使用CLIENT setname设置一个，使得客户端更好区分。</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>flags属性记录了客户端的角色以及目前所处的状态，具体各个标志可看书p165或redis.h源码。</p><h3 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h3><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求。</p><h3 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h3><p>在服务器将客户端发送的命令请求保存到客户端的输入缓冲区之后，服务器会解析得到命令参数以及参数个数，并把这两个值分别保存到argv属性和argc属性。</p><h3 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h3><p>服务器之后会到命令表（一个字典）中根据argv[0]的值查找命令实现的一个数据结构redisCommand，argv[0]不区分大小写，找到后将客户端状态的cmd属性指向该结构。</p><h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区中，每个客户端都有两个输出缓冲区可用，一个大小固定，一个大小可变。</p><ul><li>大小固定的缓冲区用于保存长度比较小的回复</li><li>大小可变的缓冲区用于保存长度比较大的回复</li></ul><p>大小固定的缓冲区由buf和bufpos两个属性组成，buf是一个大小为<code>REDIS_REPLY_CHUNK_BYTES</code>字节的字节数组，而bufpos属性则记录buf数组已使用的字节数量，数组长度默认16KB。</p><p>可变大小缓冲区由reply链表和一个或多个字符串对象组成。</p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>authenticated属性用于记录客户端是否通过了身份验证，仅在服务器启用了身份验证功能时使用。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>c_time：记录创建客户端的时间，CLIENT list命令的age域记录了这个秒数。</p><p>lastinteraction属性记录客户端与服务器最后一次互动的时间，idle域记录该秒数。</p><p>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制的时间。</p><h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><h3 id="普通客户端"><a href="#普通客户端" class="headerlink" title="普通客户端"></a>普通客户端</h3><p>创建普通客户端时，就把新的客户端状态添加到服务器状态结构clients链表的末尾。</p><p>普通客户端被关闭的原因有多种：</p><ul><li>客户端进程退出或者被杀死；</li><li>客户端向服务器发送了带有不符合协议格式的命令请求；</li><li>客户端成了CLIENT KILL命令的目标；</li><li>客户端空转时间超过了timeout配置选项（有一些例外情况见书上p173）</li><li>客户端发送的命令请求大小超过输入缓冲区限制大小；</li><li>要发送给客户端的命令回复大小超过了输出缓冲区的限制。服务器使用两种模式来限制客户端输出缓冲区的大小：硬性限制和软性限制。</li></ul><h2 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h2><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中；</p><p>lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</p><h2 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h2><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后关闭该伪客户端。</p><h1 id="第十四章-服务器"><a href="#第十四章-服务器" class="headerlink" title="第十四章 服务器"></a>第十四章 服务器</h1><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h2 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h2><ol><li>客户端向服务器发送命令请求，命令请求会转换成协议格式发送</li><li>服务器接受命令请求并存入客户端状态的输入缓冲区中，然后处理，在数据库中进行设置操作，并产生命令回复</li><li>服务器将命令回复发送给客户端</li><li>客户端接受服务器返回的命令回复并将命令回复打印给用户观看</li></ol><h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>serverCron函数默认每隔100ms执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><h3 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h3><p>为了减少对当前时间系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存了秒级精度的系统当前unix时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">//保存了毫秒级精度的系统当前unix时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个属性记录的时间精确度并不高，当需要执行高精度时间的功能来说，服务器还是会再次执行系统调用。</p><h3 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h3><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，也是服务器时间缓存的一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//默认每十秒更新一次，用于计算键的空转时长</span></span><br><span class="line">    <span class="keyword">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空转时间就是lruclock-lru的值，当然只是一个模糊估计值。</p><h3 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h3><p>serverCron函数中的trackOperationsPerSecond函数会以抽样计算的方式估算并记录最近一秒钟处理的命令请求数量，可通过INFO status命令中的instantaneous_ops_per_sec查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//上一次抽样的时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_last_sample_time;</span><br><span class="line">    <span class="comment">//上一次抽样时服务器已执行命令的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_last_sample_ops;</span><br><span class="line">    <span class="comment">//数组中的每一项记录了一次抽象结果</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_samples[REDIS_OPS_SEC_SAMPLES];</span><br><span class="line">    <span class="comment">//数组索引，每次抽样后加1，索引到最后一格则变成0，形成环形数组</span></span><br><span class="line">    <span class="keyword">int</span> ops_sec_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数组中记录的值是根据服务器平均每一毫秒处理了多少个命令请求乘以1000估算出来的。</p><p>instantaneous_ops_per_sec的值则是根据环形数组里的值求平均数得到的估算值。</p><h3 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h3><p>服务器状态中的stat_peak_memory属性记录该值。</p><h3 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h3><p>收到该信号后悔调用sigtermHandler函数，会打开服务器状态的shutdown_asap标志，用于关闭服务器。</p><h3 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h3><p>serverCron函数中每次都会调用clientsCron函数，该函数会对一些客户端进行一些检查。</p><h3 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h3><p>serverCron函数每次都会调用databasesCron函数，会对一部分数据库进行检查。</p><h3 id="执行被延迟的BGREWRITEAOF命令"><a href="#执行被延迟的BGREWRITEAOF命令" class="headerlink" title="执行被延迟的BGREWRITEAOF命令"></a>执行被延迟的BGREWRITEAOF命令</h3><p>服务器状态的aof_rewrite_scheduled标志记录是否延迟。</p><h3 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h3><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，也可以用来查询这两个命令是否在执行。</p><img src="/2018/12/09/《Redis设计与实现》笔记/持久化检查.png" title="判断是否需要执行持久化操作"><h3 id="将AOF缓冲区中的内容写入AOF文件"><a href="#将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="将AOF缓冲区中的内容写入AOF文件"></a>将AOF缓冲区中的内容写入AOF文件</h3><h3 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h3><h3 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h3><p>该值记录serverCron函数执行的次数。</p><h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><p>服务器从刚启动到能够接受客户端命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p><h3 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h3><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为各个属性设置默认值。</p><p>主要函数是initServerConfig，会做以下工作：</p><ul><li>设置服务器的运行ID</li><li>设置服务器的默认运行频率。</li><li>设置服务器的默认配置文件路径</li><li>设置服务器的运行架构</li><li>设置服务器的默认端口号</li><li>设置服务器的默认RDB和AOF持久化条件</li><li>初始化LRU时钟</li><li>创建命令表</li></ul><h3 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h3><h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>在initServerConfig函数中只初始化了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，这里列两个比较熟悉的，更多数据结构见书：</p><ul><li>server.clients链表</li><li>server.db数组</li></ul><p>主要函数是initServer函数，除了初始化数据结构外，该函数还做了一些其他重要的操作设置：</p><ul><li>为服务器设置进程信号处理器</li><li>创建共享对象</li><li>打开服务器监听端口</li><li>为serverCron函数创建时间事件</li><li>检查AOF</li><li>初始化后台I/O模块</li></ul><h3 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h3><h3 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h3><h1 id="第十五章-复制"><a href="#第十五章-复制" class="headerlink" title="第十五章 复制"></a>第十五章 复制</h1><p>在Redis中，用户可以通过SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，则被复制的服务器为主服务器，进行复制的称作从服务器。</p><h2 id="旧版复制功能的实现（2-8版本以前）"><a href="#旧版复制功能的实现（2-8版本以前）" class="headerlink" title="旧版复制功能的实现（2.8版本以前）"></a>旧版复制功能的实现（2.8版本以前）</h2><p>Redis的复制功能分为同步（sync）和命令传播两个操作。</p><p>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p><p>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致时，让主从服务器数据重新回到一致的状态。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当客户端向从服务器发送SLAVEOF命令时，要求从服务器复制主服务器，从服务器需要执行同步操作。</p><ol><li>从服务器向主服务器发送SYNC命令。</li><li>主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用缓冲区来记录从现在开始执行的所有写命令</li><li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器</li><li>主服务器将缓冲区里的所有写命令发送给从服务器。</li></ol><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>同步操作执行完之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是永远的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就可能被修改并导致主从服务器状态不再一致，这时就需要主服务器将运行的写命令传播给从服务器，使两者数据库保持一致。</p><h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>简单来说，同步完成之后主从服务器之间是通过命令传播来保持一致的，但如果在命令传播阶段主从服务器断开连接了，等到从服务器重新连上来的时候，它会重新发送SYNC同步命令将自上次同步之后的所有命令都重新生成RDB文件同步一遍，但这RDB文件中可能有很多操作是在掉线之前的命令传播阶段就做了的，所以会很低效，而且SYNC是一个非常耗费资源的资源。</p><h2 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h2><p>为了解决上述缺陷，Redis从2.8版本开始使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p><p>PSYNC命令具有完整重同步和部分重同步两种模式：</p><ul><li>完整重同步用于处理初次复制情况，和SYNC命令执行步骤基本一样。</li><li>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只处理这些写命令。</li></ul><h2 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h2><p>部分重同步功能由以下三个部分构成：</p><ul><li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。个人感觉可以和TCP连接中收发端的滑动窗口以及序号类比，主服务器发了N字节，就把主服务器的偏移量加上N，从服务器接收到N字节就把自己的偏移量加上N，主从一致时，主从服务器的偏移量应该是一样的。</li><li>主服务器的复制积压缓冲区（replication backlog），主服务器每次往从服务器命令传播时也会往一个叫做复制积压缓冲区的定长先进先出队列中写入相同命令，当主从服务器断开连接，这时主从服务器的偏移量就不一样了，当从服务器重新连上来时会检查主从偏移量之间的差距，如果相差的数据大小没有超过复制积压缓冲区大小，则可从积压缓冲区中将没接收到的数据重新发送，即PSYNC，否则只能完整重同步；</li><li>服务器的运行ID（run ID），实现部分重同步还需要用到服务器运行ID，是40个随机十六进制，当从服务器初次对主服务器进行复制时，主服务器会将自己的运行ID传送给从服务器，掉线重连后从服务器会向主服务器发送该ID，如果相同则说明连上的就是之前的主服务器，就执行PSYNC，否则只能完整重同步。</li></ul><h2 id="PSYNC命令实现流程"><a href="#PSYNC命令实现流程" class="headerlink" title="PSYNC命令实现流程"></a>PSYNC命令实现流程</h2><img src="/2018/12/09/《Redis设计与实现》笔记/psync实现.png" title="PSYNC命令调用流程图"><h2 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h2><p>通过向从服务器发送SLAVEOF命令，可以让一个从服务器去复制一个主服务器（2.8版本以上）。</p><p><code>SALVEOF &lt;mater_ip&gt; &lt;master_port&gt;</code></p><p>本节是一个具体例子，可以看p211，这里简单列出步骤：</p><ol><li>设置主服务器的地址和端口；</li><li>建立套接字连接；</li><li>发送ping命令；</li><li>身份验证；</li><li>发送端口信息；</li><li>同步，从服务器向主服务器发送PSYNC命令，值得一提的是在同步操作之前只有从服务器时主服务器的客户端，但是在执行同步操作之后，主服务器也是从服务器的客户端；</li><li>命令传播。</li></ol><h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>在命令传播阶段，从服务器会默认以每秒一次的频率向主服务器发送命令<code>REPLCONF ACK &lt;replication_offset&gt;</code>，主要有三个作用：检测主从服务器的网络连接状态、辅助实现min-slaves选项、检测命令丢失。</p><p>2.8版本之前没有这个命令，所以尽量使用2.8版本以上的Redis。</p><h1 id="第十六章-Sentinel"><a href="#第十六章-Sentinel" class="headerlink" title="第十六章 Sentinel"></a>第十六章 Sentinel</h1><p>Sentinel（哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及这些主服务器下的所有从服务器，当被监视的主服务器下线时，Sentinel系统会自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续执行命令请求。</p><h2 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h2><p>启动一个Sentinel可以使用命令：<code>redis-sentinel /path/to/your/sentinel.conf</code>或者命令<code>redis-server /path/to/your/sentinel.conf --sentinel</code>.</p><p>启动步骤如下：</p><ol><li>初始化一个服务器</li><li>将普通Redis服务器使用的代码替换城Sentinel专用代码</li><li>初始化Sentinel状态</li><li>根据给定的配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连上主服务器的网络连接，对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接：一个是命令连接，一个是订阅连接。</li></ol><h2 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h2><p>Sentinel默认会以每十秒一次的频率向被监视的主服务器发送INFO命令，从命令返回的结果中可以看出该主服务器的信息以及其属下的从服务器信息，并进行更新。</p><h2 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h2><p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建新的实例之外，还会创建连接到从服务器的命令连接和订阅连接。</p><p>Sentinel也会默认每十秒一次向从服务器发送INFO命令。</p><h2 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h2><p>默认下，Sentinel会以每两秒一次的频率向所有被监视的主从服务器发送以下格式的命令：</p><p><code>PUBLISH \__sentine__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_pi&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</code></p><p>s_开头的是Sentinel本身的信息，m_表示的是当前监视的主或从服务器的信息。</p><h2 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h2><p>当Sentinel与一个主服务器或从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令：<code>SUBSCRIBE \__sentinel__: hello</code>，对该频道的订阅会一直持续到连接断开为止。</p><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到并处理。</p><p>Sentinel和Sentinel之间不会创建订阅连接，只有命令连接。</p><h2 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h2><p>默认下，Sentinel会以每秒一次的频率向所有与它建立了命令接连的实例发送ping命令，并通过返回的结果判断实例是否在线。</p><p>Sentinel配置文件中的down-after-milliseconds选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，以此来表示这个实例已经进入主观下线状态。</p><h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，当Sentinel从其他Sentinel那接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，打开主服务器实例结构flags属性的SRI_O_DOWN标识，并对主服务器执行故障转移操作。</p><h2 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h2><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，由它对下线主服务器进行故障转移操作。</p><p>选举规则还比较复杂，详细看p239.</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移擦操作，该操作包含以下三个步骤：</p><ol><li>在已下线主服务器属下的所有从服务器中挑选出一个转换成主服务器；</li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器；</li><li>将已下线主服务器设置为新的主服务器的从服务器。</li></ol><h1 id="第十七章-集群"><a href="#第十七章-集群" class="headerlink" title="第十七章 集群"></a>第十七章 集群</h1><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>连接各个节点的工作可以使用<code>CLUSTER MEET</code>命令来完成，Redis服务器会在启动时根据cluster-enabled配置选项是否是yes来决定是否开启服务器的集群模式。</p><h3 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h3><p>clusterNode结构保存了一个节点的当前状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line">    <span class="comment">//节点名字，由40个十六进制组成</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    <span class="comment">//节点标识</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//节点当前的配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line">    <span class="comment">//节点ip</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line">    <span class="comment">//节点端口</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">//保持连接节点所需的有关信息</span></span><br><span class="line">    clusterLink* link;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clustereLink</span>&#123;</span></span><br><span class="line">    <span class="comment">//连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line">    <span class="comment">//TCP套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//输出缓冲区，保存着等待发送给其他节点的消息</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    <span class="comment">//输入缓冲区，保存着从其他节点接收到的消息</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line">    <span class="comment">//与这个连接相关联的节点，如果没有就为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个节点都保存一个clusterState结构，记录在当前节点的视角下集群目前所处的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//指向当前节点的指针</span></span><br><span class="line">    clusterNode* myself;</span><br><span class="line">    <span class="comment">//配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">//集群当前的状态，在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//集群节点名单</span></span><br><span class="line">    dict* nodes;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><h3 id="CLUSTER-MEET命令的实现"><a href="#CLUSTER-MEET命令的实现" class="headerlink" title="CLUSTER MEET命令的实现"></a>CLUSTER MEET命令的实现</h3><img src="/2018/12/09/《Redis设计与实现》笔记/clustermeet.png" title="节点的握手过程"><h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理0个或最多16384个槽。</p><p>当所有16384个槽都有节点在处理时，集群处于上线状态，否则处于下线状态。</p><p>可以利用CLUSTER ADDSLOTS命令将一个或多个槽指派给节点负责。</p><h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>slots属性是一个二进制位数组，每一位用来表示该节点是否负责处理该槽，1表示处理。</p><h3 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h3><p>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots之外，还会将自己的slots数组通过消息发送给集群中的其他节点。</p><h3 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* slots[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure><h3 id="CLUSTER-ADDSLOTS命令的实现"><a href="#CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="CLUSTER ADDSLOTS命令的实现"></a>CLUSTER ADDSLOTS命令的实现</h3><ol><li>遍历所有输入的槽，如果有哪怕一个槽已经指派给了某个节点，则返回错误</li><li>若所有输入槽都是未指派槽，则再次遍历所有输入槽，指派给当前节点，修改clusterState.slots数组和clusterNode.slots数组</li></ol><h2 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h2><p>集群上线后，当客户端向节点发送命令时，接收命令的节点会计算出命令要处理的数据库属于哪个槽，如果是自己则直接执行，如果不是自己则向客户端返回MOVED错误，指引客户端转向正确的节点。</p><h3 id="计算键属于哪个槽"><a href="#计算键属于哪个槽" class="headerlink" title="计算键属于哪个槽"></a>计算键属于哪个槽</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slot_number</span><span class="params">(key)</span>:</span></span><br><span class="line"><span class="keyword">return</span> CRC16(key) &amp; <span class="number">16383</span></span><br></pre></td></tr></table></figure><h3 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h3><p>节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机Redis没有这个限制，其他地方则相同。</p><h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点。</p><p>重新分片可以在线进行。</p><p>Redis集群的重新分片操作时由Redis的集群管理软件redis-trib负责执行的，具体步骤如下：</p><ol><li>redis-trib向目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让目标节点准备好从源节点导入属于槽slot的键值对</li><li>redis-trib对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>，让源节点准备好将属于槽slot的键值对迁移到目标节点</li><li>redis-trib向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令，获得最多count个属于槽slot的键值对的键名</li><li>对于3中获得的每个键名，redis-trib都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>命令，将被选中的键值对原子地迁移</li><li>重复3和4直到所有节点都完成迁移</li><li>redis-trib向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。</li></ol><h2 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h2><img src="/2018/12/09/《Redis设计与实现》笔记/ask错误.png" title="判断是否发送ASK错误的过程"><h3 id="CLUSTER-SETSLOT-IMPORTING命令的实现"><a href="#CLUSTER-SETSLOT-IMPORTING命令的实现" class="headerlink" title="CLUSTER SETSLOT IMPORTING命令的实现"></a>CLUSTER SETSLOT IMPORTING命令的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure><p>如果importing_slots_from[i]的值不是NULL，而是指向一个clusterNode节点，那么表示当前节点正在从clusterNode所代表的节点导入槽i。</p><p>在对集群进行重新分片的时候，向目标节点发送命令：</p><p><code>CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</code>可以将目标节点的importing_slots_from[i]的值设置为source_id所代表的节点的clusterNode结构。</p><h3 id="CLUSTER-SETSLOT-MIGRATING命令的实现"><a href="#CLUSTER-SETSLOT-MIGRATING命令的实现" class="headerlink" title="CLUSTER SETSLOT MIGRATING命令的实现"></a>CLUSTER SETSLOT MIGRATING命令的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure><p>同理，如果migrating_slots_to[i]的值不为NULL，则表示正在向所指的clusterNode节点迁移。</p><p>命令：<code>CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</code></p><h3 id="ASK错误-1"><a href="#ASK错误-1" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>如果节点收到一个键key的请求，但并没有在自己的数据库里找到键key，那么节点会检查自己的clusterState.migrating_slots_to[i]，如果正在迁移，则会向客户端发送一个ASK错误，引导客户端到正在导入槽i的节点去查找key。</p><h3 id="ASKING命令"><a href="#ASKING命令" class="headerlink" title="ASKING命令"></a>ASKING命令</h3><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识。</p><p>当客户端接受到ASK错误时会先向转向节点发一个ASKING命令，然后才再次发送命令。</p><p>客户端的REDIS_ASKING标识是一个一次性标识，当节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，该客户端的REDIS_ASKING标识就会被移除。</p><h3 id="ASK错误和MOVED错误的区别"><a href="#ASK错误和MOVED错误的区别" class="headerlink" title="ASK错误和MOVED错误的区别"></a>ASK错误和MOVED错误的区别</h3><p>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点；</p><p>ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施。</p><h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p>Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，从节点用于复制某个主节点，并在被复制的主节点下线时代替下线主节点继续处理命令请求。</p><h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>向一个节点发送命令：<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为noid_id所指定节点的从节点并开始复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//如果这时一个从节点，那么指向主节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">slaveof</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>集群中的所有节点都会在代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//正在复制这个主节点的从节点数量</span></span><br><span class="line">    <span class="keyword">int</span> numslaves;</span><br><span class="line">    <span class="comment">//一个数组，每个项指向一个正在复制这个主节点的从节点的clusterNode结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>** <span class="title">slaves</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中的每个节点都会定期向集群中的其他节点发送ping消息，如果接受ping消息的节点没有在规定的时间内返回pong消息，则会被标记为疑似下线（probable fail，PFAIL）。</p><p>当一个主节点A通过消息得知主节点B认为主节点C进入了PFAIL，主节点A会在自己的clusterState.nodes字典里找到主节点C，并将B的下线报告添加到fail_reports链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一个链表，记录了所有其他节点对该节点的下线报告</span></span><br><span class="line">    <span class="built_in">list</span>* fail_reports;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span>&#123;</span></span><br><span class="line">    <span class="comment">//报告目标节点已经下线的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">//最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> time;</span><br><span class="line">&#125;<span class="keyword">typedef</span> clusterNodeFailReport;</span><br></pre></td></tr></table></figure><p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线，将X标记为已下线的节点会向集群广播此消息，所有收到该消息的节点都会立刻将X标记为已下线。</p><h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>当一个从节点发现自己正在复制的主节点进入了已下线状态，则会开始进行故障转移。</p><ol><li>从所有从节点中选中一个节点，选举方法和16章中选举零头Sentinel的方法非常相似，因为两者都是基于Raft算法的领头选举方法来实现的；</li><li>被选中的从节点执行SLAVEOF no one命令，成为新的主节点；</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己；</li><li>新的主节点广播PONG消息；</li><li>新的主节点开始接受命令请求。</li></ol><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>节点发送的消息主要有以下五种：</p><ol><li>MEET消息</li><li>PING消息</li><li>PONG消息，以上三种消息都是用相同的消息正文，所以是通过消息头的type属性来判断的，每次发送这三种消息的时候，发送者都从自己的已知节点列表中随机选出两个节点保存到clusterMsgDataGossip结构中发送出去。</li><li>FAIL消息，当主节点A将主节点B标记为FAIl时，A会向集群广播关于B的FAIL消息，FAIL消息的正文里只包含nodename属性。</li><li>PUBLISH消息，当客户端向集群中的某个节点发送命令<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>命令，接收到PUBLISH命令的节点不仅会向channel频道发送消息message，还会向集群广播一条PUBLISH消息，所有接受到这条PUBLISH消息的节点都会向channel发送message。</li></ol><p>一条消息由消息头和消息正文组成。</p><p>消息头的主要字段见p282，由clusterMsg结构表示。</p><h1 id="第十八章-发布与订阅"><a href="#第十八章-发布与订阅" class="headerlink" title="第十八章 发布与订阅"></a>第十八章 发布与订阅</h1><p>Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。</p><h2 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h2><p>当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立起了一种订阅关系。</p><p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存所有频道的订阅关系</span></span><br><span class="line">    dict* pubsub_channels;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>订阅和退订就是在字典上进行操作，p294。</p><h2 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h2><p>PSUBSCRIBE命令用来订阅模式，与频道类似，服务器也将所有模式的订阅关系都保存在一个属性里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存所有模式订阅关系</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该属性是一个链表，链表中的每个节点都包含着一个pubsubPattern结构，这个结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span>&#123;</span></span><br><span class="line">    <span class="comment">//订阅模式的客户端</span></span><br><span class="line">    redisClient * client;</span><br><span class="line">    <span class="comment">//被订阅的模式</span></span><br><span class="line">    robj* pattern;</span><br><span class="line">&#125;pubsubPattern;</span><br></pre></td></tr></table></figure><p>模式的订阅与退订也就是在list上进行操作，p296.</p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>当一个Redis客户端执行<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：</p><ol><li>将消息message发送给channel频道的所有订阅者；</li><li>如果有一个或多个模式和channel频道匹配，那么将message发送给pattern模式的订阅者。</li></ol><h2 id="查看订阅信息"><a href="#查看订阅信息" class="headerlink" title="查看订阅信息"></a>查看订阅信息</h2><p><code>PUBSUB</code>命令是Redis2.8新增加的命令之一，客户端可以通过这个命令来查看频道或模式的相关信息。</p><p><code>PUBSUB CHANNELS [pattern]</code>用于返回服务器当前被订阅的频道</p><p><code>PUBSUB NUMSUB [channel-1 channel-2 ...]</code>接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。</p><p><code>PUBSUB NUMPAT</code>命令用于返回服务器当前被订阅模式的数量，即返回pubsub_patterns链表的长度。</p><h1 id="第十九章-事务"><a href="#第十九章-事务" class="headerlink" title="第十九章 事务"></a>第十九章 事务</h1><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务功能。</p><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>一个事务从开始到结束通常会经历三个阶段：</p><ul><li><p>事务开始，MULTI命令的执行标志着事务的开始，打开了客户端状态的flags属性中的REDIS_MULTI标识。</p></li><li><p>命令入队</p><img src="/2018/12/09/《Redis设计与实现》笔记/事务命令入队.png" title="服务器判断命令是该入队还是该执行的过程"></li><li><p>事务执行，每个客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里，该属性是一个multiState结构：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span>&#123;</span></span><br><span class="line">    <span class="comment">//事务队列，fifo顺序</span></span><br><span class="line">    multiCmd* commands;</span><br><span class="line">    <span class="comment">//已入队命令计数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; multiState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span>&#123;</span></span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">//命令指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行，服务器会遍历该客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p><h2 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h2><p>WATCH命令是一个乐观锁，它可以在EXEC命令执行之前监视任意数量的数据库键，并在EXEC命令执行时检查被监视的键是否至少有一个已经被修改过，如果是，服务器将拒绝执行事务并返回代表执行失败的空回复。</p><p>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//正在被WATCH命令监视的键</span></span><br><span class="line">    dict* watched_keys;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有对数据库进行修改的命令在执行之后都会调用multi.c/touchWatchKey函数对该字典进行检查，查看是否有客户端正在监视刚刚被修改过的键，如果有则打开该客户端的REDIS_DIRTY_CAS标识，标识客户端的事务安全性已经被破坏。</p><p>当服务器接收到某客户端的EXEC命令时会检查该客户端是否打开了REDIS_DIRTY_CAS标识，如果打开了则拒绝执行。</p><h2 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h2><p>原子性（Atomicity）、一致性（Consistency）、隔离性（isolation）以及持久性（durability），前三者总是有的，当Redis运行在某种特定的持久化模式下时，事务也具有持久性。</p><p>Redis没有事务回滚机制。</p><p>Redis事务中三个可能出错的地方：</p><ol><li>入队错误</li><li>执行错误</li><li>服务器停机</li></ol><p>Redis事务只有当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时才具有持久性（同时还需要no-appendfsync-on-rewrite配置选项没有被打开）。</p><p>其实不管Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事物的耐久性，但这种做法效率太低，所以不具有实用性。</p><h1 id="第二十章-Lua脚本"><a href="#第二十章-Lua脚本" class="headerlink" title="第二十章 Lua脚本"></a>第二十章 Lua脚本</h1><p>Redis从2.6版本开始引入对Lua脚本的支持，客户端可以通过使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p><h2 id="创建并修改Lua环境"><a href="#创建并修改Lua环境" class="headerlink" title="创建并修改Lua环境"></a>创建并修改Lua环境</h2><ul><li>创建一个基础的Lua环境</li><li>载入函数库</li><li>创建redis全局表格</li><li>使用redis自制的随机函数来替换Lua原有的随机函数</li><li>创建排序辅助函数</li><li>创建redis.pcall函数的错误报告辅助函数</li><li>保护lua的全局环境</li><li>将lua环境保存到服务器状态的lua属性中</li></ul><h2 id="lua环境协作组件"><a href="#lua环境协作组件" class="headerlink" title="lua环境协作组件"></a>lua环境协作组件</h2><p>一个是负责执行Lua脚本中的redis命令的伪客户端，一个是用于保存Lua脚本的lua_scripts字典，该字典有两个作用：实现SCRIPT EXISTS命令和实现脚本复制功能。</p><img src="/2018/12/09/《Redis设计与实现》笔记/lua.png" title="Lua脚本执行Redis命令时的通信步骤"><h2 id="EVAL命令的实现"><a href="#EVAL命令的实现" class="headerlink" title="EVAL命令的实现"></a>EVAL命令的实现</h2><ol><li>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数</li><li>将客户端给定的脚本保存到lua_srcipts字典，等待将来进一步使用</li><li>执行刚刚在Lua环境中定义的函数</li></ol><h2 id="EVALSHA命令的实现"><a href="#EVALSHA命令的实现" class="headerlink" title="EVALSHA命令的实现"></a>EVALSHA命令的实现</h2><p>只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的。</p><h2 id="脚本管理命令的实现"><a href="#脚本管理命令的实现" class="headerlink" title="脚本管理命令的实现"></a>脚本管理命令的实现</h2><p><code>SCRIPT FLUSH</code>：用于清除服务器中所有和Lua脚本有关的命令，这个命令会释放并重建lua_scripts字典，关闭现有的lua环境并重新创建一个新的Lua环境。</p><p><code>SCRIPT EXISTS</code>：根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p><p><code>SCRIPT LOAD</code>：和EVAL命令执行脚本所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典中。</p><p><code>SCRIPT KILL</code>：如果超时运行的脚本未执行过任何写入操作，那么客户端可以通过SCRIPT KILL命令来指示服务器停止执行这个脚本，并向执行该脚本的客户端发送一个错误回复。</p><h2 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h2><p>复制EVAL、SCRIPT FLUSH和SCRIPT LOAD命令时，主服务器会直接向所有从服务器发送该命令。</p><p>而在传播EVALSHA命令的时候，必须确保EVALSHA命令要执行的脚本已经被所有从服务器载入过，否则主服务器会将EVALSHA命令转换成一个等价的EVAL命令进行传播。</p><p>主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器，键是SHA1校验和，而值都是NULL。</p><p>每当主服务器添加一个新的从服务器时，主服务器都会清空自己的repl_scriptcache_dict字典。</p><h1 id="第二十一章-排序"><a href="#第二十一章-排序" class="headerlink" title="第二十一章 排序"></a>第二十一章 排序</h1><p>Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。</p><p>用的是快排。</p><h2 id="SORT-命令的实现"><a href="#SORT-命令的实现" class="headerlink" title="SORT 命令的实现"></a>SORT <key>命令的实现</key></h2><p>该命令可以对一个包含数字值的键key进行排序，详细步骤如下：</p><ol><li>创建一个和numbers列表长度相同的数组，数组每一项都是一个RedisSortObject结构；</li><li>遍历该数组，将各个数组项的obj指针分别指向numbers列表的各个项，并将obj指针所指的列表项转换成一个double类型浮点数存在相应数组项的u.score属性里面；</li><li>根据u.score的值对数组排序；</li><li>遍历数组，顺序输出obj所指的列表项。</li></ol><p>ALPHA、ASC以及DESC选项的实现都是在对数组排序的时候有所不同，具体看p347开始的几页。</p><h2 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h2><p>在默认情况下，SORT命令总会将排序后的所有元素都返回给客户端，但是通过LIMIT选项可以只返回其中一部分。</p><p><code>LIMIT &lt;offset&gt; &lt;count&gt;</code></p><h2 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h2><p>通过GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p><h2 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h2><p>默认情况下，SORT命令只向客户端返回排序结果，而不保存排序结果。</p><p>通过STORE选项，可以将排序结果保存到指定的键里面，并在又需要的时候重用这个排序结果。</p><p><code>SORT key ALPHA STORE key2</code></p><h2 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h2><ol><li>排序：在这一步命令会使用ALPHA、ASC或DESC、BY这几个选项；</li><li>限制排序结果集的长度，会使用LIMIT选项；</li><li>获取外部键，会使用GET选项</li><li>保存排序结果集：使用STORE选项</li><li>向客户端返回排序结果集</li></ol><h2 id="选项的摆放顺序"><a href="#选项的摆放顺序" class="headerlink" title="选项的摆放顺序"></a>选项的摆放顺序</h2><p>除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</p><h1 id="第二十二章-二进制位数组"><a href="#第二十二章-二进制位数组" class="headerlink" title="第二十二章 二进制位数组"></a>第二十二章 二进制位数组</h1><p>Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组。</p><p>BITOP命令既可以对多个位数组进行按位与、按位或、按位异或运算，也可以对给定的数组进行取反运算。</p><h2 id="位数组的表示"><a href="#位数组的表示" class="headerlink" title="位数组的表示"></a>位数组的表示</h2><p>Redis使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。</p><p>【注意】buf数组保存位数组的顺序和我们平时书写位数组的顺序是完全相反的，比如buf[0]字节中各个位分别是1/0/1/1/0/0/1/0，表示的其实是01001101。这样来保存可以简化SETBIT命令的实现。</p><h2 id="GETBIT命令的实现"><a href="#GETBIT命令的实现" class="headerlink" title="GETBIT命令的实现"></a>GETBIT命令的实现</h2><p><code>GETBIT &lt;bitarray&gt; &lt;offset&gt;</code></p><ol><li>计算byte=offset/8</li><li>计算bit=（offset mod 8）+1</li><li>根据byte和bit去取值。</li></ol><p>时间复杂度O（1）。</p><h2 id="SETBIT命令的实现"><a href="#SETBIT命令的实现" class="headerlink" title="SETBIT命令的实现"></a>SETBIT命令的实现</h2><p><code>SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt;</code></p><ol><li>计算len=offset/8+1</li><li>检查bitarray键保存的位数组的长度是否小于len，如果是则扩展为len个字节，并将新扩展的二进制位都设置为0；</li><li>计算byte=offset/8</li><li>计算bit=（offset mod 8）+1</li><li>根据byte和bit定位offset偏移量指定的二进制位，首先将该位上的值保存在oldvalue中，然后将新值value设置为这个二进制的值</li><li>向客户端返回oldvalue的值</li></ol><p>时间复杂度O(1)。</p><p>【注意】因为buf数组使用逆序来保存位数组，所以当程序需要对buf数组进行扩展时，写入操作可以直接在新扩展的二进制位中完成，而不必改动位数组原来已有的二进制位。如果buf数组使用和书写一样的顺序来保存位数组，那么每次扩展buf数组后都需要将已有的位进行移动，然后才能执行写操作，影响执行速度。</p><h2 id="BITCOUNT命令的实现"><a href="#BITCOUNT命令的实现" class="headerlink" title="BITCOUNT命令的实现"></a>BITCOUNT命令的实现</h2><p>几种可能的实现方式：</p><ol><li>遍历</li><li>查表，即映射hash，以空间换时间</li><li>variable-precison SWAR算法</li></ol><p>前两种有明显缺陷，主要看下第三种。</p><p>统计一个数组中非0二进制位的数量，在数学上被称为“计算汉明重量”，对于普通处理器来说，目前已知效率最好的通用算法就是variable-precison SWAR算法，该算法通过一系列位移和位运算操作，可以在常数时间内计算多个字节的汉明重量，并且不需要任何额外内存。</p><p>具体例子和算法见p372，看下来主要逻辑就是利用移位和位运算先算每两位有多少个1，然后算每四位有多少个1，接着是每八位有多少个1，依次类推，最后算出总的，但这个总数是在最高位的，所以需要再进行一个移位操作把值移到最低字节便于查看。</p><h3 id="Redis中的实现"><a href="#Redis中的实现" class="headerlink" title="Redis中的实现"></a>Redis中的实现</h3><p>BITCOUNT命令的实现用到了查表和SWAR两种算法：</p><ul><li>查表算法使用键长8位的表，表中记录从0000 0000到1111 1111在内的所有二进制位的汉明重量；</li><li>而SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision SWAR算法来计算这128个二进制位的汉明重量。</li></ul><p>在执行命令时，会根据未处理的二进制位的数量来决定具体使用哪种算法，大于等于128就用SWAR，否则用查表法。</p><p>时间复杂度O(n)。</p><h2 id="BITOP命令的实现"><a href="#BITOP命令的实现" class="headerlink" title="BITOP命令的实现"></a>BITOP命令的实现</h2><p>因为C语言直接支持对字节执行逻辑与或非以及异或操作，所有BITOP命令的AND、OR、XOR和NOT四个操作都是直接基于这些逻辑操作实现的。</p><p>NOT复杂度O(n)，其他的O(n^2)。</p><h1 id="第二十三章-慢查询日志"><a href="#第二十三章-慢查询日志" class="headerlink" title="第二十三章 慢查询日志"></a>第二十三章 慢查询日志</h1><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p><p>服务器配置中有两个和慢查询日至相关的选项：</p><ul><li><code>showlog-log-slower-than</code>选项指定执行时间超过多少微妙的命令请求会被记录到日志上；</li><li><code>showlog-max-len</code>选项指定服务器最多保存多少条查询日志。</li></ul><p>服务器使用先进先出的方式保存慢查询日志。</p><p><code>SLOWLOG GET</code>命令查看服务器所保存的慢查询日志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//下一条慢查询日志的ID</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;</span><br><span class="line">    <span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="built_in">list</span>* slowlog;</span><br><span class="line">    <span class="comment">//服务器配置slowlog-log-slower-than选项的值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//slowlog链表中每个节点都是一个slowlogEntry结构，新的节点插入在表头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntrt</span>&#123;</span></span><br><span class="line">    <span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">//命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> time;</span><br><span class="line">    <span class="comment">//执行命令消耗的时间，以微妙为单位</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration;</span><br><span class="line">    <span class="comment">//命令与命令参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//命令与命令参数的数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">&#125;slowlogEntry;</span><br></pre></td></tr></table></figure><p>在每次执行命令的前后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，这个时长会传给slowlogPushEntryIfNeeded函数，会根据情况检查是否需要为自己执行的命令创建慢查询日志。</p><p>slowlogPushEntryIfNeeded函数作用有两个：检查命令的执行时长是否超过阈值、检查慢查询日志的长度是否超过最大长度。</p><h1 id="第二十四章-监视器"><a href="#第二十四章-监视器" class="headerlink" title="第二十四章 监视器"></a>第二十四章 监视器</h1><p>执行MONITOR命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息。</p><p>每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令外，还会将关于这条命令请求的信息发送给所有监视器。</p><p><code>MONITOR</code>执行步骤如下：</p><ol><li>打开客户端监视器标志REDIS_MONITOR</li><li>将客户端添加到服务器状态的monitors链表的末尾</li><li>向客户端返回OK</li></ol><p>服务器每次处理命令之前，都会调用replicationFeedMonitors函数，由该函数将被处理的命令请求的相关信息发送给各个监视器，该函数步骤如下：</p><ol><li>根据执行命令的客户端、当前数据库的号码、命令参数、命令参数个数等参数创建要发送给各个监视器的信息</li><li>遍历所有监视器，发送信息</li></ol><p>举个例子，若服务器在时间1378822257，根据IP为127.0.0.1、端口56604的客户端发送的命令请求，对0号数据库执行命令<code>KEYS *</code>，那么服务器创建的信息如下：</p><p><code>1378822257 [0 127.0.0.1:56604] &quot;KEYS&quot; &quot;*&quot;</code></p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-简单动态字符串&quot;&gt;&lt;a href=&quot;#第二章-简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;第二章 简单动态字符串&quot;&gt;&lt;/a&gt;第二章 简单动态字符串&lt;/h1&gt;&lt;p&gt;在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://yoursite.com/2018/12/08/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/12/08/Redis入门/</id>
    <published>2018-12-08T08:16:18.000Z</published>
    <updated>2019-07-28T15:13:45.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个高性能内存key-value数据库，和其他key-value缓存产品相比有其他特点：</p><ol><li>Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时可以重新加载使用；</li><li>Redis不仅支持简单的key-value类型的数据，同时还提供list，set，hash，zset等数据结构；</li><li>Redis支持数据备份，即master-slave模式。</li></ol><a id="more"></a><p>Redis性能极高，读110000次/s，写81000次/s。</p><p>Redis的所有操作都是原子性的，单个操作是原子性的，多个操作可以支持事务，通过multi和exec指令包起来。</p><p>Redis还支持pulish/subscribe，通知，key过期等特性。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="windows下使用和安装"><a href="#windows下使用和安装" class="headerlink" title="windows下使用和安装"></a>windows下使用和安装</h2><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">下载地址</a></p><ol><li>解压后将文件夹名字改为redis；</li><li>进入redis目录打开cmd窗口，运行以下命令打开redis服务器（win10下的powershell似乎不行，原因不明）<code>redis-server.exe redis.windows.cof</code></li><li>另启一个cmd窗口，启动redis客户端连接服务器<code>redis-cli.exe -h 127.0.0.1 -p 6379</code></li></ol><h2 id="linux下使用和安装"><a href="#linux下使用和安装" class="headerlink" title="linux下使用和安装"></a>linux下使用和安装</h2><p>暂未用，后续用到再记录</p><h1 id="Redis的五大数据结构"><a href="#Redis的五大数据结构" class="headerlink" title="Redis的五大数据结构"></a>Redis的五大数据结构</h1><p>redis存储的是key-value键值对，所谓的五大数据结构指的是value的类型，key一般都是string类型，其中key定义的时候不要过长或过短，最好有统一的命名规范。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string类型是以二进制存储的，这意味着redis的string可以包含任意数据，比如图片或序列化对象，一个string类型的值最大能存储512MB。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>set key value</code></li><li><code>get key</code></li><li><code>getrange key start end</code> 返回key中字符串值从start到end的字符</li><li><code>getset key value</code> 将指定key的值设为value，但返回旧值</li><li><code>mget key1 [key2..]</code>获取多个给定key的值</li><li><code>setex key seconds value</code>设置key和value，并将key的过期时间设为seconds</li><li><code>setnx key value</code>只有key不存在时才设值</li><li><code>mset key value [key value..]</code>同时设置多个k-v对</li><li><code>incr key</code>将key中存储的值加1，若value不能转化成整数，则会报错</li><li><code>incrby key increment</code>将key对应的value加increment</li><li><code>decr key</code></li><li><code>decrby key decrement</code></li><li><code>append key value</code> 在key对应的值后拼接字符串key</li></ol><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash特别适合存储对象，每个hash可以存储2^32-1个键值对（42.9亿）</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>hdel key field1 [field2..]</code>删除key中某个字段</li><li><code>hexists key field</code>判断字段是否存在你</li><li><code>hget key field</code></li><li><code>hgetall key</code> 获得key所有字段和值</li><li><code>hincreby key field increment</code></li><li><code>hkeys key</code>获取key中所有字段</li><li><code>hlen key</code>获取key中字段数量</li><li><code>hmget key field1 [field2..]</code></li><li><code>hmset key field1 value1 [field2 value2..]</code></li><li><code>hset key field value</code></li><li><code>hsetnx key field value</code></li><li><code>hvals key</code>获取key所有值</li></ol><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>字符串列表，可以左右添加，用作消息队列等，列表最多存储2^32-1个元素。</p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>lpop key</code>弹出左边第一个元素</li><li><code>lpush key value1 [value2..]</code>在左边依次插入多个值</li><li><code>llen key</code>获取列表长度</li><li><code>lrange key start end</code>获取列表指定范围内的元素，-1表示倒数第一个元素，依次类推</li><li><code>lrem key count value</code>从左往右删除count个value值</li><li><code>lset key index value</code>通过索引设置值</li><li><code>rpop key</code>弹出右边第一个元素</li><li><code>rpoplpush source dest</code>移除source右边第一个元素，加入到dest最左边</li><li><code>rpush key value1 [value2..]</code></li></ol><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>是字符串的无序集合，元素不可重复，是通过哈希表实现的，所以添加删除查找的时间复杂度都是O(1)，最大成员数2^32-1，支持交并差。</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>sadd key mem1 [mem2..]</code></li><li><code>scard key</code> 获取集合的成员数</li><li><code>sdiff key1 [key2]</code>返回key1和key2的差集</li><li><code>sdiffstore dest key1 [key2]</code>返回key1和key2的差集并存入dest中</li><li><code>sinter key1 [key2]</code>交集</li><li><code>sinterstore dest key1 [key2]</code></li><li><code>sunion key1 [key2]</code>并集</li><li><code>sunionstore dest key1 [key2]</code></li><li><code>sismember key member</code>判断member是否在集合key中</li><li><code>smembers key</code>返回key的成员</li><li><code>smove source dest member</code>将member从source移到dest中</li><li><code>spop key</code>移除并返回集合中的一个随机数</li><li><code>srandmember key [count]</code> 随机返回集合中count个元素</li><li><code>srem key member1 [member2]</code> 移除集合中元素</li></ol><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>除了有序外，和set相同，每个元素会关联一个double的分数，通过该分数排序，zset成员是唯一的，但是成员的分数可以相同。</p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>zadd key score1 member1 [score2 member2..]</code></li><li><code>zcard key</code></li><li><code>zcount key min max</code> 计算在有序集合中指定区间分数内的成员数</li><li><code>zincrby key increment member</code> 在有序集合中对指定成员的分数加上增量</li><li><code>zinterstore dest numkeys key [key..]</code>求numkeys个有序集合的交集并存到dest中</li><li><code>zrange key start end [withscores]</code>返回有序集合指定范围内的值（可带分数）</li><li><code>zrevrange key start end [withscores]</code></li><li><code>zremrangebyrank key start end</code>按索引删</li><li><code>zremrangebyscore key start end</code>按分数删</li><li><code>zrank key member</code>返回有序集合中指定成员的索引</li><li><code>zrem key member [member..]</code></li><li><code>zremrangebylex key min max</code>移除有序集合中给定的字典区间的所有成员</li><li><code>zrangebyscore key min max [withscores] [limit]</code>通过分数返回有序集合指定区间内的成员</li></ol><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis的高性能是因为它所有数据都存在内存当中，要保证重启后数据不丢失，就需要数据持久化。有两种方式——RDB和AOF，可以只用一种，也可以两种结合使用。</p><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><p>在指定的时间间隔内将数据集快照写入到磁盘。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>整个redis数据只包含一个文件，备份方便</li><li>对于灾难恢复，比较容易</li><li>性能最大化，分叉出一些子进程，由子进程进行持久化</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li>不能保证有效性，因为是定时写的</li><li>fork子进程太多</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认持久化方法，在redis.conf中，保存文件是dump.rdb</p><h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>将以日志的形式记录redis的每一次操作，当redis重启时会从该日志重现redis的每一次操作，重构redis。</p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ol><li>能带来更高数据安全性，有三种同步：每秒同步、每个修改同步、不同步</li><li>对日志文件写入采用append模式，所以即便写入的时候出错，也不会影响日志，可以通过redis -check -aof来解决数据一致性</li><li>如果日志过大，可以自动重写，在重写切换的时候可以更好地保证安全性</li><li>日志文件格式清晰</li></ol><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ol><li>对于相同数据集而言，aof文件比rdb文件大</li><li>aof执行效率上会低于rdb</li></ol><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>不是默认方式，也在redis.conf中，查找到appendonly no这一行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;p&gt;Redis是一个高性能内存key-value数据库，和其他key-value缓存产品相比有其他特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时可以重新加载使用；&lt;/li&gt;
&lt;li&gt;Redis不仅支持简单的key-value类型的数据，同时还提供list，set，hash，zset等数据结构；&lt;/li&gt;
&lt;li&gt;Redis支持数据备份，即master-slave模式。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《弗雷的小说写作坊-飞起来》笔记</title>
    <link href="http://yoursite.com/2018/10/29/%E3%80%8A%E5%BC%97%E9%9B%B7%E7%9A%84%E5%B0%8F%E8%AF%B4%E5%86%99%E4%BD%9C%E5%9D%8A-%E9%A3%9E%E8%B5%B7%E6%9D%A5%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/29/《弗雷的小说写作坊-飞起来》笔记/</id>
    <published>2018-10-29T14:58:23.000Z</published>
    <updated>2019-09-01T08:15:50.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、唤醒虚构梦境"><a href="#一、唤醒虚构梦境" class="headerlink" title="一、唤醒虚构梦境"></a>一、唤醒虚构梦境</h1><p>1、要展示，不要叙述。小说家试图去“展示”，通过感官细节上的暗示将读者拖入虚幻的梦境。    </p><p>2、同情是一种“认可”。要让观众产生同情，得先让他们对角色产生同情感，这是很关键的一点。<br><a id="more"></a><br>3、同情是深入故事的途径，有了同情，读者就能从内心真正感受到故事的情感，没有产生同情则说明读者在读故事时没有参与到故事的情感中来。获得了读者的同情之后，写作者应该进一步深入虚构梦境的创作，让读者认可你创造的角色。</p><p>4、只有当读者不仅同情角色的困境，还支持他的目标和勇气，并强烈希望这个角色能实现他的目标时，他们才能说这个角色得到了读者的认同。</p><p>5、移情是一种比同情心更强烈的情感。个人感觉移情就是靠细节描写。激发情感的感官细节，能够通过暗示的力量激发读者的情感，抚慰读者的同理心。</p><p>6、身临其境时，读者进入一种梦境，完全进入虚幻的世界里，现实世界消失了。这就是小说家的目标：带领读者沉浸在他们所塑造的角色世界中。</p><p>7、怎样使你的读者从同情、认同、移情到完全沉浸其中呢？答案就是：内心冲突。</p><p>8、内心冲突可以被看做角色心中两种“声音”之间的战争：一个是理智，另一个是情感，或者两种情感之间的冲突。</p><h1 id="二、设置悬念还是循规蹈矩——这是一个问题"><a href="#二、设置悬念还是循规蹈矩——这是一个问题" class="headerlink" title="二、设置悬念还是循规蹈矩——这是一个问题"></a>二、设置悬念还是循规蹈矩——这是一个问题</h1><p>1、“担心和好奇”也就是我们所说的给读者设置悬念。《韦氏词典》是这样定义悬念的：悬念就是一种悬而未决的状态。</p><p>2、故事问题是一种让读者好奇的策略。它们一般不是以问题的形式出现，而是以需深入理解的叙述、亟待解决的问题或是灾难的预测等类似的形式出现。</p><p>3、不管是短篇小说作家还是长篇小说作家，都应该尽早呈现故事问题，通常是在开头的第一句或第二句。p33</p><p>4、因此，一篇很好的小说的开篇，在最开始就要像大师一样，以一个强有力的故事问题姥姥拴住读者，让他们想一直读下去。《韦氏词典》列出了悬念的第二个定义：悬念是一种不确定的状态，就像等待一个决定，通常伴随着焦虑或担忧。</p><p>5、首先，悬念是一种好奇，作者提出让读者好奇的问题。其次，作者将读者置于一种焦虑或担忧的状态，使读者又不单单局限在好奇的层面上。</p><p>6、为了让读者感到焦虑和担忧，作者首先必须创作一个能让人产生共鸣的任务，也就是大多数读者都希望有好结局的人物。</p><p>7、点燃导火索是设置悬念最有力的技巧，它意味着将有可怕的事情发生，并且在一个约定的时间内，故事中的人物必须要阻止，但这并不是一件简单的事情。</p><p>8、其实悬念就是一个提出故事问题、将能产生同情感的人物设置在一个充满威胁的情境中，然后再点燃导火索的过程。</p><h1 id="三、懦夫或疯子：真正令人难忘的人物"><a href="#三、懦夫或疯子：真正令人难忘的人物" class="headerlink" title="三、懦夫或疯子：真正令人难忘的人物"></a>三、懦夫或疯子：真正令人难忘的人物</h1><p>1、以一个懦弱的人物开篇没有错，选主妇或会计作为人物也没有错。问题不在于主角是否懦弱，而在于他或她是否麻木不仁、不会改变。</p><p>2、作者一定要避免自己笔下出现麻木不仁的人物。</p><p>3、人物必须有真实人物的独特性，他们必须跟一般人物形成对比，对比中产生了个性。</p><p>4、创作一个古怪的人物是有趣的。一种方式就是简单地塑造一个特征，然后再把这个特征夸大。另外一种方式就是赋予人物一种颇有偏差的人生哲学观。</p><p>5、人物之间不仅应该形成对比反差，还应该跟各自所在的情节环境有对比。比如乡巴佬进城、社会名流进入监狱。</p><p>6、人物的主导情感是人物的主要驱动力，是人物内心动力和推力的总和。</p><p>7、文学作品中，一些最难忘的人物都具有双重性。事实上，具有双重人格的人物就是一个身体里面有两种截然不同性格的人。</p><p>8、为了让人物值得深入了解，你要创造一个耐人寻味的背景环境，你的人物要特立独行、见解独到。你可以把他们塑造成奇葩怪物，让人物相互之间、人物与背景环境之间形成对比与反差，或者再给他们加上一个双重性格。塑造人物时可以大胆尝试，让读者耳目一新。</p><h1 id="四、预设的再讨论之第一部分：概念的释义与简化"><a href="#四、预设的再讨论之第一部分：概念的释义与简化" class="headerlink" title="四、预设的再讨论之第一部分：概念的释义与简化"></a>四、预设的再讨论之第一部分：概念的释义与简化</h1><p>1、在小说创工作中，再没有比预设更有力的概念了。若你在脑海里以强烈的预设来编织你的故事，那么你的小说将中心突出并富有戏剧性，这样的作品将吸引你的读者从头读到尾。</p><p>2、预设是发生在角色身上事件的叙述，也是故事里核心冲突的结果。</p><p>3、我的故事应该是写人们生活里的某些方面，不是所有方面。</p><p>4、寓意是故事要教给读者的东西。把主题定义为小说里反复出现的想法，是人性中受检验或探讨的某一面。预设就是发生在角色身上事件的叙述，也是故事里动作的结果，它既不是寓意，也不是主题。</p><p>5、小说有三种预设：（1）连锁反应式；（2）反向式；（3）情景式。</p><h1 id="五、预设的再讨论之第二部分：小说家的魔杖"><a href="#五、预设的再讨论之第二部分：小说家的魔杖" class="headerlink" title="五、预设的再讨论之第二部分：小说家的魔杖"></a>五、预设的再讨论之第二部分：小说家的魔杖</h1><p>1、如果没有讽刺与意外的事件发生，角色们自身也没有得到成长，那么显然这个故事不值得一写。</p><p>2、问自己几个相关问题：故事的预设被证明了吗？是否有多余的情节？是否有讽刺或意外的事情？故事角色是否有成长或升华？这个故事值得一写吗？</p><p>3、多预设小说。每个故事都有一个预设，一本小说可以有一个以上的故事，因此也可以有一个以上的预设。</p><p>4、先看几部电影，从预设的角度描述影片内容；接下来看看在不同预设的指引下故事会发生怎样的变化；下一步便是在预设的指导下开始创作。</p><h1 id="六、语气或“谁”，谁在讲故事"><a href="#六、语气或“谁”，谁在讲故事" class="headerlink" title="六、语气或“谁”，谁在讲故事"></a>六、语气或“谁”，谁在讲故事</h1><p>1、强有力的叙述语气给读者一种感觉，即作者对他的叙述了如指掌。在非虚构作品中，强有力的叙述语气通过对语气和事实的支配来实现；而在小说中，则是由对语气和细节的支配来达成的。</p><p>2、作者（叙事者）不应该隐身。</p><p>3、所谓的第一人称比第三人称更亲切、更富色彩的定律毫无根据。事实上，不管是用第一人称还是第三人称，都能实现小说的价值观、表现亲密度、渲染气氛、烘托色彩。</p><h1 id="七、作者与读者合同的订立：不要承诺樱草却交付泡菜"><a href="#七、作者与读者合同的订立：不要承诺樱草却交付泡菜" class="headerlink" title="七、作者与读者合同的订立：不要承诺樱草却交付泡菜"></a>七、作者与读者合同的订立：不要承诺樱草却交付泡菜</h1><p>1、除了小说内容精彩之外，你的读者期待的还是一部常规小说——类型小说、主流小说、纯文学小说。</p><p>2、读者一开始就会对你的预设进行揣测，如果你要履行你在合同中的义务，预设的证实便必不可少。</p><p>3、按照与读者拟定合同的要求，你必须公平公正地向读者履行在合同中的义务。这就是说，如果你写的是一本推理小说，你就要向读者提供一个智胜侦探的公平机会；换言之，你要向读者提供所有的事实、线索等信息。</p><p>4、要不遗余力地避免作者帮助故事中的人物解决难题。你要必须发誓要将老生常谈统统抛弃、要对欠佳的情节退避三舍。</p><h1 id="八、七个致命的错误"><a href="#八、七个致命的错误" class="headerlink" title="八、七个致命的错误"></a>八、七个致命的错误</h1><p>1、第一个错误——胆小。要成为一名作家需要勇气和胆量。你得战胜你的胆小和怯懦，勇敢面对这个坚强的作家团队的批评。其中的一个办法就是忍耐，还可以学会自我朝服，另一个途径就是绝不能让大家讨论你为何要这样创作，不要对自己的作品做任何辩解。</p><p>2、创作中的另一种胆小就是不愿意冒险。不要害怕尝试实现你的效果。</p><p>3、一个作家必须要自我推销，否则他注定是一个无名小卒。</p><p>4、第二个错误——试图成为一个“文人”。这些人的问题在于：他们不是尝试着去掌握创意写作的基本原则，也不是去学习如何让自己的文学作品独具匠心、引人注目，而是把某一个文学巨人当成神。</p><p>5、第三个错误——自我写作。要以读者为中心，而不是以自我为中心，要吸引读者、循循善诱、将读者带进故事中来、通过创造情感试金石来构建读者和故事之间的桥梁、让读者认可故事人物。要让你的读者身心愉悦，而不是自我满足。</p><p>6、客观关联物指的是读者有必要了解和经历故事中引起他们情感共鸣的行为。</p><p>7、第四个错误——不会重构故事。尽管改写故事情节是一项很难掌握的技能，但如果你学不会，就将成为你创作时致命的错误。</p><p>8、第五个错误——不能坚持信念。一旦信念破灭了，作家就不可能再回到以前写作时的状态。</p><p>9、第六个错误——不当的生活方式。p191</p><p>10、第七个错误——没法创作。灵感枯竭的作家还有另一个名字——胆小鬼，他害怕的是作品没能符合自己的标准，然而又有谁的作品符合过呢？p197</p><h1 id="九、激情写作"><a href="#九、激情写作" class="headerlink" title="九、激情写作"></a>九、激情写作</h1><p>1、这是小说家的黄金时代。</p><p>2、除了写作，没有更好的方法可供你在地球上消磨时光了。</p><p>3、你必须仔细审视你的内心，并找到生活中你最在意的事物，这样你才能实现你真正的愿景。</p><p>4、写一份写作目的宣言书很有必要，例如，如果你将作家当做你一生的职业，你想要获得怎样的成就；就你所写的某本书而言，你想借此得到什么。等等。</p><p>5、写作是一个分享经历、传达人生信条的过程，没有所谓的“纯属娱乐”一说。你写作的内容无论是在情感层面还是精神层面上都应有极大的影响力，如果你发挥得好，这种影响力会深入骨髓。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、唤醒虚构梦境&quot;&gt;&lt;a href=&quot;#一、唤醒虚构梦境&quot; class=&quot;headerlink&quot; title=&quot;一、唤醒虚构梦境&quot;&gt;&lt;/a&gt;一、唤醒虚构梦境&lt;/h1&gt;&lt;p&gt;1、要展示，不要叙述。小说家试图去“展示”，通过感官细节上的暗示将读者拖入虚幻的梦境。    &lt;/p&gt;
&lt;p&gt;2、同情是一种“认可”。要让观众产生同情，得先让他们对角色产生同情感，这是很关键的一点。&lt;br&gt;
    
    </summary>
    
      <category term="大杂烩" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="小说教程" scheme="http://yoursite.com/tags/%E5%B0%8F%E8%AF%B4%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《C++并发编程实战》笔记</title>
    <link href="http://yoursite.com/2018/10/25/%E3%80%8AC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/25/《C-并发编程实战》笔记/</id>
    <published>2018-10-25T14:36:33.000Z</published>
    <updated>2019-07-28T15:11:43.833Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action" target="_blank" rel="noopener">书籍中文版翻译地址</a></p><p><a href="https://github.com/bsmr-c-cpp/Cpp-Concurrency-in-Action" target="_blank" rel="noopener">书中源码地址</a></p><h1 id="一、你好，C-的并发世界！"><a href="#一、你好，C-的并发世界！" class="headerlink" title="一、你好，C++的并发世界！"></a>一、你好，C++的并发世界！</h1><p>1、最简单和最基本的并发，是指两个或更多个独立的活动同时发生。</p><p>2、为性能而使用并发就像其他所有优化策略一样：它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。<br><a id="more"></a><br>3、C++多线程历史：C++98标准不承认线程的存在，并且各种语言要素的操作效果都已顺序抽象机的形式编写。不仅如此，内存模型也没有正式定义，所以没办法在缺少编译器相关扩展的情况下编写多线程应用程序。但C++11新标准改变了这一切，主要模型是Boost中的线程库。</p><p>4、管理线程的函数和类在头文件<thread>中，而保护共享数据的函数和类在其他头文件中声明。简单例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;//添加头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span><span class="comment">//每个线程都必须有一个初始函数，新线程的执行将从这里开始，对于主线程来说是main()。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;<span class="comment">//将hello函数作为新线程的初始函数，</span></span><br><span class="line">t.join();<span class="comment">//使调用线程等待t相关联的线程运行结束，少了这一行会报错，因为main可能就会在新线程运行之前结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></thread></p><h1 id="二、线程管理"><a href="#二、线程管理" class="headerlink" title="二、线程管理"></a>二、线程管理</h1><p>1、使用C++线程库启动线程，可以归结为构造thread对象。</p><p>2、构造对象时要避免“最令人头痛的语法解析”问题，如：<br>std::thread    my_thread(background_task());<br>这里相当与声明了一个名为my_thread的函数，这个函数带有一个参数(函数指针指向没有参 数并返回background_task对象的函数)，返回一个std::thread对象的函数，而非启动了一个线程。<br>可使用如下写法避免：<br>std::thread    my_thread((background_task()));        //    1<br>std::thread    my_thread{background_task()};        //    2<br>或用lambda表达式：<br>std::thread    my_thread([]{<br>​        do_something();<br>​        do_something_else(); })</p><p>3、启动了线程，你需要明确是要等待线程结束(加入式)，还是让其自主运行(分离式)。</p><p>4、使用一个能访问局部变量的函数去创建线程是一个糟糕的主意(除非十分确定线程会在函数完成前结束)。</p><p>5、通常称分离线程为守护线程(daemon    threads),UNIX中守护线程是指，没有任何用户接口，并且在后台运行的线程。</p><p>6、向线程函数函数传递参数。P29</p><p>7、需要在线程对象被析构前，显式地等待线程完成，或者分离它；进行复制时也需要满足这些条件(说明：不能通过赋一个新值给std::thread对象的方式来”丢弃”一个线程)。</p><p>8、    std::thread::hardware_concurrency()在新版C++标准库中是一个很有用的函数。这个函数将返回能同时并发在一个程序中的线程数。</p><p>9、线程标识类型是std::thread::id，可以通过两种方式进行检索。第一种，可以通过调 用std::thread    对象的成员函数get_id()来直接获取。如果std::thread对象没有与任何执行线程相关联，get_id()将返回std::thread::type默认构造值，这个值表示“没有线程”。第二种，当前线程中调用std::this_thread::get_id()(这个函数定义在<thread>头文件中)也可以获得线程标识。</thread></p><h1 id="三、线程间共享数据"><a href="#三、线程间共享数据" class="headerlink" title="三、线程间共享数据"></a>三、线程间共享数据</h1><p>1、不变量通常会在一次更新中被破坏，特别是比较复杂的数据结构，或者一次更新就要改动很大的数据结构。</p><p>2、C++中通过实例化std::mutex    创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。C++标准库为互斥量提供了一个RAII语法的模板类std::lack_guard，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。</p><p>3、具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书籍中文版翻译地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bsmr-c-cpp/Cpp-Concurrency-in-Action&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书中源码地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、你好，C-的并发世界！&quot;&gt;&lt;a href=&quot;#一、你好，C-的并发世界！&quot; class=&quot;headerlink&quot; title=&quot;一、你好，C++的并发世界！&quot;&gt;&lt;/a&gt;一、你好，C++的并发世界！&lt;/h1&gt;&lt;p&gt;1、最简单和最基本的并发，是指两个或更多个独立的活动同时发生。&lt;/p&gt;
&lt;p&gt;2、为性能而使用并发就像其他所有优化策略一样：它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。&lt;br&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《弗雷的小说写作坊-秘境游走》笔记</title>
    <link href="http://yoursite.com/2018/10/10/%E3%80%8A%E5%BC%97%E9%9B%B7%E7%9A%84%E5%B0%8F%E8%AF%B4%E5%86%99%E4%BD%9C%E5%9D%8A-%E7%A7%98%E5%A2%83%E6%B8%B8%E8%B5%B0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/10/《弗雷的小说写作坊-秘境游走》笔记/</id>
    <published>2018-10-09T16:03:43.000Z</published>
    <updated>2019-09-01T08:16:11.996Z</updated>
    
    <content type="html"><![CDATA[<p>一部戏剧性小说具有如下特点：它以一个中心人物即主人公为焦点，该主人公面临困境；这个困境发展成一种危机；这种危机通过一系列纠纷构建成小说的故事高潮；在高潮部分危机化解。p13<br><a id="more"></a></p><h1 id="一、所有的秘密就在于“人物”"><a href="#一、所有的秘密就在于“人物”" class="headerlink" title="一、所有的秘密就在于“人物”"></a>一、所有的秘密就在于“人物”</h1><p>1、如果你不能塑造出在读者心目中活灵活现的人物形象，那你就不可能创作出令人拍案叫绝的劲爆小说。小说中的人物形象无论如何不能等同于现实中有血有肉的活人本身，要更加不同寻常，但要依然可以认识、理解。p3<br>小说人物是对现实人物的抽象描写，他展现现实生活中原型的本质，但并不是原型的全部。</p><p>2、小说人物有两种类型：扁平人物和圆形人物。<br>圆形人物三位一体：生理维度、社会学维度以及心理维度。</p><p>3、对大多数作者来说，包括所有的写作初学者，为角色写传记是小说创作中最必要也最重要的一步。</p><p>4、两个主要因素决定你在小说创作中对人物特征的取舍：打破原型、精心编排。</p><p>5、为角色写传记的时候，应寻找能影响故事中角色的情感和行为的因素。</p><p>6、塑造一个鲜活、不刻板的人物形象，其秘诀在于将人物身上那些读者没能预料到在同一个角色里会见到的特质糅合起来。</p><p>7、无论何时，你的主人公都面临这些要紧的决定。再问问自己关于能力极限的两个问题：第一，他真的会这么干吗？第二，他还能做其他更加巧妙、更戏剧化、更令人惊奇或者更有趣的事情吗？</p><h1 id="二、杰作生成三大妙法：冲突、冲突、冲突。"><a href="#二、杰作生成三大妙法：冲突、冲突、冲突。" class="headerlink" title="二、杰作生成三大妙法：冲突、冲突、冲突。"></a>二、杰作生成三大妙法：冲突、冲突、冲突。</h1><p>1、如果没有了由矛盾冲突所产生的紧张和刺激，即使世界上最精心设计的情节也是不起作用的。</p><p>2、主要人物+目标+对抗性因素=冲突。</p><p>3、让你的人物处于熔炉之内。熔炉是一个能够将人物聚集在一起像物品一样加热的容器。</p><p>4、内心冲突。假设你的主人公被召唤上战场，首先要确定他有强而有力的理由让他极不情愿参战。</p><p>5、戏剧冲突的模式：静止型、跳跃型和渐进型。P57<br>静止型冲突是指任何一种不发生变化的戏剧冲突。<br>跳跃型冲突时指在没有充足动因或过渡阶段的情况下，从一个紧张强度跃进到另外一个。<br>在顶级的戏剧性小说里，冲突是循序渐进的，渐进型冲突的秘密是从进攻和反击的角度来思考冲突。</p><p>6、如何确保拥有渐进型冲突？<br>第一、经常在脑海里用渐进型冲突构思小说。<br>第二、只有当人物发展变化时，冲突才可以升级；当冲突升级时，人物随之变化发展。<br>第三、为了确保你能有一个逐渐升级的冲突，在场景开始和结束的时候你都应该关注人物的情绪波动状况。人物在每个场景中都应该有循序渐进的变化。</p><p>7、核心矛盾：人类反抗自然、人类反抗人类、人类反抗社会、人类反抗自己、人类反抗命运。</p><p>8、类型，文学的分隔板。要深入了解那些传统、惯例和不同流派的类型。一旦熟知那些类型，就会知道在这些类型中的前提假设是什么。如果你把矛盾冲突看成小说写作的火药，那前提就是加农炮。</p><h1 id="三、前提很重要，小说没有前提就如同无桨划船"><a href="#三、前提很重要，小说没有前提就如同无桨划船" class="headerlink" title="三、前提很重要，小说没有前提就如同无桨划船"></a>三、前提很重要，小说没有前提就如同无桨划船</h1><p>1、在一本小说中，写作前提只有在小说的特殊场景中才能够成为真实。</p><p>2、故事的前提是故事角色在核心矛盾发展下各自的最终命运的简单表现。</p><p>3、寻找自己小说的前提，但不要从一个前提展开故事，而是用人物。</p><p>4、一个好的前提应该包含一个可以通过矛盾冲突带出结论的人物。要记得三C理论：人物(Character)、冲突(conflict)以及结论(conclusion)。</p><p>5、选择性是作家作品的关键部分，选择性即在一部小说中选择囊括什么、忽略什么。</p><p>6、如果没有与整体故事发生如果、而且、但是之类的关系，只能删去。</p><p>7、人物角色、冲突还有前提是砖块和水泥，它们构建了故事。</p><h1 id="四、讲故事的顺序"><a href="#四、讲故事的顺序" class="headerlink" title="四、讲故事的顺序"></a>四、讲故事的顺序</h1><p>1、所有的故事都是事件的叙述，但却不止如此。</p><p>2、故事是对一系列有因果关系的事件的叙述，这些事件涉及有价值的、随着时间变化而变化的人物。</p><p>3、在一个戏剧性故事里，人物斗争是唯一值得一读的东西。人物因为遭受磨难而发生了改变，这样的事件的叙述才可以称其为一个故事，但还不能算是一个戏剧性故事。戏剧中，人物必须要抗争。</p><p>4、小说中的人物面临的困境叫做“故事悬念”，故事悬念使读者愿意继续读下去寻找答案，它是你上大餐前的开胃菜。</p><p>5、现状向读者展示了在核心冲突发生前小说的世界，它是上主菜前的汤和沙拉。</p><p>6、可以从故事开始前开篇，也有在另一种选择。p102但最好在故事开始前开篇，读者就会了解人物并同情他。你可以将标志着故事开始且发生于现状中的改变戏剧化。</p><p>7、阶段表是一个记载故事巧合的详细的计划表。使用阶段表是作者掌控故事的一个方法，可以将之看做一个蓝图。</p><p>8、故事的事件、冲突能影响读者，因此人物应对冲突时，会随着故事的推进而改变。</p><h1 id="五、冲突上升或证据存在于前提中"><a href="#五、冲突上升或证据存在于前提中" class="headerlink" title="五、冲突上升或证据存在于前提中"></a>五、冲突上升或证据存在于前提中</h1><p>1、将故事的高潮看做目标，其他的故事情节看作飞行的射线。</p><p>2、故事就是斗争。主人公遇到困境、受到攻击时，你的小说就开始了。人物与困境斗争，困境变成危机；危机发展到一定程度，急需解决；采取行动后，带来了高潮。结果要么令人满意，要么令人不满，但是危机结束了。无论如何，整个现状发生了改变，不管事态发展如何，进化都是必然。</p><p>3、尽管在高潮时刻核心冲突得到解决，但这并没有验证前提。前提是由结合成一个整体的冲突和化解证明的。</p><p>4、每一个故事的主要人物都有自己的命运。因此，每个角色都有各自的前提。</p><p>5、如何构成一个伟大的高潮？第一，寻找惊喜；第二，激发强烈的情感；第三，在诗意的正义法院宣布判决；第四，发掘人物新的一面；第五，高潮——解决应使小说完整。</p><h1 id="六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意"><a href="#六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意" class="headerlink" title="六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意"></a>六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意</h1><p>1、人物视角是该任务所有意见的集合，包括偏见、喜好、态度。他的视角决定了他怎样解读世界。</p><p>2、视角分类：客观视角、修正的客观视角、第一人称主观视角、全知视角、有限的全知视角。</p><p>3、叙述者独特的说话方式叫做叙述声音。</p><p>4、小说家是一个魔术师，向读者编织一个咒语。为了催动周瑜，小说家用了一个叫做“认同”的魔术。</p><p>5、一旦一种情感在故事的开头被激起，人物应该立即被置于不断发展的危机中。如果你已经感动了读者，他们就会感兴趣，但是，真正的认同只能发生在人物面临选择时，读者也能参与到决策过程中。</p><p>6、倒叙是经常被错用和滥用的小说技巧。读者觉得大部分倒叙都难以忍受，但还有许多新手像疯了一样倒叙。倒叙可能只是愚蠢的作者想要避免冲突的手段。</p><p>7、什么时候倒叙是绝对必需的呢？如果你的人物被置于一个境遇中，他的行为与他在故事发生的这个时刻之前的行为完全相反，那么它是必要的。在你使用倒叙之前，问问自己在当下的小说中采用冲突是否能达到同样的效果。</p><p>8、伏笔并不是冲突，而是冲突的迹象。伏笔是提出故事悬念的艺术。伏笔是一个预示，如果作出了预示而没有实现它的话，你就是在欺骗读者。</p><p>9、如果有无聊又冗长的叙述，在其中加伏笔。</p><p>10、象征符号是除了事物本身的意义外对一些人有其他意义的事物。</p><p>11、如果一位人物有任务和目标，它应该符号化。</p><h1 id="七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧"><a href="#七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧" class="headerlink" title="七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧"></a>七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧</h1><p>1、直白对话表达的恰好是人物所想，不用费力去描述人物如何表示反对、使用诡计、说谎、表现机智等。成功的对话含蓄地表达人物的意志。</p><p>2、戏剧性小说有三种模式：戏剧化叙事模式、场景叙事模式、半场景叙事模式。在戏剧化叙事模式中，叙事者叙述相关情节，展现角色成长经历，运用内部矛盾，但这些都是以一种总结性方式来叙述的；场景叙事模式是，在某一个场景中，叙述者描述所发生的情节；半场景叙事模式是一种被打断的戏剧性叙事，里面糅合着部分场景。</p><p>3、戏剧性创作需要不断激化的矛盾，这种矛盾不仅对整个戏剧性故事来说有必要，而且对戏剧性场景也有必要。</p><p>4、很多情况下全场景并不可取，，因为在场景开头时矛盾的力道通常不足以吸引读者。而跳入其他场景可以加速小说剧情发展，使你的读者参与矛盾激化的过程。写小说时，你要考虑每一个场景，问问自己哪些场景可以剪掉，以便加快小说节奏。</p><p>5、好的对话应该是置于矛盾中的、间接的、机智的、丰富多彩的。p172~p176的例子。</p><p>6、对每行对话思考以下几个问题：是不是有冲突？是不是太陈腐？委婉地说会不会更好？台词是否已经尽量做到巧妙、生动了？</p><p>7、动态散文体小说有三条戒律：具体、有感染力、富有诗意。具体：概括性的话要变具体，加入细节。有感染力：带起多种感官上的感受：视觉、嗅觉、味觉、触觉以及听觉甚至心理上的感觉。富有诗意：富有诗意但又不要太诗意，诗意意味着用修辞来实现不错的效果。</p><p>8、练习比喻，每次叙述时，都要试着尽可能多地运用恰当的修辞。</p><p>9、总的来说，散文体小说应该有时间跨度，色彩斑斓，结构缜密（具体而明确，不是泛泛之谈）；能够传递一种动作感；能够调动七种感官——听觉、视觉、触觉、味觉、嗅觉、心灵感和幽默感。</p><h1 id="八、修改：最后的煎熬"><a href="#八、修改：最后的煎熬" class="headerlink" title="八、修改：最后的煎熬"></a>八、修改：最后的煎熬</h1><p>1、几乎每个人都能写东西，但是只有作家知道如何修改，只有这种能力才能使业余作家提升为专业作家。</p><p>2、让作家评估自己所写的内容是极其困难的，除非他们知道初稿的亮点和缺陷，否则不可能将初稿变为成品。</p><p>3、解决问题的一个方法是找得到一个作家群，征询他们的意见。有三种作家群：吹捧派、文学派和抨击派。抨击派是唯一一个有价值的群体。</p><p>4、没有抨击性作家群的话，自己做自己的评论家，并寻求朋友的帮忙，可以不告诉他们是你写的，让他们没有道德负担，让他们说清楚每一个不好的地方，确切说出他们不喜欢的点——角色、环境、节奏等等。</p><p>5、为评论者们提供一张评论要素清单，让他们列举你故事中的哪些要素得到了“最专业的处理”。也可以将小说中的每一个场景按等级排列在一条兴趣曲线上，让他们给每一个场景打分，分值从1到10。</p><p>6、可以请读者们看完后给你复述这个故事，他们遗漏的部分可能就是无聊得犯困的部分。</p><p>7、可以将你的小说录到录音机里，然后播放它。或者试着将小说从头到尾讲给朋友听，你略去的和那些讲述起来笨嘴拙舌的地方能帮你定位缺陷之处。如果把草稿搁置一段时间再分析的话，你会更容易、更客观地进行分析。</p><p>8、问自己几个问题：1、你是否已经证明了自己的前提？2、是否已经使读者对人物产生共鸣？3、有没有反面人物，他们都表现得淋漓尽致吗？等等p199</p><h1 id="九、小说写作之道"><a href="#九、小说写作之道" class="headerlink" title="九、小说写作之道"></a>九、小说写作之道</h1><p>1、什么最重要？并不是天赋。是自我训练、顽强的决心、坚韧不拔的毅力。天赋只会带来阻碍，因为如果拥有天赋，你就会认为写小说很容易。</p><p>2、完成一篇小说的秘诀是规律性。每天都要坚持在同一时间写作。你必须对在那个时间段的所有其他事情、所有干扰你创作的事情说“不”。</p><p>3、灵感丧失时，你的行为将你与那些声称“我将要写一本书”的人区分开来。</p><p>4、如果你真的思路受阻，最重要的是记住，作家都会经历瓶颈期，这没什么好担心的。你要做的就是让这些刺激因素消失。你可以重新打出自己已经写好的内容，从而起到热身的作用。也可以放热门音乐。不管做什么，只要别推迟写作就行。继续敲打键盘，即使写出的是官样文章也行。只要坚持写，你就会度过写作的瓶颈期。如果离开打字机，你永远也无法走出瓶颈，并且在下一次瓶颈到来的时候更容易重蹈覆辙。</p><p>5、不要讲其他影响创作的情绪与作家的瓶颈期混淆。真正的作家瓶颈期有四个基本原因：对你的人物不够了解，试图将编辑和写作同时进行，害怕失败，害怕成功。解决办法见p214</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一部戏剧性小说具有如下特点：它以一个中心人物即主人公为焦点，该主人公面临困境；这个困境发展成一种危机；这种危机通过一系列纠纷构建成小说的故事高潮；在高潮部分危机化解。p13&lt;br&gt;
    
    </summary>
    
      <category term="大杂烩" scheme="http://yoursite.com/categories/%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    
    
      <category term="小说教程" scheme="http://yoursite.com/tags/%E5%B0%8F%E8%AF%B4%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>未完待续-贰</title>
    <link href="http://yoursite.com/2018/05/31/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E8%B4%B0/"/>
    <id>http://yoursite.com/2018/05/31/未完待续-贰/</id>
    <published>2018-05-31T09:36:46.000Z</published>
    <updated>2019-07-28T15:15:08.614Z</updated>
    
    <content type="html"><![CDATA[<p>（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2017年1月21日，2018年5月31日上传保存。）</p><p>有的时候是看见一句话。<br>有的时候是听见一首歌。<br>有的时候是站在老地方。<br>有的时候是见到老朋友。<br>有的时候是静在沉默里。<br>但更多的时候是在呼吸里。<br>想你。<br>想我是怎么渐渐失去了你。<br>我的匆匆时光。<br><a id="more"></a></p><p>是2013年吧，我结束高考，怀揣着一份不满意的成绩，来到我满意的城市，上了一所不甚满意的大学。依稀还记得军训时我曾独自坐在宿舍靠窗的位置，透过窗外那颗不知年岁几何的枇杷树树隙，看蓝天被枝条切割成零碎不一的图案，偶尔被阳光刺到，就像是斑驳的万花筒晃了我的眼。<br>江南曾在《此间的少年》里写他当年北大宿舍窗外是一棵梧桐树，静若仙女的王语嫣某个清晨从树下走过，就轻轻带走了碰巧趴在窗前的段誉的心。我的学校比北大差远，枇杷树也不如梧桐树有意境，男生宿舍区里的枇杷树下更不会有女生走过，但也曾无数次听到这棵枇杷树在雨夜里的交响曲，也曾见过枇杷成熟的季节里男生们偷着竹竿背着宿管大妈打落果实，短裤背心，摸滚打爬。<br>就这么一晃眼，2017便已到了，他笑眯眯地说着：“你终于来了”，似乎等了我们很久，却又偷偷摸摸地把沉重压上我们的肩头。<br>嘿，又要毕业了。<br>谁能想到这么快呢？</p><p>2015年8月的时候，我写了《未完待续1》，到如今已经一年半的时间，大学本科还剩下最后半年的时间。在这个春节之前我犹豫了很久，最终决定还是写下《未完待续2》，大概没有《未完待续3》了吧，也可能会有，也可能换一种形式……比如《梧桐树下的少年》这种形式（微笑）？<br>兴许是人老了记忆衰退，也或者是大三之后事情变多，很少有之前所写的大块事件，记忆里的事情大多琐碎，就像那年夏天我透过那棵枇杷树看到的蓝天。<br>记不起事情的时候我就会默默翻开自己的说说，沿着时间顺序阅读下去，有些说说早已忘了为何而发，那应该是些惹人冲动的事，时间已经抚平就无须再刨根问底，依然记得的那些才是重要的。</p><p>2015年八月，时间在刚发完《未完待续1》后不久，我受ZC等人挑唆曾入过《天涯明月刀》的坑，着着实实地玩了一月有余。<br>天涯、明月、树影、孤鸟的加载界面出现的时候，我心中似乎有根弦绷紧，仿佛一扇大门打开，刀光剑影、快意恩仇的世界展现，带着丝丝凛意。<br>如今游戏早已弃坑，但那时我选择了唐门，角色名为牧南山，紫袍荡荡，折扇翩翩。<br>是的，他是《南山北海》的主角原型，是我笔下第一个武侠人物。我倾注了不少心血，最终把他写成那个天下第一、唐门无双、为亡妻与天下敌的绝世高手！虽然在游戏里他被一个叫“心有林西”的神威用一杆枪戳得不要不要的……好吧我打不过你我还写不过你？<br>没有玩游戏的天赋，真是不能不认。<br>顺带提一句，我女朋友也被我拉进了坑……<br>对，你们猜的没错，她游戏的ID就是北海，北海谷。<br>南山有墓，北海有谷。<br>如果还有下一篇武侠，可能就在北海。</p><p>我本想把大学的事情都留到一本可能名为《梧桐树下的少年》这样中二名字的书中去，可是当时间来到2015年九月后，即大三上半学期时，有些事却还是想稍微提一提。<br>这一学期，我接替学长的位置，荣幸担任院科协某部部长一职。<br>我曾经仔细想过，为什么生性内向腼腆的我会毫不犹豫接受任职？<br>可能是为了锻炼自己，可能是为了那几点加分，自然也可能是为了年轻可人的学妹们啊！<br>不过现在，我感觉应该找到了答案。<br>很简单，只是为了不后悔吧。<br>迎新那天，面对满满一屋子学弟学妹，上台介绍的时候，我的双腿还在微微打颤，语言也不慎利索，自己都觉得已经搞砸了。可是最后的结果还不错，竟然成功地骗到，哦不，招到十几位新学员，最关键的是……学妹整整一半多哩！<br>也是那时，我才真正走进科协这个大家庭，认识了一群新的伙伴：一起打撸的SSM、一起聊天说地的WTT、一起闹腾的ZY学妹……<br>有人的地方就有江湖，科协不过二三十平米，大家低头不见抬头见，自然便是江湖。江湖里可说的东西太多，三天三夜也讲不完，我会尽量把它写入《梧桐树下的少年》里，如果真的会有这本书的话……<br>若有一天我真的写那样一本书，真的又能写到结尾，那说不定会有这么一个段落：<br>我毕业一年后的某天，科协里已经空荡荡了，突然有人挤开钥匙走进来，是ZY，那天是她毕业的日子，她来科协收拾东西。她可能会在开门之后站在门口默默朝里注视一会儿，然后才打开灯走进来。<br>她座位正上方的那盏灯可能到那时也没有人修，显得她的位置稍暗一些，整个人的表情都看不清。<br>她坐在座位上，撕去桌上贴着的名牌，揉成一团，却又慢慢展开摊在桌前。<br>她沉默地收拾东西，轻轻地放进包里。<br>收拾完了桌上东西，她可能会发现被压在桌下已久的、老旧的纸张。<br>那是往届的名牌。<br>可能是SSM的，可能是WTT的，可能是我的……<br>…………<br>哈哈，熟悉的人一定会大喊：“你扯淡吧就！ZY是那样安静文艺的人吗？！”<br>哈哈，说的也是，如果真是ZY，恐怕最可能的情形就是……<br>“嘭！”科协的门被摔开。<br>“啪！”灯被拍开。<br>“咚咚咚！”东西被灌进书里。<br>“唰唰唰！”名牌、废纸连通着垃圾被甩进垃圾桶。<br>“哗！”拉链拉上。<br>灯灭。<br>门阖。<br>ZY就是这么雷厉风行的妹子。<br>但即便是她，我相信也会在某个的时刻想起那间屋子里的欢声笑语、淙淙流年。<br>然后，可能，我是说可能。<br>她会站在门外，轻轻松开关门的手，透过窗户深深往里看一眼，缓缓握紧那把钥匙。</p><p>大三上半学期还有些事，比如宿舍二公子终于脱单，对象是大一的某学妹……<br>不管怎么说，宿舍终于不是我单独面对五只单身汪的局面了。<br>事到如今不得不简单提一提宿舍六位公子了。<br>宿舍一公子的常态就是盘膝坐在上铺，床帘围得严严实实，玩手机。如果是冬天他还会戴上羽绒服的帽子，然后盘膝坐在上铺，床帘围得严严实实，玩手机……<br>宿舍二公子，和一公子并称宿舍两睡神，大多时稍逊一公子一筹，巅峰时堪称一时瑜亮！二公子社交能力极强，巧言善辩，学生会副主席，他说他梦想做《此间的少年》里的杨康，我却总觉得他是欧阳克……<br>宿舍三公子，清秀小白脸，大学两件事，睡觉配游戏，是那种传说中的“高玩”，巅峰时期《梦幻西游》五开，卖出去不少钱，也带我入过不少坑，《天龙八部》、《武魂》、《剑灵》、《天谕》……当然不能少了LOL。除了LOL，其他游戏没在我这活过一个月。现在和二公子迷上狼人杀，都是狼王级别。<br>宿舍四公子，本宿舍学霸，保研狗一枚，大三时任学生会学习部部长，大一时就跟我念叨妹子，到现在还是跟我念叨妹子，有贼心没贼胆的典型代表，长年占据宿舍找资源的第一把交椅。<br>宿舍五公子，文艺暖男，周董资深粉丝，什么雨中送伞没钱刷卡找他准没错，大二时恋上学妹一枚，不果遂黯然神伤，口号是“忧伤是一种态度”。<br>宿舍六公子，不多说了，神仙下凡。<br>二公子谈恋爱是用了心的，每晚都很晚回来，然后朋友圈就会在每晚的固定一段时间多一条动态，有时候是学校的夜景，有时候是稍远一些地方的夜景图，佳人依袖，灯火几重，美不胜言<br>…………<br>后来有个深夜，二公子重重捶床，久久不寐。那晚一公子前往南航赴约，缺席一出。<br>“出去喝酒吧。”黑暗中他轻轻说。<br>凌晨一点的光景，五条汉子从被窝里钻出来，撑开伞，走在只剩路灯的校园里，安静得只剩小雨淅淅沥沥的声音。<br>夜太深了，烧烤店都灭火打烊了，辗转几圈只有饺子店还开着门。<br>饺子店里还有不少聚餐的学生，人声鼎沸。<br>“吃什么饺子？”服务员问道。<br>“酒，来酒。”二公子说着，便上了楼。<br>有饺子，有肘子，当然还有酒。<br>大家聊着，依旧没心没肺的，有些事却避而不谈。<br>渐渐二公子的神情松弛了些，脸上却已微红。<br>不说二公子，便嘲讽五公子，嘲讽他追学妹一年无果，那曾是宿舍的乐事，五公子也不生气。<br>“舍长，XXX最近咋样了？”三公子问。<br>忘了说，五公子是我们的舍长。<br>五公子喝了口酒，也不避讳，直接道：“和YYY在一起了好像。”<br>“那是谁？”<br>“球队的。”五公子说着，又喝了口酒，“快当队长了。”<br>“哦……”我们不问了。<br>我们还能问什么呢？<br>五公子也是球队的，是这一届的队长。<br>五公子把部门留给了那位学弟，把球队留给了他，现在好像连学妹也留给了他。<br>聊到三点多终于决定回去，多年后我可能还记得那个夜晚，他们四个走在前面的路灯下，我眯眼看他们的背影，觉得路灯下的影子格外得长。<br>我总怀疑二公子会突然冲到马路中央冲着空旷无人的马路大吼，但他没有，反而走得比我们都稳，好像要证明什么。<br>可是经过学妹宿舍的时候，他没有忍住。<br>他猛地冲了过去，很快就融入了黑暗里看不见了。<br>我们四个静静站在一边，等着他吼，或者不吼。<br>他没有吼。<br>过了会儿他的身影重新从黑暗里靠近，眼神疲倦。<br>“困了，回去睡觉。”他说。<br>从我身边经过时我感觉到他外套上褪不去的寒意。<br>我不知道那时他在黑暗里看了些什么，又想了些什么。<br>我到现在也不知道。</p><p>大三到这告一段落吧，不然就收不住了，还是那句话，如果有《梧桐树下的少年》的话，我会尽量写进去，我们宿舍其实每个都是大好青年啊！<br>时间来到大三下，也就是2016年的上班年，也面试过几次实习不过好像都没过，对于一个内向不善交际的人来说，只能把每次面试都当做锻炼，吸取教训再逆流而上。<br>也是在2016的上半年，我完结了在创世连载的小说，共计209W字，耗时两年多，算是给了自己一个交代。<br>关于这本小说，实在没什么好说的，扑街是自然的，靠着拿全勤赚的几千块钱也早花光。<br>借着新年的机会，感谢感谢那些一直支持我到这本小说完结的人，没有你们，实在写不下去。<br>也是从这本小说完结时开始，我决定不写网文了，一来是硬性要求比较累，二来则是我觉得那不是我真正想要的，三则是觉得自己似乎不适合，我挺喜欢宁忘川、叶芷柔、林月雅等人的，可好像没什么其他人喜欢，那便算了。<br>要说我真正想要的，《南山北海》算是一篇，这些日志也可以算，不过都只是雏形，差得还很多。<br>以后，还需努力。<br>至于放弃，还没想过。</p><p>其实2016那个暑假就已经是毕业的前奏，XS放假很晚，等他回来CX已经去学校准备考研了，三人竟没能聚到一起。<br>我和XS思忖了几天，决定去常州CX玩玩，顺便去一次淹城动物园。<br>天很热，TY和SYY等人一直在群里质疑我和XS这种大热天白找罪受的行为，懒得解释，女生有时候是搞不懂男生的，反之也一样。<br>不过……天真的很热啊，我们三人平均在动物园厕所里冲了不下三次头，T恤脱下冷水一冲再套上，唯有这样才能有些凉意。<br>动物园里那些叫得上名叫不上名的动物也很热，有水坑的例如河马等根本不露头，没有水坑的一脸生无可恋，躲在阴影里不屑地看着我们，像是也在说：“这么热的天傻逼才来看我们。”<br>“好热啊！”我把脑袋探出浏览车外对天大喊。<br>浏览车租价一天八十，本来只坐两个人，售票大妈见我们三人块头都不大遂大手一挥：“三人挤一辆吧，帮你们省钱吧！”<br>我是挺感谢她的，可就是……真的挺热的。<br>“轰隆隆！！”空中雷声大作，转瞬间暴雨倾盆而下，阳光却依旧刺眼。<br> “我了个靠……”我连忙把头缩回来，撑开伞挡住一边，回头对左边的CX喊，“你打伞撑住那边！”<br>于是，一辆小小浏览车，挤着三个老爷们，撑着两把雨伞当车门，慢悠悠地行驶在雨中。<br>雨砸在车窗上，“咚咚”作响。<br>“张Y你真牛逼！”XS握着方向盘，道。<br>“简直雨神。”CX说。<br>“嘿嘿，”我笑，“雨中漫步，多特么有意境！懂不懂啊你们！”<br>“有意境你自己漫去！”二人异口同声。<br>路经一道回廊，回廊上藤蔓缠绕地十分严实，竟将大雨遮了七七八八。<br>我从回廊这边望去，雨帘里还有几辆浏览车也在缓缓前进，有的是情侣，有的是亲子，也有的是一个人，静静地停在回廊里，斜斜靠在座位上不知在看些什么。<br>那天后来的天气就在曝晒和暴雨之间切换，太阳可能觉得换来换去烦了，干脆一直高悬在空中，便成了太阳雨。<br>光和雨都从那些缝隙里透进来，雨金光闪闪的，像是过往的岁月在流动，也像是我们在时光里彼此追逐彼此相融。<br>我想起很多很多年前在空间写的矫情文字，那时还是个中二的少年，矫情的文字现在是决计看不下去的。隐约记得在那篇不知能不能称为文章的文章里，太阳雨有深刻的含义。<br>如今想想，自己都不由摇头笑出了声。<br>当时真是年轻。<br>不过转念一想，自己竟然喜欢写东西喜欢了这么久？倒也是不容易。<br>时光匆匆，很少有东西是不变的，但这份热爱不变，纵使没啥成绩，也真是开心啊。<br>淹城动物园有野生区，这还是我第一次进野生区，动物不再被囚禁在可见的牢笼里，而是就在我们身边。<br>斑马在奔跑，羚羊在漫步，狮子在咆哮，狗熊在蹭树。<br>我们买了两包喂食，递给路边的羚羊。羚羊并不怕人，雄羚羊顶着树杈型的鹿角缓步靠近，鼻翼扇动，眼睛大得吓人。<br>从野生区离开，我们去看了表演。<br>鹦鹉表演和别处一样，倒也没什么出彩；<br>狗熊表演十分搞笑，我记住了那两只对拳的狗熊；<br>最后的大马戏无比震撼，杂技魔术精彩丰呈，场面美轮美奂，强烈推荐。<br>马戏团来自乌克兰，乌克兰美女名不虚传！！<br>马戏结束后天色已晚，我和XS也和CX告别，坐上返程的汽车。<br>如今已是寒假，只是三人却彻底没了聚在一起的机会，XS被学校派往帝都实习，过年也不回家。<br>下次见他，还不知是什么时候。<br>可能到时他的肩上已经别着军章了吧。</p><p>暑假里按照传统和FXT、TM聚了一回、和ZL吃了一顿饭，也和许久不见的BLY约了一次，她依然明媚如花，一起看了一场《大鱼海棠》，画面挺好的。<br>后来得知BLY竟然也在玩撸啊撸，我便腆着老脸找她一起开黑了几次，哈哈，反正我菜得抠脚，她也不嫌弃我，有点找回曾经前后桌的感觉，真好。<br>八月一日，我记得这一天，对我来说是个好日子。<br>南航面试通过，亚信面试也通过，一时间好像学业事业双丰收。<br>如果没有我后来的傻逼行为，确实很好。</p><p>八月和九月，是我2016年两度转折的时间。<br>八月份的那张实习offer让我错过和CX等人在家相约的日子，早早来到南京，开始我短短的两个月实习之旅，熬过夜、吃过苦，认识了不少公司前辈，尤其是我的导师为我解了不少惑。<br>若是没有九月份发生的事情，我恐怕会在公司呆得久一些。<br>九月……痛苦的九月。<br>因为自己的失误，保研名额拱手让人，我不得不辞去工作，不得不从九月末十月初加入茫茫考研大军，再一次拼独木桥。<br>起初当然是痛苦的，记不清有多少个夜晚我蜷缩着对着冰冷的墙壁，只觉得痛苦从每一个细胞里挤出来，顺着四肢百骸撕扯着、咆哮着，像要把我扯碎。<br>三年前高考输了，三年后，又输给了自己。<br>没有人知道那段时间我重读了《老人与海》，一遍又一遍。<br>二公子也不知道这事，但他曾拍拍我说：“人如果颓废了，那才真的废了。”那时我把自己整个人都裹在被子里，半天都不说话。<br>有时候想想人真的是个神奇的物种，二公子自己也是颓废起来能整天不下床的人物，竟偏偏能说出这样的话。而我明明知道他是个怎样的人，却还偏偏觉得他说的真特么对，好像他真的废寝忘食一样。<br>FXT还说：“说不定考研对你来说更好，你能去个更好的学校。”<br>嗯，可能吧。<br>几天之后终于恢复得差不多，望着面前厚厚的复习书，我一头钻了进去。<br>没有plan B。<br>那就只能拾起刀剑，一往无前。<br>所谓不破不立，可能就是这样。</p><p>有人说考研比高考更痛苦，因为高考有一群人在陪你，而考研是一个人在战斗。<br>这么说来的话我倒是运气不错，并不那么害怕孤独，一个人关在科协旁边的培训教室里学一整天也不觉得有什么。<br>隔壁有时会SSM和WTT等人的欢闹声，什么游戏又赢了什么小说好看极了诸如此类。我没觉得吵，反而觉得温馨，嘴角会微微扬起，胸中弥漫着温热的感觉。<br>有什么孤独呢，他们就在隔壁啊！<br>当然也有疲倦的时候，那时就翻开手机找研友聊聊天。</p><p>有时候找CX，他暑假就开始复习了，目标是他女票家乡的一所大学。<br>我复习得晚，数学不会的就问他，惊叹一句：“这你都会！”<br>“废话，这不会考个毛线啊！”<br>“那我不会。”<br>“你才复习几天，怎么可能会？复习完了就会了。”<br>我还会问：“考不上咋办？”<br>“考不上就找工作，我要赚钱。”<br>“不想工作。”<br>“那你二战啊！”<br>“也不想。”<br>“那你去死吧。”<br>“哼唧，爸爸一定会考上的。”<br>“哦，滚去看书。”</p><p>有时候和FJY聊天，她也考研，目标远大，却不够自信，一遍一遍地问我她能考上么她能考上么，像个紧张过度的妹妹。<br>我说：“能能能，当然能，不能不行！”<br>仿佛咬牙切齿，怒目如龙。<br>她很单纯，我这么说她便笃定地不得了，学我一样得咬牙切齿：“嗯嗯！！我们都能考上的！！一定！！！”<br>“考不上提头来见！”<br>“好！截图为证！！”<br>过了一会儿，她果然把截图发了过来，这张截图至今保留在我手机里，每每想起，都像有鼓声响在耳边，振聋发聩。<br>我想象屏幕那头的丫头，轻咬着下唇，目光里光芒涌动，微微鼓着腮帮子，用力握拳。<br>嘿，真是力量源源不断地上涌啊！</p><p>有时候和ZYN聊天，她沉稳得多，言语比我还少，我总觉得她才有真正考研人的样子，每天天蒙蒙亮就起床，在图书馆帮姗姗来迟的我占座，然后直到深夜才离开，而那时我大多时候已经躺下了。<br>她目标明确并且决心很大，一年前就立下跨考的志向，努力的整整一年，我相信上天总会给她个好结果。<br>我有时候会沉不住气问她：“感觉怎么样，有没有把握？”<br>她轻轻笑笑，摇摇头：“没想过，尽力吧。”<br>“累不累？”<br>她有时会摇摇头，有时候会歪着脑袋思索片刻，长发垂在桌上，然后说：“有什么累不累，累也要继续，不然能怎样？”<br>然后她又沉浸到张宇八套卷里去了。<br>而那时，我还没买八套卷……<br>真不知道现在自己的感觉良好是从哪来的……</p><p>还有时候和LYF聊天，她竟然报考我们学校，还好不是农业信息化，一到晚上十一点后就给我发各种学校美图。<br>我只想说智障么我呆了四年还用得着你给我发图么……<br>好像有天我受了刺激，跟她说了些不想考了啥的。我也只是随口发泄发泄说完便又埋进书里，过了一会儿手机却响了，是个陌生的号码。<br>我接通，没想到就是她，这才想起来好像真的没有存过彼此的号码。<br>“你别放弃好不好？”上来一句话就把我给整懵了。<br>我呆呆地：“啊？”<br>她竟然有些急了：“我说你千万别放弃啊。你都不知道当你告诉我只剩三个月时间你还要考研的时候我有多震撼……”巴拉巴拉说了一大堆。<br>我已经彻底懵了，想笑却又笑不出来，只是低着头，不断地“嗯嗯”。<br>终于她好像累了，沉默了会儿问道：“所以，你不会放弃了吧？”<br>“嗯，不会。”<br>“那好，我看书去了。”<br>“去吧。”<br>挂断电话，我眯眼透过教学区的窗户看天边一轮明月。<br>后来ZL也来找我，问我出了什么，害得LYF忙急忙慌地找她要我电话。<br>喂，搞什么啊……<br>放弃什么的，我真的没想过啊……</p><p>更多时候是和女票聊天，她虽然也报了名，不过嘛……用她自己的话来说就是“陪我考”，该吃还是吃，该睡到太阳晒屁股还是睡。<br>有时候我气急败坏地骂她，她也不恼，只是冲我笑。<br>“笑笑笑，笑个屁啊，考不上怎么办！！”<br>“有你啊。”她说。<br>“考不上你就找不到好工作了你知道吗！”<br>“有你啊。”她说。<br>“没好工作怎么养活自己？！”<br>“有你啊。”她还是说。<br>我……我没脾气了，灰溜溜滚去看书。<br>当然，她也在努力，只是在我面前故意这样罢了。</p><p>有时候也会和不考研的人聊。</p><p>ZL有阵子忙着写论文，偏偏中国知网上不去，求助于我。<br>我将我的账号发给她，她电脑竟然又显示下载失败，真是气煞我也。<br>没办法，我只能让她远程控制我的电脑下载，下好了再发给她……我可没那闲工夫帮她下载，控制权给她，自己忙活去吧！<br>然而，接通之后她足足三分钟啥也没干，鼠标在桌面上晃荡来去半天也不知道干嘛。<br>我翻了翻白眼，二话不说，握起鼠标，找到角落里的浏览器，打开。<br>鼠标静止。<br>片刻后她发消息给我：“你怎么知道我找不到浏览器！！”<br>我抚额……<br>呵呵……<br>有时候想想，真心佩服我自己……<br>后来ZL特意发微博夸我，说默契终于在十年后体现了。<br>嗯，十年了。</p><p>ZSK那段时间帮了我很多，复习的专业课书籍都是他寄给我的，他这学期去上海实习了，世界五百强企业，又保研本校，有些屌。<br>他一直是这么优秀，至少我这么看。<br>听说他女票也保研来了南京某所学校。<br>真替他高兴，四年的异地恋终于画上句号。<br>距离考研还有十天左右的时候他突然给我打电话，语气有些低沉，似乎是有了心事，迷茫得不行。<br>即使在我眼里独立如他，原来也会迷茫。<br>足足说了有半个小时，最后他道：“回家再说吧，你加油啊，别没考上。”<br>“嗯，我知道。”我点头，“放心吧，不出意外……”<br>“出意外也不行。”<br>我哂笑：“好，我明白。”<br>和他说话真是无需拐弯抹角，一词一句都是真话，好像承诺。</p><p>BLY高三复读一年，所以今年还没有考研，却也很关心我，经常问我进展如何，有时候甚至还给我发红包，说是要吃点好的。<br>有天晚上买了粥和烤鸭，发图给她看，她说：“好丰盛！”<br>“很贵的，十几块呢。”<br>“贵也要吃，吃饱了才有力气学习。加油！”<br>“吃吃吃……”<br>等到明年她考研的时候，我也会支持她，给她发红包，对她说要吃点好的。<br>考研这件事，有人支持真的很重要。</p><p>TY和SYY自然也不会不管我，某个傍晚我正在快递处拿刚到的《张宇真题详解》，口袋里的电话突然响起来。<br>我一愣，竟然是TY的电话。<br>“喂，干嘛？”我接通电话。<br>“你在干嘛啊？”电话那头的声音却是SYY。<br>“我还能干嘛，拿快递回去学习！”<br>“我们马上来看你啊，你吃了吗？想吃啥我们给你带！”<br>我看了一眼手中刚买的粥和包子，说道：“刚买了一碗粥两个包子。你们要干嘛？”<br>“慰问你啊！”TY的声音从一边窜出来。<br>SYY说：“那反正你也吃不饱，一会儿给你带点吃的。”<br>后来她们真地来了，拎着一个袋子。<br>我带她们去教学楼前的池塘回廊里坐着，那时天还不算冷，风吹着池水，还不逼人。<br>“喏，给你。”SYY把袋子扔给我。<br>TY一把拦住：“等会儿，我买了两块蛋糕呢，一块给他，一块我要自己吃的。”<br>我看了看TY不见瘦的体型，笑出了声。<br>“笑个屁。”她骂道，小胖子做凶狠状。<br>“哦还有鸭脖，我要吃鸭脖！”SYY翻着袋子，突然大喊道。<br>我在她们对面坐下，屈腿靠着柱子，笑道：“到底是带给我吃的还是你们自己吃的？”<br>“干嘛！”两人瞪我。<br>我举手投降：“不敢不敢。”<br>天已渐渐黑了，看不清楚池水，只听得见风吹过树叶的声音和……她们吃东西的声音。<br>“对了，SYY你要出国吧？”我突然问道。<br>“是啊，刚考完GRE，不然我哪有时间来看你？”SYY吸着冷气，龇牙咧嘴，“啊啊啊好辣好辣……”<br>“哦……去美国？”<br>“嗯。”<br>“还回来么？”<br>“不知道，看情况！”她跳上跳下的，还是当年那个在东南大学中山楼下吐着舌头对我诉苦DYM好像来了的女孩。<br>“那TY呢？”<br>“我啊？明年考研啊！”TY咽下最后一口蛋糕，我手里的还剩大半。<br>TY学医，五年制。<br>顿了顿，她又说道：“我们这个不专业不考研没出路的，如果我能考上南京市人民医院的话就好了。”<br>我不太懂，她解释了，我现在又忘了……<br>“太笨了你，反正你只要知道如果我能考上就人生巅峰，考不上就死翘翘了。”<br>“哦……”我挠挠头，眯起眼睛，“那以后就见不到啦，SYY去美国，你留在南京，我还不一定去哪呢……”<br>“本来就是咯，大家都要分开了。”TY说，死死盯着我。<br>我避开她的目光，装作看不懂那里面的离别，耸了耸肩：“哈，那以后去美国找SYY和CSB玩啊！你们买个大房子，有院子的那种，听说美国房子不贵，我们去投奔你们，一人一间房，多好！”<br>“好啊好啊！”SYY又跳起来，“不过我要留一间衣帽间！！”<br>“什，什么间……”我没听清。<br>“衣——帽——间！”<br>“那是啥？”<br>两人对我白了白眼，SYY道：“就是放衣服裤子帽子啊什么的……没看过《小时代》吗？顾里家里的那种！”<br>哦，我想起来了，《小时代》里顾里有个大房间。<br>“哗”的一声房门推开，玻璃反射光华晃了所有人眼，放眼望去房间都看不到头，全都是……衣服衣服衣服……帽子帽子帽子……裤子裤子裤子……靴子靴子靴子……<br>想想有点可怕！<br>“可怕。”我哆嗦了一下，说道。<br>“可怕个大头鬼咧！”SYY道，“不要太爽哦……”<br>“好吧……希望你有，然后我们连衣服都省的买了。”<br>“想得美哦，要给钱的！”<br>…………<br>“饱了。”TY打了个嗝，道。<br>我没好气地摇头。<br>她们站起来拍拍灰：“不早了，你回去看书吧，我们走了！”<br>“嗯。”我点点头，也不留她们。<br>不知何时月亮都已经升起来了。<br>我目送着两人在月光下沿着勤仁坡那条路渐渐远去，胳膊挽着胳膊，蹦蹦跳跳的。</p><p>现在，已经结束了，不管结果如何，我们都曾经努力过。</p><p>时间过得太快了。<br>说起来还是在去年八月，有个夜晚WYZ又给我推歌，然后她说《夏至未至》要拍影视了，她不喜欢白敬亭演陆之昂。<br>《夏至未至》，我看过的唯一一本郭敬明的言情小说，她推荐我看的，那时她说她觉得我像陆之昂，ZSK像傅小司，时隔多年早已记不清情节，只记得那座城好像叫浅川。<br>WYZ曾用过一个网名，叫忘川。<br>我笑着回她：“陆之昂不是我吗？”<br>然后，然后然后然后！<br>她说“拜托，你已经不是18岁了。”<br>我有些惊悚，原来……早就不是18岁了啊！<br>书里的人不会老，什么时候翻开他都是那个年纪，站在阳光里浅笑嫣然。<br>书外的人却老得快，快得出乎意料，快得毫无察觉。<br>后来很少聊天，只是有时候我发些发泄用的说说，她会留个言或者找我，问我怎么了。<br>她问我，我却不知从何说起，于是随便扯些别的，随意聊聊，知道彼此都过得还算好就行。<br>讲真，我真的很喜欢《未完1》里关于她的比喻。</p><p>想着不写长，写完又是近一万字。<br>能写的太多了，没写的也太多了。<br>结束来得太匆匆，我还没想好要怎么结尾。<br>想来想去，既然我把它们归为一个系列，那就还用《未完1》的话结尾吧。<br>2017，我们的故事，未完待续。</p><p>即使我真的不会再写《未完3》，这些故事，该续的还在续。<br>毕竟这人生，我们都在相互扶持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2017年1月21日，2018年5月31日上传保存。）&lt;/p&gt;
&lt;p&gt;有的时候是看见一句话。&lt;br&gt;有的时候是听见一首歌。&lt;br&gt;有的时候是站在老地方。&lt;br&gt;有的时候是见到老朋友。&lt;br&gt;有的时候是静在沉默里。&lt;br&gt;但更多的时候是在呼吸里。&lt;br&gt;想你。&lt;br&gt;想我是怎么渐渐失去了你。&lt;br&gt;我的匆匆时光。&lt;br&gt;
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
