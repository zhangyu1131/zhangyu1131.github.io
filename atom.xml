<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZRainy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-24T08:34:45.356Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZRainy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题记录</title>
    <link href="http://yoursite.com/2019/04/16/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/04/16/LeetCode刷题记录/</id>
    <published>2019-04-16T06:32:34.000Z</published>
    <updated>2019-04-24T08:34:45.356Z</updated>
    
    <content type="html"><![CDATA[<p>想养成刷题的习惯，之前刷过一点，但校招之后就断了，现在想捡起来，定个小目标，从头开始刷题吧，看能坚持多久。</p><h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><p>2019/4/16，易。</p><p>这题以前做过，记得第一次做的时候应该是用的最蠢的两重遍历方法相加求解，毫无疑问超时了，隐约记得可以使用查找<code>目标值-某个值</code>是否存在该vector中来反向求解，简单写了一下，通过了。其实是一个反向思维的题，正面求解超时，则反向来求。仍然属于蛮力法的范畴，n<sup>2</sup>时间复杂度，1空间复杂度，LeetCode平台耗时136ms。</p><p>尝试降低时间复杂度，想到以空间换时间，在查找<code>目标值-某个值</code>的时候，上述蛮力法使用<code>std::find</code>方法，说白了也是一层遍历，这层遍历目的是为了查找差值是否存在于vector中并返回下标，自然可以想到用哈希表来代替这一层遍历。当然，事先需要遍历一次原数组构建哈希表。如此时间复杂度n，空间复杂度n。</p><a id="more"></a><p>最终代码如下，本版本耗时仅16ms。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;<span class="comment">//哈希表</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=nums.begin();it!=nums.end();it++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> com=<span class="built_in">map</span>.find(target-*it);</span><br><span class="line">            <span class="keyword">if</span>(com!=<span class="built_in">map</span>.end()&amp;&amp;com-&gt;second!=it-nums.begin())&#123;</span><br><span class="line">                res.push_back(it-nums.begin());</span><br><span class="line">                res.push_back(com-&gt;second);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>2019/4/19，中。</p><p>平心而论是个比较简单的链表题了，但是太久不做题竟然觉得很难理清楚，这也说明了常做题保持手感很重要。</p><p>本题也没啥特别的方法，注意循环进位即可，另外链表的题往往一开始会定义两个变量，一个用于最后返回，一个用来遍历处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* res=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p=res;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1||l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>; </span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">            &#123;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2)</span><br><span class="line">            &#123;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">1</span>)</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h1><p>2019/4/21，中。</p><p>一道经典dp题，准备找工作的时候刷过，以为很简单，但写的时候却发现细节又已经遗忘了，虽然最后还是一遍过了，但还是感慨得要经常刷题保持手感啊，忘性太大了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        m[s[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=m.find(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(it==m.end())&#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-it-&gt;second&gt;dp[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i]=i-m[s[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m[s[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;dp.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max)</span><br><span class="line">                max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4.Median of Two Sorted Arrays"></a>4.Median of Two Sorted Arrays</h1><p>2019/4/22，难。</p><p>想法一开始就很明确，将两个有序数组Merge成一个新的有序数组就是了，然后直接返回中间值即可。后来稍微改进了下代码，因为Merge其实只需要Merge到中间数即可，后面的数并不需要处理了，所以去除了冗余排序，感觉时间复杂度是n+m，空间复杂度也是n+m。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length1=nums1.size(),length2=nums2.size();</span><br><span class="line">        <span class="keyword">int</span> sumLen=length1+length2;</span><br><span class="line">        <span class="keyword">int</span> midIndex=(length1+length2)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(res.size()&lt;midIndex+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j == length2 || (i &lt; nums1.size() &amp;&amp; nums1[i] &lt; nums2[j])) &#123;</span><br><span class="line">    res.push_back(nums1[i]);</span><br><span class="line">    i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == length1 || (j&lt;nums2.size() &amp;&amp; nums1[i] &gt;= nums2[j])) &#123;</span><br><span class="line">    res.push_back(nums2[j]);</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sumLen%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res.back();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> r=(res[res.size()<span class="number">-1</span>]+res[res.size()<span class="number">-2</span>])/<span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但后来发现题目要求的时间复杂度是log(n+m)，才感觉到为什么这道题目难度级别是hard，不过我习惯从这个要求的时间复杂度就得到该题应该要使用二分查找或者是二分查找的变形，看了网上的解答，应该是查找第K小数字的变体，最后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1=nums1.size(),length2=nums2.size();</span><br><span class="line">        <span class="keyword">int</span> sumLen=length1+length2;</span><br><span class="line">        <span class="keyword">if</span>(sumLen%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> FindKth(nums1,length1,nums2,length2,sumLen/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (FindKth(nums1,length1,nums2,length2,sumLen/<span class="number">2</span>)+</span><br><span class="line">                    FindKth(nums1,length1,nums2,length2,sumLen/<span class="number">2</span>+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">FindKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1,<span class="keyword">int</span> length1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2,<span class="keyword">int</span> length2,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length1&gt;length2)</span><br><span class="line">            <span class="keyword">return</span> FindKth(nums2,length2,nums1,length1,k);</span><br><span class="line">        <span class="keyword">if</span>(length1==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums2[k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> min(nums1[<span class="number">0</span>],nums2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> pa=min(k/<span class="number">2</span>,length1),pb=k-pa;</span><br><span class="line">        <span class="keyword">if</span>(nums1[pa<span class="number">-1</span>]&lt;nums2[pb<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(nums1.begin()+pa,nums1.end());</span><br><span class="line">            <span class="keyword">return</span> FindKth(tmp,length1-pa,nums2,length2,k-pa);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[pa<span class="number">-1</span>]&gt;nums2[pb<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(nums2.begin()+pb,nums2.end());</span><br><span class="line">            <span class="keyword">return</span> FindKth(nums1,length1,tmp,length2-pb,k-pb);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[pa<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考<a href="https://blog.csdn.net/lis_12/article/details/53128594" target="_blank" rel="noopener">https://blog.csdn.net/lis_12/article/details/53128594</a></p><h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5.Longest Palindromic Substring"></a>5.Longest Palindromic Substring</h1><p>2019/4/23，中。</p><p>求最长回文子串，看到题目之后我感觉这是一道dp题，但是太菜了，还是写不出来，查了解析后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(s.size(),<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(),<span class="literal">true</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=s.size();i++)&#123;<span class="comment">//i表示子串长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> leftIdx=<span class="number">0</span>;leftIdx&lt;=s.size()-i;leftIdx++)&#123;<span class="comment">//j表示子串起始坐标</span></span><br><span class="line">                <span class="keyword">int</span> rightIdx=leftIdx+i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[leftIdx]==s[rightIdx]&amp;&amp;dp[leftIdx+<span class="number">1</span>][rightIdx<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[leftIdx][rightIdx]=<span class="literal">true</span>;</span><br><span class="line">                    max=i;</span><br><span class="line">                    start=leftIdx;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[leftIdx][rightIdx]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度n<sup>2</sup>，空间复杂度n<sup>2</sup>。</p><p>利用中心扩展法可以将空间复杂度降低到1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1=expandAroundCenter(s,i,i);<span class="comment">//奇数</span></span><br><span class="line">            <span class="keyword">int</span> len2=expandAroundCenter(s,i,i+<span class="number">1</span>);<span class="comment">//偶数</span></span><br><span class="line">            <span class="keyword">int</span> len=max(len1,len2);</span><br><span class="line">            <span class="keyword">if</span>(len&gt;end-start)&#123;</span><br><span class="line">                start=i-(len<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,end-start+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span>&amp; s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">    <span class="keyword">while</span> (left&gt;=<span class="number">0</span> &amp;&amp; right&lt;len &amp;&amp; s[left] == s[right]) </span><br><span class="line">    &#123;</span><br><span class="line">    left--;</span><br><span class="line">    right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right-left<span class="number">-1</span>;<span class="comment">//返回长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后还有一种Manacher方法，能将时间复杂度降到n，同时空间复杂度也是n，没看得太明白，以后再说。<a href="http://www.cnblogs.com/bitzhuwei/p/Longest-Palindromic-Substring-Part-II.html" target="_blank" rel="noopener">http://www.cnblogs.com/bitzhuwei/p/Longest-Palindromic-Substring-Part-II.html</a></p><h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6.ZigZag Conversion"></a>6.ZigZag Conversion</h1><p>2019/4/24，中。</p><p>之字形排列字符串然后按行打印。</p><p>刚看到时候第一种办法就是自己定义一个二维数组排一下然后按行输出得了，蛮力法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//蛮力法</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="comment">//构建一个二维字符数组存数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">array</span>(numRows,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(s.size()/<span class="number">2</span>+<span class="number">1</span>,<span class="string">"null"</span>));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> direction=<span class="literal">true</span>;<span class="comment">//记录方向，ture表示向下，false向上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>;idx&lt;s.size();idx++)&#123;</span><br><span class="line">            <span class="built_in">array</span>[i][j]=s[idx];</span><br><span class="line">            <span class="keyword">if</span>(direction)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(i==numRows)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    i=i<span class="number">-2</span>;</span><br><span class="line">                    direction=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i--;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">-1</span>)&#123;</span><br><span class="line">                    i=i+<span class="number">2</span>;</span><br><span class="line">                    j--;</span><br><span class="line">                    direction=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;numRows;p++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;s.size()/<span class="number">2</span>+<span class="number">1</span>;q++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[p][q]!=<span class="string">"null"</span>)&#123;</span><br><span class="line">                   res+=<span class="built_in">array</span>[p][q]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交后虽然通过了，但花费时间560ms，空间占有400MB，感觉效率太低了，于是尝试另一种方法。</p><p>另一种方法也很好想到，既然是按某种规律排列并输出，那自然把规律找出来就好了，多在草稿纸上排了几个用例后发现每一行的间隔都是有规律的，主要规律是2*numRows-2，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//找规律直接输出</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxInterval=<span class="number">2</span>*numRows<span class="number">-2</span>;<span class="comment">//最大间隔</span></span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> startIdx=i;</span><br><span class="line">            <span class="keyword">int</span> interval=maxInterval<span class="number">-2</span>*i;</span><br><span class="line">            <span class="keyword">if</span>(i==numRows<span class="number">-1</span>)</span><br><span class="line">                interval=maxInterval;</span><br><span class="line">            <span class="keyword">while</span>(startIdx&lt;s.size())&#123;</span><br><span class="line">                res+=s[startIdx];</span><br><span class="line">                startIdx+=interval;</span><br><span class="line">                interval=(maxInterval-interval!=<span class="number">0</span>)?maxInterval-interval:interval;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交后时间降到16ms，空间占有降低到10MB，效率提升还是很明显的。</p><p>这道题算是这几天做的比较顺利的题了，阿弥陀佛。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想养成刷题的习惯，之前刷过一点，但校招之后就断了，现在想捡起来，定个小目标，从头开始刷题吧，看能坚持多久。&lt;/p&gt;
&lt;h1 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1. Two Sum&quot;&gt;&lt;/a&gt;1. Two Sum&lt;/h1&gt;&lt;p&gt;2019/4/16，易。&lt;/p&gt;
&lt;p&gt;这题以前做过，记得第一次做的时候应该是用的最蠢的两重遍历方法相加求解，毫无疑问超时了，隐约记得可以使用查找&lt;code&gt;目标值-某个值&lt;/code&gt;是否存在该vector中来反向求解，简单写了一下，通过了。其实是一个反向思维的题，正面求解超时，则反向来求。仍然属于蛮力法的范畴，n&lt;sup&gt;2&lt;/sup&gt;时间复杂度，1空间复杂度，LeetCode平台耗时136ms。&lt;/p&gt;
&lt;p&gt;尝试降低时间复杂度，想到以空间换时间，在查找&lt;code&gt;目标值-某个值&lt;/code&gt;的时候，上述蛮力法使用&lt;code&gt;std::find&lt;/code&gt;方法，说白了也是一层遍历，这层遍历目的是为了查找差值是否存在于vector中并返回下标，自然可以想到用哈希表来代替这一层遍历。当然，事先需要遍历一次原数组构建哈希表。如此时间复杂度n，空间复杂度n。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Effeciteve Modern C++笔记</title>
    <link href="http://yoursite.com/2019/03/18/Effeciteve-Modern-C-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/03/18/Effeciteve-Modern-C-笔记/</id>
    <published>2019-03-18T13:03:08.000Z</published>
    <updated>2019-04-11T10:28:09.034Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录下阅读《Effective Modern C++》的一些笔记，列出本书的一些提纲，但不给出解释，希望后续复习时直接看提纲就能回忆起相关内容。</p><h1 id="条款1：理解模板型别推导"><a href="#条款1：理解模板型别推导" class="headerlink" title="条款1：理解模板型别推导"></a>条款1：理解模板型别推导</h1><p>针对以下代码，分为三种情况讨论。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line">f(expr);</span><br></pre></td></tr></table></figure><ol><li>ParamType是个指针或引用，但不是个万能引用；</li><li>ParamType是个万能引用，又分为实参是左值还是右值；</li><li>ParamType不是指针也不是引用，又会分为实参具有引用或者指针特性或者什么都没有；</li></ol><p>除此之外还有一些参数会退化成指针的情况出现，比如数组实参、函数实参。</p><a id="more"></a><h1 id="条款2：理解auto型别推导"><a href="#条款2：理解auto型别推导" class="headerlink" title="条款2：理解auto型别推导"></a>条款2：理解auto型别推导</h1><p>对于条款1中的代码，auto=T，变量的型别修饰则是ParamType，其余规则除了一种特殊情况外则和条款1一致。</p><p>特殊情况：当用于auto声明变量的初始化表达式是用大括号括起来的时候，推导的型别就属于<code>std::initializer_list</code>。</p><p>根本原因在于，auto会假定用大括号括起来的初始化表达式代表一个<code>std::initializer_list</code>，但模板型别推导却不会。</p><p>注意：在C++14中auto可能用于函数返回值或lambda表达式的形参声明中，在这两种情况下auto进行的模板型别推导而不是正常的auto型别推导。</p><h1 id="条款3：理解decltype"><a href="#条款3：理解decltype" class="headerlink" title="条款3：理解decltype"></a>条款3：理解decltype</h1><p>C++11中，decltype的主要作用大概就在于声明那些返回值型别依赖于形参型别的函数模板。</p><p>绝大多数情况下，decltype会得出变量或表达式的型别而不作任何修改。</p><p>C++14会有些特殊。</p><h1 id="条款4：掌握查看型别推导结果的方法"><a href="#条款4：掌握查看型别推导结果的方法" class="headerlink" title="条款4：掌握查看型别推导结果的方法"></a>条款4：掌握查看型别推导结果的方法</h1><p>IDE、编译器等工具会有帮助，但理解条款1~3更重要。</p><h1 id="条款5：优先选用auto，而非显式型别声明"><a href="#条款5：优先选用auto，而非显式型别声明" class="headerlink" title="条款5：优先选用auto，而非显式型别声明"></a>条款5：优先选用auto，而非显式型别声明</h1><h1 id="条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法"><a href="#条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法" class="headerlink" title="条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法"></a>条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法</h1><p>隐形代理类和auto无法和平共处。</p><p>解决方案不应该放弃auto，而是强制进行另一次性别转换，即带显式型别的初始化物习惯用法。</p><p>还有一个好处是有时这样做可以强调程序员意在创建一个型别有异于初始化表达式型别的变量的场合。</p><h1 id="条款7：在创建对象时注意区分-和"><a href="#条款7：在创建对象时注意区分-和" class="headerlink" title="条款7：在创建对象时注意区分{}和()"></a>条款7：在创建对象时注意区分{}和()</h1><p>大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析与法免疫。</p><p>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本更合适。</p><h1 id="条款8：优先选用nullptr，而非0或NULL"><a href="#条款8：优先选用nullptr，而非0或NULL" class="headerlink" title="条款8：优先选用nullptr，而非0或NULL"></a>条款8：优先选用nullptr，而非0或NULL</h1><p>可以避免在整型和指针型别之间重载。</p><h1 id="条款9：优先选用别名声明，而非typedef"><a href="#条款9：优先选用别名声明，而非typedef" class="headerlink" title="条款9：优先选用别名声明，而非typedef"></a>条款9：优先选用别名声明，而非typedef</h1><p>typedef不支持模板化，但别名声明支持。</p><p>别名模板可以让人免写“::type”后缀，并且在模板内，对于内嵌typedef的引用经常要加typename前缀。</p><h1 id="条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"><a href="#条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别" class="headerlink" title="条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别"></a>条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别</h1><p>用<code>enum class</code>来定义枚举类，即使限定作用域的枚举型别。</p><h1 id="条款11：优先选用删除函数，而非private未定义函数"><a href="#条款11：优先选用删除函数，而非private未定义函数" class="headerlink" title="条款11：优先选用删除函数，而非private未定义函数"></a>条款11：优先选用删除函数，而非private未定义函数</h1><p>任何函数都可以删除，包括非成员函数和模板具现。</p><h1 id="条款12：为意在改写的函数添加override声明"><a href="#条款12：为意在改写的函数添加override声明" class="headerlink" title="条款12：为意在改写的函数添加override声明"></a>条款12：为意在改写的函数添加override声明</h1><h1 id="条款13：优先选用const-iterator，而非iterator"><a href="#条款13：优先选用const-iterator，而非iterator" class="headerlink" title="条款13：优先选用const_iterator，而非iterator"></a>条款13：优先选用const_iterator，而非iterator</h1><h1 id="条款14：只要函数不会发射异常，就为其加上noexcept声明"><a href="#条款14：只要函数不会发射异常，就为其加上noexcept声明" class="headerlink" title="条款14：只要函数不会发射异常，就为其加上noexcept声明"></a>条款14：只要函数不会发射异常，就为其加上noexcept声明</h1><h1 id="条款15：只要有可能使用constexpr，就使用它"><a href="#条款15：只要有可能使用constexpr，就使用它" class="headerlink" title="条款15：只要有可能使用constexpr，就使用它"></a>条款15：只要有可能使用constexpr，就使用它</h1><p>constexpr对象都具备const属性，并由编译期已知的值完成初始化。</p><p>constexpr函数在调用时若传入的实参值是编译期已知的，则会产出编译期结果。</p><h1 id="条款16：保证const成员函数的线程安全性"><a href="#条款16：保证const成员函数的线程安全性" class="headerlink" title="条款16：保证const成员函数的线程安全性"></a>条款16：保证const成员函数的线程安全性</h1><p>利用<code>std::mutex</code>或<code>std::atomic</code></p><h1 id="条款17：理解特种成员函数的生成机制"><a href="#条款17：理解特种成员函数的生成机制" class="headerlink" title="条款17：理解特种成员函数的生成机制"></a>条款17：理解特种成员函数的生成机制</h1><p>特种成员函数是指C++会自行生成的成员函数：默认构造函数、析构函数、复制操作以及移动操作。</p><p>自行生成的移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数时才会生成。</p><h1 id="条款18：使用std-unique-ptr管理具备专属所有权的资源"><a href="#条款18：使用std-unique-ptr管理具备专属所有权的资源" class="headerlink" title="条款18：使用std::unique_ptr管理具备专属所有权的资源"></a>条款18：使用std::unique_ptr管理具备专属所有权的资源</h1><p><code>std::unique_ptr</code>是小巧、高速的、具备只移型别的智能指针，对托管资源实施专属所有权语义。</p><h1 id="条款19：使用std-shared-ptr管理具备共享所有权的资源"><a href="#条款19：使用std-shared-ptr管理具备共享所有权的资源" class="headerlink" title="条款19：使用std::shared_ptr管理具备共享所有权的资源"></a>条款19：使用std::shared_ptr管理具备共享所有权的资源</h1><p><code>std::shared_ptr</code>是提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。</p><h1 id="条款20：对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr"><a href="#条款20：对于类似std-shared-ptr但有可能空悬的指针使用std-weak-ptr" class="headerlink" title="条款20：对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr"></a>条款20：对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr</h1><h1 id="条款21：优先选用std-make-unique和std-make-shared，而非直接使用new"><a href="#条款21：优先选用std-make-unique和std-make-shared，而非直接使用new" class="headerlink" title="条款21：优先选用std::make_unique和std::make_shared，而非直接使用new"></a>条款21：优先选用std::make_unique和std::make_shared，而非直接使用new</h1><p>相比于直接私用new表达式，make系列函数消除了重复代码、改进了异常安全性，并提升性能。</p><h1 id="条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中"></a>条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中</h1><h1 id="条款23：理解std-move和std-forward"><a href="#条款23：理解std-move和std-forward" class="headerlink" title="条款23：理解std::move和std::forward"></a>条款23：理解std::move和std::forward</h1><p><code>std::move</code>只做一件事，就是把实参强制转换成右值，并不做移动。</p><p><code>std::forward</code>是有条件的强制型别转换：仅当其实参是使用右值完成初始化时，它才会执行向右值型别的强制型别转换。</p><p>在运行期，<code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p><h1 id="条款24：区分万能引用和右值引用"><a href="#条款24：区分万能引用和右值引用" class="headerlink" title="条款24：区分万能引用和右值引用"></a>条款24：区分万能引用和右值引用</h1><p>如果函数模板形参具备T&amp;&amp;型别，并且T的型别系推导而来，或如果对象使用auto&amp;&amp;声明其型别，则该形参或对象就是个万能引用。</p><h1 id="条款25：针对右值引用实施std-move，针对万能引用实施std-forward"><a href="#条款25：针对右值引用实施std-move，针对万能引用实施std-forward" class="headerlink" title="条款25：针对右值引用实施std::move，针对万能引用实施std::forward"></a>条款25：针对右值引用实施<code>std::move</code>，针对万能引用实施<code>std::forward</code></h1><p>编译器若要在一个按值返回的函数里省略对局部对象的复制（或者移动），则需要满足两个前提条件：1局部对象型别和函数返回值型别相同；2返回的就是局部对象本身。</p><p>若局部对象可能适用于返回值优化，则请勿针对其实施std::move或std::forward。</p><h1 id="条款26：避免依万能指针型别进行重载"><a href="#条款26：避免依万能指针型别进行重载" class="headerlink" title="条款26：避免依万能指针型别进行重载"></a>条款26：避免依万能指针型别进行重载</h1><h1 id="条款27：熟悉依万能引用型别进行重载的替代方案"><a href="#条款27：熟悉依万能引用型别进行重载的替代方案" class="headerlink" title="条款27：熟悉依万能引用型别进行重载的替代方案"></a>条款27：熟悉依万能引用型别进行重载的替代方案</h1><p>SFINAE：substitution failure is not an error，替换失败不是错误。利用<code>std::enable_if</code>。</p><p>万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势。</p><h1 id="条款28：理解引用折叠"><a href="#条款28：理解引用折叠" class="headerlink" title="条款28：理解引用折叠"></a>条款28：理解引用折叠</h1><p>引用折叠：如果任一引用为左值引用，则结果就是左值引用，否则结果是右值引用。</p><p>引用折叠会在四中语境中发生：模板实例化、auto型别生成、创建和运用typedef和别名声明，以及decltype。</p><h1 id="条款29：假定移动操作不存在、成本高、未使用"><a href="#条款29：假定移动操作不存在、成本高、未使用" class="headerlink" title="条款29：假定移动操作不存在、成本高、未使用"></a>条款29：假定移动操作不存在、成本高、未使用</h1><p>对于那些型别或对于移动语义的支持情况已知的代码，则无需做以上假定。</p><h1 id="条款30：熟悉完美转发的失败情形"><a href="#条款30：熟悉完美转发的失败情形" class="headerlink" title="条款30：熟悉完美转发的失败情形"></a>条款30：熟悉完美转发的失败情形</h1><p>论及一般意义上的转发时，都是在处理形参为引用型别的情形。</p><ol><li>大括号初始化物</li><li>0和NULL用作空指针</li><li>仅有生命的整型static const成员变量</li><li>重载的函数名字和模板名字</li><li>位域：非const引用不得绑定到位域。</li></ol><h1 id="条款31：避免默认捕获模式"><a href="#条款31：避免默认捕获模式" class="headerlink" title="条款31：避免默认捕获模式"></a>条款31：避免默认捕获模式</h1><p>按引用的默认捕获会导致空悬指针问题。</p><p>按值的默认捕获极易受空悬指针影响，并会误导人们认为lambda式是自恰的。</p><h1 id="条款32：使用初始化捕获将对象移入闭包"><a href="#条款32：使用初始化捕获将对象移入闭包" class="headerlink" title="条款32：使用初始化捕获将对象移入闭包"></a>条款32：使用初始化捕获将对象移入闭包</h1><p>初始化捕获又称广义lambda捕获。</p><p>使用C++14的初始化捕获将对象移入闭包。</p><p>在C++11中，经由手工实现的类或std::bind去模拟初始化捕获。</p><h1 id="条款33：对auto-amp-amp-型别的形参使用decltype，以std-forward之"><a href="#条款33：对auto-amp-amp-型别的形参使用decltype，以std-forward之" class="headerlink" title="条款33：对auto&amp;&amp;型别的形参使用decltype，以std::forward之"></a>条款33：对auto&amp;&amp;型别的形参使用decltype，以std::forward之</h1><h1 id="条款34：优先使用lambda式，而非std-bind"><a href="#条款34：优先使用lambda式，而非std-bind" class="headerlink" title="条款34：优先使用lambda式，而非std::bind"></a>条款34：优先使用lambda式，而非std::bind</h1><p>C++14已经不需要用std::bind了</p><p>C++11中，std::bind仅在实现移动捕获、或是绑定到具备模板化的函数调用运算符的对象的场合中可能尚有余热可以发挥。</p><h1 id="条款35：优先选用基于任务而非基于线程的程序设计"><a href="#条款35：优先选用基于任务而非基于线程的程序设计" class="headerlink" title="条款35：优先选用基于任务而非基于线程的程序设计"></a>条款35：优先选用基于任务而非基于线程的程序设计</h1><p>std::thread 基于线程</p><p>std::async 基于任务</p><h1 id="条款36：如果异步是必要的，则指定std-launch-async"><a href="#条款36：如果异步是必要的，则指定std-launch-async" class="headerlink" title="条款36：如果异步是必要的，则指定std::launch::async"></a>条款36：如果异步是必要的，则指定std::launch::async</h1><p>std::async的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行。</p><p>正因为这种弹性，所以当以默认启动策略使用std::async的时候要考虑一些不确定性。</p><h1 id="条款37：使std-thread型别对象在所有路径皆不可联结"><a href="#条款37：使std-thread型别对象在所有路径皆不可联结" class="headerlink" title="条款37：使std::thread型别对象在所有路径皆不可联结"></a>条款37：使std::thread型别对象在所有路径皆不可联结</h1><p>在成员列表的最后声明std::thread型别对象。</p><h1 id="条款38：对变化多端的线程句柄析构函数行为保持关注"><a href="#条款38：对变化多端的线程句柄析构函数行为保持关注" class="headerlink" title="条款38：对变化多端的线程句柄析构函数行为保持关注"></a>条款38：对变化多端的线程句柄析构函数行为保持关注</h1><p>期值的析构函数在常规情况下，仅仅会析构期值的成员变量。</p><p>指涉到经由std::aysnc启动的未推迟任务的共享状态的最后一个期值会保持阻塞，直至该任务结束。</p><h1 id="条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值"><a href="#条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值" class="headerlink" title="条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值"></a>条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值</h1><h1 id="条款40：对并发使用std-atomic，对特种内存使用volatile"><a href="#条款40：对并发使用std-atomic，对特种内存使用volatile" class="headerlink" title="条款40：对并发使用std::atomic，对特种内存使用volatile"></a>条款40：对并发使用std::atomic，对特种内存使用volatile</h1><p>注：一般地，编译器可以将不相关的赋值语句重新排序。</p><p>volatile的用处是告诉编译器，正在处理的内存是特种内存，不具备常规行为，即读写操作不可以被优化。</p><p>最常见的特种内存就是用于内存映射I/O的内存。</p><h1 id="条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"><a href="#条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递" class="headerlink" title="条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递"></a>条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递</h1><p>经由构造复制形参的成本可能比经由赋值复制形参高出很多。</p><p>按值传递肯定会导致切片问题，所以基类型别特别不适用于按值传递。</p><h1 id="条款42：考虑置入而非插入"><a href="#条款42：考虑置入而非插入" class="headerlink" title="条款42：考虑置入而非插入"></a>条款42：考虑置入而非插入</h1><p>从原理上说，置入函数（emplace）应该有时比对应的插入函数（insert、push）高效，而且不应该有更低效的可能。</p><p>但从实践上说，置入函数在以下几个前提成立时，极有可能会运行的更快：</p><ol><li>待添加的值是以构造而非赋值方式加入容器；</li><li>传递的实参型别与容器持有之物的型别不同；</li><li>容器不会由于存在重复值而拒绝待添加的值。</li></ol><p>置入函数可能会执行在插入函数中会被拒绝的型别转换，如隐式型别转换构造函数。</p><p>置入函数使用的是直接初始化，而插入函数使用的复制初始化。</p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录下阅读《Effective Modern C++》的一些笔记，列出本书的一些提纲，但不给出解释，希望后续复习时直接看提纲就能回忆起相关内容。&lt;/p&gt;
&lt;h1 id=&quot;条款1：理解模板型别推导&quot;&gt;&lt;a href=&quot;#条款1：理解模板型别推导&quot; class=&quot;headerlink&quot; title=&quot;条款1：理解模板型别推导&quot;&gt;&lt;/a&gt;条款1：理解模板型别推导&lt;/h1&gt;&lt;p&gt;针对以下代码，分为三种情况讨论。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ParamType param)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f(expr);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;ParamType是个指针或引用，但不是个万能引用；&lt;/li&gt;
&lt;li&gt;ParamType是个万能引用，又分为实参是左值还是右值；&lt;/li&gt;
&lt;li&gt;ParamType不是指针也不是引用，又会分为实参具有引用或者指针特性或者什么都没有；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除此之外还有一些参数会退化成指针的情况出现，比如数组实参、函数实参。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>未完待续-叁</title>
    <link href="http://yoursite.com/2019/02/04/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E5%8F%81/"/>
    <id>http://yoursite.com/2019/02/04/未完待续-叁/</id>
    <published>2019-02-04T10:51:59.000Z</published>
    <updated>2019-02-04T11:17:25.936Z</updated>
    
    <content type="html"><![CDATA[<p>（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。全文一万字左右，慎读。本文写于己亥年春节前夕。）</p><p>人们高兴，人们悲哀。</p><p>人们憧憬，人们缅怀。</p><p>一左一右的时间，握在手里放不开。</p><p>人啊，</p><p>总是不愿承认，</p><p>现在的境遇，</p><p>有时候已经是最好的安排。</p><p>……</p> <a id="more"></a><p>决定要不要写这篇《叁》用了很久时间，从2017年1月到2018年6月，本科毕业了，连硕士毕业都已在眼前。</p><p>而从决定了到真正动笔，又花费了半年，半年里我走过了江浙沪。</p><p>最终真正写下第一个字的时候，家里又添置了不少衣服，除了不少尘灰。</p><p>所以啊，人生很长，许多事都在做；人生很短，有些事做不完。</p><p>时光一去如梭，两天不见的、两月不见的、两年不见的、甚至更久未见的各位，你们过得怎么样？</p><p>我觉得我过得还不算太坏。</p><p>过去的《壹》和《贰》里，大多数写的都是和朋友间的往事，但今年实习以来，更多的时间是和自己在一起，所以这篇文字里可能关于自己的内容会多一些，这是自我总结的一篇文章。</p><p>《贰》的结束时间点在2018年春节，这个系列不是小说，我没法直接打出“XX年后”这样的字段跳到最近来叙述，所以还得按顺序来。</p><p>先来后到，很好。</p><p>插句题外话，之前有段时间动不动发朋友圈发说说好像被视为一种没事找事，所以我也没有发太多怕打扰到别人更怕看不懂的人说些煞风景的话，但后来我发现这样会导致一系列的遗忘，我已经想不起来太多太多生活中细小的喜怒哀乐了，而这是令我很不喜甚至是不能容忍的，所以我捡回发朋友圈的习惯。（好像插得有点多，对不起对不起，不能再插了，哈哈哈哈哈哈哈哈哈啊哈~~~）</p><p>但不好意思，还得再插一句，因为刚刚拉朋友圈近两年列表的时候突然发现，这一年和女票去的最多的那家勿相忘串串，这家我自以为和它一见钟情的串串店，原来早在2017年4月的时候就和它有过邂逅，这不朋友圈里还留着当时到店转发文章集赞的记录吗？这种感觉就很美好，以为是一见倾心，原来早已相逢。（这次题外话真的结束了。）</p><p>17年春节后，第一件大事自然是考研成绩出榜，我记得那天我正好和表弟逛完街回来，到点之后倒也没有特别得着急，说起来可能有的时候人就是知道自己付出了多少努力和应该得到怎样的结果，所以所谓的狂喜都是出现在你知道你的努力配不上结果的时候。</p><p>我走进自己卧室，坐在床沿上，对着面前那张很多年前买的、廉价的、随意用细胶带粘住四个角的、有点破损卷边的火影海报，用我的第三台手机——VIVO X5查出了成绩。</p><p>三位数，四开头，和我预估的分数甚至只误差1分。</p><p>那便够了。</p><p>说一点不开心那太装了，当然开心，心里确实也很轻松，但更多的却是庆幸。</p><p>那天晚上，夜深人静的时候我还坐在家中阳台上，望着寂静的夜空，没有什么星星，但我知道那里真的有。</p><p>然后我在知乎上写了篇回答，回答的是那天刚刚刷出来的热门问题“考研出成绩后，你有什么感受？”。</p><p>每打出一句话就是一层剥离，那半年里将我牢牢捆绑的层层束缚与强压都在回答中褪去了。</p><p>那是于我而言第一次真正的救赎。</p><p>后来也有几个人在回答下留言，有恭喜的，有加油的，当然也有跟我说自身经历和我相似的，告诉我战胜自己的不是我一个人。</p><p>其中有一个2017年九月左右的评论者似乎比我小一届，她说经历一样，她说希望三个月也能逆袭，她说她会努力的。</p><p>我说加油，成功后会感受到不一样。</p><p>我不常看知乎消息，因为没什么存在感，看到她的再次留言已经是2018年年初的事情。</p><p>她说她成功了，成绩比我要更好，她说她反反复复查了好几次，因为不敢相信，她说她这几个月每次撑不下去的时候就会来看看，给自己鼓劲。</p><p>努力的人都能有回报，真好。</p><p>自己能给别人以力量，更好。</p><p> ……</p><p>开学之后，便是忙活毕设和准备答辩，转眼就到了要告别那座生活了四年的学校，现在想来竟然至今都不曾好好在笔下和它说声再见，但若现在再太郑重其事地来说这事的话又难免显得有些不合时宜，所以我说有些话该说的时候就要说，有些事该做的时候就要做，因为过了此时此刻此情此景，就都是他年他月他人他事，而当年的爱又最难提。</p><p>不记得是哪一天从科协收拾东西离开的，只记得那天科协里人挺多，大家都在聊天。</p><p>头顶的日光灯自然是没修好的。</p><p>把东西都塞进书包里，桌上就只剩下那只绿色乌龟玩偶，我喜欢借着它的长脖子把它挂在办公桌的挡板上。</p><p>我把它拿给了ZY，她觊觎此物很久了。</p><p>她可能刚开始没注意到我在收东西，从脑袋上拿下乌龟的时候意识到了啥，伸长脖子看了我的座位一眼，立马炸了。</p><p>“雨哥，你干嘛？”</p><p>“走了啊，你看SSM也收得差不多了。”我笑着摊了摊双手，笑容的弧度保持得很刻意，既不清浅，也不肆意。</p><p>她走到我俩位置前，好像没说啥。</p><p>我伸手把桌上的名牌撕了下来，故作随意地扔给她：“诺，还给你。”</p><p>她一甩手，重新塞到我手里，看着我：“你们的东西你们不留着，给我干嘛？”</p><p>那一刻我也不知哪来的怪脾气做犯，一把拿起名牌，撕了。</p><p>所有人都安静了。</p><p>纸张撕裂的声音惊醒了我，我也不知道自己那一刻是为什么，但我后悔了，可是已经撕了，能咋办？</p><p>所以我继续撕了下去，一至二，二至四，四至八……直到那两个字支离破碎再也拼不回来。</p><p>我望着手里的纸屑，脸上开始烧得滚烫，却不敢抬头。</p><p>那时候我竟有些害怕看到ZY的眼睛，甚至连身边其他人都不敢去看。</p><p>“我靠。”我听到面前女孩压着愠怒的低音。</p><p>我猛然抬起头，眯着眼挤出笑容，强作出一副无所谓的模样：“我也不想留着，就撕了呗。”</p><p>说什么不想留着，还不是一时没想好怎么接话。</p><p>有时候男人要面子的臭毛病真是更加要命。</p><p>她看了我一眼，甩头走了，只抛下一句：“随你。”</p><p>后来真是有点难受，本来按照我的性子这种名牌肯定是要留着的，我甚至连高中第5考场20桌的准考证都留着只为了当时凑个“520”，那天却不知发了什么疯，还惹得别人生气。</p><p>不过好在后来ZY没太生气，请她吃顿饭，小事化了。</p><p>那只绿色乌龟也随着一年后ZY她自己考研成功被带去了南大，可惜她是在仙林校区。</p><p>只不过名牌是真的没了，撒进垃圾桶后，如今恐怕早已腐烂，南农回了几次，但那间小屋子，是再也没进去过了。</p><p>或者应该找个机会，重新让ZY给我做张一模一样的？</p><p>……</p><p>那年初到杭州。</p><p>烟雨江南，满池荷花常开不败。</p><p>匆匆路过，一瞥流连。</p><p>刚到时下雨，我坐在公车上，绕西湖而行，隔着厚厚的玻璃和更厚的雨帘，想要看清朦胧灰白中的西子湖。</p><p>“前面要到于谦祠了。”二公子说。</p><p>啧，有文化的人就是不一样，“岳王庙”、“于谦祠”、“南屏晚钟”、“花港观鱼”，这些词二公子都信手拈来呀！</p><p>我就只知道雷峰塔，里面有法海，镇着一条白蛇，还有个书生叫许仙，人与妖爱得死去活来，却还是没能感动老和尚法海。</p><p>哦，还有断桥残雪，不管是传说还是歌曲都很早就吸引我去走一走，可真等到雨停了走上断桥的时候，我却插着耳机在QQ群里进行党课学习……</p><p>那时苏堤白堤还分不清，后来知道短的是白堤，长的是苏堤，我从断桥走下去的那一道长堤，是白堤。</p><p>即使只是较短的白堤，对我而言走下来也累得不行，实在没有勇气再去挑战苏堤。</p><p>歇脚的时候，我对身边的三公子和四公子说：“这次就走个白堤吧，苏堤明年再来走。”</p><p>“明年雨哥还来杭州？”三公子问。</p><p>“那是。”我也不知道哪来的自信，兴许是眼前粼粼的湖水晃了心神，不要脸说道，“明年我不就去网易实习了？”</p><p>“666！”三公子对着湖风鼓掌。</p><p>四公子更夸张，几乎要当场给我跪下了：“雨哥，带我啊，我也想去网易！”</p><p>翻白眼……</p><p>一年后，我真的去了网易实习，和二公子三公子再次在西湖聚首，但直到离开，也没有去过苏堤。</p><p>西湖是去过不少次，有事没事都爱去走走，但有意无意，每次都没能去苏堤看看。</p><p>暂且不提。</p><p>除了西湖，毕业旅行还和他们一起去了西溪湿地和灵隐寺，西溪湿地是自然，灵隐寺是人文，具体行程已经记不太清了，而且我读书少，不能像二公子一样把游记写得那么好，所以便简笔带过。</p><p>去西溪湿地的时候下着微雨，所以偌大的湿地景区里并没有多少游人，这便便宜了我们几个，倚栏走桥，穿雨过花，不用在意他人目光，摆尽了poss，搞尽了古怪，沾得一身雨露，快哉快哉。</p><p>去灵隐寺的时候是晴天，爬了飞来峰，在山顶的小亭子里坐了会儿，重新下山，下山的时候遇到溪涧，于是只能趟水而过，湿了整双鞋，倒也凉快去乏。</p><p>临走前还去了趟六和塔，爬到塔顶的时候将四周青山绿水收于眼底，清风拂面，铃铛轻响，于是我特意找了个角度拍了张照，想了半天配了首小小诗发了个朋友圈。</p><p>青山朱座，</p><p>替时间上锁。</p><p>天地蹉跎，</p><p>等你遇见我。<br><img src="/2019/02/04/未完待续-叁/psb.jpg"></p><p>哎呀，文字的滋味，有时候真是贪之不厌，即使写得再差也爱。</p><p>……</p><p>临回学校前，又去了一次西湖，想要弥补之前没能好好欣赏盛大音乐喷泉的遗憾，西湖周围的人是真的多——用二公子的话说，“不是溜对象就是溜孩子遛狗的”——而音乐喷泉又是其中数一数二的地方，自然吸引了源源不绝的人，甚至能感受到早晚高峰地铁的热情。</p><p>七点整，音乐起，喷泉开始升起。</p><p>而和喷泉一同升起的，是千千万万只手臂，手臂上是手掌，手掌里有手机。</p><p>这么漂亮的喷泉，自己看不到是可以的，但是一定要给手机那端的他/她看到。</p><p>分享是一件很快乐的事情，而如果你分享的对象也愿意和你分享的话，那快乐就会变成幸福。</p><p>喷泉只有两三曲音乐的时间，有梁祝，也有泰坦尼克号，悠扬的曲调从音响里传出来，被漫天起伏、旋转、挥舞的水流裹挟着飞舞，最后洒进满池湖水，波光粼粼，灯光渺渺。</p><p>和每次都没去成的苏堤相对比，音乐喷泉每次来西湖都会来看，倒是件有些奇怪的事，想来比较靠谱的解释应该是音乐喷泉往后走不远就是商城，吃饭聚餐首选，自然每次都会走到这里来。</p><p>离开杭州的时候，还不知道后来到底能不能再去，所以留了些未竟的心愿，而如今杭州是去过了并生活了半年，但那些想去的地方，却也没真的都走完。</p><p>可能有时候就是这样，明明只是想见你，所以故意落些东西在你家，好成为下次去的借口。</p><p>东西可以不要，但你不能不见。</p><p> ……</p><p>回到学校没歇几天，又去了一次常州恐龙园，这次是和高中挚友们一起，算是整个大学聚得最齐的一次，当然祖国的担当、伟大的军医同志XS照旧缺席。</p><p>说来这还是我第一次去游乐园，可惜女票没空，没有能一起来，她的缺席本就是遗憾，而因为少了她我没有足够的胆子坐上跳楼机过山车，又是更大的遗憾，所以归根结底还是要把锅甩给她，都是她的错！（跪搓衣板可真香！）</p><p>时间过得久了，很多细节都忘了，想要依靠照片寻回一些记忆的时候又发现手机换了，照片零零碎碎不成体统，真是有些让人抓狂，但好在还有人保存着，在此感谢提供老照片的各位，下次不会犯同样的错了。</p><p>去恐龙园的前一晚去了趟环球港，那里有一座摩天轮，如果她在的话，我想那天晚上我可以离星空更近一些。</p><p>吃了一顿避风塘，其他的菜都忘了，唯独记得那份榴莲春卷不错，炸得金黄的皮又脆又酥，榴莲夹心也是回味无穷。</p><img src="/2019/02/04/未完待续-叁/chunjuan.jpg"><p>去过游乐园的人都知道，排队两小时，玩命两分钟，第一次去还是有些放不开，只玩了趟疯狂毒龙钻，emmmm，是叫这个名字吗，还是我……</p><p>常恐：我真的是正经游乐园啊！！！</p><p>总之就是那个左右一百八十度摇摆的大摆锤就对了。</p><p>玩过之后我只能说，失重的感觉真的太难受了，感觉下面漏了，还有就是……活着真好。</p><p>你知道我在上面的时候心里在念叨啥吗？</p><p>“麻痹，你来啊，你还能整死老子不？”</p><p>“卧槽你真的来？”</p><p>“稳住，我们能赢……”</p><p>……</p><p>所以后来看着SYY和CSB两个人坐跳楼机的时候在那玩“落耶落耶”的，我可真是佩服得不行。</p><p>所以他俩后来出了恐龙园要去隔壁玩蹦极的时候我内心十分平静。</p><p>诶，等等，那个摇摆着跟过去的小胖子是什么鬼啊？</p><p>TY？</p><p>你不要命啦！</p><p>刚才在鬼屋里鬼哭狼嚎的时候忘啦！？</p><p>那绳子拴不住你的……</p><p>完了完了……</p><p>她真的跟他们一起上去了……</p><p>……</p><p>我抱头坐在下面的椅子里，想着这个世界一定是疯了。</p><p> ……</p><p>再后来学校里就开始了一系列的散伙饭，班级的、社团的、宿舍的，二公子和五公子整天不见人影，流连于各种酒席，烧烤啤酒旧事，饺子学妹余情。</p><p>用二公子的话说，是真的要吃到吐了。</p><p>但还是餐餐必去，顿顿皆到。</p><p>我倒是没去过几次，毕竟小透明，于是也乐得清闲，和宿舍其余三位公子在宿舍拍了不少合照，吃过一顿烧烤，也曾在午夜沿着中山陵漆黑的山道闲逛，走过下马坊、明孝陵，用手机的流光模式在小路上舞出绚烂的五角星。</p><p>毕业照自然是拍了不少的，古墙青苔的主楼下、大气巍峨的大鼎旁，都有都有。</p><p>拍照的那天是不是还下着小雨？不过部门的小孩们还是都来了，一个个拉着我拍了不少照片，不枉我对他们一年悉心“教导”呀。</p><p>转眼他们现在都要毕业了，而我竟然也又要毕业了，突然觉得自己辈分低了是怎么回事？要绷住要绷住。</p><p>小孩子们，以后也都要一直好好生活下去。<br><img src="/2019/02/04/未完待续-叁/xing.jpg" title="没找到五角星的图，就放这张了"></p><p>那些日子里，女票来了很多次，穿着我的学士服，拍了更多更多的照片。</p><p>和我不同，南农曾经是她想考的大学，只是错过了，但还好，我牵住了她，没让她走太远。</p><p>所以你要是想拍，就拍个够。</p><p>我都替你存着。</p><p> ……</p><p>那四年，终于还是划下了句号。</p><p>起点不算太完美，但终点的句号，好像还算圆润。</p><p>那么，就此别过。</p><p> ……</p><p>2017年9月，南京大学鼓楼校区。</p><p>同一座城市，离南农也不算远，ZSK两年前也搬到了这里，但却偏偏不曾真的来过。</p><p>其实，四年前就想来的啊，只是自己不够争气，倒在了半路。</p><p>真是走得很慢啊，但好在终于还是走到了这里，晚一点到，总比没到过强。</p><p>初来乍到，面对宿舍两尊本土巨佬，我和四公子（他保研也选了南大）一开始是处于瑟瑟发抖的状态的，常常听二佬交流而悟道，唯唯诺诺，晃晃不可终日。</p><p>但后来，发现二佬其实也是二皮脸大逗比，ZSK虽自幼相识，但六年级之后倒也没有再次同班过，印象里可能还保留着小时候的模样，但其实早已蜕变成了逗比中的战斗逼，一口骚话简直难辨雌雄；另一位WKS大佬，那可是能和四公子WJY试比高的资源小王子，足球迷，生活作息算是我见过最规律的——每晚十点必拉屎，拉完屎必洗澡，洗完澡必与父母通个电话，有时后两者会交换顺序，但前者，雷打不动，实乃律己之辈。</p><p>另外还认识了位其他宿舍的大佬，大名JXD，形容他也比较简单——gay逼，还好这货后来找到了女票，要不然还真不敢深交……深交……好像哪里怪怪的……</p><p>阿弥陀佛，我还是直的。</p><p> ……</p><p>当然除此之外还有幸结实了很多其他优秀的同学，真是很庆幸能和你们相识，每个人都有太多值得我学习的地方。</p><p>求学的过程没什么特别值得说的，无非是上了人生中第一堂全英文授课的课，无非又是熬夜复习一夜一门，转眼就到去年春节。</p><p>实习的压力倏忽来到面前，打量自己似乎也就比写“helloworld”强一些，这样怎么有机会找到好实习呢？</p><p>所以当机立断好好学习，一边和JXD互相监督学习一边收快递，最后当当送快递的大叔把书递到我手里的时候看着我意味深长地说道：“小伙子很认真啊！”</p><p>好吧大叔，我知道你是在问我同是当当自营为什么就不能一起买？非要一本本买，你都连续给我送一个礼拜了！</p><p>我也没办法……谁让一会儿觉得看不完一会儿又觉得先买了再说呢……</p><p>总之去年春节似乎回到了考研的状态，看了不少书，刷了不少题，现在想来今年能去网易、能有现在，实实在在要感谢曾经努过力的自己。</p><p>时间，总不会骗人的。</p><p> ……</p><p>如果说2017年的主题是救赎，那么2018年的主题必然是前进了，这一年里几乎一直在求职，从三月份的开始春招找实习，直到十一月份最终选择阅文作为毕业后的第一份工作，大半年来整个人真的体会到了很多很多。</p><p>春招面试的时候，大大小小经历了几十场面试，从紧张到寻常，从定位不准到渐渐明白自己的水平与价值，与其说是面试，倒不如说更像是一次对自己的不断探索、不断寻找。</p><p>就像《猎场》里面，郑秋冬刚刚利用覃飞的身份的时候，也是经过一系列面试来让自己对这个身份更加熟悉，来检验自己的伪装是否到位。</p><p>面试确实是一种对自己很好的锻炼，虽然也曾在面试里回答不出问题痛不欲生，但事后想来终究还是自身太菜的原因，怨不得其他。</p><p>不管是春招还是秋招，我最后选择的竟然都是最后一个面试的公司，也都是在一定意义上面试的时候不抱希望的公司，甚至最后放弃了杭州而选择了魔都这座之前从未考虑过的可怕城市。</p><p>所以人生有时候真是玄之又玄，不可说，不可说。</p><p>时至今日我还记得网易HR告诉我面试通过的那个下午，那时我还在召唤师峡谷里玩个女警苟活发育，哪里也不敢冒头。</p><p>电话来得很突然，像平湖起惊雷，那阵子对浙江杭州的来电简直有一种迷一样的感觉。</p><p>按B回城，连忙接起电话走到阳台上，深深吸气，余光看到刚起床的ZSK坐到我位置上，开始操作我的撸啊撸。</p><p>……</p><p>等我回到座位上的时候，好嘛，这货已经送了两人头在玩黑白游戏。</p><p>局势一度陷入丢龙丢塔丢高地的境地，即使一起开黑的三公子奋力凯瑞似乎也要无力回天。</p><p>然后我有无尽了。</p><p>那时的无尽还没有改版。</p><p>那时的女警还没有成为下水道。</p><p>那时的我心情爆表。</p><p>那时的我们还没有放弃。</p><p>……</p><p>辅助开团。</p><p>上单打野跟上。</p><p>三公子小鱼人侧面切入。</p><p>我拉开距离开始输出。</p><p>枪枪爆头，瞬间吞没敌方四人。</p><p>只剩一人闪现逃窜。</p><p>然而皮城女警最爱的就是追杀。</p><p>微微半蹲，瞄准，红色的准星已经锁定，拉动扳机，让子弹飞一会儿。</p><p>“我？Miss？怎么可能？”</p><p>成功翻盘。</p><p>电子竞技不要放弃。</p><p>人生也不要。</p><p> ……</p><p>再到杭州，这次我不是过客。</p><p>RNG在MSI上摘下奖杯，那五个年轻人相拥着怒吼咆哮，金色的雨从天而降。</p><p>那时我正站在网易门前，耳机里充斥着“恭喜RNG”的声音，一门之隔的网易大厦灯火通明，人来人往，没人会注意到路旁树下持伞独立的男孩。</p><p>可那时的我就敢认为，这一年属于我也属于RNG。</p><p>可惜最后证明我错了，RNG倒在世界赛八强，沦为笑柄，我也没有选择一直在这里待下去。</p><p>刚收到offer的时候我和JXD说这下子我真的没有什么好烦恼的事情了，他说不可能，我这样的人总会有各种各样的烦心事。</p><p>你说的可真特么对，我可谢谢你。</p><p>才实习没几天，自己的积极性就被挫败感冲击得一败涂地，开始陷入阴暗的自我否定中。</p><p>那真是段难熬的日子，而且还孤单一人在陌生的城市，虽然那时候二公子还没去美国还在杭州工作，但毕竟相距颇远，有些感受经过信息电子流发送之后总觉得情不对意，索然无味。</p><p>于是倒头就睡。</p><p>但房间毗邻街道，楼层又高，马路上时不时驶过一辆大货车，就能清晰地感受到自己在晃动，惊得我连忙抱紧我的狗头抱枕。</p><p>房间里不知什么时候飞进来一直苍蝇，“嗡嗡嗡”从耳边飞过，甚至还降落在我的脸上。</p><p>我一个激灵坐起来，靠在床头大口喘气。</p><p>有时候人真是脆弱，黑夜里一只苍蝇都能使之崩溃。</p><p>无奈之下只能起床开灯，把书卷成卷，誓要把那只苍蝇打死以报心头之患。</p><p>于是往往要一直折腾到后半夜才勉强入睡。</p><p>女票来了几次，每晚下班回来走到楼下抬头看到房间里的灯亮着，心情就会稍微好一些。</p><p>第一次她来，走的时候我还在上班，晚上回到家打开房门……这货平时懒得要死，这次却偏偏把房间收拾得既干净又整齐，被子方方正正地叠在床上，门边属于她的那双粉色小拖鞋并排依偎着，灯光只照亮了房间一半，明暗分明。</p><p>只一瞬间我就没能绷住，她肯定是故意的。</p><p>等到艰难地慢慢熟悉了公司环境和工作节奏，终于不再像之前一样整日担惊受怕。</p><p>也是在那个时候，开始反思一些事情。</p><p>被挫败感吞没的时候，会想说如果没来这里，会不会就开心一些？每天上班下班，万家灯火看得太多，真的只会更寂寞。</p><p>但是后来想想，就算没来这，我总归会去一个其他地方实习，到时候恐怕也是一样吧？</p><p>就连ZSK他们刚开始实习的时候也会觉得自己啥也不会。</p><p>那或许情况并没有我想象地那么糟，说不定只是每个人到达一个新环境，每个学生初次工作都会经历的事情呢。</p><p>这里可是网易，是我最想来的地方，难道会更开心？</p><p>应该不会。</p><p>而恰好又在这个时候读文章看到了开头那句话。</p><p>“人总是不愿承认，现在的境遇，就是最好的安排。”</p><p>像是溺水者抓住的最后一根稻草，像是盛夏里最后一丝清风拂过面颊，像是黑夜里最后一丝光芒闪耀。</p><p>人们有时候总是幻想得到更好的，嫌弃自己当下拥有的，却忘了自己现在拥有的很多就是自己过去渴望的最好的，然后越贪婪，然后越埋怨，然后越失去。</p><p> ……</p><p>这半年初步体验了工作赚钱的不易，越发觉得众生皆苦，路上、地铁上、公司里，遇到的每一个成年人，我都忍不住去猜想他们身上都背负着怎样外人看不到的压力。</p><p>隔壁房间的室友有一次空调坏了，需要修外机，空调师傅说需要从我的房间窗户爬出去比较方便。</p><p>于是在接近四十度的大太阳下，男人从十楼的窗户翻了出去，只在腰间绑了根从厨房里好不容易找出来的细绳，用“根”来形容都不免有夸大之嫌，还是用“条”比较合适。</p><p>我和隔壁房间的室友把绳子抓得很紧，心里有些紧张，汗水瞬间湿透衣背，这尼玛要掉下去指不定能不能抓得住啊！</p><p>我建议把绳子绑在类似窗沿或者什么其他的固定物上固定一下，空调师傅摆手大笑：“不用，这才十楼，四十楼的空调不是一样修？你们两年轻力壮小伙子还抓不住？”</p><p>我更慌了，您从我身上是从哪看出年轻力壮来的……</p><p>没办法，我只能在手上把绳子饶了一圈又一圈，生怕有个意外没抓稳。</p><p>但还好一切顺利，空调师傅很快就翻了回来，比了个手势：“搞定。”</p><p>我走到窗前往下看了一眼，十楼的高度瞬间让我感觉有点晕，我缩回脑袋，想着每个人都在为生计奔波，这样的高危职业又能赚到几个钱？</p><p>真是说不出值还是不值。</p><p>空调师傅还在那跟我们侃大山，一边收拾家伙一边说他修空调的经历，有的时候被户主坑了耍了，有的时候修一次空调要跑好多次，有的时候从楼上摔下去，最可怕的一次就是从四十楼摔下去，头上脚下地在空中挂了半个小时，直到救护车赶来。</p><p>他都是笑着说这些事的，生活已经在男人身上留下很多粗糙的痕迹，眼角眉边皱纹隐现，老旧的白背心染了很多油渍灰尘，套上工作服便算完事。</p><p>“还有你的空调，我也顺手看了下，除了点灰。”男人看了我一眼说。</p><p>“哦哦那太感谢了。”</p><p>“不算事，走了。”男人拎起工具箱走了。</p><p>门口楼道里有闪灯一闪一闪，直到我离开也人来修。</p><p>男人站在灯下，黝黑的脸庞一明一暗。</p><p>他忽然抬头，开口骂道：“什么破灯？老子找根棍给你捅灭咯！”</p><p>……</p><p>有时候想着若是把空调师傅他们的压力换到我身上，恐怕就是片刻也会压得我喘不过气来，可他们却依然能在这种平凡甚至是沉重的生活中找到快乐。前阵子看到快手上有个跑运输的司机似乎挺火，三十几岁便已两鬓斑白，抬头纹深到能塞进整条河流。</p><p>他们一样在这地球上生活着，没有光鲜，甚至没有太多钱，他们的苦痛比我不知多出多少，可他们比苦痛更坚强、更坚韧，所以他们依然拥有快乐与幸福。</p><p>这世上的苦难没法击倒人的，能击倒人的只有人。</p><p>实在是太佩服。</p><p>众生皆苦，但众生也都在苦中作乐，并且真的能寻到快乐，这才是众生最值得敬佩的地方，因此他们才活在这世上，因此这世界才太精彩。</p><p>The one与众生，太多人想成为the one，但太多人都只是众生。</p><p>我好像却不是很想成为the one，我偏爱众生。</p><p>有人说明知道生活的残酷并且还热爱它的人就是英雄。</p><p>那众生皆是英雄。</p><p>我希望我也能尽快成为这样的众生、这样的英雄。</p><p> ……</p><p>在网易实习了半年时光，最后却选择了离开，不是说不喜欢它了，而只是自己想换条路去走一走，想看一看别处的风景，即使相比下来可能更加路远水长。</p><p>二公子结束了杭州的工作，转而奔向了美国进修，临行前吃了顿饭，之后也多次进行友好的跨洋交流，二公子还是牛逼的，虽然晚了一年时间，但就像我前面说的，想去的地方，只要最后能去，总比从没去过强。</p><p>半年里女票来了几次，有时会带她去一些地方逛逛；XS和CX也来找我玩过，去的地方也都是西湖沿岸，重复描述没什么必要，只是和女票走了趟九溪十八涧，在走到倒数第二个溪涧的时候没保住“节操”，一脚踏进了冰凉的溪水中，于是彻底放开，嬉闹了很久；和XSCX登了雷峰塔，重温了那段凄美的神话爱情传说。</p><p>除此之外，研究生宿舍三位大佬秋招来网易面试的时候各见了一面，ZSK从北京赶高铁过来，到的时候已经要午夜十二点，下车一甩车门，隔着一条马路就气沉丹田地喊“雨狗”，我可真是去你的。</p><p>最后的时候，JXD也来了杭州，他秋招最终还是选择了杭州的公司，临行前必然要约一波，本来说要他请客，然而又拖了过去，没事，拖到年后开学档次就该上升到水林间了。去了趟APPLE体验店，JXD和WKS已经没救，扑到新款ipad上就是一阵口水与屏幕摩擦的声音，我反正没钱，所以成功地没做一只舔狗。</p><p>离开杭州的那天也在下雨，这座城市似乎整年笼罩在雨水中，太阳只难得几天才有幸露个脸。</p><p>刚开始实习的时候想着要实习半年，觉得那可是一段很长的时间啊。</p><p>可等到离开的时候才发现，半年时光竟然也就这么一晃而过了，还记得第一次在食堂吃免费午餐、在天台吃露天烧烤、组内团建……竟都已一去不复返了。</p><p>离开网易的时候，RNG也正好倒了下来，在一场全年度最不该输的BO5里输了，金色的丰碑坍塌，寂静无声。</p><p>离开网易之后，没休息几天就来了上海，加入了阅文集团，对于一个有写作梦的人来说，最后选择这里好像也没什么太出人意料的地方。</p><p>在这里认识了更多优秀有趣的人，也感觉到自己在做的事好像有点意思，虽然还有很多很多东西要学，但不着急，慢慢学，摆正心态才是正确的，毕竟现在这一切是我自己选的，自己选的就是最好的。</p><p>转眼又是两个月过去，在阅文的实习也快结束了。</p><p>而2019年的春节，就要到了。</p><p>时间永远是这么温柔的杀手。</p><p>这一年，李敖走了；</p><p>这一年，霍金走了；</p><p>这一年，李咏走了；</p><p>这一年，计春华走了；</p><p>这一年，单田芳走了；</p><p>这一年，蓝洁瑛走了；</p><p>这一年，金庸也走了；</p><p>还有太多其他人离我们而去了，把名字都列出来的话估计比这篇文章的字数还多。当然，离开的更多的是你我这样没有名字的众生。</p><p>我们永远不知道和某人某地的相聚会不会是最后一次，所以每一次的相聚都应该用力一些，每一次告别也都应该深情一些。</p><p> ……</p><p>似乎每次落笔都是在看过某部电影之后，《未完待续2》是在看了《驴得水》之后几天写的，而在写这篇文字的第一字时，刚好从《无名之辈》的汹涌情感里抽出身来，可能是因为最近感悟的缘故，我觉得《无名之辈》拍的挺不错，我们都是这个世界上的无名之辈，过着自己的喜怒哀乐，孤独却也相互扶持。</p><p>人类的悲欢虽不相通，但我们还可以相遇、相知、相爱、相拥。</p><p>和我落笔前想的差不多，这一篇《叁》没有写太多的人和事，主要写的是自己今年的一些总结体会，也不知道有没有说清楚说全，但既然是同一个系列，字数也不该差太多，一万字可以了。</p><p>很多人没提到，提到的人也大多都只是一笔带过，我知道这个系列有很多人是为了看我写你写我写他，但这篇有些抱歉，有很多事情没有写，有很多人没出现。</p><p>但请相信，我没有将你们遗忘。</p><p>现在没钱，所以只能你们请我吃饭。</p><p>等我有钱了，就还让你们请我吃饭！</p><p>如果说每个人都是一个点，那么人与人之间的联系便是一根线，这根线会沿着某条轨迹蜿蜒或者笔直地延伸出去，有时候会断，有时候不会，有时候是寻常颜色，有时候它们会加深或变淡，有时候还可能有一条会变成红色。</p><p>这些线条彼此之间有时独立，有时相互影响，最后绘制成一幅恢弘的图画。</p><p>而对于我们，这幅图画还远没有结束。</p><p>既然没有结束，那自然就有未完待续。</p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。全文一万字左右，慎读。本文写于己亥年春节前夕。）&lt;/p&gt;
&lt;p&gt;人们高兴，人们悲哀。&lt;/p&gt;
&lt;p&gt;人们憧憬，人们缅怀。&lt;/p&gt;
&lt;p&gt;一左一右的时间，握在手里放不开。&lt;/p&gt;
&lt;p&gt;人啊，&lt;/p&gt;
&lt;p&gt;总是不愿承认，&lt;/p&gt;
&lt;p&gt;现在的境遇，&lt;/p&gt;
&lt;p&gt;有时候已经是最好的安排。&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下C++基础篇</title>
    <link href="http://yoursite.com/2019/01/26/Linux%E4%B8%8BC-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2019/01/26/Linux下C-基础篇/</id>
    <published>2019-01-26T06:31:12.000Z</published>
    <updated>2019-03-18T12:41:10.876Z</updated>
    
    <content type="html"><![CDATA[<p>以前没系统学过linux下C++的一些基本开发方法，所以抽空在网易云课堂上听了个课程简单学习一下基础，本文记录一下听课中的笔记。</p><p>课程前几章介绍开发环境、linux基础操作、配置SAMBA共享目录啥的就不进行记录了，毕竟听这个课是为了补一下linux下如何进行C++编程的基础知识。</p><p>最简单的两个命令记录一下：</p><p><code>g++ -c main.cpp -o main.o</code>：表示将main.cpp编译成main.o中间文件。</p><p><code>g++ main.o -o helloworld</code>：表示将main.o链接成可执行文件helloworld。</p><p>也可直接：</p><p><code>g++ main.cpp -o helloworld</code></p><a id="more"></a><h1 id="第五章-makefile"><a href="#第五章-makefile" class="headerlink" title="第五章 makefile"></a>第五章 makefile</h1><p>makefile的基本规则在另一篇笔记里记录了，这里只记录几个新的点。</p><h2 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h2><p>增量编译其实在记录makefile的那篇笔记里也提过，就是当某个文件改变时，只增量编译受影响的文件，而不是把整个项目重新编译。</p><p>增量编译是靠文件时间来判断的，查看文件时间可以用：<code>ls -ls --full-time</code></p><p>所谓的比较时间，规则如下：</p><ol><li>如果target不存在，则执行make，否则转2；</li><li>如果dependencies的时间比target时间新，则执行make，否则转3；</li><li>输出已经是最新的了，不执行规则。</li></ol><h2 id="优化makefile"><a href="#优化makefile" class="headerlink" title="优化makefile"></a>优化makefile</h2><p>这个教程里的优化写的比较简单，但也可以学习：</p><ul><li>使用变量、通配符</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">g++  ‐c <span class="variable">$&lt;</span>  ‐o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li>自动罗列*.o文件</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CXX_SOURCES=$(wildcard*.cpp)</span><br><span class="line">CXX_OBJECTS=$(patsubst%.cpp,%.o,<span class="variable">$(CXX_SOURCES)</span>)</span><br></pre></td></tr></table></figure><ul><li>头文件依赖</li></ul><p>使用编译选项-MMD，比如<code>g++ -c -MMD main.cpp -o main.o</code>则会在生成main.o的同时生成main.d文件，该文件里的内容就是所需要的依赖，然后如下操作:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEP_FILES=$(patsubst%.o,%.d,<span class="variable">$(CXX_OBJECTS)</span>)</span><br><span class="line"><span class="section">%.o:%.cpp</span></span><br><span class="line">g++  ‐c‐MMD <span class="variable">$&lt;</span>  ‐o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用‐include指令，将所有的.d文件包含进来</span></span><br><span class="line">‐<span class="keyword">include</span><span class="variable">$(DEP_FILES)</span></span><br></pre></td></tr></table></figure><ul><li>利用foreach函数进行对子目录的支持</li></ul><p>该章节最终的makefile如下，能支持简单使用了：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">######### 标准Makefile Lv1.0 ########</span></span><br><span class="line">EXE=helloworld</span><br><span class="line">SUBDIR=src object</span><br><span class="line"><span class="comment">#CXX_SOURCES=$(wildcard  *.cpp)</span></span><br><span class="line">CXX_SOURCES =<span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(SUBDIR)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.cpp)</span>)</span><br><span class="line">CXX_OBJECTS=<span class="variable">$(<span class="built_in">patsubst</span>  %.cpp, %.o, <span class="variable">$(CXX_SOURCES)</span>)</span></span><br><span class="line">DEP_FILES  =<span class="variable">$(<span class="built_in">patsubst</span>  %.o,  %.d, <span class="variable">$(CXX_OBJECTS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(EXE)</span>: <span class="variable">$(CXX_OBJECTS)</span></span><br><span class="line">g++  <span class="variable">$(CXX_OBJECTS)</span> -o <span class="variable">$(EXE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">g++  -c  -MMD <span class="variable">$&lt;</span>  -o  <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEP_FILES)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">rm  -rf  <span class="variable">$(CXX_OBJECTS)</span>  <span class="variable">$(DEP_FILES)</span>  <span class="variable">$(EXE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">echo <span class="variable">$(CXX_OBJECTS)</span></span><br></pre></td></tr></table></figure><h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><p>在compile这一步添加选项-g，如果没有用-g选项生成的可执行文件虽然也可以gdb运行，但是调试过程中不会显示调试信息，没什么用。</p><p><code>g++ -g main.cpp -o hello</code></p><p>b：添加断点</p><p>r：从头开始运行</p><p>n：下一步</p><p>c：程序继续运行直到下一处断点</p><p>p：显示表达式的值</p><p>info break：显示断点信息</p><p>del break n：删除编号n的断点</p><p>q：退出gdb</p><p>disp：监视变量的值</p><p>x：显示内存：x/16xb n，看16个单元，x表示16进制看，b表示每个单元多少字节，b是1个字节，h是2个字节，w是4个字节，g是8个字节。</p><p>bt：显示堆栈。</p><h2 id="段错误"><a href="#段错误" class="headerlink" title="段错误"></a>段错误</h2><p>在Linux下，程序中如果进行了不正确的指针操作(如空指针访问、野指针访问)，那么程序会崩溃，发生段错误(Segment Fault)。</p><p>很容易复现的话就可以直接用GDB来调试。</p><p>当错误不容易复现的时候，可以使用内存转储的手段。</p><p>内存转储步骤如下：</p><ol><li>ulimit -c unlimited</li><li>运行程序，程序发生段错误退出时会将信息转储到core.*文件中</li><li>用gdb来查看段错误的代码位置<code>gdb exe core.*</code>。</li></ol><p>一个程序生成时用了-g选项的话，生成的可执行文件会更大一些，因为包含了可调式信息。</p><p>如果要判断一个程序是否包含可调式信息，可以用<code>objdump -h helloworld</code>来判断，有debug就是有调试信息。</p><h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><ul><li>单元测试</li><li>段错误的定位</li></ul><h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><ul><li>大型程序</li><li>多线程</li></ul><h1 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h1><h2 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h2><p>编译：<code>g++ -c -fPIC example.cpp -o example.o</code></p><p>链接：<code>g++ -shared example.o -o libexample.so</code></p><p>PIC：position independent code位置无关代码</p><p>动态库命名规范：libxxx.so</p><p>可以使用nm命令查看库中的符号。</p><h2 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h2><p>包含头文件，调用里面的函数即可。</p><p>编译：<code>g++ -c main.cpp -o main.o</code></p><p>链接：<code>g++ main.o -o helloworld -L. -leample</code></p><p>-L.：指定库文件的位置</p><p>-leample：使用libexample.so这个动态库。</p><p>操作系统默认从标准位置寻找相应的库：/lib /usr/lib /usr/local/lib</p><p>如果没有就会去LD_LIBRARY_PATH环境变量里找。</p><p>所以要想使用自己的库，得做好上述设置。</p><h3 id="查看依赖的库"><a href="#查看依赖的库" class="headerlink" title="查看依赖的库"></a>查看依赖的库</h3><p><code>readelf -d helloworld</code></p><p>通常目录结构是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libxxx/</span><br><span class="line">-lib/</span><br><span class="line">-include/</span><br></pre></td></tr></table></figure><p>常用CXXFLAGS表示C++编译选项，LDFLAGS表示链接选项。</p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>命名标准：libxxx.a</p><p>第一步，编译得到.o文件</p><p>第二步，打包<code>ar -rcs libxxx.a file1.o file2.o...</code></p><p>静态库本质就是将.o文件打个包而已，因此可以像.o文件一样使用。</p><p>当静态库和动态库同时存在的时候，会优先选择动态库进行链接，若要使用静调库，泽科使用全路径方式指定静态库。</p><h2 id="c-兼容c的库"><a href="#c-兼容c的库" class="headerlink" title="c++兼容c的库"></a>c++兼容c的库</h2><p>以前就学过，用external “C”即可，但比较好的做法是在.h文件中就写好兼容C和C++的版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="动态库的手工加载"><a href="#动态库的手工加载" class="headerlink" title="动态库的手工加载"></a>动态库的手工加载</h2><p>使用dl库中的函数</p><p>#include&lt;unistd.h&gt;</p><p>#include&lt;dlfcn.h&gt;</p><p>具体再看教程吧，感觉用的不多，主要用dlopen、dlsym和dlclose方法。</p><h1 id="Linux文件读写"><a href="#Linux文件读写" class="headerlink" title="Linux文件读写"></a>Linux文件读写</h1><p>简单来说有两种方式：</p><ol><li>ANSI C，使用stdio.h里的函数fopen、fclose、fwrite、fread。</li><li>Linux API，open、close、write、read</li></ol><p>推荐使用第一种吧，能被各平台支持。</p><p>使用第一种的时候，文件路径使用/，换行符Linux和windows下不同，linux是\n，windows是\n\r。</p><p>普通情况下均推荐使用ANSIC来操作文件。</p><p>仅当该文件表示一个外部设备时，才用LinuxAPI来操作。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>在Linux下，使用pthread库来创建和操作线程，pthread是Linux系统自带的一个库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(&amp;handle,<span class="comment">//指代一个线程对象，pthreat_t类型的实例</span></span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">               function,<span class="comment">//线程入口函数，用函数指针</span></span><br><span class="line">               context<span class="comment">//线程参数</span></span><br><span class="line">              )</span><br></pre></td></tr></table></figure><p>线程主函数退出时，线程自然终止。</p><p>pthread_join（handle，NULL）：等待B线程自然退出，在B线程退出后回收B线程的系统资源。</p><p>pthread_cancel：用于终止取消一个正在运行的线程，不推荐使用。</p><h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><p>pthread_mutex_t hMutex；</p><p>pthread_mutex_init（&amp;hMutext，NULL）；</p><p>pthread_mutext_destroy（&amp;hMutext）；</p><p>pthread_mutext_lock(&amp;hMutex);//不能获取锁的时候会阻塞，但trylock不能获取锁的时候就会直接返回。</p><p>pthread_mutext_unlock(&amp;hMutex);</p><h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sem_t</span> hSem;</span><br><span class="line">sem_init(&amp;hSem,<span class="number">1</span>,initial_value);</span><br><span class="line">sem_destroy(&amp;hSem);</span><br><span class="line">sem_wait(&amp;hSem);</span><br><span class="line">sem_post(&amp;hSem);</span><br></pre></td></tr></table></figure><h1 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h1><p>何为进程？</p><p>当helloworld文件被运行后，在操作系统内部创建一个进程对象。</p><p>查看进程：ps。</p><p>top：实时查看进程。</p><p>kill强制杀死进程。</p><h2 id="前台进程和后台进程"><a href="#前台进程和后台进程" class="headerlink" title="前台进程和后台进程"></a>前台进程和后台进程</h2><p>关闭终端时会关闭前台进程。</p><p>以后台进程运行，在命令行后面加一个&amp;符号。</p><p>前后台进程切换：ctrl+z暂停任务，bg将任务送到后台继续任务，fg将任务拿到前台运行。</p><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>IPC：inter-process communicating。</p><p>四种方式：管道、消息队列、共享内存、网络套接字。</p><p>管道：pipe，是Linux操作系统提供的一个消息传递机制。</p><ol><li>系统中创建一个文件，其文件类型为管道<code>mkfifo message</code></li><li>进程A打开该文件写入数据</li><li>进程B打开该文件读取数据</li></ol><p>open是阻塞的，read也是阻塞的，管道是单向的，和普通文件有区别。</p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>查看可用的系统调用<code>man syscalls</code></p><p>如果找不到对应的系统调用，可以在代码里直接调用命令行，用system().</p><p><code>int ret = system(&quot;rm -rf *.txt&quot;);</code></p><p>该函数会阻塞。</p><p>也可以用popen（）：调用某个命令行，并获取其标准输出。</p><p>该函数是linux特有的，windows下对应的叫_popen/_pclose</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp = popen(<span class="string">"ifconfig"</span>,<span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">int</span> n = fread(buf,<span class="number">1</span>,<span class="number">512</span>,fp);</span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure><h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><p>尽量使用标准函数/类型/语法</p><p>可以用条件编译。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前没系统学过linux下C++的一些基本开发方法，所以抽空在网易云课堂上听了个课程简单学习一下基础，本文记录一下听课中的笔记。&lt;/p&gt;
&lt;p&gt;课程前几章介绍开发环境、linux基础操作、配置SAMBA共享目录啥的就不进行记录了，毕竟听这个课是为了补一下linux下如何进行C++编程的基础知识。&lt;/p&gt;
&lt;p&gt;最简单的两个命令记录一下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;g++ -c main.cpp -o main.o&lt;/code&gt;：表示将main.cpp编译成main.o中间文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;g++ main.o -o helloworld&lt;/code&gt;：表示将main.o链接成可执行文件helloworld。&lt;/p&gt;
&lt;p&gt;也可直接：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;g++ main.cpp -o helloworld&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>makefile学习</title>
    <link href="http://yoursite.com/2019/01/13/makefile%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/13/makefile学习/</id>
    <published>2019-01-13T08:07:47.000Z</published>
    <updated>2019-01-19T03:42:09.535Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单记录下对Makefile学习的一些笔记。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_38391755/article/details/80380786" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38391755/article/details/80380786</a></p><h1 id="makefile简介和例子"><a href="#makefile简介和例子" class="headerlink" title="makefile简介和例子"></a>makefile简介和例子</h1><p>个人感觉makefile就是整个项目工程的一个编译规则，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p><p>该文章是基于GNU make的。</p><a id="more"></a><h2 id="makefile介绍"><a href="#makefile介绍" class="headerlink" title="makefile介绍"></a>makefile介绍</h2><p>makefile主要规则：</p><ol><li>如果一个工程没有编译过，那么我们的所有源文件都要编译并链接；</li><li>如果一个工程的某几个源文件被修改过，那么我们只编译被修改的源文件，并链接目标程序；</li><li>如果头文件改变，那么需要编译引用了该头文件的源文件，并链接目标程序。</li></ol><h2 id="makefile规则"><a href="#makefile规则" class="headerlink" title="makefile规则"></a>makefile规则</h2><p>核心规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">command</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>target是一个目标文件，可以是objectfile，也可以是执行文件，还可以是一个标签。</p><p>prerequisites是要生成target所需的文件或是目标。</p><p>command就make需要执行的命令，即任意的shell命令。</p><p>说白了，所有makefile的东西就是这个规则，但具体还有很多细节。</p><p>【注】在别人的makefile文件中，有时会遇到以下三个变量：$@/$^/$&lt;，含义分别如下：</p><p>$@：目标文件</p><p>$^：所有依赖文件</p><p>$&lt;：第一个依赖文件</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>原文中的示例如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o /</span><br><span class="line">           insert.o search.o files.o utils.o</span><br><span class="line">            cc -o edit main.o kbd.o command.o display.o /</span><br><span class="line">                       insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">    main.o : main.c defs.h</span><br><span class="line">            cc -c main.c</span><br><span class="line">    kbd.o : kbd.c defs.h command.h</span><br><span class="line">            cc -c kbd.c</span><br><span class="line">    command.o : command.c defs.h command.h</span><br><span class="line">            cc -c command.c</span><br><span class="line">    display.o : display.c defs.h buffer.h</span><br><span class="line">            cc -c display.c</span><br><span class="line">    insert.o : insert.c defs.h buffer.h</span><br><span class="line">            cc -c insert.c</span><br><span class="line">    search.o : search.c defs.h buffer.h</span><br><span class="line">            cc -c search.c</span><br><span class="line">    files.o : files.c defs.h buffer.h command.h</span><br><span class="line">            cc -c files.c</span><br><span class="line">    utils.o : utils.c defs.h</span><br><span class="line">            cc -c utils.c</span><br><span class="line">    clean :</span><br><span class="line">            rm edit main.o kbd.o command.o display.o /</span><br><span class="line">               insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>反斜杠（/）是换行符的意思。</p><p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，<strong>一定要以一个Tab键</strong>作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。</p><p>clean不是一个文件，只不过是一个动作名字，有点像C语言中的label一样，其冒号后什么也没有，那么make就不会自动去找文件的依赖性，也不会自动执行其后定义的命令。要执行该命令，就要在make命令后显式指出该label的名字，比如make clean。</p><h2 id="makefile使用变量"><a href="#makefile使用变量" class="headerlink" title="makefile使用变量"></a>makefile使用变量</h2><p>makefile中可以定义变量，变量是一个字符串，用$(name)即可使用。</p><p>所以改良版makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">              insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">    edit : <span class="variable">$(objects)</span></span><br><span class="line">            cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">    main.o : main.c defs.h</span><br><span class="line">            cc -c main.c</span><br><span class="line">    kbd.o : kbd.c defs.h command.h</span><br><span class="line">            cc -c kbd.c</span><br><span class="line">    command.o : command.c defs.h command.h</span><br><span class="line">            cc -c command.c</span><br><span class="line">    display.o : display.c defs.h buffer.h</span><br><span class="line">            cc -c display.c</span><br><span class="line">    insert.o : insert.c defs.h buffer.h</span><br><span class="line">            cc -c insert.c</span><br><span class="line">    search.o : search.c defs.h buffer.h</span><br><span class="line">            cc -c search.c</span><br><span class="line">    files.o : files.c defs.h buffer.h command.h</span><br><span class="line">            cc -c files.c</span><br><span class="line">    utils.o : utils.c defs.h</span><br><span class="line">            cc -c utils.c</span><br><span class="line">    clean :</span><br><span class="line">            rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><h2 id="让make自动推导"><a href="#让make自动推导" class="headerlink" title="让make自动推导"></a>让make自动推导</h2><p>GNU的make很强大，他可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个.o文件后都写上类似的命令。</p><p>只要make看到一个.o文件，它就会自动的把.c文件加入到依赖关系中，比如make找到一个a.o，那么a.c就会是a.o的依赖文件，并且<code>cc -c a.c</code>也会被推导出来，于是我们的makefile又可以更新如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">              insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">    edit : <span class="variable">$(objects)</span></span><br><span class="line">            cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">    main.o : defs.h</span><br><span class="line">    kbd.o : defs.h command.h</span><br><span class="line">    command.o : defs.h command.h</span><br><span class="line">    display.o : defs.h buffer.h</span><br><span class="line">    insert.o : defs.h buffer.h</span><br><span class="line">    search.o : defs.h buffer.h</span><br><span class="line">    files.o : defs.h buffer.h command.h</span><br><span class="line">    utils.o : defs.h</span><br><span class="line"></span><br><span class="line">    .PHONY : clean</span><br><span class="line">    clean :</span><br><span class="line">            rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><p>.PHNOY表示clean是个伪目标文件。</p><h2 id="另类风格的makefile"><a href="#另类风格的makefile" class="headerlink" title="另类风格的makefile"></a>另类风格的makefile</h2><p>如果觉得看到那堆[.o]和[.h]的依赖有点不爽，则可以把重复的.h收拢，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o /</span><br><span class="line">              insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">    edit : $(objects)</span><br><span class="line">            cc -o edit $(objects)</span><br><span class="line"></span><br><span class="line">    $(objects) : defs.h</span><br><span class="line">    kbd.o command.o files.o : command.h</span><br><span class="line">    display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">    .PHONY : clean</span><br><span class="line">    clean :</span><br><span class="line">            rm edit $(objects)</span><br></pre></td></tr></table></figure><p>不过这样依赖关系就不是那么清楚了，看喜欢哪种了，我觉得还是依赖关系看的清楚些好。</p><h2 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h2><p>每个makefile都应该写一个清空目标文件的规则，clean的规则不要放在开头，应该放在最后。</p><p>稳健的做法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">        clean :</span><br><span class="line">                -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><p>rm前加-表示也许某些文件会出问题，但不要管，继续做后面的事。</p><h1 id="makefile总述"><a href="#makefile总述" class="headerlink" title="makefile总述"></a>makefile总述</h1><h2 id="makefile里有什么"><a href="#makefile里有什么" class="headerlink" title="makefile里有什么"></a>makefile里有什么</h2><p>makefile主要包含五个东西：显式规则、隐晦规则、变量定义、文件指示和注释</p><ol><li>显式规则。显式规则说明了，如何生成一个或多个的目标文件，这是由makefile的书写者显式指出要生成的文件、文件的依赖文件以及生成的命令。</li><li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写makefile。</li><li>变量定义。</li><li>文件指示。其包含了三个部分，一个是在一个makefile中引用另一个makefile，就像C中的include一样；另一个是指根据某些情况指定makefile中的有效部分，就像C中的预编译#if一样；还有就是定义一个多行的命令。</li><li>注释。只有行注释，用#字符。</li></ol><h2 id="makefile文件名"><a href="#makefile文件名" class="headerlink" title="makefile文件名"></a>makefile文件名</h2><p>默认情况下，make命令会在当前目录下按顺序查找文件名为”GNUmakefile”、“makefile”和“Makefile”的文件，找到就解释该文件。最好不要用“GNUmakefile”。</p><p>如果要用其他文件名书写，则可以使用如下命令：</p><p><code>make -f yourmake</code>或<code>make --file yourmake</code></p><h2 id="引用其他makefile"><a href="#引用其他makefile" class="headerlink" title="引用其他makefile"></a>引用其他makefile</h2><p>使用include关键字可以把其他makefile包含进来。</p><p><code>include&lt;filename&gt;</code></p><p>在include前可以有空字符，但不能是Tab键，多个文件之间可以用空格隔开。</p><p>include前加-表示无论include过程中出现什么错误，都不要报错，继续执行。</p><p>如果文件没有指定路径的话，make会先在当前目录下找，如果没有找到，那么make还会去以下目录中找：</p><ol><li>若make执行时有参数-I或–include-dir，那么make会去参数指定目录下找</li><li>一般也会去/user/local/bin 或/usr/include中找，如果这些目录存在的话。</li></ol><h2 id="环境变量MAKEFILES"><a href="#环境变量MAKEFILES" class="headerlink" title="环境变量MAKEFILES"></a>环境变量MAKEFILES</h2><p>如果你的当前环境中定义了环境变量MAKEFILES，那么make会把这个变量中的值做一个类似于include的动作。</p><p>不建议设置，如果遇到问题可以去看看这个变量是否被定义了。</p><h2 id="make的工作方式"><a href="#make的工作方式" class="headerlink" title="make的工作方式"></a>make的工作方式</h2><p>make执行步骤如下：</p><ol><li>读入所有makefile</li><li>读入被include的其他makefile</li><li>初始化文件中的变量</li><li>推导隐晦规则，并分析所有规则</li><li>为所有目标文件创建依赖关系链</li><li>根据依赖关系决定哪些目标要重新生成</li><li>执行命令。</li></ol><h1 id="makefile书写规则"><a href="#makefile书写规则" class="headerlink" title="makefile书写规则"></a>makefile书写规则</h1><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p><p>规则的顺序是很重要的，因为makefile中只应该有一个最终目标。</p><p>规则语法之前已经讲过了。</p><p>规则中可以使用通配符，通配符也可以用在变量里。</p><p>比如<code>objects=*.o</code>，但要注意的是通配符并不会展开，objects的值就是“<em>.o”，如要要让通配符在变量中展开，那么可以这样写：`objects=$(wildcard </em>.o)`</p><h2 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h2><p>在大工程中，有大量源文件，通常会把这许多源文件分类存放到不同目录中，所以当make需要去寻找文件的依赖关系时，可以在文件前加上路径，但最好的方法是把路径告诉make，让它自动去找。</p><p>makefile中的特殊变量VPATH就是用来完成该功能的，如果没有声明该变量，那make只会在当前的目录中去找，如果声明了，那当前目录找不到就会去VPATH所指定的目录中找了，多个目录由<strong>冒号</strong>分开。</p><p><code>VPATH = src:../headers</code></p><p>另一个方法是使用make的vpath(全小写)关键字，它和VPATH类似，但更灵活，使用方法有三种：</p><ol><li><code>vpath &lt;pattern&gt; &lt;dirs&gt;</code>为符合pattern的文件指定目录</li><li><code>vpath &lt;patter&gt;</code>清空pattern模式的文件搜索目录</li><li><code>vpath</code>清空所有已经设置好的文件搜索目录</li></ol><p><pattern>中需要包含%通配符，表示匹配零个或若干个字符。</pattern></p><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>在最早的例子里，有一个clean目标，这就是一个伪目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean :</span><br><span class="line">rm *.o temp</span><br></pre></td></tr></table></figure><p>伪目标的取名不能和文件名重名，为了避免这种情况，可以使用特殊标记<code>.PHONY</code>来指明一个目标时伪目标。</p><p><code>.PHONY : clean</code></p><p>makefile的第一个目标会被作为其默认目标。</p><p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性。</p><h2 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h2><p>makefile的规则中的目标可以不止一个，其支持多目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">            generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br><span class="line"><span class="comment"># 等价于如下makefile</span></span><br><span class="line">bigoutput : text.g</span><br><span class="line">            generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">            generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure><p>-$(subst output,,$@)中的$表示执行一个makefile的函数，函数名为subst，后面是参数。</p><p>$@表示目标的集合，就像一个数组，依次取出目标执行命令。</p><h2 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h2><p>静态模式可以更加容易地定义多目标的规则，先看语法：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">            &lt;commands&gt;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p><p>target-parrtern是指明了targets的模式，也就是的目标集模式。</p><p>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p><h2 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h2><p>在makefile中，我们的依赖关系可能会需要包含一系列的头文件，但如果是一个大工程，你必须清楚哪些C文件包含了哪些头文件，并且在加入或删除头文件时也需要小心地修改makefile，这就很麻烦。</p><p>但大多数编译器都支持一个-M的选项，即自动找寻源文件中包含的头文件并生成一个依赖关系。</p><p>如果使用的是GNU的C++编译器，则使用-MM参数，否则会把标准库头文件也输出。</p><p>有点复杂，没看太明白。</p><h1 id="makefile书写命令"><a href="#makefile书写命令" class="headerlink" title="makefile书写命令"></a>makefile书写命令</h1><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以<strong>Tab</strong>键开头，除非命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p><h2 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h2><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。</p><p>当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来。</p><p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile。</p><p>而make参数“-s”或“–slient”则是全面禁止命令的显示。</p><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。</p><h2 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h2><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p><p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p><p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p><p>clean:<br>           -rm -f *.o</p><p>   还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p><p>还有一个要提一下的make的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p><h2 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h2><p> 在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p><p>如果要传递参数到下级makefile，则使用这样的声明<code>export &lt;variable ...&gt;</code></p><p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：<code>unexport &lt;variable ...&gt;</code></p><p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p><p>还有很多参数，具体看原文吧。</p><h2 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h2><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line"></span><br><span class="line">   yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line"></span><br><span class="line">   mv y.tab.c <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">endef</span></span><br></pre></td></tr></table></figure><p>run-yacc就是命令包的名字，像下面这样使用：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line"></span><br><span class="line">          $(run-yacc)</span><br></pre></td></tr></table></figure><h1 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h1><p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。但和宏不同的是，你可以在makefile中改变其值。</p><p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等），且大小写敏感。</p><h2 id="变量的基础"><a href="#变量的基础" class="headerlink" title="变量的基础"></a>变量的基础</h2><p>变量在声明时需要给予初值，使用时加上$符号，如果你要使用真实的“$”字符，那么你需要用“$$”来表示。</p><h2 id="变量中的变量"><a href="#变量中的变量" class="headerlink" title="变量中的变量"></a>变量中的变量</h2><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p><p>第一种就是用等号。</p><p>第二种用“:=”，推荐用这种，但用这种方式下，前面定义的变量不能用后面定义的变量，等号可以.</p><p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p><pre><code>nullstring :=space := $(nullstring) # end of the line</code></pre><p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p><pre><code>dir := /foo/bar    # directory to put the frobs in</code></pre><p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p><p>还有一个比较有用的操作符是“?=”，先看示例：</p><pre><code>FOO ?= bar</code></pre><p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p><pre><code>ifeq ($(origin FOO), undefined)  FOO = barendif</code></pre><h2 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h2><p>第一种是变量值的替换.</p><p>我们可以替换变量中共有的部分,其格式是<code>$(var: a=b)</code>或<code>${var : a=b}</code>。其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p><p>变量替换的还有一种技术是在静态模式中定义的，如：</p><p>foo := a.o b.o c.o<br>​        bar := $(foo:%.o=%.c)</p><p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。</p><p>第二种高级用法是把变量的值再变成变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure><h2 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h2><p>可以使用+=给变量追加值。</p><h2 id="override指示符"><a href="#override指示符" class="headerlink" title="override指示符"></a>override指示符</h2><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; = &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt; := &lt;value&gt;</span><br></pre></td></tr></table></figure><h2 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h2><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令。</p><p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p><h2 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h2><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p><p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p><p>其语法是：</p><pre><code>&lt;target ...&gt; : &lt;variable-assignment&gt;&lt;target ...&gt; : overide &lt;variable-assignment&gt;</code></pre><p><variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</variable-assignment></p><h2 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h2><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p><p><code>%.o : CFLAGS = -O</code></p><h1 id="使用条件判断"><a href="#使用条件判断" class="headerlink" title="使用条件判断"></a>使用条件判断</h1><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p><p>ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>条件表达式的语法为：</p><pre><code>&lt;conditional-directive&gt;&lt;text-if-true&gt;endif</code></pre><p>以及：</p><pre><code>&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif</code></pre><p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个：ifeq、ifneq、ifdef、ifndef。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。</conditional-directive></p><p>在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以[Tab]键开始就行了。</conditional-directive></p><p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p><p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p><h1 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h1><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p><h2 id="函数的调用语法"><a href="#函数的调用语法" class="headerlink" title="函数的调用语法"></a>函数的调用语法</h2><p>函数调用很像变量的使用，也是以$来标识    ，其语法如下：</p><p><code>$(&lt;function&gt; &lt;arguments&gt; )</code>或是<code>${&lt;function&gt; &lt;arguments&gt;}</code>.</p><h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>  <code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; )</code></p><p>名称：字符串替换函数——subst。</p><p>功能：把字串<text>中的<from>字符串替换成<to>。</to></from></text></p><p>返回：函数返回被替换过后的字符串。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p> <code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt; )</code></p><p>名称：模式字符串替换函数——patsubst。</p><p>功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。</pattern></replacement></replacement></pattern></replacement></pattern></text></p><p><code>$(var:&lt;pattern&gt;=&lt;replacement&gt; )</code>相当于<code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><code>$(strip &lt;string&gt; )</code></p><p>名称：去空格函数——strip。</p><p>功能：去掉<string>字串中开头和结尾的空字符。</string></p><p>返回：返回被去掉空格的字符串值。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p><code>$(findstring &lt;find&gt;,&lt;in&gt; )</code></p><p>名称：查找字符串函数——findstring。</p><p>功能：在字串<in>中查找<find>字串。</find></in></p><p>返回：如果找到，那么返回<find>，否则返回空字符串。</find></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><code>$(filter &lt;pattern...&gt;,&lt;text&gt; )</code></p><p>名称：过滤函数——filter。</p><p>功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。</pattern></text></pattern></p><p>返回：返回符合模式<pattern>的字串。</pattern></p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p><code>$(filter-out &lt;pattern...&gt;,&lt;text&gt; )</code></p><p>名称：反过滤函数——filter-out。</p><p>功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可<br>以有多个模式。</pattern></text></pattern></p><p>返回：返回不符合模式<pattern>的字串。</pattern></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p><code>$(sort &lt;list&gt; )</code></p><p>名称：排序函数——sort。</p><p>功能：给字符串<list>中的单词排序（升序）。</list></p><p>返回：返回排序后的字符串。</p><p>备注：sort函数会去掉<list>中相同的单词。</list></p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p><code>$(word &lt;n&gt;,&lt;text&gt; )</code></p><p>名称：取单词函数——word。</p><p>功能：取字符串<text>中第<n>个单词。（下标从一开始）</n></text></p><p>返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空<br>字符串。</text></n></n></text></p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p><code>$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt; )</code></p><p>名称：取单词串函数——wordlist。</p><p>功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。</e></s></e></s></text></p><p>返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那<br>么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单<br>词串。</text></s></text></e></text></s></e></s></text></p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p><code>$(words &lt;text&gt; )</code></p><p>名称：单词个数统计函数——words。</p><p>功能：统计<text>中字符串中的单词个数。</text></p><p>返回：返回<text>中的单词数。</text></p><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p><code>$(firstword &lt;text&gt; )</code></p><p>名称：首单词函数——firstword。</p><p>功能：取字符串<text>中的第一个单词。</text></p><p>返回：返回字符串<text>的第一个单词。</text></p><h2 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h2><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是<br>一系列的文件名来对待。</p><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p><code>$(dir &lt;names...&gt; )</code></p><p>名称：取目录函数——dir。</p><p>功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。</names></p><p>返回：返回文件名序列<names>的目录部分。</names></p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p><code>$(notdir &lt;names...&gt; )</code></p><p>名称：取文件函数——notdir。</p><p>功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”<br>）之后的部分。</names></p><p>返回：返回文件名序列<names>的非目录部分。</names></p><h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><p><code>$(suffix &lt;names...&gt; )</code></p><p>名称：取后缀函数——suffix。</p><p>功能：从文件名序列<names>中取出各个文件名的后缀。</names></p><p>返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。</names></p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h3><p><code>$(basename &lt;names...&gt; )</code></p><p>名称：取前缀函数——basename。</p><p>功能：从文件名序列<names>中取出各个文件名的前缀部分。</names></p><p>返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。</names></p><h3 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h3><p><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt; )</code></p><p>名称：加后缀函数——addsuffix。</p><p>功能：把后缀<suffix>加到<names>中的每个单词后面。</names></suffix></p><p>返回：返回加过后缀的文件名序列。</p><h3 id="6-1"><a href="#6-1" class="headerlink" title="6"></a>6</h3><p><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt; )</code></p><p>名称：加前缀函数——addprefix。</p><p>功能：把前缀<prefix>加到<names>中的每个单词后面。</names></prefix></p><p>返回：返回加过前缀的文件名序列。</p><h3 id="7-1"><a href="#7-1" class="headerlink" title="7"></a>7</h3><p><code>$(join &lt;list1&gt;,&lt;list2&gt; )</code></p><p>名称：连接函数——join。</p><p>功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比&lt;<br>list2&gt;的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比</list2></list1></list1></list1></list2></p><p><list1>多，那么，<list2>多出来的单词将被复制到<list2>中。</list2></list2></list1></p><p>返回：返回连接过后的字符串。</p><p>示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。</p><h2 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h2><p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的<br>foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin<br>/csh）中的foreach语句而构建的。它的语法是：</p><p><code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt; )</code></p><p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。  </text></text></text></text></var></list></p><p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var></var></text></list></var></p><h2 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h2><p><code>$(if &lt;condition&gt;,&lt;then-part&gt; )</code>或<code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt; )</code></p><p>  可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。</else-part></then-part></condition></p><p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part="">会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</else-part></else-part></condition></then-></condition></p><p>所以，<then-part>和<else-part>只会有一个被计算。  </else-part></then-part></p><h2 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h2><p>  call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是</p><p><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code></p><p>当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。  </expression></parm3></parm2></parm1></expression></p><h2 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h2><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的。</p><p><code>$(origin &lt;variable&gt; )</code></p><p>如果variable没有被定义过，返回undefined</p><p>如果是一个默认定义，就返回default</p><p>如果是环境变量，返回environment</p><p>如果是被定义在makefile中，返回file</p><p>如果是命令行定义的，返回command line</p><p>如果是被override指示符重新定义的，返回override</p><p>如果是一个命令运行中的自动化变量，返回automatic。</p><h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号”`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。</p><h2 id="控制make的函数"><a href="#控制make的函数" class="headerlink" title="控制make的函数"></a>控制make的函数</h2><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p><p>  <code>$(error &lt;text ...&gt; )</code></p><p>产生一个致命的错误，<text ...="">是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。</text></p><p><code>$(warning &lt;text ...&gt; )</code></p><p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。  </p><h1 id="make的运行"><a href="#make的运行" class="headerlink" title="make的运行"></a>make的运行</h1><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。</p><h2 id="make的退出码"><a href="#make的退出码" class="headerlink" title="make的退出码"></a>make的退出码</h2><p>make命令执行后有三个退出码：</p><p>0——成功</p><p>1——make运行时出现任何错误，其返回1</p><p>2——如果使用了make的-q选项，并且make使得一些目标不需要更新，那么返回2。</p><h2 id="指定makefile"><a href="#指定makefile" class="headerlink" title="指定makefile"></a>指定makefile</h2><p>除了按照默认规则寻找makefile，也可以指定特殊名字的makefile。</p><p><code>make -f filename</code>或者<code>make --file filename</code></p><p>如果在make的命令行时，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p><h2 id="指定目标"><a href="#指定目标" class="headerlink" title="指定目标"></a>指定目标</h2><p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。</p><p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p><p>具体可以看原文，比如常见的有“all”、“clean”、“install”等等。</p><h2 id="检查规则"><a href="#检查规则" class="headerlink" title="检查规则"></a>检查规则</h2><p>  有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p><p>“-n”</p><p>“–just-print”</p><p>“–dry-run”</p><p>“–recon”</p><p>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。  </p><p>“-t”</p><p>“–touch”</p><p>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p><p>“-q”</p><p>“–question”</p><p>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p><p>“-W <file>”</file></p><p>“–what-if=<file>”</file></p><p>“–assume-new=<file>”</file></p><p>“–new-file=<file>”</file></p><p>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p><h2 id="make的参数"><a href="#make的参数" class="headerlink" title="make的参数"></a>make的参数</h2><p>  “-b”</p><p>“-m”</p><p>这两个参数的作用是忽略和其它版本make的兼容性。</p><p>“-B”</p><p>“–always-make”</p><p>认为所有的目标都需要更新（重编译）。  </p><p>“-C <dir>”</dir></p><p>“–directory=<dir>”</dir></p><p>指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</p><p>“–debug[=<options>]”</options></p><p>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。</p><p>-i”</p><p>“–ignore-errors”</p><p>在执行时忽略所有的错误。</p><p>“-I <dir>”</dir></p><p>“–include-dir=<dir>”</dir></p><p>指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p><p>还有看原文吧，感觉不用的话看了也记不住，就不搬过来了。</p><h1 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h1><p>  在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p><p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。  </p><h2 id="使用隐含规则"><a href="#使用隐含规则" class="headerlink" title="使用隐含规则"></a>使用隐含规则</h2><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。</p><h2 id="隐含规则一览"><a href="#隐含规则一览" class="headerlink" title="隐含规则一览"></a>隐含规则一览</h2><p>这里列一下隐含规则，当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p><ol><li>编译C的隐含规则。</li><li>编译C++的隐含规则。</li><li>编译Pascal的隐含规则。</li><li>编译Fortran/Ratfor程序的隐含规则。</li><li>预处理Fortran/Ratfor程序的隐含规则。</li><li>编译Modula-2程序的隐含规则。</li><li>汇编和汇编预处理的隐含规则。</li><li>链接Object文件的隐含规则。“<n>” 目标依赖于“<n>.o”。</n></n></li><li>Yacc C程序时的隐含规则。</li><li>Lex C程序时的隐含规则。</li><li>Lex Ratfor程序时的隐含规则。</li><li>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</li></ol><h2 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h2><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p><p>具体看原文吧。</p><h2 id="隐含规则链"><a href="#隐含规则链" class="headerlink" title="隐含规则链"></a>隐含规则链</h2><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p><p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。</p><p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p><h2 id="定义模式规则"><a href="#定义模式规则" class="headerlink" title="定义模式规则"></a>定义模式规则</h2><p>  你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p><p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。  </p><h3 id="模式规则介绍"><a href="#模式规则介绍" class="headerlink" title="模式规则介绍"></a>模式规则介绍</h3><p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。</p><h3 id="模式规则示例"><a href="#模式规则示例" class="headerlink" title="模式规则示例"></a>模式规则示例</h3><p>把所有的.c文件都编译成.o文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h3><p>  在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p><p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p><p>$@：表示规则中的目标文件集。 </p><p>$%：仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p><p>$&lt;：依赖目标中的第一个目标名字。</p><p>$?：所有比目标新的依赖目标的集合。以空格分隔。</p><p>$^：所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p><p>$+：这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p><p>$*：这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，”$*”的值就是”dir/a.foo”。</p><p>  最后想提醒一下的是，对于”$&lt;”，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，”$(&lt; )”就要比”$&lt;”要好一些。</p><p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。  </p><h3 id="模式的匹配"><a href="#模式的匹配" class="headerlink" title="模式的匹配"></a>模式的匹配</h3><p>  一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。</p><p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat” 匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）  </p><h3 id="重载内建隐含规则"><a href="#重载内建隐含规则" class="headerlink" title="重载内建隐含规则"></a>重载内建隐含规则</h3><p>你可以重载内建的隐含规则（或是定义一个全新的）。</p><h3 id="老式风格的后缀规则"><a href="#老式风格的后缀规则" class="headerlink" title="老式风格的后缀规则"></a>老式风格的后缀规则</h3><p>  后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。</p><p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o : %c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”% : %.c”。</p><p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c” 是源文件的后缀，”.o”是目标文件的后缀。  </p><p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p><p>而要让make知道一些特定的后缀，我们可以使用伪目标”.SUFFIXES”来定义或是删除。</p><h3 id="隐含规则搜索算法"><a href="#隐含规则搜索算法" class="headerlink" title="隐含规则搜索算法"></a>隐含规则搜索算法</h3><p>比如有一个目标T，下面列出搜索目标T的规则的算法：</p><ul><li><p>把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）</p></li><li><p>创建所有匹配于T或是N的模式规则列表。</p></li><li><p>如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。</p></li><li><p>移除列表中没有命令的规则。</p></li><li><p>对于第一个在列表中的模式规则：</p><ol><li>推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。</li><li>计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</li><li>测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）</li><li>如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</li></ol></li><li>如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<ol><li>如果规则是终止规则，那就忽略它，继续下一条模式规则。</li><li>计算依赖文件。（同第5步）</li><li>测试所有的依赖文件是否存在或是理当存在。</li><li>对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</li><li>如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</li></ol></li><li>如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。</li></ul><p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p><h1 id="使用make更新函数库文件"><a href="#使用make更新函数库文件" class="headerlink" title="使用make更新函数库文件"></a>使用make更新函数库文件</h1><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p><h2 id="函数库文件的成员"><a href="#函数库文件的成员" class="headerlink" title="函数库文件的成员"></a>函数库文件的成员</h2><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p><p><code>archive(member)</code></p><p>  这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o) : hack.o</span><br><span class="line">ar cr foolib hack.o</span><br></pre></td></tr></table></figure><h2 id="函数库成员的隐含规则"><a href="#函数库成员的隐含规则" class="headerlink" title="函数库成员的隐含规则"></a>函数库成员的隐含规则</h2><p>当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o” 的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o。</p><h2 id="函数库文件的后缀规则"><a href="#函数库文件的后缀规则" class="headerlink" title="函数库文件的后缀规则"></a>函数库文件的后缀规则</h2><p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line"><span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line"><span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。</p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单记录下对Makefile学习的一些笔记。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.csdn.net/weixin_38391755/article/details/80380786&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weixin_38391755/article/details/80380786&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;makefile简介和例子&quot;&gt;&lt;a href=&quot;#makefile简介和例子&quot; class=&quot;headerlink&quot; title=&quot;makefile简介和例子&quot;&gt;&lt;/a&gt;makefile简介和例子&lt;/h1&gt;&lt;p&gt;个人感觉makefile就是整个项目工程的一个编译规则，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;
&lt;p&gt;该文章是基于GNU make的。&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++编程规范笔记</title>
    <link href="http://yoursite.com/2018/12/27/C-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/27/C-编程规范笔记/</id>
    <published>2018-12-27T15:19:08.000Z</published>
    <updated>2018-12-27T15:24:50.736Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：</p><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/</a></p><a id="more"></a><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><h2 id="Self-contained-头文件"><a href="#Self-contained-头文件" class="headerlink" title="Self-contained 头文件"></a>Self-contained 头文件</h2><p>头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code>.h</code> 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code>.inc</code> 结尾。不允许分离出 <code>-inl.h</code> 头文件的做法.</p><h2 id="define保护"><a href="#define保护" class="headerlink" title="#define保护"></a>#define保护</h2><p>所有头文件都应该使用 <code>#define</code> 来防止头文件被多重包含, 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code> ，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef FOO_BAR_BAZ_H_</span><br><span class="line">#define FOO_BAR_BAZ_H_</span><br><span class="line">...</span><br><span class="line">#endif // FOO_BAR_BAZ_H_</span><br></pre></td></tr></table></figure><h2 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h2><p>尽可能地避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p><h2 id="include-的路径及顺序"><a href="#include-的路径及顺序" class="headerlink" title="#include 的路径及顺序"></a><code>#include</code> 的路径及顺序</h2><p>使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h.</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>鼓励在 <code>.cc</code> 文件内使用匿名命名空间或 <code>static</code> 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。且要在命名空间的最后注释出命名空间的名字。</p><h2 id="匿名命名空间和静态变量"><a href="#匿名命名空间和静态变量" class="headerlink" title="匿名命名空间和静态变量"></a>匿名命名空间和静态变量</h2><p>在 <code>.cc</code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p><p>匿名命名空间的声明和具名的格式相同，在最后注释上 <code>namespace</code></p><h2 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h2><p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p><p>【注】有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</p><h2 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h2><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="构造函数的职责"><a href="#构造函数的职责" class="headerlink" title="构造函数的职责"></a>构造函数的职责</h2><p>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p><p>如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式.</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 <code>explicit</code> 关键字.</p><p>一个例外是, 拷贝和移动构造函数不应当被标记为 <code>explicit</code>, 因为它们并不执行类型转换.</p><h2 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h2><p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p><p>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <code>public virtual Clone()</code> 和一个 <code>protected</code> 的拷贝构造函数以供派生类实现.</p><h2 id="结构体-VS-类"><a href="#结构体-VS-类" class="headerlink" title="结构体 VS. 类"></a>结构体 VS. 类</h2><p>当只有数据成员时使用 <code>struct</code>, 其它一概使用 <code>class</code>.</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 <code>public</code> 继承.</p><p>必要的话, 析构函数声明为 <code>virtual</code>. 如果你的类有虚函数, 则析构函数也应该为虚函数，数据成员都必须是私有的。</p><p>对于重载的虚函数或虚析构函数, 使用 <code>override</code>, 或 (较不常用的) <code>final</code> 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 <code>virtual</code> 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 <code>override</code>, <code>final</code> 或 <code>virtual</code> 的其中之一进行标记. 标记为 <code>override</code> 或 <code>final</code> 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code>Interface</code>为后缀的纯接口类</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是指满足特定条件的类, 这些类以 <code>Interface</code> 为后缀 (不强制).</p><p>当一个类满足以下要求时, 称之为纯接口:</p><ul><li>只有纯虚函数 (“<code>=0</code>”) 和静态函数 (除了下文提到的析构函数).</li><li>没有非静态数据成员.</li><li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 <code>protected</code>.</li><li>如果它是一个子类, 也只能从满足上述条件并以 <code>Interface</code> 为后缀的类继承.</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p><h2 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h2><p>将 <em>所有</em> 数据成员声明为 <code>private</code>, 除非是 <code>static const</code> 类型成员</p><p>存取函数一般内联在头文件中。</p><h2 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h2><p>将相似的声明放在一起, 将 <code>public</code> 部分放在最前.</p><p>类定义一般应以 <code>public:</code> 开始, 后跟 <code>protected:</code>, 最后是 <code>private:</code>. 省略空部分.</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数顺序"><a href="#函数顺序" class="headerlink" title="函数顺序"></a>函数顺序</h2><p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p><h2 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h2><p>我们倾向于编写简短, 凝练的函数.</p><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须加上 <code>const</code>.</p><p>总而言之, 大多时候输入形参往往是 <code>const T&amp;</code>. 若用 <code>const T*</code> 则说明输入另有处理. 所以若要使用 <code>const T*</code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p><p>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code>std::vector</code> 以便使用者可以用列表初始化指定参数.</p><h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#function-overloading" target="_blank" rel="noopener">函数重载</a> 遵循同样的规则. 一般情况下建议使用函数重载。</p><h2 id="函数返回类型后置语法"><a href="#函数返回类型后置语法" class="headerlink" title="函数返回类型后置语法"></a>函数返回类型后置语法</h2><p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p><h1 id="来自Google的奇技"><a href="#来自Google的奇技" class="headerlink" title="来自Google的奇技"></a>来自Google的奇技</h1><h2 id="所有权与智能指针"><a href="#所有权与智能指针" class="headerlink" title="所有权与智能指针"></a>所有权与智能指针</h2><p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p><p>不要使用 <code>std::auto_ptr</code>, 使用 <code>std::unique_ptr</code> 代替它.</p><h2 id="Cpplint"><a href="#Cpplint" class="headerlink" title="Cpplint"></a>Cpplint</h2><p>使用 <code>cpplint.py</code> 检查风格错误，可以单独下载使用。</p><h1 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h1><h2 id="引用参数-1"><a href="#引用参数-1" class="headerlink" title="引用参数"></a>引用参数</h2><p>所有按引用传递的参数必须加上 <code>const</code>.</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 <code>std::forward</code>.</p><h2 id="变长数组和-alloca"><a href="#变长数组和-alloca" class="headerlink" title="变长数组和 alloca()"></a>变长数组和 alloca()</h2><p>我们不允许使用变长数组和 <code>alloca()</code>，改用更安全的分配器（allocator），就像 <code>std::vector</code> 或 <code>std::unique_ptr&lt;T[]&gt;</code>.</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>我们允许合理的使用友元类及友元函数.</p><p>某些情况下, 相对于将类成员声明为 <code>public</code>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>我们不使用 C++ 异常.</p><h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><p>我们禁止使用 RTTI。</p><p>RTTI允许程序员在运行时识别C++类对象的类型，通过使用typeid或者dynamic_cast完成。</p><p>在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免.</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用 <code>int y = (int)x</code> 或 <code>int y = int(x)</code> 等转换方式</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>只在记录日志时使用流.</p><p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code> 之类的代替.</p><h2 id="前置自增和自减"><a href="#前置自增和自减" class="headerlink" title="前置自增和自减"></a>前置自增和自减</h2><p>对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</p><h2 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a><code>const</code> 用法</h2><p>我们强烈建议你在任何可能的情况下都要使用 <code>const</code>. 此外有时改用 C++11 推出的 constexpr 更好。</p><h2 id="constexpr-用法"><a href="#constexpr-用法" class="headerlink" title="constexpr 用法"></a><code>constexpr</code> 用法</h2><p>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>C++ 内建整型中, 仅使用 <code>int</code>. 如果程序中需要不同大小的变量, 可以使用 <code>&lt;stdint.h&gt;</code> 中长度精确的整型, 如 <code>int16_t</code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 <code>int64_t</code>. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。</p><p>不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p><h2 id="64位下的可移植性"><a href="#64位下的可移植性" class="headerlink" title="64位下的可移植性"></a>64位下的可移植性</h2><p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记。</p><h2 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h2><p>使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p><ul><li>不要在 <code>.h</code> 文件中定义宏.</li><li>在马上要使用时才进行 <code>#define</code>, 使用后要立即 <code>#undef</code>.</li><li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li><li>不要用 <code>##</code> 处理函数，类和变量的名字。</li></ul><h2 id="0-nullptr-和-NULL"><a href="#0-nullptr-和-NULL" class="headerlink" title="0, nullptr 和 NULL"></a>0, <code>nullptr</code> 和 <code>NULL</code></h2><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>&#39;\0&#39;</code>.</p><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 这一点是毫无争议的.</p><p>对于指针 (地址值), 到底是用 <code>0</code>, <code>NULL</code> 还是 <code>nullptr</code>. C11 项目用 <code>nullptr</code>; C03 项目则用 <code>NULL</code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 <code>NULL</code> 的定义比较特殊，可以输出有用的警告，特别是 <code>sizeof(NULL)</code> 就和 <code>sizeof(0)</code> 不一样。</p><p>字符 (串) 用 <code>&#39;\0&#39;</code>, 不仅类型正确而且可读性好.</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</p><p>使用 <code>sizeof(varname)</code> 是因为当代码中变量类型改变时会自动更新. 您或许会用 <code>sizeof(type)</code> 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>用 <code>auto</code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>你可以用列表初始化。但千万别直接列表初始化 auto 变量。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p><h2 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h2><p>不要使用复杂的模板编程</p><h2 id="Boost库"><a href="#Boost库" class="headerlink" title="Boost库"></a>Boost库</h2><p>只使用 Boost 中被认可的库.</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>适当用 C11（前身是 C0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。</p><h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h1><h2 id="通用命令规则"><a href="#通用命令规则" class="headerlink" title="通用命令规则"></a>通用命令规则</h2><p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p><h2 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h2><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p><p>可接受的文件命名示例:</p><ul><li><code>my_useful_class.cc</code></li><li><code>my-useful-class.cc</code></li><li><code>myusefulclass.cc</code></li></ul><h2 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h2><p>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>.</p><h2 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h2><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int kDaysInAWeek = 7;</span><br></pre></td></tr></table></figure><h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>.</p><p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>).</p><h2 id="命名空间命名"><a href="#命名空间命名" class="headerlink" title="命名空间命名"></a>命名空间命名</h2><p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p><h2 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h2><p>枚举的命名应当和常量或宏一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>.</p><h2 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h2><p>如果你一定要用宏, 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p><h2 id="命名规则的特例"><a href="#命名规则的特例" class="headerlink" title="命名规则的特例"></a>命名规则的特例</h2><p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h2><p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p><h2 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h2><p>在每一个文件开头加入版权公告.</p><h2 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h2><p>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p><h2 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h2><p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p><h2 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h2><p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p><p>如果变量可以接受 <code>NULL</code> 或 <code>-1</code> 等警戒值, 须加以说明.</p><h2 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h2><p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p><h2 id="标点-拼写和语法"><a href="#标点-拼写和语法" class="headerlink" title="标点, 拼写和语法"></a>标点, 拼写和语法</h2><p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p><h2 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h2><p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释.</p><h2 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h2><p>通过弃用注释（<code>DEPRECATED</code> comments）以标记某接口点已弃用.</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h2><p>每一行代码字符数不超过 80.</p><h2 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h2><p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p><h2 id="空格还是制表符"><a href="#空格还是制表符" class="headerlink" title="空格还是制表符"></a>空格还是制表符</h2><p>只使用空格, 每次缩进 2 个空格.</p><p>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</p><h2 id="函数声明与定义"><a href="#函数声明与定义" class="headerlink" title="函数声明与定义"></a>函数声明与定义</h2><p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用一致.</p><p>注意以下几点：</p><ul><li>使用好的参数名.</li><li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li><li>如果返回类型和函数名在一行放不下, 分行.</li><li>如果返回类型与函数声明或定义分行了, 不要缩进.</li><li>左圆括号总是和函数名在同一行.</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li><li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li><li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li><li>右圆括号和左大括号间总是有一个空格.</li><li>所有形参应尽可能对齐.</li><li>缺省缩进为 2 个空格.</li><li>换行后的参数保持 4 个空格的缩进.</li></ul><h2 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p><p>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格。</p><p>参数也可以放在次行, 缩进四格。</p><h2 id="列表初始化格式"><a href="#列表初始化格式" class="headerlink" title="列表初始化格式"></a>列表初始化格式</h2><p>您平时怎么格式化函数调用, 就怎么格式化列表初始化。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.</p><p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格</p><h2 id="循环和开关选择语句"><a href="#循环和开关选择语句" class="headerlink" title="循环和开关选择语句"></a>循环和开关选择语句</h2><p><code>switch</code> 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 <code>{}</code> 或 <code>continue</code>，而不是一个简单的分号.</p><h2 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h2><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>) 之后不能有空格.</p><p>在多重声明中不能使用 &amp; 或 *。</p><h2 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h2><p>如果一个布尔表达式超过 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#line-length" target="_blank" rel="noopener">标准行宽</a>, 断行方式要统一一下.</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>不要在 <code>return</code> 表达式里加上非必须的圆括号.</p><h2 id="变量及数组初始化"><a href="#变量及数组初始化" class="headerlink" title="变量及数组初始化"></a>变量及数组初始化</h2><p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可.</p><p>请务必小心列表初始化 <code>{...}</code> 用 <code>std::initializer_list</code> 构造函数初始化出的类型. 非空列表初始化就会优先调用 <code>std::initializer_list</code>, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用 <code>std::initializer_list</code> 构造函数, 请改用括号.</p><p>此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</p><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>预处理指令不要缩进, 从行首开始.</p><p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p><h2 id="类格式"><a href="#类格式" class="headerlink" title="类格式"></a>类格式</h2><p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p><ul><li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li><li>关键词 <code>public:</code>, <code>protected:</code>, <code>private:</code> 要缩进 1 个空格.</li><li>除第一个关键词 (一般是 <code>public</code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li><li>这些关键词后不要保留空行.</li><li><code>public</code> 放在最前面, 然后是 <code>protected</code>, 最后是 <code>private</code>.</li></ul><h2 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h2><p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p><h2 id="命名空间格式化"><a href="#命名空间格式化" class="headerlink" title="命名空间格式化"></a>命名空间格式化</h2><p>命名空间内容不缩进.</p><h2 id="水平留白"><a href="#水平留白" class="headerlink" title="水平留白"></a>水平留白</h2><p>水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p><p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉。</p><h2 id="垂直留白"><a href="#垂直留白" class="headerlink" title="垂直留白"></a>垂直留白</h2><p>垂直留白越少越好.</p><p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p><h1 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h1><h2 id="现有不合规范的代码"><a href="#现有不合规范的代码" class="headerlink" title="现有不合规范的代码"></a>现有不合规范的代码</h2><p>对于现有不符合既定编程风格的代码可以网开一面.</p><h2 id="Windows代码"><a href="#Windows代码" class="headerlink" title="Windows代码"></a>Windows代码</h2><p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>运用常识和判断力, 并且 <em>保持一致</em>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>《Redis设计与实现》笔记</title>
    <link href="http://yoursite.com/2018/12/09/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/</id>
    <published>2018-12-09T08:33:16.000Z</published>
    <updated>2019-02-10T06:55:18.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h1><p>在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8</p><a id="more"></a><h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sds.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用该结构比直接使用C字符串有以下好处：</p><ol><li>获取字符串长度的复杂度从O（n）降低到O（1）；</li><li>杜绝缓冲区溢出，SDS在进行字符串操作时会先检查是否有足够的空间p11；</li><li>减少修改字符串时带来的内存重分配次数，通过free字段，SDS实现了空间预分配和惰性空间释放两种优化策略。对于空间预分配策略而言，如果对SDS修改后len小于1MB，则将分配和len相同长度的未使用空间，如果修改后len大于1MB，则分配1MB的未使用空间；对于惰性空间释放，则是说缩短字符串长度时，并没有真正释放空间，而是将free值增大而已，便于将来可能有的增长操作。另外SDS也提供了相应的API用来真正释放未使用空间。</li><li>C字符串中不能包含空字符，所以也不能保存像图片、音频等二进制数据，但SDS可以，它是二进制安全的。</li><li>兼容部分C字符串函数，如strcasecamp、strcat。</li></ol><p>主要API见p17。</p><h1 id="第三章-链表"><a href="#第三章-链表" class="headerlink" title="第三章 链表"></a>第三章 链表</h1><p>当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除此以外，发布与订阅、慢查询、监视器等功能也用到了链表。</p><h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//adlist.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode* head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode* tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> * ptr,<span class="keyword">void</span> * key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>双端</li><li>无环</li><li>有头尾节点</li><li>有链表长度计数器</li><li>多态，链表节点使用void*指针保存节点值，所以可以保存各种不同类型的值</li></ul><p>API见p21</p><h1 id="第四章-字典"><a href="#第四章-字典" class="headerlink" title="第四章 字典"></a>第四章 字典</h1><p>Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查也是构建在对字典的操作之上的。当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h/dictht</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;<span class="comment">//dictEntry定义也在dict.h中，每个dictEntry保存一个键值对</span></span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">//指向下个hash表节点，形成链表，解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;distEntry;</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引，当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*keyDup)(<span class="keyword">void</span> * privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*valDup)(<span class="keyword">void</span> privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span>* key1,<span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure><p>一般情况下，字典只使用ht[0]哈希表，ht[1]只会在对ht[0]进行rehash时使用。</p><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>Redis计算哈希值和索引值的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字典设置的哈希函数计算键key的哈希值</span></span><br><span class="line">hash=dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">//使用哈希表的sizemask属性和哈希值计算出索引值，根据情况不同，ht[x]可以是ht[0] 或 //ht[1]</span></span><br><span class="line">index=hash&amp;dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>因为dictEntry节点组成的链表没有指向链表尾部的指针，所以在哈希冲突的时候为了速度考虑，程序总是将新节点添加到链表的表头位置（O（1）），排在已有元素前面。</p><p>当字典呗用作数据库或哈希键的底层实现时，Redis使用MurmurHash2算法来计算哈希值。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会增多或减少，为了保证负载因子在一个合理的范围内，则需要对哈希表的大小进行相应的扩展或者收缩，这可以通过rehash来完成。</p><p>步骤如下：</p><ol><li>为ht[1]分配空间，如果是扩展操作，则大小等于第一个大于等于ht[0].used*2的2^n，如果是收缩操作，则大小等于第一个大于等于ht[0].used的2^n；</li><li>将ht[0]中的所有键值对重新计算哈希值和索引值放入ht[1]中；</li><li>释放ht[0]，并将ht[1]置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次做准备。</li></ol><p>当以下条件之一满足时，会开始扩展：</p><ol><li>服务器没有执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于1；</li><li>服务器在执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于5；</li></ol><p>当负载因子小于0.1时，或进行收缩操作。</p><h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>为了避免一次性rehash对服务器性能造成影响，服务器分多次、渐进地将ht[0]慢慢rehash到ht[1]。</p><p>步骤如下：</p><ol><li>为ht[1]分配空间；</li><li>在字典中维持一个索引计数器变量rehashidx，并将它赋值为0，标志rehash开始；</li><li>在rehash期间，每次对字典执行增删改查时，除了执行该操作外，还会顺带将ht[0]中rehashidx上的所有键值对rehash到ht[1]上，当rehash完成后，rehashidx++；</li><li>当ht[0]所有键值对都rehash到ht[1]上时，rehashidx置为-1，结束rehash。</li></ol><p>在rehash期间，删改查会在两个哈希表上进行，而增操作只会在ht[1]上进行。</p><p>主要API见p36.</p><h1 id="第五章-跳跃表"><a href="#第五章-跳跃表" class="headerlink" title="第五章 跳跃表"></a>第五章 跳跃表</h1><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>查找效率平均水平O（logN），最坏O（N），大部分情况下，跳跃表的效率可以和平衡树媲美，所以有些程序可以用跳跃表来代替平衡树。</p><p>Redis使用跳跃表来作为有序集合键的底层实现之一，也被用在集群节点中，其余地方没有再用。</p><p>如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会用跳跃表来作为有序集合键的底层实现。</p><h2 id="跳跃表实现"><a href="#跳跃表实现" class="headerlink" title="跳跃表实现"></a>跳跃表实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点 redis.h/zskiplistNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//层，程序可以通过层来加快访问其他节点的速度，一般来说</span></span><br><span class="line">    <span class="comment">//层越多，访问其他节点的速度就越快</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针，用于从表头向表尾方向访问节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度，跨度越大，相距越远，与遍历操作无关，是用来计算排位的，排位就是在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来的值</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值，可相同</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象，不可相同</span></span><br><span class="line">    robj* obj;</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure><p>多个跳跃表节点就可以组成一个跳跃表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量，不算表头节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> longn length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数，每个层高都是1至32之间的随机数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure><p>API见p45</p><h1 id="第六章-整数集合"><a href="#第六章-整数集合" class="headerlink" title="第六章 整数集合"></a>第六章 整数集合</h1><p>整数集合（intset）时候集合键的底层实现之一，当一个集合只包含整数值元素，并且集合元素数量不多时，Redis就会使用整数集合来作为集合键的底层实现。</p><h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并保证不会重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intset.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组，各个项在数组中升序排列，虽然声明写的是int8_t，但真正保存的类型取决于encoding属性的值，分别能存16/32/64位的整数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长的时候，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。</p><p>升级分三步：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间；</li><li>将原来的所有元素都转换成新类型，注意这里扩展空间后原来的元素是从后往前被重新放到正确的位置上的</li><li>添加新元素</li></ol><p>向整数集合中添加新元素的时间复杂度是O（n）</p><p>升级的好处：</p><ol><li>提升灵活性</li><li>节约内存</li></ol><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>要注意的是，整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p><p>API见p51</p><h1 id="第七章-压缩列表"><a href="#第七章-压缩列表" class="headerlink" title="第七章 压缩列表"></a>第七章 压缩列表</h1><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且每个列表项要么是小整数要么是长度比较短的字符串，Redis就会使用压缩列表来做列表键的底层实现。哈希键同理。</p><h2 id="压缩列表构成"><a href="#压缩列表构成" class="headerlink" title="压缩列表构成"></a>压缩列表构成</h2><p>压缩列表各个组成部分以及书名</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">长度（字节）</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">zlbytes</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4</td><td style="text-align:center">整个压缩表占用的内存字节数</td></tr><tr><td style="text-align:center">zltail</td><td style="text-align:center">uint32_t</td><td style="text-align:center">4</td><td style="text-align:center">压缩表表尾节点距离起始地址有多少字节</td></tr><tr><td style="text-align:center">zllen</td><td style="text-align:center">uint16_t</td><td style="text-align:center">2</td><td style="text-align:center">压缩列表包含的节点数量，当该值等于UINT16_MAX时，节点真实数量需要遍历整个压缩列表得出</td></tr><tr><td style="text-align:center">entryX</td><td style="text-align:center">列表节点</td><td style="text-align:center">不定</td><td style="text-align:center">各个节点长度由保存的内容决定</td></tr><tr><td style="text-align:center">zlend</td><td style="text-align:center">uint8_t</td><td style="text-align:center">1</td><td style="text-align:center">0xFF，标志末尾</td></tr></tbody></table><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中字节数组可以是以下三种长度中的一种：</p><ol><li>长度小于（2^6-1）</li><li>长度小于2^14-1</li><li>长度小于2^32-1</li></ol><p>而整数值可以是六种长度中的一种：</p><ol><li>4位长，介于0至12之间的无符号整数；</li><li>1字节长有符号整数</li><li>3字节长有符号整数</li><li>int16_t</li><li>int32_t</li><li>int64_t</li></ol><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。</p><p>previous_entry_length可以是1字节或5字节长，如果前一节点的长度小于254字节，则previous_entry_length是1字节，保存前一个节点的长度，如果前一节点的长度大于等于254字节，则previous_entry_length长度是五字节，其中第一字节被置为0xFE，而后四个字节用来保存前一节点的长度。这个属性可以用来逆序遍历节点。</p><p>encoding属性记录节点的conten属性所存数据的类型和长度，具体可以看p56，简单来说以11开头表示整数编码，content存的是整数，而以00/01/10开头则表示content存的是字节数组，后面几位存的是长度。</p><h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>添加和删除节点都可能导致连锁更新的现象，所谓连锁更新，简单来说就是原来e1…eN存的都是250~253字节的数据，那么它们的previous_entry_length只需要1字节，但如果这时在e1之前插入一个大于等于254长度的数据，那么e1的previous_entry_length就不够了，就要从1字节扩充成5字节，但这就导致e1长度超过253字节，导致后续所有节点都要重新分配内存，这就是连锁更新，最坏时间复杂度将达到O（n^2）。</p><p>但要注意的是，连锁更新真正造成性能问题的几率是很低的，因为O（n^2）的时间复杂度是在很极端的情况下达到的，所以平均复杂度只是线性的。</p><p>具体API见p59</p><h1 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章 对象"></a>第八章 对象</h1><p>前面介绍了Redis用到的主要数据结构，但Redis并没有直接使用这些数据结构，而是基于这些数据结构创建了一个对象系统。</p><p>Redis对象系统实现了基于引用计数的内存回收机制，还通过引用计数实现了对象共享机制，最后对象带有访问时间记录信息。</p><h2 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h2><p>每当在Redis数据中新创建一个键值对时，都至少会创建两个对象，每个对象都由一个redisObject表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisObject;</span><br></pre></td></tr></table></figure><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对象的type属性记录了对象的类型，type属性对应REDIS_STRING/REDIS_LIST/REDIS_HASH/REDIS_SET/REDIS_ZSET五中类型中的一种。</p><h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，一共有八种。。</p><p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码。</p><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，则字符串对象会将字符串对象的编码设置为int。</p><p>如果一个字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，则用一个SDS来保存，编码设置为raw。</p><p>如果一个字符串对象保存的是一个字符串值，并且长度小于等于32字节，则使用embstr编码的方式来保存。</p><p>int和embstr编码的字符串对象会在某些情况下转换为raw编码，比较特殊的一点是embstr编码的字符串对象实际上时只读的，当修改值的时候就会变成raw。</p><h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>当列表对象同时满足以下两个条件的时候，使用ziplist编码：</p><ol><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；</li></ol><p>否则使用linkedlist编码。</p><h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>当哈希对象同时满足以下两个条件时，使用ziplist编码：</p><ol><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个。</li></ol><p>否则使用hashtable编码。</p><h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是intset或者hashtable。</p><p>当集合对象同时满足以下两个对象时，使用intset编码：</p><ol><li>集合对象保存的所有元素都是整数；</li><li>集合对象保存的元素数量不超过512个。</li></ol><p>否则使用hashtable编码。</p><h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist。</p><p>skiplist编码的有序结合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist* zsl;<span class="comment">//按分值从小到大保存了所有集合元素</span></span><br><span class="line">    dict* dict;<span class="comment">//创建了一个从成员到分值的映射</span></span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure><p>当有序集合对象同时满足以下两个条件时，可以使用ziplist编码：</p><ol><li>有序集合保存的元素数量小于128个；</li><li>有序集合保存的所有元素成员的长度都小于64字节；</li></ol><p>否则使用skiplist编码。</p><h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>在Redis中，有些命令可以在多种类型上执行，但有些则不行。</p><p>为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入建的类型是否正确，然后再决定是否执行该命令。</p><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>每个对象的引用计数信息由redisObject结构的refcount属性记录，即是基于引用计数的内存回收机制。</p><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>除了用于实现内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p><p>目前来说，Redis会在初始化服务器时创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当需要用到的时候，服务器就会使用这些共享对象。</p><h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>Redis中的RedisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。</p><p>利用OBJECT IDLETIME命令可以打印出给定键的空转时长，即当前时间减去lru时间算出的值。</p><h1 id="第九章-数据库"><a href="#第九章-数据库" class="headerlink" title="第九章 数据库"></a>第九章 数据库</h1><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每一个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中所有数据库</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>默认情况下，客户端的目标数据库为0号数据库，但可以通过SELECT命令切换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录客户端当前正在使用的数据库库</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p>目前Redis没有可以返回客户端目标数据库的命令。</p><h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//数据库建空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict* dict;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure><p>在读取一个键之后，服务器会根据键是否存在来更新键的hit次数和miss次数，这两个值可以在INFO stats命令的keyspace_hits和keyspace_misses属性中查看。</p><h2 id="设置生存时间或过期时间"><a href="#设置生存时间或过期时间" class="headerlink" title="设置生存时间或过期时间"></a>设置生存时间或过期时间</h2><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，过期后就会自动删除生存时间为0的键。</p><p>而EXPIREAT或PEXPIREAT命令则以秒或毫秒给数据库中的某个键设置过期时间，过期时间是一个UNIX时间戳，当该时间来临时服务器自动删除该键。</p><p>其中EXPIRE、PEXPIRE、EXPIREAT三个命令最后都是转换成PEXPIREAT一样。</p><p>redisDb结构中会有一个名为expires的字典，该字典中保存了数据库中所有键的过期时间，这个字典也被称作过期字典。</p><p>过期字典的键是一个指针，这个指针指向键空间中的某个键对象，值是一个longlong类型的整数。</p><p>PERSIST命令可以移除一个键的过期时间，即将该键值对从过期字典中移除。</p><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>有三种不同的删除策略：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。【对CPU不友好，内存友好】</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键，如果没有过期就返回该键。【CPU友好，内存不友好】</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。【结合】</li></ul><h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>使用的是惰性删除和定期删除两种策略。</p><p>惰性删除在db.c/expireIfNeeded方法中。</p><p>定期删除策略在redis.c/activeExpireCycle方法中。周期性执行，每次执行的时候，则在规定时间内分多次遍历服务器中的各个数据库，随机检查一部分键的过期时间并删除过期的。</p><h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><h3 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h3><p>在执行SAVE命令或者BGSAVE创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件中。</p><h3 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h3><p>如果服务器以主服务器模式运行，那么在载入RDB文件时会进行检查，过期键会被忽略。</p><p>如果以从服务器模式运行，那么不会检查，所有键都被载入。但因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以一般也不会有影响。</p><h3 id="AOF写入"><a href="#AOF写入" class="headerlink" title="AOF写入"></a>AOF写入</h3><p>如果数据库中的某个键已经过期但还没有被惰性删除或定期删除，那么AOF文件不会因此而有任何影响，但当过期键被惰性删除或者定期删除之后，程序就会向AOF文件追加一条DEL命令，显示记录该键被删除。</p><p>AOF重写和RDB类似，不会管已过期的键。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li>主服务器删除一个键后，会向所有从服务器发送一个del命令，通知从服务器删除该键；</li><li>从服务器本身不会删除键，即使该键已经过期，也仍然按未过期处理，该get还是能get到，只有在收到主服务器的del命令时才进行删除。</li></ul><h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>该功能可以让客户端通过订阅给定的频道或者模式，来获取数据库中键的变化，以及数据库中命令的执行情况。</p><p>分为两种：</p><ul><li>键空间通知：某个键执行了什么命令</li><li>键事件通知：某个命令被什么键执行了</li></ul><p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型。</p><h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现，具体实现见p120.</p><h1 id="第十章-RDB持久化"><a href="#第十章-RDB持久化" class="headerlink" title="第十章 RDB持久化"></a>第十章 RDB持久化</h1><h2 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h2><p>Save和BGSAVE两个命令都可以生成RDB文件，但又有不同，save是阻塞的，而BGSAVE则是生成一个子进程创建RDB文件，父进程继续处理命令请求。</p><p>实际工作由rdb.c/rdbSave函数完成，上述两个命令都是调用该函数的，载入时实际调用的函数是rdb.c/rdbLoad函数。</p><p>在执行BGSAVE命令期间，客户端发送的SAVE和GBSAVE命令会被服务器拒绝，而对于BGREWRITEAOF则会等到BGSAVE写完后再调用。</p><p>如果BGREWRITEAOF执行期间调用了BGSAVE，则BGSAVE会被拒绝。</p><p>载入RDB文件期间，服务器会一直处于阻塞状态。</p><h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>Redis会定期使用BGSAVE命令，当Redis服务器启动时，用户可以指定配置文件或传入启动参数设置save选项，若用户没有指定则使用默认的。</p><p>save 900 1</p><p>save 300 10</p><p>save 60 10000</p><p>接着设置服务器状态redisServer结构的saveparams属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>* <span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//修改计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="comment">//上一次执行bgsave的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">//修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务器会以100ms为周期周期性执行函数serverCron，该函数用于对正在运行的服务器进行维护，它会检查save属性中设置的条件是否已经满足，满足就执行BGSAVE。</p><h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p>Redis文件所包含的各个部分：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">REDIS</td><td style="text-align:center">db_version</td><td style="text-align:center">databases</td><td style="text-align:center">EOF</td><td style="text-align:center">check_num</td></tr></tbody></table><p>RDB文件的最开头是REDIS部分，长度5字节，保存“REDIS”五个字符，用来判断文件是否是RDB文件。</p><p>db_version长度为4字节，记录RDB文件的版本号。</p><p>databases包含着另个或多个数据库，以及各个数据库中的键值对数据。</p><p>EOF长度为1字节，标志着RDB文件正文内容的结束。</p><p>check_num是一个8字节的无符号整数，保存一个检验和。</p><h3 id="database部分"><a href="#database部分" class="headerlink" title="database部分"></a>database部分</h3><p>database部分可以保存任意多个非空数据库，每个非空数据库在RDb文件中可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读的是一个数据库号码。</p><p>db_number保存一个数据库号码，根据号码大小不同，长度可以是1字节、2字节或5字节。</p><p>当程序读入该部分后，服务器会调用SELECT命令切换到对应数据库。</p><p>key_value_pairs部分保存该数据库中所有键值对数据。</p><h3 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h3><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成。</p><p>带有过期时间的键值对的结构由五部分组成：EXPIRETIME_MS、ms、TYPE、key以及value。</p><p>根据TYPE不同，不同类型的值对象在RDB文件中的保存结构都不相同，详细见p128起的叙述，这里只简单记录一下。</p><ul><li>字符串对象，有两种编码：REDIS_ENCODING_INT或者REDIS_ENCODING_RAW，如果是前者则按照ENCODING和integer两部分保存，若是后者，则又有压缩或不压缩两种方式保存。</li><li>列表对象，TYPE的值为REDIS_RDB_TYPE_LIST，则表示value存的是REDIS_ENCODING_LINKEDLIST编码对象，RDB中保存结构分为list_length、item1、item2…itemN。</li><li>集合对象，编码REDIS_ENCODING_HT，也是分为长度和元素集合存储。</li><li>哈希表对象，也是长度，后面跟各个kv对。</li><li>有序集合对象，也一样，长度跟上分值和成员本身值。</li><li>INTSET编码的集合，存的时候整数转换成字符串存，取的时候再转换回整数。</li><li>ZIPLIST编码的列表、哈希表或者有序集合，存的时候是把压缩列表转换成了一个字符串对象。</li></ul><h2 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h2><p>od命令可以打印RDB文件</p><p><code>od -c dump.rdb</code></p><p>具体可看这一节书中的例子。</p><p>Redis本身带有RDB检查工具redis-check-dump。</p><p>od命令加上-c参数和-x参数可以同时以ASCII编码和十六进制显示，便于查看检验和。</p><h1 id="第十一章-AOF持久化"><a href="#第十一章-AOF持久化" class="headerlink" title="第十一章 AOF持久化"></a>第十一章 AOF持久化</h1><p>AOF(Append Only File)</p><p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p>是纯文本格式。</p><h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>AOF持久化功能的实现可以分为命令追加append、文件写入、文件同步sync三个步骤。</p><p>服务器配置的appendfsync选项有三个值：always、everysec和no。</p><table><thead><tr><th>appendfsync的值</th><th>flushAppendOnlyFile的行为</th></tr></thead><tbody><tr><td>always</td><td>将aof_buf缓冲区的所有内容写入并同步到AOF文件</td></tr><tr><td>everysec</td><td>将aof_buf缓冲区的所有内容写入到AOF文件，但每隔一秒才同步一次</td></tr><tr><td>no</td><td>只写，不同步，什么时候同步由操作系统控制</td></tr></tbody></table><h2 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h2><ol><li>创建一个不带网络连接的微客户端；</li><li>从AOF文件中分析并读取一条写命令；</li><li>使用伪客户端执行读出的写命令；</li><li>重复步骤2和3，直到AOF文件中所有写命令都被处理完毕。</li></ol><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>随着时间流逝，AOF文件内容会越来越多，为了解决AOF文件体积膨胀的问题，Redis提供了AOF重写功能，新AOF文件中不会包含任何浪费空间的冗余命令，所以体积要小很多。</p><p>虽然功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读写操作，真正操作时读取服务器当前的数据库状态来实现的。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写时会先检查元素数量，如果超过<code>redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>值时，就分成多条命令来写，所以并不是简单的一个键值对数据用一条命令来代替，具体见p147。</p><p>为了避免AOF操作重写造成线程长时间阻塞，会让子进程执行重写，这就是AOF后台重写，但这样又会导致子进程在重写的时候父进程执行了新的写操作，使得子进程重写后的AOF文件并不一致。</p><p>为了解决这个问题，Redis设置了一个AOF重写缓冲区，这个缓冲区在子进程被创建之后开始使用，当Redis执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程接收到该信号之后会调用一个信号处理函数，并执行以下两步：</p><ol><li>将AOF重写缓冲区的所有内容写入到新AOF文件中；</li><li>对新的AOF文件进行改命，原子地覆盖原有的AOF文件。</li></ol><p>完成这两步后，父进程就可以正常接收命令请求了。</p><p>整个步骤里，父进程只有在最后调用信号处理函数的时候会阻塞。</p><p>这就是AOF后台重写，也是命令BGREWRITEAOF命令的实现原理。</p><h1 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章 事件"></a>第十二章 事件</h1><p>Redis服务器是一个事件驱动程序，需要处理以下两类事件：</p><ol><li>文件事件（file event）：服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象，完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作需要在给定的时间点执行，时间事件就是对这类定时操作的抽象。</li></ol><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>使用I/O多路复用来同时监听多个套接字。</p><p>是基于Reactor模式实现的网络通信程序。</p><p>文件事件处理器有四个组成部分：套接字、I/O多路复用程序、文件时间分派器（dispatcher）以及事件处理器。</p><p>尽管多个文件事件可能会并发出现，但I/O多路复用程序总是将所有产生事件的套接字都放在一个队列里，然后通过这个队列以有序地、同步地、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后，再进行下一个。</p><p>I/O多路复用程序的实现中包装了常见的select、epoll、evport和kqueue。</p><p>有两类事件：AE_READABLE和AE_WRITABLE。</p><p>如果一个套接字同时产生了这两种事件，那么文件事件分派器优先处理AE_READABLE事件。</p><p>文件事件有多个处理器，最常用的是连接应答处理器、命令请求处理器和命令回复处理器。</p><p>具体看p156.</p><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类：</p><ul><li>定时事件</li><li>周期性事件</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li>id，全局唯一，新的比旧的大</li><li>when：毫秒精度unix时间戳，记录时间事件的到达时间</li><li>timeProc：时间事件处理器，一个函数。如果该函数返回值为AE_NOMORE，则为定时事件，否则是周期性事件。</li></ul><p>书上说目前版本的Redis只使用了周期事件。</p><p>在实现方面，服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表找到所有已到达的时间事件，并调用相应的事件处理器。</p><p>【注】在目前的版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，在benchmark模式下也只有两个时间事件，所以用无序链表不会影响性能。</p><h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>事件的调度和执行由<code>ae.c/aeProcessEvents</code>函数负责，大致逻辑如下：</p><ol><li>获取到达时间离当前时间最近的时间事件，最计算出距离还有多少毫秒赋值给remaind_ms</li><li>如果剩余时间小于0，则将remaind_ms更新为0</li><li>根据remaind_ms创建一个timeval结构</li><li>根据timeval结构阻塞并等待文件事件产生，如果remaind_ms==0，则不阻塞</li><li>处理所有产生的文件事件</li><li>处理所有已到达的时间事件</li></ol><p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数。<br><img src="/2018/12/09/《Redis设计与实现》笔记/redisServerMainLoop.png" title="Redis服务器主循环"></p><h1 id="第十三章-客户端"><a href="#第十三章-客户端" class="headerlink" title="第十三章 客户端"></a>第十三章 客户端</h1><p>Redis服务器是典型的一对多服务器程序。</p><p>对于每个与服务器进行连接的客户端，服务器都会其建立了相应的<code>redis.h/redisClient</code>结构，该结构保存了客户端当前的状态信息以及相关数据结构。</p><p>Redis服务器状态结构的clients属性是一个链表，保存了所有与服务器相连的客户端的状态结构。</p><h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><p>客户端属性可以分为两类：</p><ol><li>一类是比较通用的属性；</li><li>另一类是和特定功能相关的属性，比如操作数据库时用到的db属性等等。</li></ol><h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>fd属性的值是-1或者大于-1的整数，-1表示伪客户端，其他表示普通客户端。</p><h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><p>name属性一般是空，但可以使用CLIENT setname设置一个，使得客户端更好区分。</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>flags属性记录了客户端的角色以及目前所处的状态，具体各个标志可看书p165或redis.h源码。</p><h3 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h3><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求。</p><h3 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h3><p>在服务器将客户端发送的命令请求保存到客户端的输入缓冲区之后，服务器会解析得到命令参数以及参数个数，并把这两个值分别保存到argv属性和argc属性。</p><h3 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h3><p>服务器之后会到命令表（一个字典）中根据argv[0]的值查找命令实现的一个数据结构redisCommand，argv[0]不区分大小写，找到后将客户端状态的cmd属性指向该结构。</p><h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区中，每个客户端都有两个输出缓冲区可用，一个大小固定，一个大小可变。</p><ul><li>大小固定的缓冲区用于保存长度比较小的回复</li><li>大小可变的缓冲区用于保存长度比较大的回复</li></ul><p>大小固定的缓冲区由buf和bufpos两个属性组成，buf是一个大小为<code>REDIS_REPLY_CHUNK_BYTES</code>字节的字节数组，而bufpos属性则记录buf数组已使用的字节数量，数组长度默认16KB。</p><p>可变大小缓冲区由reply链表和一个或多个字符串对象组成。</p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>authenticated属性用于记录客户端是否通过了身份验证，仅在服务器启用了身份验证功能时使用。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>c_time：记录创建客户端的时间，CLIENT list命令的age域记录了这个秒数。</p><p>lastinteraction属性记录客户端与服务器最后一次互动的时间，idle域记录该秒数。</p><p>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制的时间。</p><h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><h3 id="普通客户端"><a href="#普通客户端" class="headerlink" title="普通客户端"></a>普通客户端</h3><p>创建普通客户端时，就把新的客户端状态添加到服务器状态结构clients链表的末尾。</p><p>普通客户端被关闭的原因有多种：</p><ul><li>客户端进程退出或者被杀死；</li><li>客户端向服务器发送了带有不符合协议格式的命令请求；</li><li>客户端成了CLIENT KILL命令的目标；</li><li>客户端空转时间超过了timeout配置选项（有一些例外情况见书上p173）</li><li>客户端发送的命令请求大小超过输入缓冲区限制大小；</li><li>要发送给客户端的命令回复大小超过了输出缓冲区的限制。服务器使用两种模式来限制客户端输出缓冲区的大小：硬性限制和软性限制。</li></ul><h2 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h2><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中；</p><p>lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</p><h2 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h2><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后关闭该伪客户端。</p><h1 id="第十四章-服务器"><a href="#第十四章-服务器" class="headerlink" title="第十四章 服务器"></a>第十四章 服务器</h1><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p><h2 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h2><ol><li>客户端向服务器发送命令请求，命令请求会转换成协议格式发送</li><li>服务器接受命令请求并存入客户端状态的输入缓冲区中，然后处理，在数据库中进行设置操作，并产生命令回复</li><li>服务器将命令回复发送给客户端</li><li>客户端接受服务器返回的命令回复并将命令回复打印给用户观看</li></ol><h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>serverCron函数默认每隔100ms执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><h3 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h3><p>为了减少对当前时间系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存了秒级精度的系统当前unix时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">//保存了毫秒级精度的系统当前unix时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个属性记录的时间精确度并不高，当需要执行高精度时间的功能来说，服务器还是会再次执行系统调用。</p><h3 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h3><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，也是服务器时间缓存的一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//默认每十秒更新一次，用于计算键的空转时长</span></span><br><span class="line">    <span class="keyword">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空转时间就是lruclock-lru的值，当然只是一个模糊估计值。</p><h3 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h3><p>serverCron函数中的trackOperationsPerSecond函数会以抽样计算的方式估算并记录最近一秒钟处理的命令请求数量，可通过INFO status命令中的instantaneous_ops_per_sec查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//上一次抽样的时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_last_sample_time;</span><br><span class="line">    <span class="comment">//上一次抽样时服务器已执行命令的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_last_sample_ops;</span><br><span class="line">    <span class="comment">//数组中的每一项记录了一次抽象结果</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_samples[REDIS_OPS_SEC_SAMPLES];</span><br><span class="line">    <span class="comment">//数组索引，每次抽样后加1，索引到最后一格则变成0，形成环形数组</span></span><br><span class="line">    <span class="keyword">int</span> ops_sec_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数组中记录的值是根据服务器平均每一毫秒处理了多少个命令请求乘以1000估算出来的。</p><p>instantaneous_ops_per_sec的值则是根据环形数组里的值求平均数得到的估算值。</p><h3 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h3><p>服务器状态中的stat_peak_memory属性记录该值。</p><h3 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h3><p>收到该信号后悔调用sigtermHandler函数，会打开服务器状态的shutdown_asap标志，用于关闭服务器。</p><h3 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h3><p>serverCron函数中每次都会调用clientsCron函数，该函数会对一些客户端进行一些检查。</p><h3 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h3><p>serverCron函数每次都会调用databasesCron函数，会对一部分数据库进行检查。</p><h3 id="执行被延迟的BGREWRITEAOF命令"><a href="#执行被延迟的BGREWRITEAOF命令" class="headerlink" title="执行被延迟的BGREWRITEAOF命令"></a>执行被延迟的BGREWRITEAOF命令</h3><p>服务器状态的aof_rewrite_scheduled标志记录是否延迟。</p><h3 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h3><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，也可以用来查询这两个命令是否在执行。</p><img src="/2018/12/09/《Redis设计与实现》笔记/持久化检查.png" title="判断是否需要执行持久化操作"><h3 id="将AOF缓冲区中的内容写入AOF文件"><a href="#将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="将AOF缓冲区中的内容写入AOF文件"></a>将AOF缓冲区中的内容写入AOF文件</h3><h3 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h3><h3 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h3><p>该值记录serverCron函数执行的次数。</p><h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><p>服务器从刚启动到能够接受客户端命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p><h3 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h3><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为各个属性设置默认值。</p><p>主要函数是initServerConfig，会做以下工作：</p><ul><li>设置服务器的运行ID</li><li>设置服务器的默认运行频率。</li><li>设置服务器的默认配置文件路径</li><li>设置服务器的运行架构</li><li>设置服务器的默认端口号</li><li>设置服务器的默认RDB和AOF持久化条件</li><li>初始化LRU时钟</li><li>创建命令表</li></ul><h3 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h3><h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>在initServerConfig函数中只初始化了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，这里列两个比较熟悉的，更多数据结构见书：</p><ul><li>server.clients链表</li><li>server.db数组</li></ul><p>主要函数是initServer函数，除了初始化数据结构外，该函数还做了一些其他重要的操作设置：</p><ul><li>为服务器设置进程信号处理器</li><li>创建共享对象</li><li>打开服务器监听端口</li><li>为serverCron函数创建时间事件</li><li>检查AOF</li><li>初始化后台I/O模块</li></ul><h3 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h3><h3 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h3><h1 id="第十五章-复制"><a href="#第十五章-复制" class="headerlink" title="第十五章 复制"></a>第十五章 复制</h1><p>在Redis中，用户可以通过SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，则被复制的服务器为主服务器，进行复制的称作从服务器。</p><h2 id="旧版复制功能的实现（2-8版本以前）"><a href="#旧版复制功能的实现（2-8版本以前）" class="headerlink" title="旧版复制功能的实现（2.8版本以前）"></a>旧版复制功能的实现（2.8版本以前）</h2><p>Redis的复制功能分为同步（sync）和命令传播两个操作。</p><p>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p><p>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致时，让主从服务器数据重新回到一致的状态。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当客户端向从服务器发送SLAVEOF命令时，要求从服务器复制主服务器，从服务器需要执行同步操作。</p><ol><li>从服务器向主服务器发送SYNC命令。</li><li>主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用缓冲区来记录从现在开始执行的所有写命令</li><li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器</li><li>主服务器将缓冲区里的所有写命令发送给从服务器。</li></ol><h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>同步操作执行完之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是永远的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就可能被修改并导致主从服务器状态不再一致，这时就需要主服务器将运行的写命令传播给从服务器，使两者数据库保持一致。</p><h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>简单来说，同步完成之后主从服务器之间是通过命令传播来保持一致的，但如果在命令传播阶段主从服务器断开连接了，等到从服务器重新连上来的时候，它会重新发送SYNC同步命令将自上次同步之后的所有命令都重新生成RDB文件同步一遍，但这RDB文件中可能有很多操作是在掉线之前的命令传播阶段就做了的，所以会很低效，而且SYNC是一个非常耗费资源的资源。</p><h2 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h2><p>为了解决上述缺陷，Redis从2.8版本开始使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p><p>PSYNC命令具有完整重同步和部分重同步两种模式：</p><ul><li>完整重同步用于处理初次复制情况，和SYNC命令执行步骤基本一样。</li><li>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只处理这些写命令。</li></ul><h2 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h2><p>部分重同步功能由以下三个部分构成：</p><ul><li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。个人感觉可以和TCP连接中收发端的滑动窗口以及序号类比，主服务器发了N字节，就把主服务器的偏移量加上N，从服务器接收到N字节就把自己的偏移量加上N，主从一致时，主从服务器的偏移量应该是一样的。</li><li>主服务器的复制积压缓冲区（replication backlog），主服务器每次往从服务器命令传播时也会往一个叫做复制积压缓冲区的定长先进先出队列中写入相同命令，当主从服务器断开连接，这时主从服务器的偏移量就不一样了，当从服务器重新连上来时会检查主从偏移量之间的差距，如果相差的数据大小没有超过复制积压缓冲区大小，则可从积压缓冲区中将没接收到的数据重新发送，即PSYNC，否则只能完整重同步；</li><li>服务器的运行ID（run ID），实现部分重同步还需要用到服务器运行ID，是40个随机十六进制，当从服务器初次对主服务器进行复制时，主服务器会将自己的运行ID传送给从服务器，掉线重连后从服务器会向主服务器发送该ID，如果相同则说明连上的就是之前的主服务器，就执行PSYNC，否则只能完整重同步。</li></ul><h2 id="PSYNC命令实现流程"><a href="#PSYNC命令实现流程" class="headerlink" title="PSYNC命令实现流程"></a>PSYNC命令实现流程</h2><img src="/2018/12/09/《Redis设计与实现》笔记/psync实现.png" title="PSYNC命令调用流程图"><h2 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h2><p>通过向从服务器发送SLAVEOF命令，可以让一个从服务器去复制一个主服务器（2.8版本以上）。</p><p><code>SALVEOF &lt;mater_ip&gt; &lt;master_port&gt;</code></p><p>本节是一个具体例子，可以看p211，这里简单列出步骤：</p><ol><li>设置主服务器的地址和端口；</li><li>建立套接字连接；</li><li>发送ping命令；</li><li>身份验证；</li><li>发送端口信息；</li><li>同步，从服务器向主服务器发送PSYNC命令，值得一提的是在同步操作之前只有从服务器时主服务器的客户端，但是在执行同步操作之后，主服务器也是从服务器的客户端；</li><li>命令传播。</li></ol><h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>在命令传播阶段，从服务器会默认以每秒一次的频率向主服务器发送命令<code>REPLCONF ACK &lt;replication_offset&gt;</code>，主要有三个作用：检测主从服务器的网络连接状态、辅助实现min-slaves选项、检测命令丢失。</p><p>2.8版本之前没有这个命令，所以尽量使用2.8版本以上的Redis。</p><h1 id="第十六章-Sentinel"><a href="#第十六章-Sentinel" class="headerlink" title="第十六章 Sentinel"></a>第十六章 Sentinel</h1><p>Sentinel（哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及这些主服务器下的所有从服务器，当被监视的主服务器下线时，Sentinel系统会自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续执行命令请求。</p><h2 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h2><p>启动一个Sentinel可以使用命令：<code>redis-sentinel /path/to/your/sentinel.conf</code>或者命令<code>redis-server /path/to/your/sentinel.conf --sentinel</code>.</p><p>启动步骤如下：</p><ol><li>初始化一个服务器</li><li>将普通Redis服务器使用的代码替换城Sentinel专用代码</li><li>初始化Sentinel状态</li><li>根据给定的配置文件，初始化Sentinel的监视主服务器列表</li><li>创建连上主服务器的网络连接，对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接：一个是命令连接，一个是订阅连接。</li></ol><h2 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h2><p>Sentinel默认会以每十秒一次的频率向被监视的主服务器发送INFO命令，从命令返回的结果中可以看出该主服务器的信息以及其属下的从服务器信息，并进行更新。</p><h2 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h2><p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建新的实例之外，还会创建连接到从服务器的命令连接和订阅连接。</p><p>Sentinel也会默认每十秒一次向从服务器发送INFO命令。</p><h2 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h2><p>默认下，Sentinel会以每两秒一次的频率向所有被监视的主从服务器发送以下格式的命令：</p><p><code>PUBLISH \__sentine__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_pi&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</code></p><p>s_开头的是Sentinel本身的信息，m_表示的是当前监视的主或从服务器的信息。</p><h2 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h2><p>当Sentinel与一个主服务器或从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令：<code>SUBSCRIBE \__sentinel__: hello</code>，对该频道的订阅会一直持续到连接断开为止。</p><p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到并处理。</p><p>Sentinel和Sentinel之间不会创建订阅连接，只有命令连接。</p><h2 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h2><p>默认下，Sentinel会以每秒一次的频率向所有与它建立了命令接连的实例发送ping命令，并通过返回的结果判断实例是否在线。</p><p>Sentinel配置文件中的down-after-milliseconds选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，以此来表示这个实例已经进入主观下线状态。</p><h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，当Sentinel从其他Sentinel那接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，打开主服务器实例结构flags属性的SRI_O_DOWN标识，并对主服务器执行故障转移操作。</p><h2 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h2><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，由它对下线主服务器进行故障转移操作。</p><p>选举规则还比较复杂，详细看p239.</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移擦操作，该操作包含以下三个步骤：</p><ol><li>在已下线主服务器属下的所有从服务器中挑选出一个转换成主服务器；</li><li>让已下线主服务器属下的所有从服务器改为复制新的主服务器；</li><li>将已下线主服务器设置为新的主服务器的从服务器。</li></ol><h1 id="第十七章-集群"><a href="#第十七章-集群" class="headerlink" title="第十七章 集群"></a>第十七章 集群</h1><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>连接各个节点的工作可以使用<code>CLUSTER MEET</code>命令来完成，Redis服务器会在启动时根据cluster-enabled配置选项是否是yes来决定是否开启服务器的集群模式。</p><h3 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h3><p>clusterNode结构保存了一个节点的当前状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line">    <span class="comment">//节点名字，由40个十六进制组成</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    <span class="comment">//节点标识</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//节点当前的配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line">    <span class="comment">//节点ip</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line">    <span class="comment">//节点端口</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">//保持连接节点所需的有关信息</span></span><br><span class="line">    clusterLink* link;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clustereLink</span>&#123;</span></span><br><span class="line">    <span class="comment">//连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line">    <span class="comment">//TCP套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//输出缓冲区，保存着等待发送给其他节点的消息</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    <span class="comment">//输入缓冲区，保存着从其他节点接收到的消息</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line">    <span class="comment">//与这个连接相关联的节点，如果没有就为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个节点都保存一个clusterState结构，记录在当前节点的视角下集群目前所处的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//指向当前节点的指针</span></span><br><span class="line">    clusterNode* myself;</span><br><span class="line">    <span class="comment">//配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">//集群当前的状态，在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//集群节点名单</span></span><br><span class="line">    dict* nodes;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><h3 id="CLUSTER-MEET命令的实现"><a href="#CLUSTER-MEET命令的实现" class="headerlink" title="CLUSTER MEET命令的实现"></a>CLUSTER MEET命令的实现</h3><img src="/2018/12/09/《Redis设计与实现》笔记/clustermeet.png" title="节点的握手过程"><h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理0个或最多16384个槽。</p><p>当所有16384个槽都有节点在处理时，集群处于上线状态，否则处于下线状态。</p><p>可以利用CLUSTER ADDSLOTS命令将一个或多个槽指派给节点负责。</p><h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>slots属性是一个二进制位数组，每一位用来表示该节点是否负责处理该槽，1表示处理。</p><h3 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h3><p>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots之外，还会将自己的slots数组通过消息发送给集群中的其他节点。</p><h3 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* slots[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure><h3 id="CLUSTER-ADDSLOTS命令的实现"><a href="#CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="CLUSTER ADDSLOTS命令的实现"></a>CLUSTER ADDSLOTS命令的实现</h3><ol><li>遍历所有输入的槽，如果有哪怕一个槽已经指派给了某个节点，则返回错误</li><li>若所有输入槽都是未指派槽，则再次遍历所有输入槽，指派给当前节点，修改clusterState.slots数组和clusterNode.slots数组</li></ol><h2 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h2><p>集群上线后，当客户端向节点发送命令时，接收命令的节点会计算出命令要处理的数据库属于哪个槽，如果是自己则直接执行，如果不是自己则向客户端返回MOVED错误，指引客户端转向正确的节点。</p><h3 id="计算键属于哪个槽"><a href="#计算键属于哪个槽" class="headerlink" title="计算键属于哪个槽"></a>计算键属于哪个槽</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slot_number</span><span class="params">(key)</span>:</span></span><br><span class="line"><span class="keyword">return</span> CRC16(key) &amp; <span class="number">16383</span></span><br></pre></td></tr></table></figure><h3 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h3><p>节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机Redis没有这个限制，其他地方则相同。</p><h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点。</p><p>重新分片可以在线进行。</p><p>Redis集群的重新分片操作时由Redis的集群管理软件redis-trib负责执行的，具体步骤如下：</p><ol><li>redis-trib向目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让目标节点准备好从源节点导入属于槽slot的键值对</li><li>redis-trib对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>，让源节点准备好将属于槽slot的键值对迁移到目标节点</li><li>redis-trib向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令，获得最多count个属于槽slot的键值对的键名</li><li>对于3中获得的每个键名，redis-trib都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>命令，将被选中的键值对原子地迁移</li><li>重复3和4直到所有节点都完成迁移</li><li>redis-trib向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。</li></ol><h2 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h2><img src="/2018/12/09/《Redis设计与实现》笔记/ask错误.png" title="判断是否发送ASK错误的过程"><h3 id="CLUSTER-SETSLOT-IMPORTING命令的实现"><a href="#CLUSTER-SETSLOT-IMPORTING命令的实现" class="headerlink" title="CLUSTER SETSLOT IMPORTING命令的实现"></a>CLUSTER SETSLOT IMPORTING命令的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure><p>如果importing_slots_from[i]的值不是NULL，而是指向一个clusterNode节点，那么表示当前节点正在从clusterNode所代表的节点导入槽i。</p><p>在对集群进行重新分片的时候，向目标节点发送命令：</p><p><code>CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</code>可以将目标节点的importing_slots_from[i]的值设置为source_id所代表的节点的clusterNode结构。</p><h3 id="CLUSTER-SETSLOT-MIGRATING命令的实现"><a href="#CLUSTER-SETSLOT-MIGRATING命令的实现" class="headerlink" title="CLUSTER SETSLOT MIGRATING命令的实现"></a>CLUSTER SETSLOT MIGRATING命令的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure><p>同理，如果migrating_slots_to[i]的值不为NULL，则表示正在向所指的clusterNode节点迁移。</p><p>命令：<code>CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</code></p><h3 id="ASK错误-1"><a href="#ASK错误-1" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>如果节点收到一个键key的请求，但并没有在自己的数据库里找到键key，那么节点会检查自己的clusterState.migrating_slots_to[i]，如果正在迁移，则会向客户端发送一个ASK错误，引导客户端到正在导入槽i的节点去查找key。</p><h3 id="ASKING命令"><a href="#ASKING命令" class="headerlink" title="ASKING命令"></a>ASKING命令</h3><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识。</p><p>当客户端接受到ASK错误时会先向转向节点发一个ASKING命令，然后才再次发送命令。</p><p>客户端的REDIS_ASKING标识是一个一次性标识，当节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，该客户端的REDIS_ASKING标识就会被移除。</p><h3 id="ASK错误和MOVED错误的区别"><a href="#ASK错误和MOVED错误的区别" class="headerlink" title="ASK错误和MOVED错误的区别"></a>ASK错误和MOVED错误的区别</h3><p>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点；</p><p>ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施。</p><h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p>Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，从节点用于复制某个主节点，并在被复制的主节点下线时代替下线主节点继续处理命令请求。</p><h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>向一个节点发送命令：<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为noid_id所指定节点的从节点并开始复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//如果这时一个从节点，那么指向主节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">slaveof</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>集群中的所有节点都会在代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//正在复制这个主节点的从节点数量</span></span><br><span class="line">    <span class="keyword">int</span> numslaves;</span><br><span class="line">    <span class="comment">//一个数组，每个项指向一个正在复制这个主节点的从节点的clusterNode结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>** <span class="title">slaves</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中的每个节点都会定期向集群中的其他节点发送ping消息，如果接受ping消息的节点没有在规定的时间内返回pong消息，则会被标记为疑似下线（probable fail，PFAIL）。</p><p>当一个主节点A通过消息得知主节点B认为主节点C进入了PFAIL，主节点A会在自己的clusterState.nodes字典里找到主节点C，并将B的下线报告添加到fail_reports链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一个链表，记录了所有其他节点对该节点的下线报告</span></span><br><span class="line">    <span class="built_in">list</span>* fail_reports;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span>&#123;</span></span><br><span class="line">    <span class="comment">//报告目标节点已经下线的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">//最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> time;</span><br><span class="line">&#125;<span class="keyword">typedef</span> clusterNodeFailReport;</span><br></pre></td></tr></table></figure><p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线，将X标记为已下线的节点会向集群广播此消息，所有收到该消息的节点都会立刻将X标记为已下线。</p><h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>当一个从节点发现自己正在复制的主节点进入了已下线状态，则会开始进行故障转移。</p><ol><li>从所有从节点中选中一个节点，选举方法和16章中选举零头Sentinel的方法非常相似，因为两者都是基于Raft算法的领头选举方法来实现的；</li><li>被选中的从节点执行SLAVEOF no one命令，成为新的主节点；</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己；</li><li>新的主节点广播PONG消息；</li><li>新的主节点开始接受命令请求。</li></ol><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>节点发送的消息主要有以下五种：</p><ol><li>MEET消息</li><li>PING消息</li><li>PONG消息，以上三种消息都是用相同的消息正文，所以是通过消息头的type属性来判断的，每次发送这三种消息的时候，发送者都从自己的已知节点列表中随机选出两个节点保存到clusterMsgDataGossip结构中发送出去。</li><li>FAIL消息，当主节点A将主节点B标记为FAIl时，A会向集群广播关于B的FAIL消息，FAIL消息的正文里只包含nodename属性。</li><li>PUBLISH消息，当客户端向集群中的某个节点发送命令<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>命令，接收到PUBLISH命令的节点不仅会向channel频道发送消息message，还会向集群广播一条PUBLISH消息，所有接受到这条PUBLISH消息的节点都会向channel发送message。</li></ol><p>一条消息由消息头和消息正文组成。</p><p>消息头的主要字段见p282，由clusterMsg结构表示。</p><h1 id="第十八章-发布与订阅"><a href="#第十八章-发布与订阅" class="headerlink" title="第十八章 发布与订阅"></a>第十八章 发布与订阅</h1><p>Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。</p><h2 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h2><p>当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立起了一种订阅关系。</p><p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存所有频道的订阅关系</span></span><br><span class="line">    dict* pubsub_channels;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>订阅和退订就是在字典上进行操作，p294。</p><h2 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h2><p>PSUBSCRIBE命令用来订阅模式，与频道类似，服务器也将所有模式的订阅关系都保存在一个属性里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存所有模式订阅关系</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该属性是一个链表，链表中的每个节点都包含着一个pubsubPattern结构，这个结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span>&#123;</span></span><br><span class="line">    <span class="comment">//订阅模式的客户端</span></span><br><span class="line">    redisClient * client;</span><br><span class="line">    <span class="comment">//被订阅的模式</span></span><br><span class="line">    robj* pattern;</span><br><span class="line">&#125;pubsubPattern;</span><br></pre></td></tr></table></figure><p>模式的订阅与退订也就是在list上进行操作，p296.</p><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>当一个Redis客户端执行<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：</p><ol><li>将消息message发送给channel频道的所有订阅者；</li><li>如果有一个或多个模式和channel频道匹配，那么将message发送给pattern模式的订阅者。</li></ol><h2 id="查看订阅信息"><a href="#查看订阅信息" class="headerlink" title="查看订阅信息"></a>查看订阅信息</h2><p><code>PUBSUB</code>命令是Redis2.8新增加的命令之一，客户端可以通过这个命令来查看频道或模式的相关信息。</p><p><code>PUBSUB CHANNELS [pattern]</code>用于返回服务器当前被订阅的频道</p><p><code>PUBSUB NUMSUB [channel-1 channel-2 ...]</code>接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。</p><p><code>PUBSUB NUMPAT</code>命令用于返回服务器当前被订阅模式的数量，即返回pubsub_patterns链表的长度。</p><h1 id="第十九章-事务"><a href="#第十九章-事务" class="headerlink" title="第十九章 事务"></a>第十九章 事务</h1><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务功能。</p><h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>一个事务从开始到结束通常会经历三个阶段：</p><ul><li><p>事务开始，MULTI命令的执行标志着事务的开始，打开了客户端状态的flags属性中的REDIS_MULTI标识。</p></li><li><p>命令入队</p><img src="/2018/12/09/《Redis设计与实现》笔记/事务命令入队.png" title="服务器判断命令是该入队还是该执行的过程"></li><li><p>事务执行，每个客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里，该属性是一个multiState结构：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span>&#123;</span></span><br><span class="line">    <span class="comment">//事务队列，fifo顺序</span></span><br><span class="line">    multiCmd* commands;</span><br><span class="line">    <span class="comment">//已入队命令计数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; multiState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span>&#123;</span></span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">//命令指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行，服务器会遍历该客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p><h2 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h2><p>WATCH命令是一个乐观锁，它可以在EXEC命令执行之前监视任意数量的数据库键，并在EXEC命令执行时检查被监视的键是否至少有一个已经被修改过，如果是，服务器将拒绝执行事务并返回代表执行失败的空回复。</p><p>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//正在被WATCH命令监视的键</span></span><br><span class="line">    dict* watched_keys;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有对数据库进行修改的命令在执行之后都会调用multi.c/touchWatchKey函数对该字典进行检查，查看是否有客户端正在监视刚刚被修改过的键，如果有则打开该客户端的REDIS_DIRTY_CAS标识，标识客户端的事务安全性已经被破坏。</p><p>当服务器接收到某客户端的EXEC命令时会检查该客户端是否打开了REDIS_DIRTY_CAS标识，如果打开了则拒绝执行。</p><h2 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h2><p>原子性（Atomicity）、一致性（Consistency）、隔离性（isolation）以及持久性（durability），前三者总是有的，当Redis运行在某种特定的持久化模式下时，事务也具有持久性。</p><p>Redis没有事务回滚机制。</p><p>Redis事务中三个可能出错的地方：</p><ol><li>入队错误</li><li>执行错误</li><li>服务器停机</li></ol><p>Redis事务只有当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时才具有持久性（同时还需要no-appendfsync-on-rewrite配置选项没有被打开）。</p><p>其实不管Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事物的耐久性，但这种做法效率太低，所以不具有实用性。</p><h1 id="第二十章-Lua脚本"><a href="#第二十章-Lua脚本" class="headerlink" title="第二十章 Lua脚本"></a>第二十章 Lua脚本</h1><p>Redis从2.6版本开始引入对Lua脚本的支持，客户端可以通过使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p><h2 id="创建并修改Lua环境"><a href="#创建并修改Lua环境" class="headerlink" title="创建并修改Lua环境"></a>创建并修改Lua环境</h2><ul><li>创建一个基础的Lua环境</li><li>载入函数库</li><li>创建redis全局表格</li><li>使用redis自制的随机函数来替换Lua原有的随机函数</li><li>创建排序辅助函数</li><li>创建redis.pcall函数的错误报告辅助函数</li><li>保护lua的全局环境</li><li>将lua环境保存到服务器状态的lua属性中</li></ul><h2 id="lua环境协作组件"><a href="#lua环境协作组件" class="headerlink" title="lua环境协作组件"></a>lua环境协作组件</h2><p>一个是负责执行Lua脚本中的redis命令的伪客户端，一个是用于保存Lua脚本的lua_scripts字典，该字典有两个作用：实现SCRIPT EXISTS命令和实现脚本复制功能。</p><img src="/2018/12/09/《Redis设计与实现》笔记/lua.png" title="Lua脚本执行Redis命令时的通信步骤"><h2 id="EVAL命令的实现"><a href="#EVAL命令的实现" class="headerlink" title="EVAL命令的实现"></a>EVAL命令的实现</h2><ol><li>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数</li><li>将客户端给定的脚本保存到lua_srcipts字典，等待将来进一步使用</li><li>执行刚刚在Lua环境中定义的函数</li></ol><h2 id="EVALSHA命令的实现"><a href="#EVALSHA命令的实现" class="headerlink" title="EVALSHA命令的实现"></a>EVALSHA命令的实现</h2><p>只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的。</p><h2 id="脚本管理命令的实现"><a href="#脚本管理命令的实现" class="headerlink" title="脚本管理命令的实现"></a>脚本管理命令的实现</h2><p><code>SCRIPT FLUSH</code>：用于清除服务器中所有和Lua脚本有关的命令，这个命令会释放并重建lua_scripts字典，关闭现有的lua环境并重新创建一个新的Lua环境。</p><p><code>SCRIPT EXISTS</code>：根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p><p><code>SCRIPT LOAD</code>：和EVAL命令执行脚本所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典中。</p><p><code>SCRIPT KILL</code>：如果超时运行的脚本未执行过任何写入操作，那么客户端可以通过SCRIPT KILL命令来指示服务器停止执行这个脚本，并向执行该脚本的客户端发送一个错误回复。</p><h2 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h2><p>复制EVAL、SCRIPT FLUSH和SCRIPT LOAD命令时，主服务器会直接向所有从服务器发送该命令。</p><p>而在传播EVALSHA命令的时候，必须确保EVALSHA命令要执行的脚本已经被所有从服务器载入过，否则主服务器会将EVALSHA命令转换成一个等价的EVAL命令进行传播。</p><p>主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器，键是SHA1校验和，而值都是NULL。</p><p>每当主服务器添加一个新的从服务器时，主服务器都会清空自己的repl_scriptcache_dict字典。</p><h1 id="第二十一章-排序"><a href="#第二十一章-排序" class="headerlink" title="第二十一章 排序"></a>第二十一章 排序</h1><p>Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。</p><p>用的是快排。</p><h2 id="SORT-命令的实现"><a href="#SORT-命令的实现" class="headerlink" title="SORT 命令的实现"></a>SORT <key>命令的实现</key></h2><p>该命令可以对一个包含数字值的键key进行排序，详细步骤如下：</p><ol><li>创建一个和numbers列表长度相同的数组，数组每一项都是一个RedisSortObject结构；</li><li>遍历该数组，将各个数组项的obj指针分别指向numbers列表的各个项，并将obj指针所指的列表项转换成一个double类型浮点数存在相应数组项的u.score属性里面；</li><li>根据u.score的值对数组排序；</li><li>遍历数组，顺序输出obj所指的列表项。</li></ol><p>ALPHA、ASC以及DESC选项的实现都是在对数组排序的时候有所不同，具体看p347开始的几页。</p><h2 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h2><p>在默认情况下，SORT命令总会将排序后的所有元素都返回给客户端，但是通过LIMIT选项可以只返回其中一部分。</p><p><code>LIMIT &lt;offset&gt; &lt;count&gt;</code></p><h2 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h2><p>通过GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p><h2 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h2><p>默认情况下，SORT命令只向客户端返回排序结果，而不保存排序结果。</p><p>通过STORE选项，可以将排序结果保存到指定的键里面，并在又需要的时候重用这个排序结果。</p><p><code>SORT key ALPHA STORE key2</code></p><h2 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h2><ol><li>排序：在这一步命令会使用ALPHA、ASC或DESC、BY这几个选项；</li><li>限制排序结果集的长度，会使用LIMIT选项；</li><li>获取外部键，会使用GET选项</li><li>保存排序结果集：使用STORE选项</li><li>向客户端返回排序结果集</li></ol><h2 id="选项的摆放顺序"><a href="#选项的摆放顺序" class="headerlink" title="选项的摆放顺序"></a>选项的摆放顺序</h2><p>除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</p><h1 id="第二十二章-二进制位数组"><a href="#第二十二章-二进制位数组" class="headerlink" title="第二十二章 二进制位数组"></a>第二十二章 二进制位数组</h1><p>Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组。</p><p>BITOP命令既可以对多个位数组进行按位与、按位或、按位异或运算，也可以对给定的数组进行取反运算。</p><h2 id="位数组的表示"><a href="#位数组的表示" class="headerlink" title="位数组的表示"></a>位数组的表示</h2><p>Redis使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。</p><p>【注意】buf数组保存位数组的顺序和我们平时书写位数组的顺序是完全相反的，比如buf[0]字节中各个位分别是1/0/1/1/0/0/1/0，表示的其实是01001101。这样来保存可以简化SETBIT命令的实现。</p><h2 id="GETBIT命令的实现"><a href="#GETBIT命令的实现" class="headerlink" title="GETBIT命令的实现"></a>GETBIT命令的实现</h2><p><code>GETBIT &lt;bitarray&gt; &lt;offset&gt;</code></p><ol><li>计算byte=offset/8</li><li>计算bit=（offset mod 8）+1</li><li>根据byte和bit去取值。</li></ol><p>时间复杂度O（1）。</p><h2 id="SETBIT命令的实现"><a href="#SETBIT命令的实现" class="headerlink" title="SETBIT命令的实现"></a>SETBIT命令的实现</h2><p><code>SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt;</code></p><ol><li>计算len=offset/8+1</li><li>检查bitarray键保存的位数组的长度是否小于len，如果是则扩展为len个字节，并将新扩展的二进制位都设置为0；</li><li>计算byte=offset/8</li><li>计算bit=（offset mod 8）+1</li><li>根据byte和bit定位offset偏移量指定的二进制位，首先将该位上的值保存在oldvalue中，然后将新值value设置为这个二进制的值</li><li>向客户端返回oldvalue的值</li></ol><p>时间复杂度O(1)。</p><p>【注意】因为buf数组使用逆序来保存位数组，所以当程序需要对buf数组进行扩展时，写入操作可以直接在新扩展的二进制位中完成，而不必改动位数组原来已有的二进制位。如果buf数组使用和书写一样的顺序来保存位数组，那么每次扩展buf数组后都需要将已有的位进行移动，然后才能执行写操作，影响执行速度。</p><h2 id="BITCOUNT命令的实现"><a href="#BITCOUNT命令的实现" class="headerlink" title="BITCOUNT命令的实现"></a>BITCOUNT命令的实现</h2><p>几种可能的实现方式：</p><ol><li>遍历</li><li>查表，即映射hash，以空间换时间</li><li>variable-precison SWAR算法</li></ol><p>前两种有明显缺陷，主要看下第三种。</p><p>统计一个数组中非0二进制位的数量，在数学上被称为“计算汉明重量”，对于普通处理器来说，目前已知效率最好的通用算法就是variable-precison SWAR算法，该算法通过一系列位移和位运算操作，可以在常数时间内计算多个字节的汉明重量，并且不需要任何额外内存。</p><p>具体例子和算法见p372，看下来主要逻辑就是利用移位和位运算先算每两位有多少个1，然后算每四位有多少个1，接着是每八位有多少个1，依次类推，最后算出总的，但这个总数是在最高位的，所以需要再进行一个移位操作把值移到最低字节便于查看。</p><h3 id="Redis中的实现"><a href="#Redis中的实现" class="headerlink" title="Redis中的实现"></a>Redis中的实现</h3><p>BITCOUNT命令的实现用到了查表和SWAR两种算法：</p><ul><li>查表算法使用键长8位的表，表中记录从0000 0000到1111 1111在内的所有二进制位的汉明重量；</li><li>而SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision SWAR算法来计算这128个二进制位的汉明重量。</li></ul><p>在执行命令时，会根据未处理的二进制位的数量来决定具体使用哪种算法，大于等于128就用SWAR，否则用查表法。</p><p>时间复杂度O(n)。</p><h2 id="BITOP命令的实现"><a href="#BITOP命令的实现" class="headerlink" title="BITOP命令的实现"></a>BITOP命令的实现</h2><p>因为C语言直接支持对字节执行逻辑与或非以及异或操作，所有BITOP命令的AND、OR、XOR和NOT四个操作都是直接基于这些逻辑操作实现的。</p><p>NOT复杂度O(n)，其他的O(n^2)。</p><h1 id="第二十三章-慢查询日志"><a href="#第二十三章-慢查询日志" class="headerlink" title="第二十三章 慢查询日志"></a>第二十三章 慢查询日志</h1><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p><p>服务器配置中有两个和慢查询日至相关的选项：</p><ul><li><code>showlog-log-slower-than</code>选项指定执行时间超过多少微妙的命令请求会被记录到日志上；</li><li><code>showlog-max-len</code>选项指定服务器最多保存多少条查询日志。</li></ul><p>服务器使用先进先出的方式保存慢查询日志。</p><p><code>SLOWLOG GET</code>命令查看服务器所保存的慢查询日志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//下一条慢查询日志的ID</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;</span><br><span class="line">    <span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="built_in">list</span>* slowlog;</span><br><span class="line">    <span class="comment">//服务器配置slowlog-log-slower-than选项的值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//slowlog链表中每个节点都是一个slowlogEntry结构，新的节点插入在表头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntrt</span>&#123;</span></span><br><span class="line">    <span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">//命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> time;</span><br><span class="line">    <span class="comment">//执行命令消耗的时间，以微妙为单位</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration;</span><br><span class="line">    <span class="comment">//命令与命令参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//命令与命令参数的数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">&#125;slowlogEntry;</span><br></pre></td></tr></table></figure><p>在每次执行命令的前后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，这个时长会传给slowlogPushEntryIfNeeded函数，会根据情况检查是否需要为自己执行的命令创建慢查询日志。</p><p>slowlogPushEntryIfNeeded函数作用有两个：检查命令的执行时长是否超过阈值、检查慢查询日志的长度是否超过最大长度。</p><h1 id="第二十四章-监视器"><a href="#第二十四章-监视器" class="headerlink" title="第二十四章 监视器"></a>第二十四章 监视器</h1><p>执行MONITOR命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息。</p><p>每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令外，还会将关于这条命令请求的信息发送给所有监视器。</p><p><code>MONITOR</code>执行步骤如下：</p><ol><li>打开客户端监视器标志REDIS_MONITOR</li><li>将客户端添加到服务器状态的monitors链表的末尾</li><li>向客户端返回OK</li></ol><p>服务器每次处理命令之前，都会调用replicationFeedMonitors函数，由该函数将被处理的命令请求的相关信息发送给各个监视器，该函数步骤如下：</p><ol><li>根据执行命令的客户端、当前数据库的号码、命令参数、命令参数个数等参数创建要发送给各个监视器的信息</li><li>遍历所有监视器，发送信息</li></ol><p>举个例子，若服务器在时间1378822257，根据IP为127.0.0.1、端口56604的客户端发送的命令请求，对0号数据库执行命令<code>KEYS *</code>，那么服务器创建的信息如下：</p><p><code>1378822257 [0 127.0.0.1:56604] &quot;KEYS&quot; &quot;*&quot;</code></p><p>【END】</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-简单动态字符串&quot;&gt;&lt;a href=&quot;#第二章-简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;第二章 简单动态字符串&quot;&gt;&lt;/a&gt;第二章 简单动态字符串&lt;/h1&gt;&lt;p&gt;在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://yoursite.com/2018/12/08/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/12/08/Redis入门/</id>
    <published>2018-12-08T08:16:18.000Z</published>
    <updated>2018-12-08T09:53:41.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个高性能内存key-value数据库，和其他key-value缓存产品相比有其他特点：</p><ol><li>Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时可以重新加载使用；</li><li>Redis不仅支持简单的key-value类型的数据，同时还提供list，set，hash，zset等数据结构；</li><li>Redis支持数据备份，即master-slave模式。</li></ol><a id="more"></a><p>Redis性能极高，读110000次/s，写81000次/s。</p><p>Redis的所有操作都是原子性的，单个操作是原子性的，多个操作可以支持事务，通过multi和exec指令包起来。</p><p>Redis还支持pulish/subscribe，通知，key过期等特性。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="windows下使用和安装"><a href="#windows下使用和安装" class="headerlink" title="windows下使用和安装"></a>windows下使用和安装</h2><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">下载地址</a></p><ol><li>解压后将文件夹名字改为redis；</li><li>进入redis目录打开cmd窗口，运行以下命令打开redis服务器（win10下的powershell似乎不行，原因不明）<code>redis-server.exe redis.windows.cof</code></li><li>另启一个cmd窗口，启动redis客户端连接服务器<code>redis-cli.exe -h 127.0.0.1 -p 6379</code></li></ol><h2 id="linux下使用和安装"><a href="#linux下使用和安装" class="headerlink" title="linux下使用和安装"></a>linux下使用和安装</h2><p>暂未用，后续用到再记录</p><h1 id="Redis的五大数据结构"><a href="#Redis的五大数据结构" class="headerlink" title="Redis的五大数据结构"></a>Redis的五大数据结构</h1><p>redis存储的是key-value键值对，所谓的五大数据结构指的是value的类型，key一般都是string类型，其中key定义的时候不要过长或过短，最好有统一的命名规范。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string类型是以二进制存储的，这意味着redis的string可以包含任意数据，比如图片或序列化对象，一个string类型的值最大能存储512MB。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>set key value</code></li><li><code>get key</code></li><li><code>getrange key start end</code> 返回key中字符串值从start到end的字符</li><li><code>getset key value</code> 将指定key的值设为value，但返回旧值</li><li><code>mget key1 [key2..]</code>获取多个给定key的值</li><li><code>setex key seconds value</code>设置key和value，并将key的过期时间设为seconds</li><li><code>setnx key value</code>只有key不存在时才设值</li><li><code>mset key value [key value..]</code>同时设置多个k-v对</li><li><code>incr key</code>将key中存储的值加1，若value不能转化成整数，则会报错</li><li><code>incrby key increment</code>将key对应的value加increment</li><li><code>decr key</code></li><li><code>decrby key decrement</code></li><li><code>append key value</code> 在key对应的值后拼接字符串key</li></ol><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash特别适合存储对象，每个hash可以存储2^32-1个键值对（42.9亿）</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>hdel key field1 [field2..]</code>删除key中某个字段</li><li><code>hexists key field</code>判断字段是否存在你</li><li><code>hget key field</code></li><li><code>hgetall key</code> 获得key所有字段和值</li><li><code>hincreby key field increment</code></li><li><code>hkeys key</code>获取key中所有字段</li><li><code>hlen key</code>获取key中字段数量</li><li><code>hmget key field1 [field2..]</code></li><li><code>hmset key field1 value1 [field2 value2..]</code></li><li><code>hset key field value</code></li><li><code>hsetnx key field value</code></li><li><code>hvals key</code>获取key所有值</li></ol><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>字符串列表，可以左右添加，用作消息队列等，列表最多存储2^32-1个元素。</p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>lpop key</code>弹出左边第一个元素</li><li><code>lpush key value1 [value2..]</code>在左边依次插入多个值</li><li><code>llen key</code>获取列表长度</li><li><code>lrange key start end</code>获取列表指定范围内的元素，-1表示倒数第一个元素，依次类推</li><li><code>lrem key count value</code>从左往右删除count个value值</li><li><code>lset key index value</code>通过索引设置值</li><li><code>rpop key</code>弹出右边第一个元素</li><li><code>rpoplpush source dest</code>移除source右边第一个元素，加入到dest最左边</li><li><code>rpush key value1 [value2..]</code></li></ol><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>是字符串的无序集合，元素不可重复，是通过哈希表实现的，所以添加删除查找的时间复杂度都是O(1)，最大成员数2^32-1，支持交并差。</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>sadd key mem1 [mem2..]</code></li><li><code>scard key</code> 获取集合的成员数</li><li><code>sdiff key1 [key2]</code>返回key1和key2的差集</li><li><code>sdiffstore dest key1 [key2]</code>返回key1和key2的差集并存入dest中</li><li><code>sinter key1 [key2]</code>交集</li><li><code>sinterstore dest key1 [key2]</code></li><li><code>sunion key1 [key2]</code>并集</li><li><code>sunionstore dest key1 [key2]</code></li><li><code>sismember key member</code>判断member是否在集合key中</li><li><code>smembers key</code>返回key的成员</li><li><code>smove source dest member</code>将member从source移到dest中</li><li><code>spop key</code>移除并返回集合中的一个随机数</li><li><code>srandmember key [count]</code> 随机返回集合中count个元素</li><li><code>srem key member1 [member2]</code> 移除集合中元素</li></ol><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>除了有序外，和set相同，每个元素会关联一个double的分数，通过该分数排序，zset成员是唯一的，但是成员的分数可以相同。</p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>zadd key score1 member1 [score2 member2..]</code></li><li><code>zcard key</code></li><li><code>zcount key min max</code> 计算在有序集合中指定区间分数内的成员数</li><li><code>zincrby key increment member</code> 在有序集合中对指定成员的分数加上增量</li><li><code>zinterstore dest numkeys key [key..]</code>求numkeys个有序集合的交集并存到dest中</li><li><code>zrange key start end [withscores]</code>返回有序集合指定范围内的值（可带分数）</li><li><code>zrevrange key start end [withscores]</code></li><li><code>zremrangebyrank key start end</code>按索引删</li><li><code>zremrangebyscore key start end</code>按分数删</li><li><code>zrank key member</code>返回有序集合中指定成员的索引</li><li><code>zrem key member [member..]</code></li><li><code>zremrangebylex key min max</code>移除有序集合中给定的字典区间的所有成员</li><li><code>zrangebyscore key min max [withscores] [limit]</code>通过分数返回有序集合指定区间内的成员</li></ol><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>redis的高性能是因为它所有数据都存在内存当中，要保证重启后数据不丢失，就需要数据持久化。有两种方式——RDB和AOF，可以只用一种，也可以两种结合使用。</p><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><p>在指定的时间间隔内将数据集快照写入到磁盘。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>整个redis数据只包含一个文件，备份方便</li><li>对于灾难恢复，比较容易</li><li>性能最大化，分叉出一些子进程，由子进程进行持久化</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li>不能保证有效性，因为是定时写的</li><li>fork子进程太多</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认持久化方法，在redis.conf中，保存文件是dump.rdb</p><h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>将以日志的形式记录redis的每一次操作，当redis重启时会从该日志重现redis的每一次操作，重构redis。</p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ol><li>能带来更高数据安全性，有三种同步：每秒同步、每个修改同步、不同步</li><li>对日志文件写入采用append模式，所以即便写入的时候出错，也不会影响日志，可以通过redis -check -aof来解决数据一致性</li><li>如果日志过大，可以自动重写，在重写切换的时候可以更好地保证安全性</li><li>日志文件格式清晰</li></ol><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ol><li>对于相同数据集而言，aof文件比rdb文件大</li><li>aof执行效率上会低于rdb</li></ol><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>不是默认方式，也在redis.conf中，查找到appendonly no这一行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;p&gt;Redis是一个高性能内存key-value数据库，和其他key-value缓存产品相比有其他特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis支持数据持久化，可以将内存中的数据保存在磁盘中，重启时可以重新加载使用；&lt;/li&gt;
&lt;li&gt;Redis不仅支持简单的key-value类型的数据，同时还提供list，set，hash，zset等数据结构；&lt;/li&gt;
&lt;li&gt;Redis支持数据备份，即master-slave模式。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>《弗雷的小说写作坊-飞起来》笔记</title>
    <link href="http://yoursite.com/2018/10/29/%E3%80%8A%E5%BC%97%E9%9B%B7%E7%9A%84%E5%B0%8F%E8%AF%B4%E5%86%99%E4%BD%9C%E5%9D%8A-%E9%A3%9E%E8%B5%B7%E6%9D%A5%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/29/《弗雷的小说写作坊-飞起来》笔记/</id>
    <published>2018-10-29T14:58:23.000Z</published>
    <updated>2018-11-15T09:51:19.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、唤醒虚构梦境"><a href="#一、唤醒虚构梦境" class="headerlink" title="一、唤醒虚构梦境"></a>一、唤醒虚构梦境</h1><p>1、要展示，不要叙述。小说家试图去“展示”，通过感官细节上的暗示将读者拖入虚幻的梦境。    </p><p>2、同情是一种“认可”。要让观众产生同情，得先让他们对角色产生同情感，这是很关键的一点。<br><a id="more"></a><br>3、同情是深入故事的途径，有了同情，读者就能从内心真正感受到故事的情感，没有产生同情则说明读者在读故事时没有参与到故事的情感中来。获得了读者的同情之后，写作者应该进一步深入虚构梦境的创作，让读者认可你创造的角色。</p><p>4、只有当读者不仅同情角色的困境，还支持他的目标和勇气，并强烈希望这个角色能实现他的目标时，他们才能说这个角色得到了读者的认同。</p><p>5、移情是一种比同情心更强烈的情感。个人感觉移情就是靠细节描写。激发情感的感官细节，能够通过暗示的力量激发读者的情感，抚慰读者的同理心。</p><p>6、身临其境时，读者进入一种梦境，完全进入虚幻的世界里，现实世界消失了。这就是小说家的目标：带领读者沉浸在他们所塑造的角色世界中。</p><p>7、怎样使你的读者从同情、认同、移情到完全沉浸其中呢？答案就是：内心冲突。</p><p>8、内心冲突可以被看做角色心中两种“声音”之间的战争：一个是理智，另一个是情感，或者两种情感之间的冲突。</p><h1 id="二、设置悬念还是循规蹈矩——这是一个问题"><a href="#二、设置悬念还是循规蹈矩——这是一个问题" class="headerlink" title="二、设置悬念还是循规蹈矩——这是一个问题"></a>二、设置悬念还是循规蹈矩——这是一个问题</h1><p>1、“担心和好奇”也就是我们所说的给读者设置悬念。《韦氏词典》是这样定义悬念的：悬念就是一种悬而未决的状态。</p><p>2、故事问题是一种让读者好奇的策略。它们一般不是以问题的形式出现，而是以需深入理解的叙述、亟待解决的问题或是灾难的预测等类似的形式出现。</p><p>3、不管是短篇小说作家还是长篇小说作家，都应该尽早呈现故事问题，通常是在开头的第一句或第二句。p33</p><p>4、因此，一篇很好的小说的开篇，在最开始就要像大师一样，以一个强有力的故事问题姥姥拴住读者，让他们想一直读下去。《韦氏词典》列出了悬念的第二个定义：悬念是一种不确定的状态，就像等待一个决定，通常伴随着焦虑或担忧。</p><p>5、首先，悬念是一种好奇，作者提出让读者好奇的问题。其次，作者将读者置于一种焦虑或担忧的状态，使读者又不单单局限在好奇的层面上。</p><p>6、为了让读者感到焦虑和担忧，作者首先必须创作一个能让人产生共鸣的任务，也就是大多数读者都希望有好结局的人物。</p><p>7、点燃导火索是设置悬念最有力的技巧，它意味着将有可怕的事情发生，并且在一个约定的时间内，故事中的人物必须要阻止，但这并不是一件简单的事情。</p><p>8、其实悬念就是一个提出故事问题、将能产生同情感的人物设置在一个充满威胁的情境中，然后再点燃导火索的过程。</p><h1 id="三、懦夫或疯子：真正令人难忘的人物"><a href="#三、懦夫或疯子：真正令人难忘的人物" class="headerlink" title="三、懦夫或疯子：真正令人难忘的人物"></a>三、懦夫或疯子：真正令人难忘的人物</h1><p>1、以一个懦弱的人物开篇没有错，选主妇或会计作为人物也没有错。问题不在于主角是否懦弱，而在于他或她是否麻木不仁、不会改变。</p><p>2、作者一定要避免自己笔下出现麻木不仁的人物。</p><p>3、人物必须有真实人物的独特性，他们必须跟一般人物形成对比，对比中产生了个性。</p><p>4、创作一个古怪的人物是有趣的。一种方式就是简单地塑造一个特征，然后再把这个特征夸大。另外一种方式就是赋予人物一种颇有偏差的人生哲学观。</p><p>5、人物之间不仅应该形成对比反差，还应该跟各自所在的情节环境有对比。比如乡巴佬进城、社会名流进入监狱。</p><p>6、人物的主导情感是人物的主要驱动力，是人物内心动力和推力的总和。</p><p>7、文学作品中，一些最难忘的人物都具有双重性。事实上，具有双重人格的人物就是一个身体里面有两种截然不同性格的人。</p><p>8、为了让人物值得深入了解，你要创造一个耐人寻味的背景环境，你的人物要特立独行、见解独到。你可以把他们塑造成奇葩怪物，让人物相互之间、人物与背景环境之间形成对比与反差，或者再给他们加上一个双重性格。塑造人物时可以大胆尝试，让读者耳目一新。</p><h1 id="四、预设的再讨论之第一部分：概念的释义与简化"><a href="#四、预设的再讨论之第一部分：概念的释义与简化" class="headerlink" title="四、预设的再讨论之第一部分：概念的释义与简化"></a>四、预设的再讨论之第一部分：概念的释义与简化</h1><p>1、在小说创工作中，再没有比预设更有力的概念了。若你在脑海里以强烈的预设来编织你的故事，那么你的小说将中心突出并富有戏剧性，这样的作品将吸引你的读者从头读到尾。</p><p>2、预设是发生在角色身上事件的叙述，也是故事里核心冲突的结果。</p><p>3、我的故事应该是写人们生活里的某些方面，不是所有方面。</p><p>4、寓意是故事要教给读者的东西。把主题定义为小说里反复出现的想法，是人性中受检验或探讨的某一面。预设就是发生在角色身上事件的叙述，也是故事里动作的结果，它既不是寓意，也不是主题。</p><p>5、小说有三种预设：（1）连锁反应式；（2）反向式；（3）情景式。</p><h1 id="五、预设的再讨论之第二部分：小说家的魔杖"><a href="#五、预设的再讨论之第二部分：小说家的魔杖" class="headerlink" title="五、预设的再讨论之第二部分：小说家的魔杖"></a>五、预设的再讨论之第二部分：小说家的魔杖</h1><p>1、如果没有讽刺与意外的事件发生，角色们自身也没有得到成长，那么显然这个故事不值得一写。</p><p>2、问自己几个相关问题：故事的预设被证明了吗？是否有多余的情节？是否有讽刺或意外的事情？故事角色是否有成长或升华？这个故事值得一写吗？</p><p>3、多预设小说。每个故事都有一个预设，一本小说可以有一个以上的故事，因此也可以有一个以上的预设。</p><p>4、先看几部电影，从预设的角度描述影片内容；接下来看看在不同预设的指引下故事会发生怎样的变化；下一步便是在预设的指导下开始创作。</p><h1 id="六、语气或“谁”，谁在讲故事"><a href="#六、语气或“谁”，谁在讲故事" class="headerlink" title="六、语气或“谁”，谁在讲故事"></a>六、语气或“谁”，谁在讲故事</h1><p>1、强有力的叙述语气给读者一种感觉，即作者对他的叙述了如指掌。在非虚构作品中，强有力的叙述语气通过对语气和事实的支配来实现；而在小说中，则是由对语气和细节的支配来达成的。</p><p>2、作者（叙事者）不应该隐身。</p><p>3、所谓的第一人称比第三人称更亲切、更富色彩的定律毫无根据。事实上，不管是用第一人称还是第三人称，都能实现小说的价值观、表现亲密度、渲染气氛、烘托色彩。</p><h1 id="七、作者与读者合同的订立：不要承诺樱草却交付泡菜"><a href="#七、作者与读者合同的订立：不要承诺樱草却交付泡菜" class="headerlink" title="七、作者与读者合同的订立：不要承诺樱草却交付泡菜"></a>七、作者与读者合同的订立：不要承诺樱草却交付泡菜</h1><p>1、除了小说内容精彩之外，你的读者期待的还是一部常规小说——类型小说、主流小说、纯文学小说。</p><p>2、读者一开始就会对你的预设进行揣测，如果你要履行你在合同中的义务，预设的证实便必不可少。</p><p>3、按照与读者拟定合同的要求，你必须公平公正地向读者履行在合同中的义务。这就是说，如果你写的是一本推理小说，你就要向读者提供一个智胜侦探的公平机会；换言之，你要向读者提供所有的事实、线索等信息。</p><p>4、要不遗余力地避免作者帮助故事中的人物解决难题。你要必须发誓要将老生常谈统统抛弃、要对欠佳的情节退避三舍。</p><h1 id="八、七个致命的错误"><a href="#八、七个致命的错误" class="headerlink" title="八、七个致命的错误"></a>八、七个致命的错误</h1><p>1、第一个错误——胆小。要成为一名作家需要勇气和胆量。你得战胜你的胆小和怯懦，勇敢面对这个坚强的作家团队的批评。其中的一个办法就是忍耐，还可以学会自我朝服，另一个途径就是绝不能让大家讨论你为何要这样创作，不要对自己的作品做任何辩解。</p><p>2、创作中的另一种胆小就是不愿意冒险。不要害怕尝试实现你的效果。</p><p>3、一个作家必须要自我推销，否则他注定是一个无名小卒。</p><p>4、第二个错误——试图成为一个“文人”。这些人的问题在于：他们不是尝试着去掌握创意写作的基本原则，也不是去学习如何让自己的文学作品独具匠心、引人注目，而是把某一个文学巨人当成神。</p><p>5、第三个错误——自我写作。要以读者为中心，而不是以自我为中心，要吸引读者、循循善诱、将读者带进故事中来、通过创造情感试金石来构建读者和故事之间的桥梁、让读者认可故事人物。要让你的读者身心愉悦，而不是自我满足。</p><p>6、客观关联物指的是读者有必要了解和经历故事中引起他们情感共鸣的行为。</p><p>7、第四个错误——不会重构故事。尽管改写故事情节是一项很难掌握的技能，但如果你学不会，就将成为你创作时致命的错误。</p><p>8、第五个错误——不能坚持信念。一旦信念破灭了，作家就不可能再回到以前写作时的状态。</p><p>9、第六个错误——不当的生活方式。p191</p><p>10、第七个错误——没法创作。灵感枯竭的作家还有另一个名字——胆小鬼，他害怕的是作品没能符合自己的标准，然而又有谁的作品符合过呢？p197</p><h1 id="九、激情写作"><a href="#九、激情写作" class="headerlink" title="九、激情写作"></a>九、激情写作</h1><p>1、这是小说家的黄金时代。</p><p>2、除了写作，没有更好的方法可供你在地球上消磨时光了。</p><p>3、你必须仔细审视你的内心，并找到生活中你最在意的事物，这样你才能实现你真正的愿景。</p><p>4、写一份写作目的宣言书很有必要，例如，如果你将作家当做你一生的职业，你想要获得怎样的成就；就你所写的某本书而言，你想借此得到什么。等等。</p><p>5、写作是一个分享经历、传达人生信条的过程，没有所谓的“纯属娱乐”一说。你写作的内容无论是在情感层面还是精神层面上都应有极大的影响力，如果你发挥得好，这种影响力会深入骨髓。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、唤醒虚构梦境&quot;&gt;&lt;a href=&quot;#一、唤醒虚构梦境&quot; class=&quot;headerlink&quot; title=&quot;一、唤醒虚构梦境&quot;&gt;&lt;/a&gt;一、唤醒虚构梦境&lt;/h1&gt;&lt;p&gt;1、要展示，不要叙述。小说家试图去“展示”，通过感官细节上的暗示将读者拖入虚幻的梦境。    &lt;/p&gt;
&lt;p&gt;2、同情是一种“认可”。要让观众产生同情，得先让他们对角色产生同情感，这是很关键的一点。&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《C++并发编程实战》笔记</title>
    <link href="http://yoursite.com/2018/10/25/%E3%80%8AC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/25/《C-并发编程实战》笔记/</id>
    <published>2018-10-25T14:36:33.000Z</published>
    <updated>2018-10-25T14:44:04.053Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action" target="_blank" rel="noopener">书籍中文版翻译地址</a></p><p><a href="https://github.com/bsmr-c-cpp/Cpp-Concurrency-in-Action" target="_blank" rel="noopener">书中源码地址</a></p><h1 id="一、你好，C-的并发世界！"><a href="#一、你好，C-的并发世界！" class="headerlink" title="一、你好，C++的并发世界！"></a>一、你好，C++的并发世界！</h1><p>1、最简单和最基本的并发，是指两个或更多个独立的活动同时发生。</p><p>2、为性能而使用并发就像其他所有优化策略一样：它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。<br><a id="more"></a><br>3、C++多线程历史：C++98标准不承认线程的存在，并且各种语言要素的操作效果都已顺序抽象机的形式编写。不仅如此，内存模型也没有正式定义，所以没办法在缺少编译器相关扩展的情况下编写多线程应用程序。但C++11新标准改变了这一切，主要模型是Boost中的线程库。</p><p>4、管理线程的函数和类在头文件<thread>中，而保护共享数据的函数和类在其他头文件中声明。简单例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;//添加头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span><span class="comment">//每个线程都必须有一个初始函数，新线程的执行将从这里开始，对于主线程来说是main()。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;<span class="comment">//将hello函数作为新线程的初始函数，</span></span><br><span class="line">t.join();<span class="comment">//使调用线程等待t相关联的线程运行结束，少了这一行会报错，因为main可能就会在新线程运行之前结束了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></thread></p><h1 id="二、线程管理"><a href="#二、线程管理" class="headerlink" title="二、线程管理"></a>二、线程管理</h1><p>1、使用C++线程库启动线程，可以归结为构造thread对象。</p><p>2、构造对象时要避免“最令人头痛的语法解析”问题，如：<br>std::thread    my_thread(background_task());<br>这里相当与声明了一个名为my_thread的函数，这个函数带有一个参数(函数指针指向没有参 数并返回background_task对象的函数)，返回一个std::thread对象的函数，而非启动了一个线程。<br>可使用如下写法避免：<br>std::thread    my_thread((background_task()));        //    1<br>std::thread    my_thread{background_task()};        //    2<br>或用lambda表达式：<br>std::thread    my_thread([]{<br>        do_something();<br>        do_something_else(); })</p><p>3、启动了线程，你需要明确是要等待线程结束(加入式)，还是让其自主运行(分离式)。</p><p>4、使用一个能访问局部变量的函数去创建线程是一个糟糕的主意(除非十分确定线程会在函数完成前结束)。</p><p>5、通常称分离线程为守护线程(daemon    threads),UNIX中守护线程是指，没有任何用户接口，并且在后台运行的线程。</p><p>6、向线程函数函数传递参数。P29</p><p>7、需要在线程对象被析构前，显式地等待线程完成，或者分离它；进行复制时也需要满足这些条件(说明：不能通过赋一个新值给std::thread对象的方式来”丢弃”一个线程)。</p><p>8、    std::thread::hardware_concurrency()在新版C++标准库中是一个很有用的函数。这个函数将返回能同时并发在一个程序中的线程数。</p><p>9、线程标识类型是std::thread::id，可以通过两种方式进行检索。第一种，可以通过调 用std::thread    对象的成员函数get_id()来直接获取。如果std::thread对象没有与任何执行线程相关联，get_id()将返回std::thread::type默认构造值，这个值表示“没有线程”。第二种，当前线程中调用std::this_thread::get_id()(这个函数定义在<thread>头文件中)也可以获得线程标识。</thread></p><h1 id="三、线程间共享数据"><a href="#三、线程间共享数据" class="headerlink" title="三、线程间共享数据"></a>三、线程间共享数据</h1><p>1、不变量通常会在一次更新中被破坏，特别是比较复杂的数据结构，或者一次更新就要改动很大的数据结构。</p><p>2、C++中通过实例化std::mutex    创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。C++标准库为互斥量提供了一个RAII语法的模板类std::lack_guard，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。</p><p>3、具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/xiaoweiChen/Cpp_Concurrency_In_Action&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书籍中文版翻译地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bsmr-c-cpp/Cpp-Concurrency-in-Action&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;书中源码地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、你好，C-的并发世界！&quot;&gt;&lt;a href=&quot;#一、你好，C-的并发世界！&quot; class=&quot;headerlink&quot; title=&quot;一、你好，C++的并发世界！&quot;&gt;&lt;/a&gt;一、你好，C++的并发世界！&lt;/h1&gt;&lt;p&gt;1、最简单和最基本的并发，是指两个或更多个独立的活动同时发生。&lt;/p&gt;
&lt;p&gt;2、为性能而使用并发就像其他所有优化策略一样：它拥有大幅度提高应用性能的潜力，但它也可能使代码复杂化，使其更难理解，并更容易出错。&lt;br&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>《弗雷的小说写作坊-秘境游走》笔记</title>
    <link href="http://yoursite.com/2018/10/10/%E3%80%8A%E5%BC%97%E9%9B%B7%E7%9A%84%E5%B0%8F%E8%AF%B4%E5%86%99%E4%BD%9C%E5%9D%8A-%E7%A7%98%E5%A2%83%E6%B8%B8%E8%B5%B0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/10/《弗雷的小说写作坊-秘境游走》笔记/</id>
    <published>2018-10-09T16:03:43.000Z</published>
    <updated>2018-10-28T15:36:09.297Z</updated>
    
    <content type="html"><![CDATA[<p>一部戏剧性小说具有如下特点：它以一个中心人物即主人公为焦点，该主人公面临困境；这个困境发展成一种危机；这种危机通过一系列纠纷构建成小说的故事高潮；在高潮部分危机化解。p13<br><a id="more"></a></p><h1 id="一、所有的秘密就在于“人物”"><a href="#一、所有的秘密就在于“人物”" class="headerlink" title="一、所有的秘密就在于“人物”"></a>一、所有的秘密就在于“人物”</h1><p>1、如果你不能塑造出在读者心目中活灵活现的人物形象，那你就不可能创作出令人拍案叫绝的劲爆小说。小说中的人物形象无论如何不能等同于现实中有血有肉的活人本身，要更加不同寻常，但要依然可以认识、理解。p3<br>小说人物是对现实人物的抽象描写，他展现现实生活中原型的本质，但并不是原型的全部。</p><p>2、小说人物有两种类型：扁平人物和圆形人物。<br>圆形人物三位一体：生理维度、社会学维度以及心理维度。</p><p>3、对大多数作者来说，包括所有的写作初学者，为角色写传记是小说创作中最必要也最重要的一步。</p><p>4、两个主要因素决定你在小说创作中对人物特征的取舍：打破原型、精心编排。</p><p>5、为角色写传记的时候，应寻找能影响故事中角色的情感和行为的因素。</p><p>6、塑造一个鲜活、不刻板的人物形象，其秘诀在于将人物身上那些读者没能预料到在同一个角色里会见到的特质糅合起来。</p><p>7、无论何时，你的主人公都面临这些要紧的决定。再问问自己关于能力极限的两个问题：第一，他真的会这么干吗？第二，他还能做其他更加巧妙、更戏剧化、更令人惊奇或者更有趣的事情吗？</p><h1 id="二、杰作生成三大妙法：冲突、冲突、冲突。"><a href="#二、杰作生成三大妙法：冲突、冲突、冲突。" class="headerlink" title="二、杰作生成三大妙法：冲突、冲突、冲突。"></a>二、杰作生成三大妙法：冲突、冲突、冲突。</h1><p>1、如果没有了由矛盾冲突所产生的紧张和刺激，即使世界上最精心设计的情节也是不起作用的。</p><p>2、主要人物+目标+对抗性因素=冲突。</p><p>3、让你的人物处于熔炉之内。熔炉是一个能够将人物聚集在一起像物品一样加热的容器。</p><p>4、内心冲突。假设你的主人公被召唤上战场，首先要确定他有强而有力的理由让他极不情愿参战。</p><p>5、戏剧冲突的模式：静止型、跳跃型和渐进型。P57<br>静止型冲突是指任何一种不发生变化的戏剧冲突。<br>跳跃型冲突时指在没有充足动因或过渡阶段的情况下，从一个紧张强度跃进到另外一个。<br>在顶级的戏剧性小说里，冲突是循序渐进的，渐进型冲突的秘密是从进攻和反击的角度来思考冲突。</p><p>6、如何确保拥有渐进型冲突？<br>第一、经常在脑海里用渐进型冲突构思小说。<br>第二、只有当人物发展变化时，冲突才可以升级；当冲突升级时，人物随之变化发展。<br>第三、为了确保你能有一个逐渐升级的冲突，在场景开始和结束的时候你都应该关注人物的情绪波动状况。人物在每个场景中都应该有循序渐进的变化。</p><p>7、核心矛盾：人类反抗自然、人类反抗人类、人类反抗社会、人类反抗自己、人类反抗命运。</p><p>8、类型，文学的分隔板。要深入了解那些传统、惯例和不同流派的类型。一旦熟知那些类型，就会知道在这些类型中的前提假设是什么。如果你把矛盾冲突看成小说写作的火药，那前提就是加农炮。</p><h1 id="三、前提很重要，小说没有前提就如同无桨划船"><a href="#三、前提很重要，小说没有前提就如同无桨划船" class="headerlink" title="三、前提很重要，小说没有前提就如同无桨划船"></a>三、前提很重要，小说没有前提就如同无桨划船</h1><p>1、在一本小说中，写作前提只有在小说的特殊场景中才能够成为真实。</p><p>2、故事的前提是故事角色在核心矛盾发展下各自的最终命运的简单表现。</p><p>3、寻找自己小说的前提，但不要从一个前提展开故事，而是用人物。</p><p>4、一个好的前提应该包含一个可以通过矛盾冲突带出结论的人物。要记得三C理论：人物(Character)、冲突(conflict)以及结论(conclusion)。</p><p>5、选择性是作家作品的关键部分，选择性即在一部小说中选择囊括什么、忽略什么。</p><p>6、如果没有与整体故事发生如果、而且、但是之类的关系，只能删去。</p><p>7、人物角色、冲突还有前提是砖块和水泥，它们构建了故事。</p><h1 id="四、讲故事的顺序"><a href="#四、讲故事的顺序" class="headerlink" title="四、讲故事的顺序"></a>四、讲故事的顺序</h1><p>1、所有的故事都是事件的叙述，但却不止如此。</p><p>2、故事是对一系列有因果关系的事件的叙述，这些事件涉及有价值的、随着时间变化而变化的人物。</p><p>3、在一个戏剧性故事里，人物斗争是唯一值得一读的东西。人物因为遭受磨难而发生了改变，这样的事件的叙述才可以称其为一个故事，但还不能算是一个戏剧性故事。戏剧中，人物必须要抗争。</p><p>4、小说中的人物面临的困境叫做“故事悬念”，故事悬念使读者愿意继续读下去寻找答案，它是你上大餐前的开胃菜。</p><p>5、现状向读者展示了在核心冲突发生前小说的世界，它是上主菜前的汤和沙拉。</p><p>6、可以从故事开始前开篇，也有在另一种选择。p102但最好在故事开始前开篇，读者就会了解人物并同情他。你可以将标志着故事开始且发生于现状中的改变戏剧化。</p><p>7、阶段表是一个记载故事巧合的详细的计划表。使用阶段表是作者掌控故事的一个方法，可以将之看做一个蓝图。</p><p>8、故事的事件、冲突能影响读者，因此人物应对冲突时，会随着故事的推进而改变。</p><h1 id="五、冲突上升或证据存在于前提中"><a href="#五、冲突上升或证据存在于前提中" class="headerlink" title="五、冲突上升或证据存在于前提中"></a>五、冲突上升或证据存在于前提中</h1><p>1、将故事的高潮看做目标，其他的故事情节看作飞行的射线。</p><p>2、故事就是斗争。主人公遇到困境、受到攻击时，你的小说就开始了。人物与困境斗争，困境变成危机；危机发展到一定程度，急需解决；采取行动后，带来了高潮。结果要么令人满意，要么令人不满，但是危机结束了。无论如何，整个现状发生了改变，不管事态发展如何，进化都是必然。</p><p>3、尽管在高潮时刻核心冲突得到解决，但这并没有验证前提。前提是由结合成一个整体的冲突和化解证明的。</p><p>4、每一个故事的主要人物都有自己的命运。因此，每个角色都有各自的前提。</p><p>5、如何构成一个伟大的高潮？第一，寻找惊喜；第二，激发强烈的情感；第三，在诗意的正义法院宣布判决；第四，发掘人物新的一面；第五，高潮——解决应使小说完整。</p><h1 id="六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意"><a href="#六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意" class="headerlink" title="六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意"></a>六、视角、观点、倒叙和小说家的魔术袋里的一些小玩意</h1><p>1、人物视角是该任务所有意见的集合，包括偏见、喜好、态度。他的视角决定了他怎样解读世界。</p><p>2、视角分类：客观视角、修正的客观视角、第一人称主观视角、全知视角、有限的全知视角。</p><p>3、叙述者独特的说话方式叫做叙述声音。</p><p>4、小说家是一个魔术师，向读者编织一个咒语。为了催动周瑜，小说家用了一个叫做“认同”的魔术。</p><p>5、一旦一种情感在故事的开头被激起，人物应该立即被置于不断发展的危机中。如果你已经感动了读者，他们就会感兴趣，但是，真正的认同只能发生在人物面临选择时，读者也能参与到决策过程中。</p><p>6、倒叙是经常被错用和滥用的小说技巧。读者觉得大部分倒叙都难以忍受，但还有许多新手像疯了一样倒叙。倒叙可能只是愚蠢的作者想要避免冲突的手段。</p><p>7、什么时候倒叙是绝对必需的呢？如果你的人物被置于一个境遇中，他的行为与他在故事发生的这个时刻之前的行为完全相反，那么它是必要的。在你使用倒叙之前，问问自己在当下的小说中采用冲突是否能达到同样的效果。</p><p>8、伏笔并不是冲突，而是冲突的迹象。伏笔是提出故事悬念的艺术。伏笔是一个预示，如果作出了预示而没有实现它的话，你就是在欺骗读者。</p><p>9、如果有无聊又冗长的叙述，在其中加伏笔。</p><p>10、象征符号是除了事物本身的意义外对一些人有其他意义的事物。</p><p>11、如果一位人物有任务和目标，它应该符号化。</p><h1 id="七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧"><a href="#七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧" class="headerlink" title="七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧"></a>七、创造精彩对话和令人赏心悦目的散文体小说支精妙技巧</h1><p>1、直白对话表达的恰好是人物所想，不用费力去描述人物如何表示反对、使用诡计、说谎、表现机智等。成功的对话含蓄地表达人物的意志。</p><p>2、戏剧性小说有三种模式：戏剧化叙事模式、场景叙事模式、半场景叙事模式。在戏剧化叙事模式中，叙事者叙述相关情节，展现角色成长经历，运用内部矛盾，但这些都是以一种总结性方式来叙述的；场景叙事模式是，在某一个场景中，叙述者描述所发生的情节；半场景叙事模式是一种被打断的戏剧性叙事，里面糅合着部分场景。</p><p>3、戏剧性创作需要不断激化的矛盾，这种矛盾不仅对整个戏剧性故事来说有必要，而且对戏剧性场景也有必要。</p><p>4、很多情况下全场景并不可取，，因为在场景开头时矛盾的力道通常不足以吸引读者。而跳入其他场景可以加速小说剧情发展，使你的读者参与矛盾激化的过程。写小说时，你要考虑每一个场景，问问自己哪些场景可以剪掉，以便加快小说节奏。</p><p>5、好的对话应该是置于矛盾中的、间接的、机智的、丰富多彩的。p172~p176的例子。</p><p>6、对每行对话思考以下几个问题：是不是有冲突？是不是太陈腐？委婉地说会不会更好？台词是否已经尽量做到巧妙、生动了？</p><p>7、动态散文体小说有三条戒律：具体、有感染力、富有诗意。具体：概括性的话要变具体，加入细节。有感染力：带起多种感官上的感受：视觉、嗅觉、味觉、触觉以及听觉甚至心理上的感觉。富有诗意：富有诗意但又不要太诗意，诗意意味着用修辞来实现不错的效果。</p><p>8、练习比喻，每次叙述时，都要试着尽可能多地运用恰当的修辞。</p><p>9、总的来说，散文体小说应该有时间跨度，色彩斑斓，结构缜密（具体而明确，不是泛泛之谈）；能够传递一种动作感；能够调动七种感官——听觉、视觉、触觉、味觉、嗅觉、心灵感和幽默感。</p><h1 id="八、修改：最后的煎熬"><a href="#八、修改：最后的煎熬" class="headerlink" title="八、修改：最后的煎熬"></a>八、修改：最后的煎熬</h1><p>1、几乎每个人都能写东西，但是只有作家知道如何修改，只有这种能力才能使业余作家提升为专业作家。</p><p>2、让作家评估自己所写的内容是极其困难的，除非他们知道初稿的亮点和缺陷，否则不可能将初稿变为成品。</p><p>3、解决问题的一个方法是找得到一个作家群，征询他们的意见。有三种作家群：吹捧派、文学派和抨击派。抨击派是唯一一个有价值的群体。</p><p>4、没有抨击性作家群的话，自己做自己的评论家，并寻求朋友的帮忙，可以不告诉他们是你写的，让他们没有道德负担，让他们说清楚每一个不好的地方，确切说出他们不喜欢的点——角色、环境、节奏等等。</p><p>5、为评论者们提供一张评论要素清单，让他们列举你故事中的哪些要素得到了“最专业的处理”。也可以将小说中的每一个场景按等级排列在一条兴趣曲线上，让他们给每一个场景打分，分值从1到10。</p><p>6、可以请读者们看完后给你复述这个故事，他们遗漏的部分可能就是无聊得犯困的部分。</p><p>7、可以将你的小说录到录音机里，然后播放它。或者试着将小说从头到尾讲给朋友听，你略去的和那些讲述起来笨嘴拙舌的地方能帮你定位缺陷之处。如果把草稿搁置一段时间再分析的话，你会更容易、更客观地进行分析。</p><p>8、问自己几个问题：1、你是否已经证明了自己的前提？2、是否已经使读者对人物产生共鸣？3、有没有反面人物，他们都表现得淋漓尽致吗？等等p199</p><h1 id="九、小说写作之道"><a href="#九、小说写作之道" class="headerlink" title="九、小说写作之道"></a>九、小说写作之道</h1><p>1、什么最重要？并不是天赋。是自我训练、顽强的决心、坚韧不拔的毅力。天赋只会带来阻碍，因为如果拥有天赋，你就会认为写小说很容易。</p><p>2、完成一篇小说的秘诀是规律性。每天都要坚持在同一时间写作。你必须对在那个时间段的所有其他事情、所有干扰你创作的事情说“不”。</p><p>3、灵感丧失时，你的行为将你与那些声称“我将要写一本书”的人区分开来。</p><p>4、如果你真的思路受阻，最重要的是记住，作家都会经历瓶颈期，这没什么好担心的。你要做的就是让这些刺激因素消失。你可以重新打出自己已经写好的内容，从而起到热身的作用。也可以放热门音乐。不管做什么，只要别推迟写作就行。继续敲打键盘，即使写出的是官样文章也行。只要坚持写，你就会度过写作的瓶颈期。如果离开打字机，你永远也无法走出瓶颈，并且在下一次瓶颈到来的时候更容易重蹈覆辙。</p><p>5、不要讲其他影响创作的情绪与作家的瓶颈期混淆。真正的作家瓶颈期有四个基本原因：对你的人物不够了解，试图将编辑和写作同时进行，害怕失败，害怕成功。解决办法见p214</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一部戏剧性小说具有如下特点：它以一个中心人物即主人公为焦点，该主人公面临困境；这个困境发展成一种危机；这种危机通过一系列纠纷构建成小说的故事高潮；在高潮部分危机化解。p13&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>未完待续-贰</title>
    <link href="http://yoursite.com/2018/05/31/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E8%B4%B0/"/>
    <id>http://yoursite.com/2018/05/31/未完待续-贰/</id>
    <published>2018-05-31T09:36:46.000Z</published>
    <updated>2018-05-31T09:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2017年1月21日，2018年5月31日上传保存。）</p><p>有的时候是看见一句话。<br>有的时候是听见一首歌。<br>有的时候是站在老地方。<br>有的时候是见到老朋友。<br>有的时候是静在沉默里。<br>但更多的时候是在呼吸里。<br>想你。<br>想我是怎么渐渐失去了你。<br>我的匆匆时光。<br><a id="more"></a></p><p>是2013年吧，我结束高考，怀揣着一份不满意的成绩，来到我满意的城市，上了一所不甚满意的大学。依稀还记得军训时我曾独自坐在宿舍靠窗的位置，透过窗外那颗不知年岁几何的枇杷树树隙，看蓝天被枝条切割成零碎不一的图案，偶尔被阳光刺到，就像是斑驳的万花筒晃了我的眼。<br>江南曾在《此间的少年》里写他当年北大宿舍窗外是一棵梧桐树，静若仙女的王语嫣某个清晨从树下走过，就轻轻带走了碰巧趴在窗前的段誉的心。我的学校比北大差远，枇杷树也不如梧桐树有意境，男生宿舍区里的枇杷树下更不会有女生走过，但也曾无数次听到这棵枇杷树在雨夜里的交响曲，也曾见过枇杷成熟的季节里男生们偷着竹竿背着宿管大妈打落果实，短裤背心，摸滚打爬。<br>就这么一晃眼，2017便已到了，他笑眯眯地说着：“你终于来了”，似乎等了我们很久，却又偷偷摸摸地把沉重压上我们的肩头。<br>嘿，又要毕业了。<br>谁能想到这么快呢？</p><p>2015年8月的时候，我写了《未完待续1》，到如今已经一年半的时间，大学本科还剩下最后半年的时间。在这个春节之前我犹豫了很久，最终决定还是写下《未完待续2》，大概没有《未完待续3》了吧，也可能会有，也可能换一种形式……比如《梧桐树下的少年》这种形式（微笑）？<br>兴许是人老了记忆衰退，也或者是大三之后事情变多，很少有之前所写的大块事件，记忆里的事情大多琐碎，就像那年夏天我透过那棵枇杷树看到的蓝天。<br>记不起事情的时候我就会默默翻开自己的说说，沿着时间顺序阅读下去，有些说说早已忘了为何而发，那应该是些惹人冲动的事，时间已经抚平就无须再刨根问底，依然记得的那些才是重要的。</p><p>2015年八月，时间在刚发完《未完待续1》后不久，我受ZC等人挑唆曾入过《天涯明月刀》的坑，着着实实地玩了一月有余。<br>天涯、明月、树影、孤鸟的加载界面出现的时候，我心中似乎有根弦绷紧，仿佛一扇大门打开，刀光剑影、快意恩仇的世界展现，带着丝丝凛意。<br>如今游戏早已弃坑，但那时我选择了唐门，角色名为牧南山，紫袍荡荡，折扇翩翩。<br>是的，他是《南山北海》的主角原型，是我笔下第一个武侠人物。我倾注了不少心血，最终把他写成那个天下第一、唐门无双、为亡妻与天下敌的绝世高手！虽然在游戏里他被一个叫“心有林西”的神威用一杆枪戳得不要不要的……好吧我打不过你我还写不过你？<br>没有玩游戏的天赋，真是不能不认。<br>顺带提一句，我女朋友也被我拉进了坑……<br>对，你们猜的没错，她游戏的ID就是北海，北海谷。<br>南山有墓，北海有谷。<br>如果还有下一篇武侠，可能就在北海。</p><p>我本想把大学的事情都留到一本可能名为《梧桐树下的少年》这样中二名字的书中去，可是当时间来到2015年九月后，即大三上半学期时，有些事却还是想稍微提一提。<br>这一学期，我接替学长的位置，荣幸担任院科协某部部长一职。<br>我曾经仔细想过，为什么生性内向腼腆的我会毫不犹豫接受任职？<br>可能是为了锻炼自己，可能是为了那几点加分，自然也可能是为了年轻可人的学妹们啊！<br>不过现在，我感觉应该找到了答案。<br>很简单，只是为了不后悔吧。<br>迎新那天，面对满满一屋子学弟学妹，上台介绍的时候，我的双腿还在微微打颤，语言也不慎利索，自己都觉得已经搞砸了。可是最后的结果还不错，竟然成功地骗到，哦不，招到十几位新学员，最关键的是……学妹整整一半多哩！<br>也是那时，我才真正走进科协这个大家庭，认识了一群新的伙伴：一起打撸的SSM、一起聊天说地的WTT、一起闹腾的ZY学妹……<br>有人的地方就有江湖，科协不过二三十平米，大家低头不见抬头见，自然便是江湖。江湖里可说的东西太多，三天三夜也讲不完，我会尽量把它写入《梧桐树下的少年》里，如果真的会有这本书的话……<br>若有一天我真的写那样一本书，真的又能写到结尾，那说不定会有这么一个段落：<br>我毕业一年后的某天，科协里已经空荡荡了，突然有人挤开钥匙走进来，是ZY，那天是她毕业的日子，她来科协收拾东西。她可能会在开门之后站在门口默默朝里注视一会儿，然后才打开灯走进来。<br>她座位正上方的那盏灯可能到那时也没有人修，显得她的位置稍暗一些，整个人的表情都看不清。<br>她坐在座位上，撕去桌上贴着的名牌，揉成一团，却又慢慢展开摊在桌前。<br>她沉默地收拾东西，轻轻地放进包里。<br>收拾完了桌上东西，她可能会发现被压在桌下已久的、老旧的纸张。<br>那是往届的名牌。<br>可能是SSM的，可能是WTT的，可能是我的……<br>…………<br>哈哈，熟悉的人一定会大喊：“你扯淡吧就！ZY是那样安静文艺的人吗？！”<br>哈哈，说的也是，如果真是ZY，恐怕最可能的情形就是……<br>“嘭！”科协的门被摔开。<br>“啪！”灯被拍开。<br>“咚咚咚！”东西被灌进书里。<br>“唰唰唰！”名牌、废纸连通着垃圾被甩进垃圾桶。<br>“哗！”拉链拉上。<br>灯灭。<br>门阖。<br>ZY就是这么雷厉风行的妹子。<br>但即便是她，我相信也会在某个的时刻想起那间屋子里的欢声笑语、淙淙流年。<br>然后，可能，我是说可能。<br>她会站在门外，轻轻松开关门的手，透过窗户深深往里看一眼，缓缓握紧那把钥匙。</p><p>大三上半学期还有些事，比如宿舍二公子终于脱单，对象是大一的某学妹……<br>不管怎么说，宿舍终于不是我单独面对五只单身汪的局面了。<br>事到如今不得不简单提一提宿舍六位公子了。<br>宿舍一公子的常态就是盘膝坐在上铺，床帘围得严严实实，玩手机。如果是冬天他还会戴上羽绒服的帽子，然后盘膝坐在上铺，床帘围得严严实实，玩手机……<br>宿舍二公子，和一公子并称宿舍两睡神，大多时稍逊一公子一筹，巅峰时堪称一时瑜亮！二公子社交能力极强，巧言善辩，学生会副主席，他说他梦想做《此间的少年》里的杨康，我却总觉得他是欧阳克……<br>宿舍三公子，清秀小白脸，大学两件事，睡觉配游戏，是那种传说中的“高玩”，巅峰时期《梦幻西游》五开，卖出去不少钱，也带我入过不少坑，《天龙八部》、《武魂》、《剑灵》、《天谕》……当然不能少了LOL。除了LOL，其他游戏没在我这活过一个月。现在和二公子迷上狼人杀，都是狼王级别。<br>宿舍四公子，本宿舍学霸，保研狗一枚，大三时任学生会学习部部长，大一时就跟我念叨妹子，到现在还是跟我念叨妹子，有贼心没贼胆的典型代表，长年占据宿舍找资源的第一把交椅。<br>宿舍五公子，文艺暖男，周董资深粉丝，什么雨中送伞没钱刷卡找他准没错，大二时恋上学妹一枚，不果遂黯然神伤，口号是“忧伤是一种态度”。<br>宿舍六公子，不多说了，神仙下凡。<br>二公子谈恋爱是用了心的，每晚都很晚回来，然后朋友圈就会在每晚的固定一段时间多一条动态，有时候是学校的夜景，有时候是稍远一些地方的夜景图，佳人依袖，灯火几重，美不胜言<br>…………<br>后来有个深夜，二公子重重捶床，久久不寐。那晚一公子前往南航赴约，缺席一出。<br>“出去喝酒吧。”黑暗中他轻轻说。<br>凌晨一点的光景，五条汉子从被窝里钻出来，撑开伞，走在只剩路灯的校园里，安静得只剩小雨淅淅沥沥的声音。<br>夜太深了，烧烤店都灭火打烊了，辗转几圈只有饺子店还开着门。<br>饺子店里还有不少聚餐的学生，人声鼎沸。<br>“吃什么饺子？”服务员问道。<br>“酒，来酒。”二公子说着，便上了楼。<br>有饺子，有肘子，当然还有酒。<br>大家聊着，依旧没心没肺的，有些事却避而不谈。<br>渐渐二公子的神情松弛了些，脸上却已微红。<br>不说二公子，便嘲讽五公子，嘲讽他追学妹一年无果，那曾是宿舍的乐事，五公子也不生气。<br>“舍长，XXX最近咋样了？”三公子问。<br>忘了说，五公子是我们的舍长。<br>五公子喝了口酒，也不避讳，直接道：“和YYY在一起了好像。”<br>“那是谁？”<br>“球队的。”五公子说着，又喝了口酒，“快当队长了。”<br>“哦……”我们不问了。<br>我们还能问什么呢？<br>五公子也是球队的，是这一届的队长。<br>五公子把部门留给了那位学弟，把球队留给了他，现在好像连学妹也留给了他。<br>聊到三点多终于决定回去，多年后我可能还记得那个夜晚，他们四个走在前面的路灯下，我眯眼看他们的背影，觉得路灯下的影子格外得长。<br>我总怀疑二公子会突然冲到马路中央冲着空旷无人的马路大吼，但他没有，反而走得比我们都稳，好像要证明什么。<br>可是经过学妹宿舍的时候，他没有忍住。<br>他猛地冲了过去，很快就融入了黑暗里看不见了。<br>我们四个静静站在一边，等着他吼，或者不吼。<br>他没有吼。<br>过了会儿他的身影重新从黑暗里靠近，眼神疲倦。<br>“困了，回去睡觉。”他说。<br>从我身边经过时我感觉到他外套上褪不去的寒意。<br>我不知道那时他在黑暗里看了些什么，又想了些什么。<br>我到现在也不知道。</p><p>大三到这告一段落吧，不然就收不住了，还是那句话，如果有《梧桐树下的少年》的话，我会尽量写进去，我们宿舍其实每个都是大好青年啊！<br>时间来到大三下，也就是2016年的上班年，也面试过几次实习不过好像都没过，对于一个内向不善交际的人来说，只能把每次面试都当做锻炼，吸取教训再逆流而上。<br>也是在2016的上半年，我完结了在创世连载的小说，共计209W字，耗时两年多，算是给了自己一个交代。<br>关于这本小说，实在没什么好说的，扑街是自然的，靠着拿全勤赚的几千块钱也早花光。<br>借着新年的机会，感谢感谢那些一直支持我到这本小说完结的人，没有你们，实在写不下去。<br>也是从这本小说完结时开始，我决定不写网文了，一来是硬性要求比较累，二来则是我觉得那不是我真正想要的，三则是觉得自己似乎不适合，我挺喜欢宁忘川、叶芷柔、林月雅等人的，可好像没什么其他人喜欢，那便算了。<br>要说我真正想要的，《南山北海》算是一篇，这些日志也可以算，不过都只是雏形，差得还很多。<br>以后，还需努力。<br>至于放弃，还没想过。</p><p>其实2016那个暑假就已经是毕业的前奏，XS放假很晚，等他回来CX已经去学校准备考研了，三人竟没能聚到一起。<br>我和XS思忖了几天，决定去常州CX玩玩，顺便去一次淹城动物园。<br>天很热，TY和SYY等人一直在群里质疑我和XS这种大热天白找罪受的行为，懒得解释，女生有时候是搞不懂男生的，反之也一样。<br>不过……天真的很热啊，我们三人平均在动物园厕所里冲了不下三次头，T恤脱下冷水一冲再套上，唯有这样才能有些凉意。<br>动物园里那些叫得上名叫不上名的动物也很热，有水坑的例如河马等根本不露头，没有水坑的一脸生无可恋，躲在阴影里不屑地看着我们，像是也在说：“这么热的天傻逼才来看我们。”<br>“好热啊！”我把脑袋探出浏览车外对天大喊。<br>浏览车租价一天八十，本来只坐两个人，售票大妈见我们三人块头都不大遂大手一挥：“三人挤一辆吧，帮你们省钱吧！”<br>我是挺感谢她的，可就是……真的挺热的。<br>“轰隆隆！！”空中雷声大作，转瞬间暴雨倾盆而下，阳光却依旧刺眼。<br> “我了个靠……”我连忙把头缩回来，撑开伞挡住一边，回头对左边的CX喊，“你打伞撑住那边！”<br>于是，一辆小小浏览车，挤着三个老爷们，撑着两把雨伞当车门，慢悠悠地行驶在雨中。<br>雨砸在车窗上，“咚咚”作响。<br>“张Y你真牛逼！”XS握着方向盘，道。<br>“简直雨神。”CX说。<br>“嘿嘿，”我笑，“雨中漫步，多特么有意境！懂不懂啊你们！”<br>“有意境你自己漫去！”二人异口同声。<br>路经一道回廊，回廊上藤蔓缠绕地十分严实，竟将大雨遮了七七八八。<br>我从回廊这边望去，雨帘里还有几辆浏览车也在缓缓前进，有的是情侣，有的是亲子，也有的是一个人，静静地停在回廊里，斜斜靠在座位上不知在看些什么。<br>那天后来的天气就在曝晒和暴雨之间切换，太阳可能觉得换来换去烦了，干脆一直高悬在空中，便成了太阳雨。<br>光和雨都从那些缝隙里透进来，雨金光闪闪的，像是过往的岁月在流动，也像是我们在时光里彼此追逐彼此相融。<br>我想起很多很多年前在空间写的矫情文字，那时还是个中二的少年，矫情的文字现在是决计看不下去的。隐约记得在那篇不知能不能称为文章的文章里，太阳雨有深刻的含义。<br>如今想想，自己都不由摇头笑出了声。<br>当时真是年轻。<br>不过转念一想，自己竟然喜欢写东西喜欢了这么久？倒也是不容易。<br>时光匆匆，很少有东西是不变的，但这份热爱不变，纵使没啥成绩，也真是开心啊。<br>淹城动物园有野生区，这还是我第一次进野生区，动物不再被囚禁在可见的牢笼里，而是就在我们身边。<br>斑马在奔跑，羚羊在漫步，狮子在咆哮，狗熊在蹭树。<br>我们买了两包喂食，递给路边的羚羊。羚羊并不怕人，雄羚羊顶着树杈型的鹿角缓步靠近，鼻翼扇动，眼睛大得吓人。<br>从野生区离开，我们去看了表演。<br>鹦鹉表演和别处一样，倒也没什么出彩；<br>狗熊表演十分搞笑，我记住了那两只对拳的狗熊；<br>最后的大马戏无比震撼，杂技魔术精彩丰呈，场面美轮美奂，强烈推荐。<br>马戏团来自乌克兰，乌克兰美女名不虚传！！<br>马戏结束后天色已晚，我和XS也和CX告别，坐上返程的汽车。<br>如今已是寒假，只是三人却彻底没了聚在一起的机会，XS被学校派往帝都实习，过年也不回家。<br>下次见他，还不知是什么时候。<br>可能到时他的肩上已经别着军章了吧。</p><p>暑假里按照传统和FXT、TM聚了一回、和ZL吃了一顿饭，也和许久不见的BLY约了一次，她依然明媚如花，一起看了一场《大鱼海棠》，画面挺好的。<br>后来得知BLY竟然也在玩撸啊撸，我便腆着老脸找她一起开黑了几次，哈哈，反正我菜得抠脚，她也不嫌弃我，有点找回曾经前后桌的感觉，真好。<br>八月一日，我记得这一天，对我来说是个好日子。<br>南航面试通过，亚信面试也通过，一时间好像学业事业双丰收。<br>如果没有我后来的傻逼行为，确实很好。</p><p>八月和九月，是我2016年两度转折的时间。<br>八月份的那张实习offer让我错过和CX等人在家相约的日子，早早来到南京，开始我短短的两个月实习之旅，熬过夜、吃过苦，认识了不少公司前辈，尤其是我的导师为我解了不少惑。<br>若是没有九月份发生的事情，我恐怕会在公司呆得久一些。<br>九月……痛苦的九月。<br>因为自己的失误，保研名额拱手让人，我不得不辞去工作，不得不从九月末十月初加入茫茫考研大军，再一次拼独木桥。<br>起初当然是痛苦的，记不清有多少个夜晚我蜷缩着对着冰冷的墙壁，只觉得痛苦从每一个细胞里挤出来，顺着四肢百骸撕扯着、咆哮着，像要把我扯碎。<br>三年前高考输了，三年后，又输给了自己。<br>没有人知道那段时间我重读了《老人与海》，一遍又一遍。<br>二公子也不知道这事，但他曾拍拍我说：“人如果颓废了，那才真的废了。”那时我把自己整个人都裹在被子里，半天都不说话。<br>有时候想想人真的是个神奇的物种，二公子自己也是颓废起来能整天不下床的人物，竟偏偏能说出这样的话。而我明明知道他是个怎样的人，却还偏偏觉得他说的真特么对，好像他真的废寝忘食一样。<br>FXT还说：“说不定考研对你来说更好，你能去个更好的学校。”<br>嗯，可能吧。<br>几天之后终于恢复得差不多，望着面前厚厚的复习书，我一头钻了进去。<br>没有plan B。<br>那就只能拾起刀剑，一往无前。<br>所谓不破不立，可能就是这样。</p><p>有人说考研比高考更痛苦，因为高考有一群人在陪你，而考研是一个人在战斗。<br>这么说来的话我倒是运气不错，并不那么害怕孤独，一个人关在科协旁边的培训教室里学一整天也不觉得有什么。<br>隔壁有时会SSM和WTT等人的欢闹声，什么游戏又赢了什么小说好看极了诸如此类。我没觉得吵，反而觉得温馨，嘴角会微微扬起，胸中弥漫着温热的感觉。<br>有什么孤独呢，他们就在隔壁啊！<br>当然也有疲倦的时候，那时就翻开手机找研友聊聊天。</p><p>有时候找CX，他暑假就开始复习了，目标是他女票家乡的一所大学。<br>我复习得晚，数学不会的就问他，惊叹一句：“这你都会！”<br>“废话，这不会考个毛线啊！”<br>“那我不会。”<br>“你才复习几天，怎么可能会？复习完了就会了。”<br>我还会问：“考不上咋办？”<br>“考不上就找工作，我要赚钱。”<br>“不想工作。”<br>“那你二战啊！”<br>“也不想。”<br>“那你去死吧。”<br>“哼唧，爸爸一定会考上的。”<br>“哦，滚去看书。”</p><p>有时候和FJY聊天，她也考研，目标远大，却不够自信，一遍一遍地问我她能考上么她能考上么，像个紧张过度的妹妹。<br>我说：“能能能，当然能，不能不行！”<br>仿佛咬牙切齿，怒目如龙。<br>她很单纯，我这么说她便笃定地不得了，学我一样得咬牙切齿：“嗯嗯！！我们都能考上的！！一定！！！”<br>“考不上提头来见！”<br>“好！截图为证！！”<br>过了一会儿，她果然把截图发了过来，这张截图至今保留在我手机里，每每想起，都像有鼓声响在耳边，振聋发聩。<br>我想象屏幕那头的丫头，轻咬着下唇，目光里光芒涌动，微微鼓着腮帮子，用力握拳。<br>嘿，真是力量源源不断地上涌啊！</p><p>有时候和ZYN聊天，她沉稳得多，言语比我还少，我总觉得她才有真正考研人的样子，每天天蒙蒙亮就起床，在图书馆帮姗姗来迟的我占座，然后直到深夜才离开，而那时我大多时候已经躺下了。<br>她目标明确并且决心很大，一年前就立下跨考的志向，努力的整整一年，我相信上天总会给她个好结果。<br>我有时候会沉不住气问她：“感觉怎么样，有没有把握？”<br>她轻轻笑笑，摇摇头：“没想过，尽力吧。”<br>“累不累？”<br>她有时会摇摇头，有时候会歪着脑袋思索片刻，长发垂在桌上，然后说：“有什么累不累，累也要继续，不然能怎样？”<br>然后她又沉浸到张宇八套卷里去了。<br>而那时，我还没买八套卷……<br>真不知道现在自己的感觉良好是从哪来的……</p><p>还有时候和LYF聊天，她竟然报考我们学校，还好不是农业信息化，一到晚上十一点后就给我发各种学校美图。<br>我只想说智障么我呆了四年还用得着你给我发图么……<br>好像有天我受了刺激，跟她说了些不想考了啥的。我也只是随口发泄发泄说完便又埋进书里，过了一会儿手机却响了，是个陌生的号码。<br>我接通，没想到就是她，这才想起来好像真的没有存过彼此的号码。<br>“你别放弃好不好？”上来一句话就把我给整懵了。<br>我呆呆地：“啊？”<br>她竟然有些急了：“我说你千万别放弃啊。你都不知道当你告诉我只剩三个月时间你还要考研的时候我有多震撼……”巴拉巴拉说了一大堆。<br>我已经彻底懵了，想笑却又笑不出来，只是低着头，不断地“嗯嗯”。<br>终于她好像累了，沉默了会儿问道：“所以，你不会放弃了吧？”<br>“嗯，不会。”<br>“那好，我看书去了。”<br>“去吧。”<br>挂断电话，我眯眼透过教学区的窗户看天边一轮明月。<br>后来ZL也来找我，问我出了什么，害得LYF忙急忙慌地找她要我电话。<br>喂，搞什么啊……<br>放弃什么的，我真的没想过啊……</p><p>更多时候是和女票聊天，她虽然也报了名，不过嘛……用她自己的话来说就是“陪我考”，该吃还是吃，该睡到太阳晒屁股还是睡。<br>有时候我气急败坏地骂她，她也不恼，只是冲我笑。<br>“笑笑笑，笑个屁啊，考不上怎么办！！”<br>“有你啊。”她说。<br>“考不上你就找不到好工作了你知道吗！”<br>“有你啊。”她说。<br>“没好工作怎么养活自己？！”<br>“有你啊。”她还是说。<br>我……我没脾气了，灰溜溜滚去看书。<br>当然，她也在努力，只是在我面前故意这样罢了。</p><p>有时候也会和不考研的人聊。</p><p>ZL有阵子忙着写论文，偏偏中国知网上不去，求助于我。<br>我将我的账号发给她，她电脑竟然又显示下载失败，真是气煞我也。<br>没办法，我只能让她远程控制我的电脑下载，下好了再发给她……我可没那闲工夫帮她下载，控制权给她，自己忙活去吧！<br>然而，接通之后她足足三分钟啥也没干，鼠标在桌面上晃荡来去半天也不知道干嘛。<br>我翻了翻白眼，二话不说，握起鼠标，找到角落里的浏览器，打开。<br>鼠标静止。<br>片刻后她发消息给我：“你怎么知道我找不到浏览器！！”<br>我抚额……<br>呵呵……<br>有时候想想，真心佩服我自己……<br>后来ZL特意发微博夸我，说默契终于在十年后体现了。<br>嗯，十年了。</p><p>ZSK那段时间帮了我很多，复习的专业课书籍都是他寄给我的，他这学期去上海实习了，世界五百强企业，又保研本校，有些屌。<br>他一直是这么优秀，至少我这么看。<br>听说他女票也保研来了南京某所学校。<br>真替他高兴，四年的异地恋终于画上句号。<br>距离考研还有十天左右的时候他突然给我打电话，语气有些低沉，似乎是有了心事，迷茫得不行。<br>即使在我眼里独立如他，原来也会迷茫。<br>足足说了有半个小时，最后他道：“回家再说吧，你加油啊，别没考上。”<br>“嗯，我知道。”我点头，“放心吧，不出意外……”<br>“出意外也不行。”<br>我哂笑：“好，我明白。”<br>和他说话真是无需拐弯抹角，一词一句都是真话，好像承诺。</p><p>BLY高三复读一年，所以今年还没有考研，却也很关心我，经常问我进展如何，有时候甚至还给我发红包，说是要吃点好的。<br>有天晚上买了粥和烤鸭，发图给她看，她说：“好丰盛！”<br>“很贵的，十几块呢。”<br>“贵也要吃，吃饱了才有力气学习。加油！”<br>“吃吃吃……”<br>等到明年她考研的时候，我也会支持她，给她发红包，对她说要吃点好的。<br>考研这件事，有人支持真的很重要。</p><p>TY和SYY自然也不会不管我，某个傍晚我正在快递处拿刚到的《张宇真题详解》，口袋里的电话突然响起来。<br>我一愣，竟然是TY的电话。<br>“喂，干嘛？”我接通电话。<br>“你在干嘛啊？”电话那头的声音却是SYY。<br>“我还能干嘛，拿快递回去学习！”<br>“我们马上来看你啊，你吃了吗？想吃啥我们给你带！”<br>我看了一眼手中刚买的粥和包子，说道：“刚买了一碗粥两个包子。你们要干嘛？”<br>“慰问你啊！”TY的声音从一边窜出来。<br>SYY说：“那反正你也吃不饱，一会儿给你带点吃的。”<br>后来她们真地来了，拎着一个袋子。<br>我带她们去教学楼前的池塘回廊里坐着，那时天还不算冷，风吹着池水，还不逼人。<br>“喏，给你。”SYY把袋子扔给我。<br>TY一把拦住：“等会儿，我买了两块蛋糕呢，一块给他，一块我要自己吃的。”<br>我看了看TY不见瘦的体型，笑出了声。<br>“笑个屁。”她骂道，小胖子做凶狠状。<br>“哦还有鸭脖，我要吃鸭脖！”SYY翻着袋子，突然大喊道。<br>我在她们对面坐下，屈腿靠着柱子，笑道：“到底是带给我吃的还是你们自己吃的？”<br>“干嘛！”两人瞪我。<br>我举手投降：“不敢不敢。”<br>天已渐渐黑了，看不清楚池水，只听得见风吹过树叶的声音和……她们吃东西的声音。<br>“对了，SYY你要出国吧？”我突然问道。<br>“是啊，刚考完GRE，不然我哪有时间来看你？”SYY吸着冷气，龇牙咧嘴，“啊啊啊好辣好辣……”<br>“哦……去美国？”<br>“嗯。”<br>“还回来么？”<br>“不知道，看情况！”她跳上跳下的，还是当年那个在东南大学中山楼下吐着舌头对我诉苦DYM好像来了的女孩。<br>“那TY呢？”<br>“我啊？明年考研啊！”TY咽下最后一口蛋糕，我手里的还剩大半。<br>TY学医，五年制。<br>顿了顿，她又说道：“我们这个不专业不考研没出路的，如果我能考上南京市人民医院的话就好了。”<br>我不太懂，她解释了，我现在又忘了……<br>“太笨了你，反正你只要知道如果我能考上就人生巅峰，考不上就死翘翘了。”<br>“哦……”我挠挠头，眯起眼睛，“那以后就见不到啦，SYY去美国，你留在南京，我还不一定去哪呢……”<br>“本来就是咯，大家都要分开了。”TY说，死死盯着我。<br>我避开她的目光，装作看不懂那里面的离别，耸了耸肩：“哈，那以后去美国找SYY和CSB玩啊！你们买个大房子，有院子的那种，听说美国房子不贵，我们去投奔你们，一人一间房，多好！”<br>“好啊好啊！”SYY又跳起来，“不过我要留一间衣帽间！！”<br>“什，什么间……”我没听清。<br>“衣——帽——间！”<br>“那是啥？”<br>两人对我白了白眼，SYY道：“就是放衣服裤子帽子啊什么的……没看过《小时代》吗？顾里家里的那种！”<br>哦，我想起来了，《小时代》里顾里有个大房间。<br>“哗”的一声房门推开，玻璃反射光华晃了所有人眼，放眼望去房间都看不到头，全都是……衣服衣服衣服……帽子帽子帽子……裤子裤子裤子……靴子靴子靴子……<br>想想有点可怕！<br>“可怕。”我哆嗦了一下，说道。<br>“可怕个大头鬼咧！”SYY道，“不要太爽哦……”<br>“好吧……希望你有，然后我们连衣服都省的买了。”<br>“想得美哦，要给钱的！”<br>…………<br>“饱了。”TY打了个嗝，道。<br>我没好气地摇头。<br>她们站起来拍拍灰：“不早了，你回去看书吧，我们走了！”<br>“嗯。”我点点头，也不留她们。<br>不知何时月亮都已经升起来了。<br>我目送着两人在月光下沿着勤仁坡那条路渐渐远去，胳膊挽着胳膊，蹦蹦跳跳的。</p><p>现在，已经结束了，不管结果如何，我们都曾经努力过。</p><p>时间过得太快了。<br>说起来还是在去年八月，有个夜晚WYZ又给我推歌，然后她说《夏至未至》要拍影视了，她不喜欢白敬亭演陆之昂。<br>《夏至未至》，我看过的唯一一本郭敬明的言情小说，她推荐我看的，那时她说她觉得我像陆之昂，ZSK像傅小司，时隔多年早已记不清情节，只记得那座城好像叫浅川。<br>WYZ曾用过一个网名，叫忘川。<br>我笑着回她：“陆之昂不是我吗？”<br>然后，然后然后然后！<br>她说“拜托，你已经不是18岁了。”<br>我有些惊悚，原来……早就不是18岁了啊！<br>书里的人不会老，什么时候翻开他都是那个年纪，站在阳光里浅笑嫣然。<br>书外的人却老得快，快得出乎意料，快得毫无察觉。<br>后来很少聊天，只是有时候我发些发泄用的说说，她会留个言或者找我，问我怎么了。<br>她问我，我却不知从何说起，于是随便扯些别的，随意聊聊，知道彼此都过得还算好就行。<br>讲真，我真的很喜欢《未完1》里关于她的比喻。</p><p>想着不写长，写完又是近一万字。<br>能写的太多了，没写的也太多了。<br>结束来得太匆匆，我还没想好要怎么结尾。<br>想来想去，既然我把它们归为一个系列，那就还用《未完1》的话结尾吧。<br>2017，我们的故事，未完待续。</p><p>即使我真的不会再写《未完3》，这些故事，该续的还在续。<br>毕竟这人生，我们都在相互扶持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2017年1月21日，2018年5月31日上传保存。）&lt;/p&gt;
&lt;p&gt;有的时候是看见一句话。&lt;br&gt;有的时候是听见一首歌。&lt;br&gt;有的时候是站在老地方。&lt;br&gt;有的时候是见到老朋友。&lt;br&gt;有的时候是静在沉默里。&lt;br&gt;但更多的时候是在呼吸里。&lt;br&gt;想你。&lt;br&gt;想我是怎么渐渐失去了你。&lt;br&gt;我的匆匆时光。&lt;br&gt;
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>未完待续-壹</title>
    <link href="http://yoursite.com/2018/05/31/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD-%E5%A3%B9/"/>
    <id>http://yoursite.com/2018/05/31/未完待续-壹/</id>
    <published>2018-05-31T09:30:03.000Z</published>
    <updated>2018-05-31T09:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2015年8月3日，2018年5月31日上传保存。）</p><p>水灌进眼底，我看见当年的你。<br>我坐在这里，岁月也无声无息。</p><p>谁能告诉我过去和现在、现在和未来之间到底有多远？<br>转眼已经大三，梧桐树叶轻轻洒落几个秋，我有时候看着它，沉默，然后把它胡乱踢进路旁的垃圾桶，转身离去，装作从来没见过。<br>风萧萧叶悄悄。<br><a id="more"></a><br>翻开尘封的空间，时间已经停留在去年的八月。<br>TY时不时会翻我的空间，将那些已经寂寞了很久的文字挨个再读一次，然后在每一篇下面再给我留一条言，接着在QQ上问我：“你什么时候再写日志啊？我想看。”<br>看到她留言的那瞬间，我心中起先是无比满足的，没什么比文字让人记住让人喜欢让人追忆更能让作者满足的了。我虽然只会自己瞎鼓捣，写作的技巧阅历还差得远，但作者的通病倒是已经学了个遍。<br>TY有时候在白天问我，正在课堂上，我的思绪却飞到天际，开始在自己曾经写过的文字和更多自己没有写过的文字里飞窜；有时候是在晚上，我侧枕着枕头，手机从手里滑落，眼睛盯着黑暗发呆，直到眼睛酸痛。<br>我想我是热爱文字的，要不然怎么可能因为TY的一句话每次都情绪奔腾？<br>可又是为什么，每次我回过去的话都是“过一段时间吧。”或者干脆“有什么好写的。”？</p><p>后来经过好几个不眠的夜晚，我找到了自己认为正确的答案。<br>原来，写作既是孤独的，但潜在目的却是渴求热闹的。<br>每个作者，在写东西时候忍受的孤独，都希望在作品完成之后能够用加倍的热闹还回来。<br>我孤独了，然后很悲哀的，变得更孤独。<br>就像一个人花整整一天准备了一桌丰盛的晚宴，结果原来只有自己一个人吃。<br>于是，扔掉刀具关上炉灶拉上门，干脆不做了。</p><p>匆匆几年，大学毕业竟然已经不再遥远，身边每个人都有自己的打算，彼此生命的轨迹分得越来越明显。<br>忙了，自然空余时间就变少，哪里还有时间看长篇的东西？正是说说微博朋友圈当道的年头啊！<br>我自己也是这样，懒得去看长篇的文章，以前特地下载下来的“一个”早就不知落下了多少期。<br>时代太匆忙，言简意赅才是王道。<br>因为这样，所以我才会拒绝TY的吧，我怕写了也没人看，最后难过的只有自己。<br>岁月无声无息，所以当我们回过神来，原来有些人有些习惯早就不知所踪。</p><p>我现在坐在床上，房间里只亮着一盏微弱的台灯光，电脑屏幕冰冷的光芒照在眼镜镜片上，眼睛有些累。<br>但我还是在写着，纵然天马行空，纵然不知道在写什么，但只要在写着，我就感觉心安。<br>有句话说得好，所谓梦想，就是坚持下去就会感觉到幸福的事情。<br>所以就算没有人看，一年我也实在忍不住了，必须要写点什么，大不了厚着脸皮挨个骚扰让来评论就是了，反正我一向这么厚脸皮。<br>耳机里的歌是姚贝娜的《鱼》，前两天淘到的歌，听说是姚贝娜生前最后一首歌，安静且忧伤，是我喜欢的风格。<br>女友的消息还在任务栏里“嘀嘀”作响，像她顽皮在身前跳动的模样。<br>安静的夜晚总是能给人灵感，这时候人的情绪会变得非常脆弱。<br>心里有故事的人会知道，回忆总在这种时候带着笑拿着刀撬开心里那扇门。<br>鱼只有七秒记忆，我开始庆幸自己不是一条鱼，我还记得那么多人那么多事。</p><p>今年南京的天气有些反常，雨下得特别多，那阵子每天都枕着雨声入睡，第二天伴着雨声醒来，发潮的衣物堆积了很多，让我每次看见满满一盆就无比想念我妈。<br>不过六月之前的南京天气却还不错，不算太热，适合结伴而行。<br>五月十六日，SYY约我们去浦口老车站，那是当年拍摄《情深深雨蒙蒙》的地方。<br>我和LJL之前已经去过，所以这一次纯属被拉着当导游。<br>天气没法跟这两天比，但也是明日高悬，一行人浩浩荡荡到弘阳广场的时候已经是十一点。<br>“热死了热死了！”SYY喊。<br>“饿死了饿死了！”TY喊。<br>“热死你热死你！”CSB喊。<br>“你在哪你在哪？”我对着电话喊。<br>“快到了快到了！”LJL在电话里喊。<br>浦口，是她的主场。<br>但其实，还得靠我指路，她那个猪脑子知道个屁哦……那么热的天可不能跟着她乱晃半天然后看她一脸无辜地说“走反了”……<br>好不容易和LJL汇合，五个人商量了一下决定去吃英伦自助餐。<br>其实也有很久没和TY他们一起吃饭了，嗯，好久没有见识SYY那人不可貌相的饭量了。<br>还是第一次，在南京的人聚得那么齐。<br>自助餐当然得吃得风卷残云，餐桌上狼藉一片，每个人都吃得老撑了。<br>然后就去浦口车站。<br>先坐637路公交到浦口公园，637路公交坐的不是特别多，但是每次坐都有一种穿越时空的感觉。<br>在南京坐车并不无聊，车窗外总是密密麻麻的参天梧桐树。车从树影光斑中穿过，我的目光随着那些光斑晃动，渐渐连成一条线，延伸向看不到的远方和过去。<br>它带着一车人，从繁华的商业区驶入那个曾经的老南京，安静祥和。<br>老南京没有鸡肉卷，老南京有老梧桐。<br>我喜欢南京，很大原因是因为那无论走到哪都能看到的漫漫梧桐，即便是在浦口公园那样的老地方，狭窄的道路两旁也不会种植其他树木。南京和梧桐，就是一对相依相靠的恋人，彼此交融，无法分开。<br>下了车，沿着小路绕几个弯，便是天桥。<br>天桥下是从中被截断的铁轨，道路两侧就是在烈日下烤的发亮的老铁轨。<br>铁轨中间的木块一日既往地沉默。<br>脚下的地面有些烫。<br>驻足，拍照。<br>走过天桥，拐过弯，就会看到一条小路。<br>小路两旁是老式的房屋，每一座房屋墙上都还留着黑色的火车标记，在岁月的风化下有些变得模糊，有些却还算清楚，能分辨出写着“津浦路区”四个字。<br>TY走上去摸了摸黑色的火车标记，墙壁上凸出的石子颗粒非常粗糙，几十年的时间就藏在这些瓦砾里，不知道她感受到了没有。<br>有一户人家墙上挂着鸟笼，门里坐着一位老人，仰在藤椅上，微闭着眼，手指轻轻打着节拍，鸟儿被SYY逗得啾啾而鸣，老人睁开眼看了她一眼，然后又闭上。<br>回过头，看到一对新人正在这条路上拍婚纱照。<br>年轻的男女执手奔跑，回头对着镜头微笑，新娘蓝色的裙摆水波一样在面前荡开。<br>SYY拉着CSB跑到摄影师身旁，对着摄影师叽叽喳喳不知说些什么。<br>我和LJL绕道走开，真想说不认识他们。<br>再回过头的时候，看到SYYTY两人在偷拍我们。<br>跟她们不用客气，我直接骂道：“拍什么拍啊？我们不要拍照！”<br>“你那么丑我高兴拍你是你的福气！”SYY翻白眼。<br>“就是就是，要不是沾我家刘的光，谁高兴拍你啊？！”TY挥舞着肉拳，满脸笑容。<br>CSB一脸无奈地站在两人身边，挠头。<br>我深吸一口气，明智地转身，拉着LJL往前走去。<br>虽然确实不喜欢拍照，不过如果能和心爱的人一起，拍就拍吧！<br>后来LJL给我单独拍了一张，然后用某个软件修改了一下，画风立刻变为漫画风，而且个人觉得特别像言情小说的封面。<br>葱翠的梧桐树下，我背着她的包，微微仰着头，光从梧桐树树叶间投下，洒在我脸上，洒在我脚下，两侧的汽车安静如沉睡的守卫。<br>嗯，至少不那么丑了。<br>再往前走，就是真正的老浦口火车站了，道路两旁的老房子多半已经尘封多年，只留下墙壁上斑驳的大字，比如“住宿”，比如“食堂”，比如“售票处”……<br>曾经的候车处也是一层厚厚的灰，大门紧闭。<br>我们透过窗户破裂的地方朝里看去，扑鼻而来一阵霉味，我发现上次看到的椅子全部不见了，候车厅里空空荡荡的，只有透窗而过的光线寂寞地照耀着，灰尘翩翩起舞。<br>那边有一群老年人在跳广场舞，SYY拉着CSB竟似乎要冲进去来上一段，TY举着相机在旁边嗷嗷叫着。<br>LJL也想找我，却发现我已经很有先见之明地绕开，并且在一张石凳子上坐下。<br>“接下来去哪啊？火车站就这些地方吗？”TY走过来问。<br>“差不多啊，里面又不让进。”我指了指对面说道，“接下来我们可以坐渡轮过江啊！”<br>“好啊好啊，ｇｏｇｏｇｏ！！”SYY已经冲了出去，CSB赶紧跟在后面。<br>到了渡轮上有些小失望，上次我和LJL来的时候还能站在甲板上，可是现在却只能呆在船舱里，门已经全部关闭起来了。<br>SYY不甘心，跑去问工作人员能不能站到甲板上，并且开始卖萌讨好。<br>我们转过身，不忍直视。<br>“这都不行，妈蛋！”<br>果然，不要脸有时候也是没用的。<br>进了渡轮，找一个位置坐好，坐了没到两分钟，船离岸之后，三个女生就干脆直接站起来推开窗户，伸手到外面，趴在窗户上。<br>我和CSB就负责把她们的鞋子收好。<br>江上的风挺大，吹起三个女孩的发，青春的笑容洋溢在她们脸上，发着光。<br>长江依旧浪滔滔，一去而东从不复返。<br>后来不知怎的开始在船舱里打闹，互相扯皮调侃，最欢乐的时光莫过于此，因为让人欢乐得几乎忘了一切，要不然我现在怎么会想不起来当时是谁说了什么笑话，逗得五人哈哈大笑。<br>照片也是一定要留下的，我难得地在照片上搞怪起来，捏着LJL的脸，比一个二二的剪刀手。<br>平时的我是怎么也想象不出会这么拍照的。<br>来来去去往往返返，我们从浦口码头到中山码头，然后再返回。<br>太阳不知不觉间已经靠西，不再那么炎热，却多了一分温暖，照在人脸上，映得人脸发红，人心发烫。<br>再次路过天桥的时候，我们选择了上去。<br>天桥两侧是台阶，台阶之间是滑坡。<br>CSB站在台阶上拉着SYY的手，SYY张开手从滑坡往上走。<br>我和LJL跟在他们之后。<br>TY早就一个人从滑坡上冲了上去，谁能想象出她胖胖的身躯里还有这样的爆发力？<br>“快点啊你们，慢死了！”她站在天桥上双手叉腰对我们喊。<br>我抬头看她，夕阳的光芒从她右侧照来，小胖子在金光里笑得无比有感染力，发丝在风里如狂蛇般飞舞。<br>嗯，以前那个快乐的胖子终于是回来了。<br>在天桥上，我们五人靠在一起，背对着夕阳，拍下了五个相依在一起的影子，剪刀手向天冲冲冲。<br>“那个最胖的影子一看就是TY！！”SYY大声喊道。<br>“你放屁！”TY自然不会承认。<br>“那最矮的那个是你咯……”CSB慢悠悠地说。<br>“不是！！”<br>“其实……这两个影子不是同一个吗？”LJL忍着笑说道。<br>“啊啊啊我跟你们拼了！！不活了！！”<br>“别啊，虽然这里不高，可从这里摔下去也挺疼的，尤其是你脸着地的情况下。”我严肃地补了最后一刀。<br>“再见！！”TY“嗖”地一声窜出去，张开双手“蹬蹬蹬”沿着滑坡几步就跑了下去。<br>速度之快，当真让人瞠目结舌。<br>倒是我们四个人，因为两个女生的缘故，走得非常慢。<br>“诶，你们等下，站着别动，我给你们拍张照！”TY突然在下面喊道，举起了手机。<br>我们四人两左两右并肩站着，我深深吸了口气，嘴角露出一丝满足的微笑。<br>风从我脑后轻轻吹来，树叶沙沙作响。<br>身边站着最爱的人，耳边吹过最轻的风，拍照的是最好的朋友。<br>嗯，时间就该在这种时候定格。<br>我朝LJL靠了靠，牵上她的手，一片温存。<br>“咔擦”<br>……<br>回去的路上，夕阳远远跟在身后，SYY说：“我现在和未来的医生、未来的老师还有未来的作家走在一起，感觉好厉害！”<br>CSB拉下脸补充：“还有未来的老公！”<br>“滚一边去！”SYY直接两巴掌。<br>“滚呀滚呀滚呀！”TY说。<br>我走在最前面，低下头。<br>我看到时光笑了。<br>那么温柔。</p><p>更早一些的时候，我和LJL去过一次常州找CX玩。<br>出车站的时候是晚上十点钟，常州的火车站确实该装修装修了，走在里面要不是人多甚至会怀疑拐角会突然跳出一只鬼怪。<br>出了车站，我已经忘了那天晚上有没有月亮，因为CX带着他女朋友早就在门口等候多时。<br>汇合之后买了回程票，我们便去打的。<br>那时候因为舍友的关系刚刚喜欢说“并”这个字，无论说什么话都要加上“并”这个字，觉得逼格特别得高。<br>“待会儿干嘛？”CX问我。<br>“并不知道啊！”我排在队伍里说道。<br>“你们吃东西了没？”<br>“并不饿啊，待会儿再说。”<br>“并并并，并你个头，再并我弄死你！！”LJL直接给我一巴掌。<br>“并不能控制自己……”我捂着脑袋，大叫，“我也并不想这样啊……”<br>“大哥，你累不累？”CX抚额。<br>“并不会。”<br>CX和他女朋友已经无奈，LJL对我张牙舞爪，直接挥手：“我不认识你，你是谁啊？”<br>“你并不能这样。”我很严肃。<br>三人不再废话，直接招呼一辆车把我塞了进去。<br>“你们这样对我，我并不开心！！”<br>汽车呼啸而过。<br>晚上也没地方去，反正早就约好了去网吧开黑，就直接在CX学校附近找了一家网吧，正好有个四连坐，运气很不错。<br>坐下来就玩游戏，首先当然要和CX开黑搞几盘英雄联盟，她女朋友看会儿视频，LJL还装模作样地做起作业来了！！<br>“我靠，你到这里来做作业的啊？！”<br>“干嘛，不服啊？你以为都像你没作业啊！”<br>“并没有不服，做你的傻逼作业去吧！我撸咯……”<br>“撸你个大头鬼，肯定又掉段。”<br>“并不会。”<br>网吧是年轻人的场所，大学之前我还从没去过网吧，记忆里的网吧都是蒙在一层厚厚满是油腻的厚帘子之后，哪有像现在这样灯光明亮？<br>网吧的电脑果然屏幕够大，玩起来感觉倍儿爽，手感走位什么的都比自己的笔记本电脑好得多。<br>于是那天晚上不仅没掉段，我还晋级了，CX运气就差一些，仅仅一盘之差没有晋级成功。<br>其实就是他太菜！！我带不动！！（此处应有傲慢的表情。）<br>晋级之后就变得满足，没有再撸下去的欲望了，况且时间也已经是深夜两点多钟，肚子有些饿。<br>“出去买点吃的。”CX说。<br>“并没有意见。”我拍拍屁股站起来，摘下LJL的耳麦，“喂，想吃什么？”<br>“肉。”她甚至没看我一眼，直接从我手里把耳麦抢了回去重套在脑袋上。<br>深夜的街道上只有黄色的路灯亮着，网吧对面有一家烧烤还开着门，浓郁的香味瞬间俘虏了我的胃。<br>小时候就曾经很多次想象过深夜街道的场景，曾经很多次想走在孤独的路灯下，抬起头是不是能看到飞蛾在灯罩上扑打？晚风“呜呜”地吹过，吹起谁的发，明月又照着谁的衣摆？小路的转弯口是不是有人在等我？我如果走过去你会不会伸出手牵起我？<br>等到真正站在深夜空旷无人的街道上，放眼望去只看到寂寞的道路一直延伸进尽头的黑暗，两旁的车辆早已安睡，烧烤店老板也变得沉默寡言，一直低着头准备烧烤。许久小路的转弯口驶过来一辆车，远光灯晃了我的眼，没有人在等我，也没有手。<br>车开过，耳中只有烧烤轻微的 “滋滋”声。<br>我和CX没有说话，毕竟深夜，都有些累了，对立着眼睛落在烧烤上，渐渐发呆。<br>慢慢地，就觉得有些凉意。<br>深夜外面有的只是安静，白天那种繁华宛若一场梦。而且白天越是热闹的地方，到了深夜就越发冷清可怕，这条街上幸好还有几家网吧开着，幸好还有一群年轻人。<br>拿了烧烤回网吧，三下五除二就消灭干净。<br>不想玩英雄联盟，于是带着两个女生玩QQ飞车。<br>这是一款对我来说有很多回忆的游戏，甚至至今在我家那台十几年的老电脑上还装着，从没有舍得卸载过，英雄联盟早就卸载重装过不知多少次。<br>虽然很久没有玩飞车了，但是老将宝刀还未老！<br>许久不玩，QQ飞车的地图很少有熟悉的了，偶尔随机到一张老地图，漂移加速的瞬间似乎看到了曾经的自己，看到曾经自己的超越与被超越。<br>“唰唰唰”几盘，毫无悬念地全是第一名。<br>看着角色站在领奖台上做着熟悉的喷啤酒动作，我眼前竟似乎朦胧了，难以言明的感觉涌上来，千百种情绪最终只变成嘴角浅浅的一丝笑容。<br>游戏承载着的东西，永远都比游戏本身重要难忘地多。<br>我没有去打开飞车好友列表，那些曾经一起飞跃奔驰的小伙伴们早已不知所向。<br>不过，网吧永远不是个适合回忆的地方，接下来，LJL毅然奋起，直接把我的键盘抢了过去压在自己键盘下，让我永远只能停留在起跑线上。<br>“我靠，你这样也行啊？！”我骂道。<br>“你别动！老实呆着！！”LJL盯着屏幕，手忙脚乱地按方向键。<br>另一边，CX女朋友虽然没有那么直接，但嘴里的威胁就更浓了：“我跟你讲，你要是再敢开在我前面，信不信我弄死你？”<br>CX和我对视一眼苦笑，然后跟屁虫一样跟在女朋友车后。<br>于是乎，原本竞速的游戏只剩下跌跌撞撞、晕头转向，和一个可怜只能在起跑线玩方向盘的角色。<br>但是，却也多了一些别的东西，比如笑容。<br>所以，那些感怀什么的，都通通离远一些吧，不管是过去还是未来，都不如现在重要。<br>“这要是真开车你九条命都死光了啊……”我为屏幕上的角色心疼。<br>“闭嘴！不许动！！”<br>再后来，永远是第四名的LJL不服，一脸委屈。<br>“诶诶诶，别说我欺负你，你会玩什么游戏？拿出来让你炫耀炫耀咯……”我推她的肩膀，一脸挑衅。<br>“这可是你说的，来，QQ炫舞！！”LJL跳起来，眼睛里闪着逼人的寒光，满是自信。<br>第一盘，她赢了。<br>但是片刻后……<br>某网吧，某女掐着某男的脖子大叫：“啊啊啊你这个变态，这我都跳不过你！！”<br>“嘿嘿……”我被她推得来回晃，心中却得意得紧，“玩游戏如果不如你我还不如去死咧！！”<br>嘿嘿，虽然我炫舞确实玩得不咋地，但无奈某人实在是手残……<br>CX一直在女友的威逼之下，处境不比我好多少。<br>总共也没多少时间，去不了什么大景区，只去了常州的红梅公园，像我们这种穷鬼就只能去公园这些免费的地方了。<br>事实证明，没钱的时候就该去逛公园，因为说不定就能捡到钱！！<br>当我们四个人围着一张红票子站成一圈的时候，我们的内心是激动的。<br>“捡了！”CX一咬牙，弯腰捡起来。<br>“晚饭可以吃好的了！”LJL欢呼。<br>我以极其协调的动作从CX手中把一百块钱拿过来，行云流水一般塞入口袋，拍拍屁股走人喽~<br>“诶？钱呢？”CX看着空空的手心问。<br>“好像哪里不对……”他女朋友PCL眨了眨大眼睛。<br>“小兔崽子，给老娘站住！”LJL手指一指脱掉鞋子以一百二十码的速度追出去。<br>我在一处小亭子前被逮住，三人把我逼到边缘，后面就是一片湖！<br>天呐，这些人为了一百块钱全部化身黄世仁，之前我怎么一点没看出来？<br>一个个的……<br>都！欺！负！我！<br>“交出来！”LJL一手叉腰又伸出另一只手，气势汹汹。<br>“你太贱了。”CX低头轻摇，让我怀疑下一刻他会从袖子里掏出一把水果刀。<br>“嘿嘿……这是干啥呀……不就一百块钱吗……大家都有份都有份哈……”我伸手保持安全距离，“先放我保管而已……我你们还信不过吗？！”我摆出一副信不过我就是瞧不起我的眼神。<br>“废话，当然信不过！”这三货异口同声！<br>最终，我还是没能独吞那一百块钱，现在想来委实是一大憾事啊！不过那天晚上的烧烤倒是吃饱了……<br>这已经不是第一次捡到百元大钞了，第一次还是在高中的时候，我CXXS三人在食堂遇到了生平第一次！<br>事后三人就把钱平分了，我拿了四十，他们一人三十，晚上自然在学校外面的地边摊上加餐加餐再加餐，现在想来那竟已成再也回不去的岁月，只能留在回忆里发酵。<br>再一次捡到一百块，当然要和唯一不在场的XS炫耀，哦不，分享一下。<br>“XS，我和CX又捡到一百块！！”我在讨论组里噼里啪啦地写，后面跟着一大串表情。<br>XS在军校，CX和我都没想到他竟然能秒回。<br>“你们俩在一起？”<br>“废话，要不怎么一起捡到？”我说。<br>“放屁，明明就是我捡到的，章鱼个禽兽想私吞！”CX说。<br>“明明我先看到的好吧？！”我当然宁死不屈。<br>“别废话，见者有份，打我支付宝就行。”XS这小子倒也真是不客气。<br>“想得美！”我和CX终于站在了一条战线上。<br>“你们告诉我这件事不就是想和我分享成果吗？太没诚意了吧！傻逼们！”<br>“你让CX打给你。”队友这种东西，该卖的时候一定要果断！<br>“再见！”CX打出挥手的表情。<br>“太伤人了，好歹一毛钱意思意思啊！你们这两个碧池！”XS大呼不甘。<br>“嘿嘿！”发完这句话就把手机重新塞进口袋，继续逛公园去！<br>有钱了心情就是不一样，逛公园也敢往那些收费项目上瞄两眼了！！<br>话说回来，现在已经八月份了，XS那小子却还没回来，军校每年都有军训，他此时此刻正在大海上晾着呢……<br>嗯，希望他回来的时候比黑炭白一些，除此之外还能对他的皮肤提什么要求呢？<br>红梅公园很大，逛了好久才走完一圈，路过一家鬼屋，我兴致大发，嚷嚷着要去玩，没想到LJL跟我闹起来，说什么也不肯往那再走一步，看来这家伙上次被吓坏了……<br>真是的，有我在，怕什么？<br>倒不是说因为我胆子大所以她在我身边没事，而是因为她在我身边所以我胆子必须大。<br>僵持了半天我也没能如愿，兴致有些缺缺，不过后来她向我示好，我大人不记小人过捏她脸蛋两下就原谅她了。<br>唉，我总是心太软。<br>再后来，到了六月份的时候，CX也来了一次南京，行程大体相仿，都是网吧呆一晚然后再继续玩，玩得四个人全都筋疲力尽就各自打道回府。<br>在玄武湖划船的时候，湖水悠悠，船晃地悠悠，阳光软绵绵地照在身上，睡意袭来，三人倒着就要睡过去，留下我这个开船的在硬撑！！稍微一不留神，船差点撞上岸，吓得顿时睡意全无！<br>嗯，即使很玩得很疲倦，但是再不疯狂我们就老了。<br>我想，老了之后再做这些一定会有另一番感受，我会等待那种感受，但至少现在我要铭记年轻的感受，因为老了之后一定会无比怀念年少时光，我可不希望到时候想起来只记得曾经在玄武湖划过船，而那些岸边的垂柳、白色的拱桥、心中的感觉却都已遗忘。<br>那必将是一种莫大的忧伤，青春期忧伤已成基调，我可不要老来也忧伤。</p><p>……<br>……</p><p>记事总是这样，起初不知道怎么开头，然后打开回忆之后便不知如何收手。<br>能写的事情还有很多，全部写下来恐怕能有好几万字，那样未免太冗长，而且也没有必要。<br>写的时候会不禁想到更多难忘的回忆，就像是找东西，有的时候怎么也找不到，有的时候却又一股脑冒出来。<br>我想到和舍友们一起窝在宿舍看电影，我的小床上最多的时候能够坐五个大男生，凑在一起盯着电脑屏幕。看的电影有的喜悦有的则充满悲伤基调，但年轻就是神奇，不管无论多么悲伤的电影都能看得宿舍里一片欢笑。<br>不是说男生不悲伤，而是我们表达的方式不一样。<br>女生在一起看悲剧，悲伤了，所以哭。<br>男生在一起看悲剧，悲伤了，所以笑。<br>我们男生，不能轻易流露心中悲伤，纵使千愁万苦心中过，回头时也一定要表现得云淡风轻！</p><p>我想到和一群人开黑玩英雄联盟，一起玩的最多的是CX，然后就是依旧贼眉贼眼的ZC。<br>提到ZC就不得不提每次假期在他家的聚餐，不管烈阳高照还是冰雪交加，那是丢下一切也必须要赴的宴。<br>因为那是在家里，因为那是一家人。<br>ZC每次整出一桌好菜还不收半分钱，兴许就是这样攒的人品让他在不久前找到了女朋友？<br>嗯，一定是这样。<br>我只想提醒一下，好习惯要保持下去啊，再接再厉！！<br>今年暑假说话的聚餐呢？我相信ZC一定在默默准备着。<br>不过话说回来，玩起英雄联盟，谁管是不是一家人？<br>该坑坑，该卖卖，该挂机还得挂机！！<br>我早就说过，游戏本就该是一群人一起玩，输赢不重要，重要的是为了守住一座塔在任何时间从任何地点赶回来，重要的是你扛了半天BUFF伤害只等我来取走，重要的是你默默守在身边让掉一切资源，重要的是哪怕你开错团我也义无反顾冲上去，重要的是被人喷了毫不讲理地帮你喷回去！！<br>CXZC一定是懂的。</p><p>我想到前两天和FXTTM吃饭，这也是一项优良传统，每次寒暑假必有一次聚餐。<br>FXT变瘦了，TM还是老样子，不过是不是变高了些？<br>这次聚餐我带上了妹妹，妹妹下半年六年级，明年上初中。<br>我对她们说时间过得真快，转眼我妹妹都要上初中了，我觉得她还是个小屁孩，可我自己初中那会儿已经觉得自己是个大人了。<br>FXT说大家都一样。<br>TM问我初中那会儿都想什么？<br>我摇了摇头没有说话，我觉得初中就在昨天，但是真正回忆起来却发现已经隔了一层厚厚的浓雾，仿佛一切都是模糊的，而偏偏最清晰的那个人那些事已没有必要也不能再提。<br>因为最清晰，所以分界线显得那么刺眼。<br>我伸筷子，说道：“吃饭，吃饭……”</p><p>和FXTTM吃完饭的第二天，我和初中另两个妹子约在必胜客吃饭，就是ZL和FJY。<br>这还是第一次三人一起吃饭，如果可以的话，我不介意让它也成为一个传统。<br>和ZL见面次数还比较多，不过和FJY却是高中毕业后的第一次。<br>她也已经有了男朋友，再次见到她，似乎比印象中瘦了一些，却又比她发给我的照片胖一些……不过还是和记忆里一样漂亮就是了。<br>还好，饭间没有出现我一直担心的冷场情形，相反彼此说了很多话，没有一刻停歇，仿佛回到在实验学校上课的那段时光。<br>这顿饭时间吃得很长，因为聊了很多，大多是对未来的打算。<br>过去是让人感怀的，而未来是让人迷茫的。考研还是工作？考什么研？以后在哪里发展？等等等等。<br>和ZL聊天也比较多，可能是因为多吧，有事没事就会骚扰她一下，骂一句傻逼什么的，也不在乎她回不回我，不回我我发窗口抖动就是了。<br>至于FJY，对我来说就像一个妹妹一样，亲切地称呼她“小弱智”，听她时不时说些烦恼，前几个学期也帮了不少学习上的忙，不过专业毕竟不一样，以后的学习要靠她自己了，烦恼什么的我还是很乐意倾听的。<br>如果我难过了，找ZL那一定得到的答复是心灵鸡汤，而如果找FJY则不一样。<br>她并不会什么心灵鸡汤，她的方法要简单得多，那就是夸我，往死里夸，夸得我每次都心虚不已。<br>我就算有再多的难过，也没法在她的夸奖下坚持太久，只能融化。<br>然后她就会说：“夸你夸得我自己都觉得过分了。”<br>我笑笑，脑中却又想到另一个女孩。<br>嗯，是LYF。<br>是“锋”不是“峰”，我一直打错，一直被她骂。<br>不过已经很少有联系，只在这一学期聊过一两次天，还是因为她说做梦梦到我结婚了却没有请她。<br>咳咳，如果真结婚了，应该不会忘了的。<br>那天还聊了不少，聊着聊着她说我变自卑了很多。<br>我问她：“那你印象里我是啥样的？”<br>然后，她说：“我十六岁时最美好的少年。”<br>我说不清那个时候我的感觉，后来她又说那时的我在她眼里风光无限。<br>风光无限。<br>我从没想过这四个字能用来形容我。<br>就像在她之前，我从没想过我能够被人喜欢。<br>那时她眼里的我，比真正的我耀眼太多。<br>她给予过我很多，但是可能每个人的年少时光里都会有一个人，一旦出现，就会让人无法再关注其他人，我的那个人不是她，于是注定给不了她任何回报。<br>有一声“谢谢”，我从来没有对她说过，是我欠她的。</p><p>还有WYZ，相识已经很久，几乎上了多少年学便认识了多少年，关系一直都不错。<br>到了如今，因为有些相似的经历，在一些事上能够互相安慰，就像两只原野里的孤狼，难得相逢一次，轻轻互舔伤口，便重新站起来朝着不同的方向前进，不约定什么时候再相见，但是一定会再相见。<br>她曾经也是个明媚活泼的女孩，现在就算笑着眉眼深处也有一丝哀伤，像是把心中的火种亲自埋在百米冰山之中。<br>我说过，未来一定有个人能重新点亮她。<br>她说她喜欢“点亮”这个词。<br>我说你要等待。<br>该来的，总会来。<br>到最后，来的一定是最绚烂夺目的那个人。</p><p>还有看到《盗墓笔记》就会想起我的YWW，虽然没有太多交流，不过我还是记得那些年你坐在我身后，轻轻戳我的后背，唤我一声最亲切的“小哥”……</p><p>时间已经过去不少年，很多东西已经沉淀或者消失，现在我回想起来，我的身边竟有过那么多好女孩。<br>能遇到你们，感觉还不错。</p><p>当然还有兄弟，不过男生之间还是少点语言比较好，只要我记得我曾经只说了一句话ZSK就翘课来陪我就行了……还有刚刚结束小学期的ZZJ，我等着他请我看电影吃饭唱歌呢，可是刚刚聊天他说已经看电影看过两遍了，心塞塞……还有……还有……</p><p>那么多人，那么多事。<br>但是最美的我却觉得是那么一句话：<br>我们的故事，未完待续。<br>请听下回分解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（生活之余，闲暇记录，禁止粘贴复制转载，谢谢配合。本文写于2015年8月3日，2018年5月31日上传保存。）&lt;/p&gt;
&lt;p&gt;水灌进眼底，我看见当年的你。&lt;br&gt;我坐在这里，岁月也无声无息。&lt;/p&gt;
&lt;p&gt;谁能告诉我过去和现在、现在和未来之间到底有多远？&lt;br&gt;转眼已经大三，梧桐树叶轻轻洒落几个秋，我有时候看着它，沉默，然后把它胡乱踢进路旁的垃圾桶，转身离去，装作从来没见过。&lt;br&gt;风萧萧叶悄悄。&lt;br&gt;
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>春招面试准备</title>
    <link href="http://yoursite.com/2018/05/31/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <id>http://yoursite.com/2018/05/31/春招面试准备/</id>
    <published>2018-05-30T16:21:18.000Z</published>
    <updated>2018-10-09T15:59:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="90道"><a href="#90道" class="headerlink" title="90道"></a>90道</h1><h2 id="1、引用和指针的区别。"><a href="#1、引用和指针的区别。" class="headerlink" title="1、引用和指针的区别。"></a>1、引用和指针的区别。</h2><p>a、定义指针时分配内存，引用不分配内存，而和原变量内存地址相同，这是最本质的区别。<br>b、引用必须初始化<br>c、没有指向空值的引用，但是存在指向空值的指针。<br><a id="more"></a></p><h2 id="2、值传递、地址传递、引用传递的区别。"><a href="#2、值传递、地址传递、引用传递的区别。" class="headerlink" title="2、值传递、地址传递、引用传递的区别。"></a>2、值传递、地址传递、引用传递的区别。</h2><p>a、值传递，为形参重新分配内存空间，拷贝，形参不改变实参的值，结束后释放空间。<br>b、引用传递：不重新分配内存，形参会改变实参的值，不涉及内存分配和释放，效率最高。<br>c、地址传递：形参是指针变量，会给该指针变量分配内存空间，形参会改变实参的值，结束后释放空间。</p><h2 id="3、static的作用"><a href="#3、static的作用" class="headerlink" title="3、static的作用"></a>3、static的作用</h2><p>a、static变量的作用范围属于整个函数体，内存只会分配一次，和auto变量不同，多次调用该函数不会重<br>新分配新的变量，一次调用，持久保存。<br>普通函数f，调用三次，输出000<br>若f中有static，调用三次，输出012<br>b、在模块内的static变量可以被模块内函数访问，但不能被模块外其他函数访问，即使extern也不行。<br>c、static函数也会被限定在模块内<br>d、类中static成员变量属于整个类所拥有的，所有对象只有一个实例<br>e、类中static成员函数属于整个类所拥有，所以不接受this指针，只能访问类中static成员变量。</p><h2 id="4、const关键字的用处"><a href="#4、const关键字的用处" class="headerlink" title="4、const关键字的用处"></a>4、const关键字的用处</h2><p>a、阻止一个变量被改变，const表示常量，需要初始化<br>b、对指针来说，可以指定指针本身const，也可以指定指针所指的数据为const，或两者都是const<br>const int <em> p;//const是底层cosnt，表示p所指向的数据是一个常量，不可通过p修改该常量的值，但是p可以指向其他变量<br>int </em> const p;//顶层const，表示指针p本身是一个常量，不可以再指向其他变量，但是它所指的变量可以改变值<br>c、函数参数const，函数内不能改变值<br>d、类的成员函数const，常函数，不能修改类的成员变量<br>e、对类的成员函数，有时候会指定其返回值为cosnt，以使得返回值不为“左值”，因为在c++中可能存在给一个函数赋值的情况，即函数返回一个引用。</p><h2 id="5、链表和数组的区别。"><a href="#5、链表和数组的区别。" class="headerlink" title="5、链表和数组的区别。"></a>5、链表和数组的区别。</h2><p>a、数组是顺序表，开辟连续空间。而链表靠指针连接不连续的空间<br>b、数组要求空间连续，占用总空间小，链表则相反<br>c、数组方便排序查找，删除修改较慢；链表则相反。</p><h2 id="6、直接实现strlen（）"><a href="#6、直接实现strlen（）" class="headerlink" title="6、直接实现strlen（）"></a>6、直接实现strlen（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrlen</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(str==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;i++);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、直接实现strstr-char-str-char-sub-搜寻子串的函数"><a href="#7、直接实现strstr-char-str-char-sub-搜寻子串的函数" class="headerlink" title="7、直接实现strstr(char str,char sub)搜寻子串的函数"></a>7、直接实现strstr(char <em>str,char </em>sub)搜寻子串的函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">mystrstr</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">char</span>* sub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *pos;</span><br><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</span><br><span class="line">&#123;</span><br><span class="line">pos=&amp;str[i];</span><br><span class="line">s=sub;</span><br><span class="line"><span class="keyword">while</span>(*pos==*s)</span><br><span class="line">&#123;</span><br><span class="line">pos++;s++;</span><br><span class="line"><span class="keyword">if</span>(*s==<span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;str[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、直接实现strcat-char-str1-char-str2"><a href="#8、直接实现strcat-char-str1-char-str2" class="headerlink" title="8、直接实现strcat(char str1,char str2)"></a>8、直接实现strcat(char <em>str1,char </em>str2)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *p=str1;</span><br><span class="line"><span class="keyword">while</span>(*str1!=<span class="string">'\0'</span>)</span><br><span class="line">str1++;</span><br><span class="line"><span class="keyword">while</span>(*str2!=<span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">*str1=*str2;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line">*str1=<span class="string">'\0'</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、直接实现strcmp-char-str1-char-str2"><a href="#9、直接实现strcmp-char-str1-char-str2" class="headerlink" title="9、直接实现strcmp(char str1,char str2)"></a>9、直接实现strcmp(char <em>str1,char </em>str2)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrcmp</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str1==<span class="literal">NULL</span> || str2==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"invalid arguments"</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*str1&gt;*str2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*str1&lt;*str2)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*str1==<span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str1++;str2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、请给出函数指针数组等定义"><a href="#10、请给出函数指针数组等定义" class="headerlink" title="10、请给出函数指针数组等定义"></a>10、请给出函数指针数组等定义</h2><p>int *<em>a;指向指针的指针<br>int </em>a[10];一个数组，每个元素是一个int指针<br>int (<em>a)[10];一个指针，指向有10个元素的int数组<br>int (</em>a) (int);一个指向函数的指针，该函数有一个整形参数并返回一个整形<br>int (*a[10])(int);函数指针数组，一个包含10个元素的数组，每个元素是一个函数指针，每个函数一个int参数返回一个int</p><h2 id="11、给定一个整形变量a，设置或清除bit-N"><a href="#11、给定一个整形变量a，设置或清除bit-N" class="headerlink" title="11、给定一个整形变量a，设置或清除bit N"></a>11、给定一个整形变量a，设置或清除bit N</h2><p>与或非操作</p><h2 id="12、C-中的空类，默认产生哪些成员函数"><a href="#12、C-中的空类，默认产生哪些成员函数" class="headerlink" title="12、C++中的空类，默认产生哪些成员函数."></a>12、C++中的空类，默认产生哪些成员函数.</h2><p>缺省构造函数<br>拷贝构造函数<br>析构函数<br>赋值运算符<br>当类成员有指针的时候，拷贝构造和赋值运算符需要重写。</p><h2 id="13、struct和class的区别"><a href="#13、struct和class的区别" class="headerlink" title="13、struct和class的区别"></a>13、struct和class的区别</h2><p>c中struct不可以有成员函数，c++中可以<br>c++中 struct默认权限public，class默认权限private</p><h2 id="14、内存思考题"><a href="#14、内存思考题" class="headerlink" title="14、内存思考题"></a>14、内存思考题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);&#125;</span><br><span class="line"><span class="function">voit <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str=<span class="literal">NULL</span>;</span><br><span class="line">get(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序崩溃，因为get不会传递动态内存，test中的str一直是null。<br>指针free后需要置为null，否则会成野指针</p><h2 id="15、关键字volatile有什么含义"><a href="#15、关键字volatile有什么含义" class="headerlink" title="15、关键字volatile有什么含义"></a>15、关键字volatile有什么含义</h2><p>被volatile修饰的变量是说这个变量可能会被意想不到地改变<br>比如硬件寄存器中的值可能经常变，所以使用的时候就要读取<br>多线程中的变量也是一样。<br>volatile告诉编译器不要优化这个变量，每次读取都读取实际的值而不是读取缓存</p><h2 id="16、读写绝对地址"><a href="#16、读写绝对地址" class="headerlink" title="16、读写绝对地址"></a>16、读写绝对地址</h2><p>int <em>ptr;<br>ptr=(int </em>)0x67a9;<br>*ptr=0xaa55</p><h2 id="17、heap与stack的区别"><a href="#17、heap与stack的区别" class="headerlink" title="17、heap与stack的区别"></a>17、heap与stack的区别</h2><p>stack的空间由操作系统自动分配/释放，heap上的空间是手动分配释放的。<br>stack空间有限，heap有很大的自由存储区（new）<br>程序在编译期对变量和函数分配内存都在栈上，且程序运行过程中函数调用参数的传递也在栈上。<br>还有一种静态内存，保存局部static对象</p><h2 id="18、不借助第三个数交换两个数的值。"><a href="#18、不借助第三个数交换两个数的值。" class="headerlink" title="18、不借助第三个数交换两个数的值。"></a>18、不借助第三个数交换两个数的值。</h2><p>第一种：a=a+b;b=a-b;a=a-b;<br>第二种：a=a*b;b=a/b;a=a/b;（b不为0）<br>第三种：a=a^b;b=a^b;a=a^b;</p><h2 id="19、用宏定义写出swap（x，y）"><a href="#19、用宏定义写出swap（x，y）" class="headerlink" title="19、用宏定义写出swap（x，y）"></a>19、用宏定义写出swap（x，y）</h2><p>#define swap(x,y) (x)=(x)+(y);(y)=(x)-(y);(x)=(x)-(y);<br>宏定义时参数用括号括起来，且表达式之间不要有空格</p><h2 id="20、用宏定义返回两个参数中较小的一个"><a href="#20、用宏定义返回两个参数中较小的一个" class="headerlink" title="20、用宏定义返回两个参数中较小的一个"></a>20、用宏定义返回两个参数中较小的一个</h2><p>#define Min(x,y) ((x)&gt;(y)?(y):(x))<br>结尾没有分号</p><h2 id="21、带参数的宏和带参数的函数的区别"><a href="#21、带参数的宏和带参数的函数的区别" class="headerlink" title="21、带参数的宏和带参数的函数的区别"></a>21、带参数的宏和带参数的函数的区别</h2><p>a、宏在编译时处理，会展开，而函数在运行时处理<br>b、宏里的参数不需要定义类型，函数中参数必须有类型<br>c、宏会使程序变长，而函数不会<br>d、宏不占用存储空间，函数占用<br>e、宏不占用运行时间，函数调用和返回时占用运行时间<br>带参宏简单，不灵活</p><h2 id="22、定义宏，求出数组元素的个数"><a href="#22、定义宏，求出数组元素的个数" class="headerlink" title="22、定义宏，求出数组元素的个数"></a>22、定义宏，求出数组元素的个数</h2><p>#define NTBL(table) (sizeof(table)/sizeof(table[0]))</p><h2 id="23、两个栈实现一个队列的功能"><a href="#23、两个栈实现一个队列的功能" class="headerlink" title="23、两个栈实现一个队列的功能"></a>23、两个栈实现一个队列的功能</h2><p>入队：将元素压入栈a<br>出队：<br>（1）判断栈b是否为空<br>（2）如果不为空，则将栈a中所有元素依次pop出并push到栈b<br>（3）将栈b的栈顶元素pop出，即出队元素</p><h2 id="24、在c-中调用c函数，为什么要加extern-c"><a href="#24、在c-中调用c函数，为什么要加extern-c" class="headerlink" title="24、在c++中调用c函数，为什么要加extern c?"></a>24、在c++中调用c函数，为什么要加extern c?</h2><p>答：c++支持函数重载，c语言不支持函数重载。函数被c++编译后在库中的名字和c的不同。<br>void foo(int x,int y)<br>在c中编译结果：_foo<br>在c++中：_foo_int_int<br>所以要加extern “c”来解决名字匹配问题</p><h2 id="25、找出程序中的错误"><a href="#25、找出程序中的错误" class="headerlink" title="25、找出程序中的错误"></a>25、找出程序中的错误</h2><p>视频第26题：5个错误<br>27题：4个（可不看）</p><h2 id="26、一句话判断x是否是2的次幂"><a href="#26、一句话判断x是否是2的次幂" class="headerlink" title="26、一句话判断x是否是2的次幂"></a>26、一句话判断x是否是2的次幂</h2><p>a、x&amp;(x-1)<br>上式为0，则是，否则不是。<br>b、判断logx/log2是不是整数</p><h2 id="27、按要求定义变量"><a href="#27、按要求定义变量" class="headerlink" title="27、按要求定义变量"></a>27、按要求定义变量</h2><p>定义全零全一的变量<br>unsigned int zero=0;<br>unsigned int compzero=~0;<br>不能写unsigned int compzero=0xFFFF，因为处理器位数不一定</p><h2 id="28、malloc分配内存"><a href="#28、malloc分配内存" class="headerlink" title="28、malloc分配内存"></a>28、malloc分配内存</h2><p>ptr=(char *)malloc(0)<br>分配能否成功？<br>分配虽然成功，但它是0个字节，无法真正使用。</p><h2 id="29、对数组名取地址"><a href="#29、对数组名取地址" class="headerlink" title="29、对数组名取地址"></a>29、对数组名取地址</h2><p>数组名本身表示数组第一个元素的地址<br>数组名取地址代表整个数组，该地址+1是加了整个数组的长度。</p><h2 id="30、static修饰局部变量"><a href="#30、static修饰局部变量" class="headerlink" title="30、static修饰局部变量"></a>30、static修饰局部变量</h2><p>生命周期延长</p><h2 id="31、switch。。。case接受哪种基本数据类型？省略break会怎样？"><a href="#31、switch。。。case接受哪种基本数据类型？省略break会怎样？" class="headerlink" title="31、switch。。。case接受哪种基本数据类型？省略break会怎样？"></a>31、switch。。。case接受哪种基本数据类型？省略break会怎样？</h2><p>不接受float、double。<br>若省略break则匹配成功后一直运行到结束或遇到第一个break</p><h2 id="32、无符号数据类型转换"><a href="#32、无符号数据类型转换" class="headerlink" title="32、无符号数据类型转换"></a>32、无符号数据类型转换</h2><p>无符号和有符号相运算，有符号会转化成无符号，若是负数则会变为极大的正数。</p><h2 id="33、算出一个字节中被置1的位个数"><a href="#33、算出一个字节中被置1的位个数" class="headerlink" title="33、算出一个字节中被置1的位个数"></a>33、算出一个字节中被置1的位个数</h2><p>循环移位并判断最后一位是否为1<br>或者用x&amp;(x-1)计算</p><h2 id="34、编写函数将给定的字符串转换成整数。"><a href="#34、编写函数将给定的字符串转换成整数。" class="headerlink" title="34、编写函数将给定的字符串转换成整数。"></a>34、编写函数将给定的字符串转换成整数。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(*str!=<span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d=*str<span class="number">-48</span>;</span><br><span class="line">num=num*<span class="number">10</span>+d;</span><br><span class="line">str=str+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35、将整数转换成字符串。"><a href="#35、将整数转换成字符串。" class="headerlink" title="35、将整数转换成字符串。"></a>35、将整数转换成字符串。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> *pval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> strval[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> val0=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> val1=<span class="number">0</span>;</span><br><span class="line">val0=num;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">val1=val0%<span class="number">10</span>;</span><br><span class="line">val0=val0/<span class="number">10</span>;</span><br><span class="line">strval[i]=val1+<span class="number">48</span>;</span><br><span class="line"><span class="keyword">if</span>(val0&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">strval[i]=val0+<span class="number">48</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">pval[j]=strval[i-j];</span><br><span class="line">pval[j]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36、怎么判断链表中是否有环？"><a href="#36、怎么判断链表中是否有环？" class="headerlink" title="36、怎么判断链表中是否有环？"></a>36、怎么判断链表中是否有环？</h2><p>追逐方式。<br>两个指针遍历链表，一个每次走一步，一个每次走两步，若后者能追上前者，则表示有环。</p><h2 id="37、双向链表的插入和删除。"><a href="#37、双向链表的插入和删除。" class="headerlink" title="37、双向链表的插入和删除。"></a>37、双向链表的插入和删除。</h2><p>插入修改四个指针。<br>删除只需要修改两个。</p><h2 id="38、二维数组转置。"><a href="#38、二维数组转置。" class="headerlink" title="38、二维数组转置。"></a>38、二维数组转置。</h2><p>核心操作:b[j][i]=a[i][j]</p><h2 id="39、输入一行字符，统计其中有多少个单词。"><a href="#39、输入一行字符，统计其中有多少个单词。" class="headerlink" title="39、输入一行字符，统计其中有多少个单词。"></a>39、输入一行字符，统计其中有多少个单词。</h2><p>按空格累加。</p><h2 id="40、杨辉三角"><a href="#40、杨辉三角" class="headerlink" title="40、杨辉三角"></a>40、杨辉三角</h2><h2 id="41、计算字符串中子串出现的次数"><a href="#41、计算字符串中子串出现的次数" class="headerlink" title="41、计算字符串中子串出现的次数"></a>41、计算字符串中子串出现的次数</h2><p>循环比较。</p><h2 id="42、数组a-n-，存放1到n，找出被重复的数字，时间复杂度为O（n）"><a href="#42、数组a-n-，存放1到n，找出被重复的数字，时间复杂度为O（n）" class="headerlink" title="42、数组a[n]，存放1到n，找出被重复的数字，时间复杂度为O（n）"></a>42、数组a[n]，存放1到n，找出被重复的数字，时间复杂度为O（n）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_dup</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">sum+=a[i];</span><br><span class="line">sum=sum-(N<span class="number">-1</span>)(N)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43、16bit的整数，每4bit为一个数，写函数求他们的和"><a href="#43、16bit的整数，每4bit为一个数，写函数求他们的和" class="headerlink" title="43、16bit的整数，每4bit为一个数，写函数求他们的和"></a>43、16bit的整数，每4bit为一个数，写函数求他们的和</h2><p>循环，移位相加即可。<br>c+=n&15;<br>n=n&gt;&gt;4;</p><h2 id="47、什么函数不能声明为虚函数？"><a href="#47、什么函数不能声明为虚函数？" class="headerlink" title="47、什么函数不能声明为虚函数？"></a>47、什么函数不能声明为虚函数？</h2><p>virtual<br>a、内联函数，内联函数在编译时展开，而虚函数是运行时动态绑定，所以两者矛盾。<br>b、构造函数，构造函数用来创建一个新的对象，而虚函数运行时建立在对象基础上，在构造函数时对象尚未形成。<br>c、静态成员函数，静态成员函数属于一个类而非某一对象，没有this指针，无法进行对象的判别。<br>d、非成员函数<br>e、类的成员函数是模板函数的时候。</p><h2 id="48、编写一个函数作用是把char数组字符串循环右移n位"><a href="#48、编写一个函数作用是把char数组字符串循环右移n位" class="headerlink" title="48、编写一个函数作用是把char数组字符串循环右移n位"></a>48、编写一个函数作用是把char数组字符串循环右移n位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoopMove</span><span class="params">(<span class="keyword">char</span> *pstr,<span class="keyword">int</span> steps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(pstr)-steps;</span><br><span class="line"><span class="keyword">char</span> temp[MAX_LEN];</span><br><span class="line"><span class="built_in">strcpy</span>(temp,pstr+n);</span><br><span class="line"><span class="built_in">strcpy</span>(temp+steps,pstr);</span><br><span class="line">*(tmp+<span class="built_in">strlen</span>(pstr))=<span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(pstr,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="49、编写类String的构造函数、析构函数和赋值函数。"><a href="#49、编写类String的构造函数、析构函数和赋值函数。" class="headerlink" title="49、编写类String的构造函数、析构函数和赋值函数。"></a>49、编写类String的构造函数、析构函数和赋值函数。</h2><p>一个类包含指针的话，一般会有析构函数，而且要重写拷贝构造和赋值运算符，因为默认是地址的拷贝和赋值，对指针来说无意义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">String(<span class="keyword">const</span> <span class="keyword">char</span> *str=<span class="literal">NULL</span>);</span><br><span class="line">String(<span class="keyword">const</span> <span class="built_in">string</span> &amp;other);<span class="comment">//拷贝构造</span></span><br><span class="line">~String();</span><br><span class="line">String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;other);<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="50、指向二维数组的指针1。"><a href="#50、指向二维数组的指针1。" class="headerlink" title="50、指向二维数组的指针1。"></a>50、指向二维数组的指针1。</h2><h2 id="51、指向二维数组的指针2。"><a href="#51、指向二维数组的指针2。" class="headerlink" title="51、指向二维数组的指针2。"></a>51、指向二维数组的指针2。</h2><p>注意++到底是加的一维数组还是一个元素。</p><h2 id="52、逗号运算符（优先级最低）"><a href="#52、逗号运算符（优先级最低）" class="headerlink" title="52、逗号运算符（优先级最低）"></a>52、逗号运算符（优先级最低）</h2><p>a=3;b=5;<br>c=a,b;<br>d=(a,b);<br>执行之后，c=3，d=5.</p><h2 id="53、sizeof运算符。"><a href="#53、sizeof运算符。" class="headerlink" title="53、sizeof运算符。"></a>53、sizeof运算符。</h2><p>int i=3;<br>int j;<br>j=sizeof(++i+ ++i);<br>print(“i=%d,j=%d”,i,j);<br>输出：i=3，j=4<br>原因：编译器进行优化，发现++对sizeof根本没影响，所以会优化不计算++，发生短路现象。</p><h2 id="54、递归展开求值。"><a href="#54、递归展开求值。" class="headerlink" title="54、递归展开求值。"></a>54、递归展开求值。</h2><h2 id="55、赋值运算符-作为循环条件。"><a href="#55、赋值运算符-作为循环条件。" class="headerlink" title="55、赋值运算符=作为循环条件。"></a>55、赋值运算符=作为循环条件。</h2><p>赋非零值，无限循环。<br>赋0，不循环。</p><h2 id="56、（a-b）-c与（a-c）-b是否恒等"><a href="#56、（a-b）-c与（a-c）-b是否恒等" class="headerlink" title="56、（a+b）+c与（a+c）+b是否恒等"></a>56、（a+b）+c与（a+c）+b是否恒等</h2><p>不一定，可能会溢出。假设a+b溢出，但是c是负数，a+c后再加b就不一定溢出了。<br>a+b+c一定等于b+a+c</p><h2 id="57、进程和线程的差别。"><a href="#57、进程和线程的差别。" class="headerlink" title="57、进程和线程的差别。"></a>57、进程和线程的差别。</h2><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>a、线程是调度分配的基本单位，进程是拥有资源的基本单位。<br>b、并发性，都可以并发。进程切换比线程切换开销大。<br>c、拥有资源，进程是拥有资源的独立单位，线程不拥有系统资源，但是可以访问所属进程的资源。<br>d、系统开销，在创建或撤销进程时，由于系统都要分配和回收资源，所以开销较大。</p><h2 id="58、解释const-char-const-p"><a href="#58、解释const-char-const-p" class="headerlink" title="58、解释const char * const p"></a>58、解释const char * const p</h2><p>左边是底层const，右边是顶层const。<br>char <em> const p//常量指针，p的地址不可以修改，即指针本身不可修改<br>const char </em> p;//指向常量的指针，指针本身可修改，但指向的内容不可修改。<br>char const * p;//同上<br>两个const就是指针本身不可以修改，所指内容也不可更改。</p><h2 id="59、memset、memcpy和strcpy的根本区别。"><a href="#59、memset、memcpy和strcpy的根本区别。" class="headerlink" title="59、memset、memcpy和strcpy的根本区别。"></a>59、memset、memcpy和strcpy的根本区别。</h2><p>memset和memcpy需要包含memory.h，strcpy需要string.h<br>memset用来对一段内存空间全部设置为某个字符 memset(a,0,sizeof(a))<br>memcpy用来内存拷贝，拷贝任何数据类型的对象 memcpy(b,a,sizeof(b))<br>strcpy只能拷贝字符串，遇到’\0’就结束，所以不需要指定大小。<br>要注意内存溢出。</p><h2 id="60、析构函数有何特点。"><a href="#60、析构函数有何特点。" class="headerlink" title="60、析构函数有何特点。"></a>60、析构函数有何特点。</h2><p>a、析构函数也是特殊的类成员函数，和构造函数一样没有返回类型<br>b、没有参数<br>c、不能重载<br>d、public、private、protected对析构函数无效<br>e、析构函数不能手动调用，只有在类对象生命周期结束的时候，由系统自动调用释放在构造函数中分配的资源，回收内存。<br>f、构造函数不可以是virtual，但析构函数可以。</p><h2 id="61、虚函数有什么用？"><a href="#61、虚函数有什么用？" class="headerlink" title="61、虚函数有什么用？"></a>61、虚函数有什么用？</h2><p>a、虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没覆盖调用父类中的函数，从而实现灵活扩展和多态性。<br>b、如果是纯虚函数，则纯粹是为了在子类覆盖时有个统一的命名而已，子类必须覆盖纯虚函数，否则子类也是抽象类<br>c、含有纯虚函数的类称为抽象类，不能实例化对象，主要用于做接口</p><h2 id="62、虚析构函数的作用"><a href="#62、虚析构函数的作用" class="headerlink" title="62、虚析构函数的作用"></a>62、虚析构函数的作用</h2><p>虚构函数调用是先子后父。<br>当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，就会导致运行时派生类不会被销毁，然而基类部分已经被销毁，这就导致了部分析构，造成内存泄露。<br>此时就需要给基类一个虚析构函数。</p><h2 id="63、分别给出bool、in、float、指针变量与零值比较的if语句"><a href="#63、分别给出bool、in、float、指针变量与零值比较的if语句" class="headerlink" title="63、分别给出bool、in、float、指针变量与零值比较的if语句"></a>63、分别给出bool、in、float、指针变量与零值比较的if语句</h2><p>bool:if(!var)<br>int:if(var==0)<br>float: const float var=0.000001;<br>    if(x&gt;-var &amp;&amp; x&lt;var)<br>浮点数不能精确到0，所以需要在一个范围内近似看做0<br>指针：if(var==NULL)</p><h2 id="64、32位下，计算sizeof"><a href="#64、32位下，计算sizeof" class="headerlink" title="64、32位下，计算sizeof"></a>64、32位下，计算sizeof</h2><p>a、<br>void fun(char str[100])<br>{<br>sizeof(str)=?//4<br>}<br>原因：数组做函数形参，会转化成指针<br>b、<br>void <em>p=malloc(100);<br>sizeof(p) //4<br>c、<br>int a[100]<br>sizeof(a)//4</em>100<br>d、<br>char *p=”aaa”<br>sizeof(p)=?//4</p><h2 id="65、写函数返回1-2-3-。。-n的值"><a href="#65、写函数返回1-2-3-。。-n的值" class="headerlink" title="65、写函数返回1+2+3+。。+n的值"></a>65、写函数返回1+2+3+。。+n的值</h2><p>解法1：一重循环<br>解法2：利用高斯公式直接求 （1+n）*n/2</p><h2 id="66、深度广度遍历二叉树。"><a href="#66、深度广度遍历二叉树。" class="headerlink" title="66、深度广度遍历二叉树。"></a>66、深度广度遍历二叉树。</h2><h2 id="67、内联函数和普通函数的区别。"><a href="#67、内联函数和普通函数的区别。" class="headerlink" title="67、内联函数和普通函数的区别。"></a>67、内联函数和普通函数的区别。</h2><p>a、内联函数是将简单函数内嵌道调用它的程序代码中，目的是节约原本函数调用时的时空开销，不能含有循环、条件、选择等复杂的结构。<br>b、内联函数和宏的区别，宏是由预处理器对宏进行替代，而内联函数是通过编译器来控制的。内联函数是真正的函数，取消了函数的参数压栈，减少调用开销，不用担心像宏函数的问题。<br>c、用inline定义内联函数，任何在类的说明部分定义的函数都会自动认为是内联函数。</p><h2 id="68、c-重写和重载重定义区别"><a href="#68、c-重写和重载重定义区别" class="headerlink" title="68、c++重写和重载重定义区别"></a>68、c++重写和重载重定义区别</h2><p>a、重载特征：相同的范围（同一个类），函数名字相同，参数不同<br>b、重写（覆盖）：派生类函数覆盖基类函数，分别位于基类和派生类中，名字相同，参数相同，基类函数必须有virtual<br>c、重定义是指派生类的函数屏蔽了与其同名的基类函数<br>如果派生类的函数和基类的函数同名，参数不同，此时不管有无virtual，基类的函数被隐藏<br>如果派生类的函数与基类的函数同名，参数也相同，但基类没有virtual，此时基类的函数被隐藏</p><h2 id="69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。"><a href="#69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。" class="headerlink" title="69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。"></a>69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。</h2><p>可以的。<br>static一般在类外初始化，const一般在构造函数里初始化。<br>既是const又是static就在类外初始化，但要在类外初始化的同时声明为const。</p><h2 id="70、构造函数和析构函数的异同点。"><a href="#70、构造函数和析构函数的异同点。" class="headerlink" title="70、构造函数和析构函数的异同点。"></a>70、构造函数和析构函数的异同点。</h2><p>构造函数的特点：<br>1、构造函数名字与类名相同<br>2、构造函数可以有任意的参数，但不能具有返回类型<br>3、定义对象时，编译系统自动调用构造函数<br>4、够咱函数是特殊的成员函数，函数体可以在类内，也可以在类外<br>5、构造函数不能像其他成员函数那样被显示调用，它是在定义对象的同时被调用</p><p>析构函数的特点：<br>1、析构函数名字与类型相同，析构函数前加一个~<br>2、析构函数没有参数，也没有返回值，不能被重载，一个类只能有一个析构函数<br>3、在撤销对象时，编译系统会自动调用析构函数<br>4、析构函数可以是virtual，而构造函数不可以。</p><h2 id="71、自动调用拷贝构造函数的几种情形。"><a href="#71、自动调用拷贝构造函数的几种情形。" class="headerlink" title="71、自动调用拷贝构造函数的几种情形。"></a>71、自动调用拷贝构造函数的几种情形。</h2><p>拷贝构造函数是用一个已知对象来初始化另一个同类对象。<br>拷贝构造函数也是类的构造函数，与雷鸣相同，又一个该类对象引用的参数。<br>若自己不写，则会自动生成一个默认的。<br>若一个类中有指针，就需要自己写，不能用默认的，因为默认的是地址拷贝。</p><p>自动调用情况：<br>1当类的一个对象去初始化该类另一个对象时。<br>2如果函数形参是类的对象，调用函数进行形参和实参结合时<br>3如果函数返回值是类对象，函数返回时。</p><h2 id="72、类型转换构造函数是什么？"><a href="#72、类型转换构造函数是什么？" class="headerlink" title="72、类型转换构造函数是什么？"></a>72、类型转换构造函数是什么？</h2><p>自动调用类型匹配的构造函数，自动将基本数据类型转换成对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> height;</span><br><span class="line">Person(<span class="keyword">double</span> h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p=<span class="number">2.3</span>;<span class="comment">//类型转换构造函数，将2.3转换成double调用该构造函数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">类型转换函数可以产生自动类型转换匹配，如下：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">intheight;</span><br><span class="line">Person(<span class="keyword">int</span> h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span>的构造函数也可以调用成功。</span><br></pre></td></tr></table></figure></p><h2 id="73、异常处理方式。"><a href="#73、异常处理方式。" class="headerlink" title="73、异常处理方式。"></a>73、异常处理方式。</h2><p>步骤：<br>1、程序执行时发生错误<br>2、以一个异常对象记录错误的原因及相关信息<br>3、程序检测到这个错误（读取错误对象）<br>4、程序决定如何处理错误<br>5、错误处理，并在此后恢复或终止程序的执行</p><h2 id="74、成员函数和友元函数的区别"><a href="#74、成员函数和友元函数的区别" class="headerlink" title="74、成员函数和友元函数的区别"></a>74、成员函数和友元函数的区别</h2><p>a、成员函数是类定义的一部分通过特定的对象来调用。成员函数可以隐式访问对象的成员，而无须使用成员操作符<br>b、友元函数不是类的组成部分，因为被称为直接函数调用。友元函数不能隐式访问类成员，必须将成员操作符用于参数传递的对象。</p><h2 id="75、c-中哪些运算符不能重载"><a href="#75、c-中哪些运算符不能重载" class="headerlink" title="75、c++中哪些运算符不能重载"></a>75、c++中哪些运算符不能重载</h2><p>.<br>?:<br>sizeof（不是函数是运算符）<br>::<br><em>（指针解引用不可以重载，乘号可以）<br>.</em></p><h2 id="76、如何重载前-和后"><a href="#76、如何重载前-和后" class="headerlink" title="76、如何重载前++和后++"></a>76、如何重载前++和后++</h2><p>前++不带参数，后++带一个（int）以示区分<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iCount &amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">data++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iCount <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">iCount temp=*<span class="keyword">this</span>;</span><br><span class="line">data++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="77、请说出STL标准模板库中的几个常用类"><a href="#77、请说出STL标准模板库中的几个常用类" class="headerlink" title="77、请说出STL标准模板库中的几个常用类"></a>77、请说出STL标准模板库中的几个常用类</h2><p>vector<br>list<br>set<br>stack<br>queue<br>map</p><h2 id="78、函数模板和函数重载的异同"><a href="#78、函数模板和函数重载的异同" class="headerlink" title="78、函数模板和函数重载的异同"></a>78、函数模板和函数重载的异同</h2><p>函数重载是指函数名字相同，但是参数类型或者个数不同，顺序不同。<br>函数模板是指函数算法相同，而参数类型不同。</p><h2 id="79、类型转换构造函数是什么？"><a href="#79、类型转换构造函数是什么？" class="headerlink" title="79、类型转换构造函数是什么？"></a>79、类型转换构造函数是什么？</h2><p>是隐式调用构造函数，将基本数据类型转换成对象。<br>对象不可转换成基本数据类型。</p><h2 id="80、c-中explicit关键字有什么用。"><a href="#80、c-中explicit关键字有什么用。" class="headerlink" title="80、c++中explicit关键字有什么用。"></a>80、c++中explicit关键字有什么用。</h2><p>explicit和构造函数一起使用，指明构造函数只能显式调用，目的是为了防止不必要的隐式调用类型转换构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> height;</span><br><span class="line">explicit Person(double h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p=<span class="number">2.3</span>;<span class="comment">//会报错，因为explicit阻止了隐式调用，必须显式调用</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">2.4</span>)</span></span>;<span class="comment">//显示调用，可以</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="81、c-中restrict关键字有什么作用？"><a href="#81、c-中restrict关键字有什么作用？" class="headerlink" title="81、c++中restrict关键字有什么作用？"></a>81、c++中restrict关键字有什么作用？</h2><p>是用来优化的，是c99新加的关键字。<br>restrict只能修饰指针，修饰的指针时能够访问所指区域的唯一入口，限制多个指针指向同一地址。<br>如果两个指针指向同一个地址，一个被释放了，另一个就成了野指针。</p><h2 id="82、c-中常用的设计模式又哪些？"><a href="#82、c-中常用的设计模式又哪些？" class="headerlink" title="82、c++中常用的设计模式又哪些？"></a>82、c++中常用的设计模式又哪些？</h2><p>工厂方法<br>策略模式<br>单例模式<br>迭代器模式<br>抽象工厂模式<br>建造者模式<br>适配器模式<br>桥接模式<br>折磨死<br>解释器模式<br>命令模式<br>中介者模式<br>观察者陌生<br>状态模式<br>代理模式</p><h2 id="83、写一个单例模式的例子。"><a href="#83、写一个单例模式的例子。" class="headerlink" title="83、写一个单例模式的例子。"></a>83、写一个单例模式的例子。</h2><p>其目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。比如定义常量的类。<br>将构造函数私有。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">C()&#123;&#125;;<span class="comment">//构造函数私有</span></span><br><span class="line"><span class="keyword">static</span> C * p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> C * <span class="title">Get</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">p=<span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">C * C::p==<span class="literal">NULL</span>;<span class="comment">//static属性类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C* p1=C::get();</span><br><span class="line">C* p2=C::get();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(p1==p2)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="84、面向对象的三大特征。"><a href="#84、面向对象的三大特征。" class="headerlink" title="84、面向对象的三大特征。"></a>84、面向对象的三大特征。</h2><p>a、封装<br>b、继承<br>c、多态</p><h2 id="85、什么是封装"><a href="#85、什么是封装" class="headerlink" title="85、什么是封装"></a>85、什么是封装</h2><p>封装是面向对象的特征之一，是对象和类概念的主要特性。<br>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<br>c++中，public、protected、private就是封装的访问权限说明符。</p><h2 id="86、什么是继承"><a href="#86、什么是继承" class="headerlink" title="86、什么是继承"></a>86、什么是继承</h2><p>继承可以使现有类的所有功能，并在无需重新编写原来类的情况下对功能进行扩展。<br>c++支持单继承和多继承，也有多级继承。<br>用public、protected和private修饰继承特性。</p><h2 id="87、什么是多态"><a href="#87、什么是多态" class="headerlink" title="87、什么是多态"></a>87、什么是多态</h2><p>polymorphisn<br>允许将父对象设置成为一个或更多的他的子对象相等的技术。<br>父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。<br>父类的指针用引用赋子类的值。<br>两种方式，覆盖（重写），重载。<br>覆盖，子类重新定义父类的virtual虚函数。<br>重载，允许存在多个同名函数，但参数列表不同。</p><h2 id="88、类和对象的区别。"><a href="#88、类和对象的区别。" class="headerlink" title="88、类和对象的区别。"></a>88、类和对象的区别。</h2><p>是一般与个别、抽象与具体、集体与个体的区别。<br>举个例子即可（人类和张三）</p><h2 id="89、c-中的namespace是什么？"><a href="#89、c-中的namespace是什么？" class="headerlink" title="89、c++中的namespace是什么？"></a>89、c++中的namespace是什么？</h2><p>命名空间，类似于java中的包<br>避免在不同程序库中的命名冲突。<br>详看c++ primer</p><h2 id="90、什么是可重入和不可重入函数？"><a href="#90、什么是可重入和不可重入函数？" class="headerlink" title="90、什么是可重入和不可重入函数？"></a>90、什么是可重入和不可重入函数？</h2><p>可重入性：reentrant<br>函数可以由多于一个任务并发使用，而不必担心数据错误，可以在任意时刻被中断，稍后再继续运行不会丢失数据。<br>不可重入函数不能超过一个任务所共享。</p><p>可重入函数：<br>不为连续的调用持有静态数据<br>不返回指向静态数据的指针<br>使用本地数据<br>如果必须访问全局变量需要利用互斥信号量<br>不调用不可重入函数</p><p>不可重入函数：<br>使用了静态变量<br>返回静态变量<br>调用了不可重入函数<br>调用了malloc或free<br>调用了其他标准i/o</p><p>总的来说，一个函数使用了未受保护的共享资源，就不可重入。</p><h1 id="hash函数、数据库基本"><a href="#hash函数、数据库基本" class="headerlink" title="hash函数、数据库基本"></a>hash函数、数据库基本</h1><p>hash函数性质：输入域巨大，输出域固定<br>1、输入域无限<br>2、相同输入，结果相同<br>3、不通输入，结果可能相同也可能不同<br>4、不同输入值得到的hash值，均匀分布在输出域上（优劣评判）</p><p>32位无符号整数范围，0到40一亿左右。    </p><p>第一范式：每一个分量都是不可分的数据项。<br>第二范式：每一个非主属性完全函数依赖于任何一个候选码。<br>第三范式：每一个非主属性既不传递依赖于码，也不部分依赖于码。<br>BCNF：若每一个决定因素都包含码。<br>一个满足BCNF的关系模式有：<br>所有非主属性对每一个码都是完全函数依赖。<br>所有主属性对每一个不包含它的码也是完全函数依赖。<br>没有任何属性完全函数依赖于非码的任何一组属性。</p><p>事务的ACID特性<br>原子性：事务中的操作要么都做，要么都不做。<br>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。<br>隔离性：一个事务的执行不能被其他事务干扰。<br>持续性：事务一旦提交，它对数据库中数据的改变就应是永久性的。</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>1、网络协议主要由三要素组成：语法、语义和 同步。</p><p>2、osi体系结构<br>物理层：单位bit，为上层提供了传输数据的物理介质。<br>数据链路层：单位帧，在不可靠的物理介质上提供可靠的传输。HDLC、PPP。<br>网络层：单位分组或数据包，负责对子网间的数据包进行路由选择。IP。<br>传输层：单位报文，是第一个端到端即进程到进程的层次，提供端到端的传输。TCP、UDP。<br>会话层：负责建立、管理、终止进程之间的会话。<br>表示层：进行数据转换，包括加密、压缩、格式转换等。<br>应用层：为操作系统或网络应用程序提供网络服务的接口。FTP、HTTP。</p><p>tcp/ip体系结构：网络接口层、网际层、传输层和应用层。<br>五层体系结构就是把网络接口层依然分解为物理层和数据链路层。</p><p>3、数据链路层三个基本问题：数据成帧，透明传输，差错检测。<br>CRC检验码的位数就是生成多项式的最高次数。</p><p>4、路由器分组转发流程<br>a、从分组首部提取目的站的IP地址D，得出目的网络地址为N<br>b、若网络N与此路由器直接相连，则直接将分组交付给目的站D，否则转到c<br>c、若路由表中有目的地址为D的特定主机路由，则将分组传送给路由表中所指明的下一跳路由器，否则转d<br>d、若路由表有到达网络N的路由，则将分组传送给路由器表指明的下一跳路由器，否则转e<br>e、若路由表中有一个默认路由，则将分组传送到默认路由，否则报错。</p><p>5、ping的过程<br>ping是ICMP的一个重要应用。<br>ping同一个网段的主机：查找目的主机的mac地址，然后直接交付。如果没查到mac地址，就进行一次arp请求。<br>ping不同网段的主机：发送到网关让其进行转发，同样要发送到网关也得知道网关的mac地址，根据mac地址进行转发。</p><p>6、三块专用地址<br>A类：10.0.0.0 ~ 10.255.255.255<br>B类：172.16.0.0 ~ 172.31.255.255<br>C类：192.168.0.0 ~ 192.168.255.255</p><p>7、用户数据包协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。</p><p>传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</p><p>8、web页面请求过程<br>a、向DNS服务器发送DNS查询报文解析域名获得IP地址。<br>b、通过TCP向服务器发送连接请求。<br>c、服务器上会有个服务进程在不断监听80端口，当监听到连接请求后便与浏览器建立连接。建立之后服务器会随机分配一个端口号给客户端，之后的tcp传输都用这个分配的客户端。<br>d、TCP建立后，浏览器向服务器放松要求获取某一Web页面的http请求。<br>e、服务器收到http请求后构建所需信息，通过HTTP响应返回给浏览器。<br>f、浏览器将信息进行解析并渲染，显示页面。最后会断开tcp连接。</p><h1 id="HTTP部分"><a href="#HTTP部分" class="headerlink" title="HTTP部分"></a>HTTP部分</h1><p>1、get和post的请求都能使用额外的参数，但是get的参数是以查询字符串出现在url中，而post的参数存储在实体主体部分。<br>get的传参方式相比于post安全性较差，因为get传的参数在url是可见的，可能会谢露私密信息。并且get只支ASCII字符，如果参数为中文则可能会出现乱码，而post支持标准字符集。<br>get的主要目的是获取资源，而post的主要目的是传输实体主体数据。</p><p>head和get一样，但是不返回报文实体主体部分。<br>put不带验证机制，存在安全问题。<br>delete作用和put相反。<br>trace追踪路径<br>connect要求用隧道协议连接代理，加密后经过隧道传输。</p><p>状态码：<br>1xx：信息性状态码<br>2xx：成功<br>3xx：重定向<br>4xx：客户端错误<br>5xx：服务器错误</p><p>四种类型首部字段：<br>通用首部、请求首部、响应首部和实体首部</p><p>HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP/1.1引入Cookie来保存状态信息。</p><p>Cookie信息存在浏览器上。</p><p>Session和Cookie区别<br>Session是服务器用来跟踪用户的一种手段，每个Session都有一个唯一标识Session ID。<br>当服务器创建一个Session时，给客户端发送的响应报文就包含了Set-Cookie字段，其中有个名为sid的键值对，这就是Session ID。当客户端收到后就把Cookie保存在浏览器中，并且之后发送的请求报文都包含Session ID。<br>HTTP就是通过Session和Cookie一起合作实现跟踪用户状态的，Session用于服务器端，Cookie用于客户端。</p><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。 持久连接 只需要进行一次 TCP 连接就能进行多次 HTTP 通信。HTTP/1.1 开始，所有的连接默认都是持久连接。</p><p>持久连接需要使用Connection首部字段进行管理。<br>HTTP1.1开始HTTP默认是持久连接，若要关闭需要客户端或服务端提出断开，使用connection：close。<br>而在HTTP1.1之前默认是非持久连接，若要持久连接则需要使用keep-alive。</p><p>代理服务器不会改变url，主要目的是缓存、网络访问控制以及访问日志记录。<br>网关服务器则不同，会将HTTP转化为其他协议进行通信，从而请求非HTTP服务器。</p><p>隧道：使用SSL等加密手段，为客户端和服务器之间建立一条安全的通信线路。</p><p>HTTP安全问题：<br>1、使用明文进行通信，内容可能会被窃听<br>2、不验证通信方的身份，通信方的身份可能遭遇伪装<br>3、无法证明报文的完整性，报文有可能被篡改。</p><p>HTTPS并不是新协议，而是HTTP先和SSL通信，再由SSL和TCP通信，提供了加密、认证和完整性保护。</p><p>加密：HTTPs使用混合加密机制，使用公钥加密用于传输信息的对称秘钥，之后使用对称秘钥进行通信。<br>对称秘钥的缺点：无法安全传输秘钥本身。<br>公钥缺点：更耗时。</p><p>认证使用证书。<br>SSL提供摘要功能来验证完整性。</p><p>HTTP/1.1新增内容：<br>1、默认为持久连接<br>2、提供了范围请求功能<br>3、提供了虚拟主机功能<br>4.、多了一些缓存处理字段<br>5、多了一些状态码</p><h1 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h1><p>操作系统基本特征：并发、共享、虚拟、异步</p><p>进程和线程的区别：<br>1、进程是除CPU外资源分配的基本单位，但是线程不拥有资源，线程访问隶属进程的资源<br>2、调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程内的线程时，会引起进程切换。<br>3、系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，所付出的开销远大于创建或撤销线程时的开销。类似的，在进程切换时，涉及到当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。<br>4、通信方面：进程间通信需要进程同步和异步手段的辅助，以保证数据的一致性。而进程内部通信可以通过直接读/写同一进程中的数据段来进行通信。</p><p>windows进程间通信：管道、共享内存、消息队列，信号量，socket<br>Windows线程间通信：临界区、互斥量、信号量和事件。</p><p>临界区与互斥体的区别<br>1、临界区只能用来同步本进程内的线程，而不能同步多个进程中的线程。互斥量、信号量、事件都可以跨越进程使用来进行同步数据操作。<br>2、临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。<br>3、临界区和互斥体在windows平台下都可用。</p><p>死锁的必要条件：<br>1、互斥条件<br>2、占有和等待<br>3、不剥夺条件<br>4、循环等待<br>死锁防止策略：<br>打破1，可同时访问<br>打破2，进程执行前申请需要的全部资源，在执行过程中不再申请资源<br>打破3，占有资源的进程若要申请新资源，必须主动释放已占用资源<br>打破4，层次分配。</p><p>死锁避免：银行家算法</p><p>分段分页的区别：<br>1、分页透明，分区需要程序员显式划分每个段。<br>2、分页是一维地址，分段是二维地址。<br>3、页的大小不可变，而段的大小可以动态改变。<br>4、分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了让程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p><h1 id="内存池、Nginx"><a href="#内存池、Nginx" class="headerlink" title="内存池、Nginx"></a>内存池、Nginx</h1><p>内存池可以减少内存碎片、避免内存泄露，提高内存分配效率。</p><p>通常我们习惯直接使用new、malloc等API申请分配内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。</p><p>Nginx（发音同 engine x）是一款轻量级的Web 服务器／反向代理服务器及电子邮件（IMAP/POP3）代理服务器</p><p>Nginx提供的负载均衡有两种：内置策略和扩展策略。<br>内置策略微轮询，加权轮询，IP hash。<br>扩展策略url hash</p><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>目的：因为阻塞模型在没有收到数据的时候就会阻塞卡住，如果一次需要接受多个socket fd的时候，就会导致必须处理完前面的fd，才能处理后面的fd，即使可能后面的fd比前面的fd还要先准备好，所以这样就会造成客户端的严重延迟。为了处理多个请求，我们自然先想到用多线程来处理多个socket fd，但是这样又会启动大量的线程，造成资源的浪费，所以这个时候就出现了io多路复用技术。就是用一个进程来处理多个fd的请求。</p><p>与多进程/多线程相比，IO多路复用最大的好处就是系统开销小。</p><p>1应用层数据到kernel<br>2 kernel复制到user space<br>阻塞io模型就是将这个两个过程合并在一起，一起阻塞。非阻塞就是第一个不阻塞，而是不断轮询，第二个仍然阻塞。</p><p>select：<br>程序呼叫select，然后整个程序就阻塞了，这个时候kernel就会轮询检查所有select负责的fd，当找到其中一个client的数据准备好了，select就会返回，这个时候程序启动系统调用，将数据从kernel复制到进程缓冲区。</p><p>poll<br>原理和select十分相似，差别如下：<br>描述fd集合的方式不同，poll没使用select的fd_set结构，所以poll是链式的，没有最大连接数的限制。<br>poll有个特点是水平触发，也就是通知fd就绪后，如果这次没有被处理，那么下次poll的时候会再次通知同个fd已经就绪。</p><p>select缺点：<br>1fd_size大小为32个整数（32位机器上就是32*32，1024bit），每个fd一个bit，所以最大只能处理1024个fd</p><p>2每一次呼叫select都要从user space把fd_set复制到kernel中，因为每一次呼叫前，set都可能有变动，而epoll提供了共享记忆存储结构。</p><p>3kernel轮询每个fd，约限行时间，消耗大且效率低下。</p><p>epoll提供三个函数：<br>创建epoll对象，传回id<br>事件注册函数，将需要监听的事件和需要监听的fd交给epoll对象。<br>等待注册的事件被触发或timeout。等待函数。</p><p>epoll没有数量限制，最大数量只和系统能够打开多少fd有关。<br>epoll不需要每次都将set赋值到kernel检查，因为在注册的时候已经将fd拷贝了进来。<br>select/poll都是主动轮询，而epoll是被动，它不仅可以知道有fd就绪，还可以知道是哪个fd就绪，直接处理。（类比轮询和中断方式。）</p><h1 id="3-12"><a href="#3-12" class="headerlink" title="3-12"></a>3-12</h1><p>nginx：异步非阻塞</p><p>nginx的请求处理：<br>1、操作系统提供的机制产生相关的时间<br>2、接受和处理这些事件，如果接收到数据，则产生更高层的request对象<br>3、处理request的header和body<br>4、产生响应，并发送回客户端<br>5、完成request的处理<br>6、重新初始化定时器及其他事件</p><h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><p>C++11新特性（很多，节选，完整看C++ Primer）<br>1、新定义long long类型，一个long long类型至少和一个long一样大。<br>2、列表初始化，就是用大括号来初始化变量。<br>3、引入新常量nullptr，用来得到或者初始化指针。<br>4、引入auto和decltype，auto一般会忽略顶层const，decltype处理顶层const和引用的方式和auto不同，他会将变量包括顶层const和引用在内的信息都返回。<br>5、范围for语句<br>6、引入了两个新函数cbegin和cend。<br>7、C++11规定商一律向0取整，不论正负。<br>8、initializer_list，参数数量未知但是全部实参类型相同时可以使用该类型，和vector类似，只是其中存储的元素都是常量，不能修改。<br>9、尾置返回类型：auto fun() -&gt; int (*)[10]，返回类型是一个指向一个十个整形数组的指针。<br>10、constexpr函数是指能够用于常量表达式的函数，函数的返回类型和所有形参类型都必须是字面值类型。<br>11、可以定义所谓的委托构造函数，使用它所属类的其他构造函数来执行它自己的初始化过程。<br>12、定义了array和forward_list，数组和单向链表。<br>13、新标准引入了三个新成员—emplace，这些操作构造而不是拷贝元素，将参数传给元素类型的构造参数。<br>14、lambda表达式<br>15、bind函数。<br>16、四个无序容器，unordere_map  unordered_set unordered_multiset  unordered_multimap，使用hash函数和==运算符<br>17、智能指针。shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象。还有一种weak_ptr的伴随类，是一种弱引用，指向shared_ptr所管理的对象，不改变引用计数。<br>18、使用=default生成默认构造函数</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>观察者模式：定义了对象间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><p>装饰模式：动态地将责任附加到对象上。在扩展功能上，装饰者提供了比继承更有弹性的替代方案。</p><p>工厂模式：<br>简单工厂：在实例化一个超类的时候，可以用它的所有子类来进行实例化，要根据具体的情况来决定使用哪个子类。<br>工厂模式：定义一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把类实例化推迟到子类。<br>抽象工厂模式：提供一个接口，用于创建相关对象家族，而不需要明确指定具体类。</p><p>单例模式：<br>确保一个类只有一个实例，并提供一个全局访问点。<br>使用一个私有构造器、一个私有静态变量以及一个公有静态函数来实现。</p><p>命令模式：将命令封装成对象，以便使用不同的命令来参数化其他对象。</p><p>适配器模式：将一个类的接口，转换为客户期望的另一个接口。适配器让原来不兼容的类可以合作无间。</p><p>外观模式：提供一个统一的接口，用来访问子系统中一群接口，从而让子系统更容易使用。</p><p>模板方法模式：在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。这使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p><p>迭代器模式：提供顺序访问一个聚合对象中各个元素的方法，而不暴露聚合对象内部的表示。<br>组合模式：允许将对象组合成树形结构来表现整体/部分层次结构。组合能让客户以一致的方式处理个别对象以及组合对象。</p><p>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p><p>复合模式：<br>MVC：视图使用组合模式、模型使用观察着模式，控制器使用策略模式。</p><p>主流PC机的每秒钟计算量约为10^7~10^8次，一亿次左右。</p><h1 id="3-14-2018"><a href="#3-14-2018" class="headerlink" title="3.14.2018"></a>3.14.2018</h1><p>C++11新标准补充：<br>1、可以用=delete定义删除的函数，删除的函数意思是：虽然声明了它们，但不能以任何方式使用它们。<br>2、新标准引入了移动构造函数和move的标准库函数。<br>3、引入了右值引用，右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。左值持久，右值短暂，不能将右值引用绑定到一个左值上。可以用static_cast显示的将一个左值转换为一个右值引用。<br>4.、标准库move函数来获得绑定到左值上的右值引用。<br>5、移动构造函数通常是noexcept。<br>6、虚函数的override指示符。<br>7、定义类为final来阻止继承。<br>8、引用折叠</p><h1 id="3-15、Effective-C-："><a href="#3-15、Effective-C-：" class="headerlink" title="3-15、Effective C++："></a>3-15、Effective C++：</h1><p>1、对于单纯常量，最好以const对象或enums替换#defines。对于形似函数的宏，最好改用inline函数来替换。<br>2、当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。<br>3、为内置型对象进行手工初始化，因为C++不保证初始化它们。构造函数最好使用成员初值列，而不要在构造函数体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。<br>为免除跨编译单元之初始化次序问题，请以local static对象替换non-local static对象。<br>4、编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。<br>5、带有多态性质的base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。如果不是为了作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数。<br>6、析构函数不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们或结束程序。<br>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数执行该操作。<br>7、在构造函数和析构函数中绝不要调用virtual函数。<br>8、令赋值操作符返回一个reference to *this。<br>9、确保当对象自我赋值时有良好行为，其中技术包括1比较来源对象和目标对象的地址2精心周到的语句顺序3copy and swap<br>10、copy函数应该确保复制对象内的所有成员变量以及所有base class成分。不要尝试以某个copy函数实现另一个copy函数，应该将共同机能放入第三个函数内，然后由两个copy函数分别调用它。<br>11、以对象管理资源。为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。两个常被使用RAII classes是shared_ptr和auto_ptr，前者通常是较佳选择，因为auto_ptr的copy操作会使它指向NULL。<br>12、赋值RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。<br>13、APIs往往要求访问原始资源，所以每一个RAII classes应该提供一个取得其所管理资源的方法。对原始资源的访问可能经由显式转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。<br>14、以独立语句将newed对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。<br>15、宁以pass-by-reference-to-const替换pass-by-value，但对于内置类型以及STL的迭代器和函数对象来说，pass-by-value比较好。<br>16、必须返回对象时，别妄想返回其reference。不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象。<br>17、将成员变量声明为private，这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证。protected并不比public更具封装性。<br>18、使用non-member、non-friend替换member函数。<br>19、如果一个函数的所有参数都需要类型转换，请为此采用non-member函数。<br>20、尽可能延后变量定义式的出现时间。<br>21、尽量少做转型动作，四种类型转换。<br>const_cast，转变对象的常量性，是唯一能将对象的常量性移除的C++转型操作符。<br>dynamic_cast：安全向下转型，唯一无法由旧式语法执行的动作。<br>reinterpret_cast：执行低级转型，强转。<br>static_cast:强迫隐式转换。<br>22、避免返回reference、pointer、iterator指向对象内部成分。<br>23、异常安全函数提供三个保证之一：<br>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。<br>强烈保证：如果异常被抛出、程序状态不会改变。如果函数成功，就是完全成功，如果函数失败，程序会回复到调用函数之前的状态。<br>不抛掷保证：承诺绝不抛出异常。<br>24、inline函数：会导致代码膨胀<br>inline只是一个申请，不是强制命令。<br>不能是virtual<br>通过函数指针而进行的调用可能也不会被inline<br>不要只因为function templates出现在头文件，就将他们声明为inlines。</p><h1 id="3-16、effective-C"><a href="#3-16、effective-C" class="headerlink" title="3-16、effective C++"></a>3-16、effective C++</h1><p>1、支持编译依存性最小化的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是handle classes和interface classes。程序库头文件应该以完全且仅有声明式的形式存在。这种做法不论是否涉及templates都试用。<br>2、public继承意味is-a，适用于base classes身上的每一件事情一定也适用于derived classes身上，每一个derived class对象也都是一个base class对象。<br>3、派生类内的名称会遮掩基类内的名称。在public继承下从来没有人希望如此。为了让被遮掩的名称再见天日，可使用using声明式。<br>4、接口继承与实现继承不同，在public继承下，derived classes纵使继承base classes的接口。<br>纯虚函数只具体指定接口继承。<br>非纯虚函数具体指定接口继承以及缺省的实现继承。<br>非虚函数指定接口继承和强制性实现继承。<br>5、绝不重新定义继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数是动态绑定。<br>6、复合的意义和public继承完全不同。在应用域，复合意味has-a，在实现域，复合意味着is-implemented-in-terms-of。<br>7、private继承意味is-implemented-in-terms-of，通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。<br>8、谨慎使用多重继承。如果virtual base classes不带任何数据，将是最具实用价值的情况。<br>9、TMP模板元编程是编写template-based C++程序并执行于编译期的过程，可以将工作由运行期移到编译期，因为得以实现早期错误侦测和更高的执行效率。<br>10、operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0bytes申请。operator delete应该在收到null指针时不做任何事。class专属版本还应该能够处理比正确大小更大的错误申请。<br>11、当你写一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，可能会发生隐微而时断时续的内存泄露。当你声明placement new 和placement delete，请不要无意识的遮掩他们的正常版本。</p><h1 id="3-18更新"><a href="#3-18更新" class="headerlink" title="3-18更新"></a>3-18更新</h1><p>redis<br>redis是速度非常快的非关系型内存键值数据库，可以存储五种不同类型之间的映射。<br>五种数据类型：<br>字符串string、列表list、集合set、有序集合zset、散列表hash。</p><p>键的过期时间：<br>redis可以为每个键设置过期时间，时间一到，自动删除。<br>但对于散列表，只能为整个散列表设置过期时间，而不能为键里面的单个元素设置过期时间。</p><p>redis最简单的事务实现方式是使用multi和exec命令将事务操作包裹起来。</p><p>持久化：<br>1、快照持久化<br>2、aof持久化</p><p>复制：<br>slave of host port命令来让一个服务器成为另一个服务器的从服务器<br>1、从服务器连接主服务器的过程<br>a、主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令。<br>b、从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令<br>c、主服务器每执行一次写命令，就向从服务器发送相同的写命令。<br>2、主从链<br>当负载不断增多时，可以创建中间层分担主服务器的复制工作。</p><p>分片<br>通过对数据进行分片，用户可以将数据存储到多台机器里面。<br>客户端分片：一致性hash<br>代理分片：将客户端请求发送到代理上，由代理转发<br>服务器分片：redis cluster</p><p>redis适用场景：<br>缓存、消息队列、计数器、好友关系</p><h1 id="h文件，-lib文件以及-dll文件"><a href="#h文件，-lib文件以及-dll文件" class="headerlink" title=".h文件，.lib文件以及.dll文件"></a>.h文件，.lib文件以及.dll文件</h1><p>头文件的作用是声明函数接口，用于编译阶段。<br>dll文件是函数可执行代码，用于运行阶段。<br>lib文件告诉编译器调用的函数在哪个dll文件中以及在该dll文件中哪个位置。是h和dll的桥梁。如果生成静态库文件，则没有dll，只有lib，这时函数的可执行代码也在lib中。用于链接阶段。</p><p>静态链接库和动态链接库的区别：<br>a、静态链接库就是把用到的函数代码直接链接进目标程序，程序运行的时候不再需要其他库文件。动态链接库就是把调用的函数所在文件模块和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从dll中寻找相应代码，因此需要dll的支持。<br>b、如果采用静态链接的方式，则无论你愿不愿意，lib中的指令都全部被包含在最终生成的exe文件中，所以会导致应用程序比较大。但如果使用动态链接库，该dll最终不会被包含在exe中，exe执行时动态的引用和卸载该dll文件。<br>c、静态链接库中不能再包含其他静态库或动态库，而动态链接库中可以包含其他动态或静态链接库。</p><p>dll的用法：<br>a、使用h、lib以及dll。<br>b、直接用dll，此时需要利用win32 的api函数LoadLibrary和GetProcAddress把函数指针取出来再用。</p><h1 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B-B+树"></a>B-B+树</h1><p>B-树：<br>B-树是一种平衡的多路查找树，在文件系统中很有用。<br>一棵m阶的B树，或者是一棵空树，或者是满足下列特性的m叉树：<br>1、树中每个结点至多有m棵子树<br>2、若根结点不是叶子结点，则至少有量棵子树<br>3、除根之外的所有非终端结点至少有m/2上限整数棵子树<br>4、所有非终端结点包含下列信息数据（n,A0,K1,A1,K2，A2……Kn，An）<br>5、所有的叶子结点都出现在同一层次上，并且不带信息。</p><p>B树的插入删除，看书。</p><p>B+树和B-树差异在于：<br>1、有n棵子树的结点中含有n个关键字<br>2、所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;90道&quot;&gt;&lt;a href=&quot;#90道&quot; class=&quot;headerlink&quot; title=&quot;90道&quot;&gt;&lt;/a&gt;90道&lt;/h1&gt;&lt;h2 id=&quot;1、引用和指针的区别。&quot;&gt;&lt;a href=&quot;#1、引用和指针的区别。&quot; class=&quot;headerlink&quot; title=&quot;1、引用和指针的区别。&quot;&gt;&lt;/a&gt;1、引用和指针的区别。&lt;/h2&gt;&lt;p&gt;a、定义指针时分配内存，引用不分配内存，而和原变量内存地址相同，这是最本质的区别。&lt;br&gt;b、引用必须初始化&lt;br&gt;c、没有指向空值的引用，但是存在指向空值的指针。&lt;br&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>王道程序员面试宝典笔记</title>
    <link href="http://yoursite.com/2018/05/31/%E7%8E%8B%E9%81%93%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/31/王道笔记/</id>
    <published>2018-05-30T16:08:31.000Z</published>
    <updated>2018-10-09T16:00:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、C-内置类型"><a href="#1、C-内置类型" class="headerlink" title="1、C++内置类型"></a>1、C++内置类型</h1><p>包括基本类型和复合类型。<br>基本类型包括整数和浮点数。<br>复合类型包括数组、字符串、指针、引用、结构体和共用体等。<br><a id="more"></a></p><h1 id="2、内存分区（5个）"><a href="#2、内存分区（5个）" class="headerlink" title="2、内存分区（5个）"></a>2、内存分区（5个）</h1><p>1）堆：动态内存区，由程序员手动分配和释放，不同于数据结构的堆，分配方式类似链表。由malloc或new分配，由free或delete释放，最好手动释放，如果程序员不释放且运行期间不出错，则程序结束后由系统释放。<br>2）栈：编译器自动分配和释放，存放函数的参数值、局部变量等，操作方式类似数据结构的栈。<br>3）全局静态存储区：存放全局变量和静态变量，包括DATA段和BSS段，初始化过的放在DATA中，否则放在BSS中。<br>4）文字常量区：存放常量字符串。<br>5）程序代码区：存放函数体的二进制代码。<br>详见P2</p><h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><p>1、没有引用数组，因为引用不能赋值。<br>2、C风格字符串包括两种，字符串常量（末尾自动添加空字符’\0’）和以’\0’结尾的字符数组。<br>3、C++规定，在声明和初始化一个二维数组时，如果对所有元素赋值，则可省略行数。<br>4、顺序表插入、删除和查找算法的平均时间是O（n）。<br>5、数组指针和指针数组。<br>习题14 15 16 17 18</p><h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><p>1、strcpy和memcpy的区别，前者参数是char<em>，后者是void</em>，表示后者可用于任何类型，范围比strcpy广。<br>a、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容。strcpy只用于字符串复制，并且它不仅复制字符串内容，还会复制字符串的结束符。memcpy对于需要复制的内容没有限制，因此用途更广。<br>b、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符‘\0’才结束，容易溢出。memcpy根据第三个参数决定复制的长度。<br>c、用途不同，strcpy复制字符串，其他类型一般用memcpy。<br>2、长度为M的字符串中查找长度为N的子串，最少时间复杂度O（M+N）。（利用KMP算法）<br>3、循环移位包串，第一种方法取模，第二种就是把m变成mm，再找n子串。<br>4、判断某字符串是不是包含什么字符之类的问题，可转为素数相乘。<br>5、字符串查找类题目可以联想到素数和桶排序，有时会解决问题。<br>6、memset将s中第三个参数表示的前n个字节用ch替换，作用是在一段内存块中填充某个给定的值，它是对较大结构体或数组清零的最快方法。</p><h1 id="三、结构体"><a href="#三、结构体" class="headerlink" title="三、结构体"></a>三、结构体</h1><p>1、sizeof是运算符不是函数，它的计算发生在编译时刻，所以可以被当做常量表达式使用，且会忽略括号中的各种运算，如sizeof（a++），“++”并不会执行。若对一个函数调用使用，则求到的是函数返回类型的值，不可以对函数使用，而且函数并不会被调用。<br>2、不可以用sizeof的：函数、返回void的函数调用、位域成员。<br>3、strlen不包括‘\0’，sizeof包括。<br>4、大小端对位域影响，自己的理解：<br>首先2个字节8位是一个划分单元。<br>大端下：对每个八位，按照位域成员声明顺序从左往右填入bit，不够的留到下一个八位中继续按照从左往右填。<br>小端下：对每个八位，按照位域成员声明顺序从右往左填入成员bit，以此类推。<br>（不知道对不对，总之根据题目上这么理解似乎正确。）<br>5、结构体占内存空间大小：P51.<br>6、结构体内函数和类型重定义不占字节。</p><h1 id="四、运算符及其优先级"><a href="#四、运算符及其优先级" class="headerlink" title="四、运算符及其优先级"></a>四、运算符及其优先级</h1><p>1、亦或运算可以用来找成对数组中不成对的那个数。<br>2、~运算符的优先级&gt;移位运算符优先级&gt;与或异或运算符的优先级<br>运算符优先级记忆规则：<br>a、括号、下标，-&gt;和.运算级别最高。<br>b、单目比双目高，算术双目的比其他双目的高<br>c、移位运算符高于关系运算符，关系运算符高于按位运算，按位运算高于逻辑运算。<br>d、三目的只有一个条件运算，低于逻辑运算<br>e、赋值运算符仅比逗号运算符高，且所有赋值运算符优先级相同，结合访问位从右到左。</p><h1 id="五、C预处理器、作用域、static、const以及内存管理"><a href="#五、C预处理器、作用域、static、const以及内存管理" class="headerlink" title="五、C预处理器、作用域、static、const以及内存管理"></a>五、C预处理器、作用域、static、const以及内存管理</h1><p>预处理主要有三个方面的内容：<br>a、宏定义与宏替换<br>b、文件包含<br>c、条件编译</p><p>1、宏定义和宏替换：<br>宏名一般大写，宏名和参数括号间不能有空格，末尾不加分号<br>宏替换只做替换，不做语法检查，不做计算，不做表达式求解；<br>宏替换在编译前进行，不分配内存，函数调用在编译后程序运行时进行，并且分配；<br>函数只有一个返回值，利用宏则可以设法得到多个值<br>宏替换使源程序变长，函数调用不会<br>宏替换不占运行时间，只占编译时间，函数调用占运行时间。<br>尽量少用宏，用const、enum和inline替换。</p><p>2、static的作用（不考虑类）：a隐藏，b把变量默认初始化为0，c保持局部变量内容的持久。<br>类中的作用：属于一个类但不属于此类中任何特定对象的变量和函数。<br>static数据成员必须在类定义体的外部定义。<br>static成员函数不能被声明为const、虚函数、volatile。</p><p>3、const<br>const和#define相比的好处：<br>1）const常量有数据类型，而宏常量没有数据类型，所以前者可以有类型安全检查。<br>2）使用const会产生更小的目标代码；<br>3）const还会进行常量折叠。<br>常量数据成员必须在构造函数的成员初始化列表中初始化。</p><p>c中的const意思是一个不能被改变的普通变量，纵使占用存储，不能把const视为一个编译期间的常量。</p><p>const的使用场景：<br>a常量<br>b指针和const修饰符<br>c修饰函数参数和返回值<br>d类中。const成员函数、const数据成员。</p><p>static、const以及static const成员变量初始化的不同。<br>static必须在类内声明，类外定义，定义时不能标为static。<br>const数据成员的初始化只能在类的构造函数初始值列表中进行，const数据成员只在某个对象生存期内是常量，对整个类而言却是可变的。<br>static const类内声明，类外定义，定义时加const不加static。</p><p>4、malloc/free和new/delete的异同（p104）<br>相同点：两组都是用来动态分配/释放内存的。<br>1）操作对象不同点：malloc和free是库函数，而new和delete是运算符，后者两个可以执行构造函数和析构函数。<br>operator new的执行流程：先分配足够大的原始空间，然后调用该类型的一个构造函数，最后返回指针。<br>operator delete的执行流程：先调用析构函数，再回收空间。<br>2）用法不同<br>malloc原型返回void*，所以要进行显式转换，它只关心分配的字节数，不关心类型。<br>malloc手工计算字节数，new自动分配。<br>new类型安全，而malloc不是。<br>malloc和free需要包含库文件，而new和delete不需要。</p><h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><p>1、使用无参数构造函数的时候不要加()，不然会被看做是某个函数的声明，如：<br>Foo b();<br>本意是构造Foo的一个对象b，但却被看做是一个函数声明，应改为 Foo b;</p><p>2、c++中调用被c编译过的函数，为什么要加extern “c”<br>c++是一种面向对象的编程语言，为了支持重载，编译器会对函数名字进行一些处理。而在c中编译就只是简单函数名而已，两者处理函数名的方式是不一样的。加了extern “c”就说明函数是用c编译器编译的，请用c的方式链接它们，否则链接会错。</p><h1 id="七、指针和引用"><a href="#七、指针和引用" class="headerlink" title="七、指针和引用"></a>七、指针和引用</h1><p>1、函数返回void<em>时表示返回一个特殊的指针，并不是没有返回值。<br>void</em>指针的操作：<br>和另一个指针进行比较。<br>向函数传递void<em>指针或从函数函数void</em>指针。<br>给另一个void*指针赋值。</p><p>2、具有函数类型的形参所对应的的实参将被自动转化为指向响应函数类型的指针，然而当返回类型是函数时，却不会转换成对应的指针。</p><p>3、引用和指针的区别<br>虽然引用和指针都可以间接访问另一个变量，但它们之间存在重要区别。<br>1）引用不能为空，当引用被创建时，必须被初始化，指针则可以为空。<br>2）一旦一个引用被初始化为指向某一对象，它就不能改变指向其他对象。指针可以。<br>3）没有NULL引用。<br>4）sizeof运算符对引用是求它所指对象大小，而对指针就是求指针本身大小。<br>5）给引用赋值就是修改它指向的那个对象的值，并不是改变引用所指的对象。<br>6）引用没有解引用，而指针需要解引用。<br>7）动态分配的对象或内存必须使用指针。<br>8）&amp;操作符对引用是取它所指对象的地址，而对指针就是求指针的地址。</p><p>4、引用类型类数据成员的初始化必须在初始化列表中，而且必须手动写构造函数。</p><p>5、野指针。<br>野指针是指向不可用内存的指针。<br>下列三种情况会产生野指针：<br>a当一个指针被初始化时不会自动成为NULl指针，而是一个野指针，默认值是随机的。<br>b当指针被free或delete后未把指针置为NULL，此时是野指针。<br>c指针操作超越变量作用范围时也是野指针。</p><h1 id="八、类"><a href="#八、类" class="headerlink" title="八、类"></a>八、类</h1><p>1、在c++中，成员变量的初始化顺序与变量在类中声明的顺序相同，与初始化时的顺序无关。<br>2、没有默认构造函数的类类型成员、const成员和引用成员必须在初始值列表里初始化。</p><p>3、深复制和浅复制。<br>浅复制：被复制的对象的所有变量都和原来对象的值相同，而所有的对其他对象的引用仍然指向原来的对象。浅复制仅复制对象，而不复制所引用的对象。<br>深复制：相反，深复制把所有对象以及引用的对象都复制了一遍。<br>浅复制可能导致运行时错误。</p><p>4、虚基类的构造函数最先调用。</p><p>5、复制构造函数只在对象实例化的时候才调用，没有返回值。<br>赋值运算符则在一个现存对象被赋值时调用，有返回值。</p><p>6、new operator和operator new不同。<br>可以重载的是operator new而不是new operator。<br>即不能重定义new和delete表达式的行为，可以重载的是全局函数operator new和operator delete。<br>new表达式行为中调用operator new分配空间，然后调用合适的构造函数。<br>delete表达式先析构，在调用合适的operator delete释放空间。</p><h1 id="九、面向对象编程。"><a href="#九、面向对象编程。" class="headerlink" title="九、面向对象编程。"></a>九、面向对象编程。</h1><p>1、公有继承下，派生类的对象、对象指针、对象引用可以赋值给基类的对象、对象指针、对象引用，这是隐式转化，保护继承和私有继承没有。<br>公有继承下，基类的对象指针、对象引用不可以隐式转换成派生类的指针和引用，但是可以显式转换（强制转换）过去。p157</p><p>2、类型转换函数的作用是将一个类的对象转换为另一个类型的数据。<br>转换函数必须是成员函数不能是友元，不能指定返回类型，但在函数体内必须用return以传值的方式返回一个目标类型的变量；转换函数不能有参数。<br>operator 类型(){return 类型的值；}</p><p>转换构造函数：可以用单个实参来调用的构造函数定义从形参类型到该类类型的一个隐式转换。</p><p>静态动态性包括函数重载和运算符重载，动态多态性包括虚函数。</p><p>3、非C++内建类型A和B，三种情况下B能隐式转换成A。<br>B公有继承自A<br>B中有类型转换函数转换成A<br>A实现了非explicit的参数为B的构造函数。</p><p>4、不能做虚函数的有哪些。<br>非成员函数、静态成员函数、构造函数、友元函数。<br>而内联成员函数和赋值操作符函数声明为虚函数也无意义。</p><p>5、C++对象模型p167，重要。<br>简单来说，static成员数据和函数都在全局静态区，非static数据成员才在对象内部，不是虚的成员函数也在对象外部。<br>虚函数在对象内部留一个pvtr指针，指向一个虚函数表，虚函数表里存放虚函数和type_info.</p><p>6、抽象类不可以定义对象，但可以作为指针或引用类型使用。</p><p>7、仅当类型之间存在隐式转换的时候（类间下行转换除外），static_cast才合法。<br>reinterpret_cast代替圆括号的显式转换，强制转换。<br>dynami_cast将基类指针或引用安全转换为派生类指针或引用，做两件事，检查是否可以转换，若有效才真正转换。</p><h1 id="十、分治法、动态规划与贪心算法"><a href="#十、分治法、动态规划与贪心算法" class="headerlink" title="十、分治法、动态规划与贪心算法"></a>十、分治法、动态规划与贪心算法</h1><p>p196，开学后看下算法导论对应例题。</p><h1 id="十一、"><a href="#十一、" class="headerlink" title="十一、"></a>十一、</h1><p>1、Catalan数p211<br>h(n)=h(0)<em>h(n-1)+h(1)</em>h(n-2)+…+h(n-1)*h(0)    h(0)=1</p><p>2、求二叉树中节点之间的最大距离。</p><p>3、树中路径上所有节点之和等于给定值。p223</p><p>4、红黑树是一种特殊的二叉搜索树，满足以下条件：<br>节点不是红就是黑。<br>根节点是黑。<br>如果节点是红，其子节点必须是黑。<br>任一节点至null的任何路径，所含之黑节点数必须相同。</p><p>5、判断树是不是平衡树p227</p><p>6、并查集p231</p><h1 id="第十四章、图"><a href="#第十四章、图" class="headerlink" title="第十四章、图"></a>第十四章、图</h1><h1 id="第十五章、排序"><a href="#第十五章、排序" class="headerlink" title="第十五章、排序"></a>第十五章、排序</h1><p>1、插入排序包括直接插入排序和希尔排序。<br>直接插入排序时间复杂度n2，空间复杂度1，最好情况下表中元素已经有序，此时每插入一个元素都只需要比较一次而不用移动，因为时间复杂度是n，是稳定的。<br>希尔排序的时间复杂度不确定，空间复杂度是1，不稳定。<br>2、交换排序<br>冒泡排序，时间复杂n2，空间复制1，稳定，最好情况下时间复杂n。<br>快速排序是所有内部排序中平均性能最好的算法，空间复杂度最坏n，平均logn，时间复杂度最坏n2但很少见，最好nlogn，不稳定。<br>快速排序两种划分方法p253</p><p>3、选择排序时间复杂度始终n2.<br>元素间的比较次数和原始序列无关，都是n(n-1)/2.</p><p>4、建堆的时间复杂度为n。<br>空间复杂度1，时间复杂度nlogn。</p><p>5、二路归并排序（递归分支，merge）<br>空间n，时间nlogn。</p><h1 id="第十六章：查找"><a href="#第十六章：查找" class="headerlink" title="第十六章：查找"></a>第十六章：查找</h1><p>1、后缀数组<br>2、键树又称数字查找树，用树的孩子-兄弟链表来表示键树。<br>用多重链表表示键树，则树的每个节点中包含d个指针域，此时又称Trie树<br>3、分布式存储方式<br>普通集群：把固定的key映射到固定的节点上，节点只存放各自key的数据。查找时需要遍历，查找速度慢。<br>hash集群：更迭慢，需要重新扫描计算一次所有节点。<br>一致性hash</p><p>4、处理海量数据大文件<br>分治——hash映射到不同块中，对每个块再分别处理。</p><p>最小k个数p261</p><p>布隆过滤器：<br>大小为m，样本数量为n，失误率为p<br>m=-(n<em>lnp)/(ln2)2<br>k=ln2</em>(m/n)<br>p=(1-e(-nk/m))k</p><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><p>1、ping使用ICMP协议。<br>网络层协议：IP 、IPX 、ICMP、IGMP、ARP、RARP、OSPF<br>传输层协议：TCP、UDP、SCTP<br>应用层协议：RIP、TELNET、TFP、HTTP、SNMP</p><p>TCP<br>a、TCP是一种面向连接的协议，提供客户与服务器的连接<br>b、tcp提供可靠性，当使用tcp向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，tcp自动重传数据并等待更长时间。在数次重传失败后，tcp才放弃。<br>c、tcp通过给发送数据的每一个字节关联一个序列号进行排序。udp提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。<br>d、tcp提供流量控制，而udp不提供。<br>e、tcp的连接是全双工的，udp的也可以是全双工的。</p><p>和udp的主要区别在于udp不一定提供可靠的数据传输，但是udp对系统资源要求少、实时性好、网络开销小。</p><p>2、终止tcp连接通常调用close，但是close有两个弊端，可用shutdown来避免。<br>close函数把套接字的引用计数减1，仅在计数变为0时才关闭，而使用shutdown不管计数如何会直接激发正常终止序列。<br>close同时关闭读写，但有时候需要关闭写但仍然可以读，这个时候就可以用shutdown。</p><p>3、tcp七个定时器：连接建立定时器，重传定时器，延迟定时器，持续定时器，保活定时器，FIN_WAIT2定时器，TIME_WAIT定时器</p><p>为了提高ip数据报成功交付机会，在网络层使用icmp来使得主机可以报告差错或异常情况。</p><p>4、输入url后按下回车发生什么？<br>向dns服务器查询url对应的IP地址。<br>dns返回ip地址。<br>浏览器打开tcp连接，并向web服务器发送http请求。<br>若页面发生跳转，服务器以重定向响应，然后转到5，否则直接转6.<br>浏览器跟随重定向，再次发送http请求。<br>服务器处理请求，并返回html响应。<br>浏览器接受请求的页面源码。<br>浏览器开始渲染html。<br>浏览器发送嵌入到html中的对象请求。<br>浏览器进一步发送异步请求。<br>浏览器关闭tcp连接。</p><p>ping用来检查网络是否通畅<br>tracert路由跟踪<br>telnet网络测试，如测试80端口的web服务器是否正常<br>netstat监控tcp/ip的工具</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>1、四个特征：并发、异步、共享、虚拟。<br>2、进程与线程的区别。p325<br>3、调度算法例题，p328例二。<br>4、死锁产生的必要条件：互斥、不剥夺、请求和保持、循环等待。<br>预防死锁：破坏四个条件之一<br>避免：银行家算法<br>检测及解除：剥夺资源、撤销进程、进程回退。</p><p>线程独有的：线程id、寄存器组的值、堆栈、错误返回码、信号屏蔽码、线程优先级</p><p>进程和线程的区别：<br>a、调度：引入线程后，线程是独立调度的基本单位，进程是拥有资源的基本单位拟。在同一进程中，线程的切换不会引起进程切换，不同进程中的线程切换会引起进程切换。<br>b、拥有资源：进程是拥有资源的基本单位，但是线程可以共享其隶属进程的系统资源。<br>c、并发，进程可以并发，线程也可以并发，而且线程并发性更高，提高系统吞吐量。<br>d、系统开销：创建和撤销进程时，系统都要为之分配或回收资源，因为付出的开销远远大于创建或撤销线程的开销。进程切换的开销也比线程大。另外，同一进程后的多个线程共享进程的地址空间，因此及这些线程间的同步通信比较容易实现，无需操作系统干预。<br>e、进程的地址空间相互独立，统一进程的各线程间共享进程的资源，某进程内的线程对其他进程不可见。<br>f、通信方面，进程间通信需要借助操作系统，而线程可以直接读写（全局变量）进行通信。</p><p>5、临界区是统一进程下的线程间通信机制。<br>6、默认下，Linux一个进程最多能打开1024个文件。</p><p>进程间通信：管道、共享内存、消息队列、信号量、socket。<br>线程间通信：临界区（只可以用于线程间）、互斥量、信号量、事件。</p><p>Linux常用命令：<br>1、cd变换工作目录<br>2、pwd显示目前所在目录<br>3、mkdir建立新目录 rmdir删目录<br>4、ls<br>5、cp复制文件或目录<br>6、rm删除，加参数-r表示删除目录<br>7、cat由第一行开始查看文件<br>8、tac从最后一行开始显示文件<br>9、head -n number file 只显示一开始的几行<br>10、touch常用来新建空文件<br>11、grep分析一行信息，若其中有我们所需要的信息就将该行显示出来，常用在管道中。<br>12、df列出文件系统的整体磁盘使用量<br>13、ps将某个时间点的程序运行情况显示出来<br>14、top可以持续侦测程序运作的状态，比如看内存使用率</p><h1 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h1><p>1、数据库的核心和基础是数据模型。<br>2、数据模型一般由数据结构、数据操作和完整性约束条件三部分组成。<br>3、事务的四个特征：原子性a，一致性c，隔离性i，持续性d。<br>4、设置索引是要付出代价的，一是增加了存储空间，二是插入和修改数据要花费较多的时间。<br>5、mysql为学生表学号增加降序唯一索引<br>create unique index Stusno on Student（Sno desc）<br>删除该索引<br>alter table Student drop index Stusno<br>6、索引的优缺点以及该不该建索引。p345<br>创建索引可以大大提高系统的性能。<br>第一、通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二、可以加快数据检索速度，这也是加索引的最主要原因。<br>第三：可以加速表与表之间的连接，特别是在实现数据的参照完整性方面特别有意义。<br>第四、再使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五、通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能。<br>缺点：<br>第一、创建索引和维护索引要耗费时间，而且这种时间随着数据量的增加而增加。<br>第二、索引需要占物理空间。<br>第三、当表中数据增加、删除、修改的时候，索引也要动态维护，降低了数据维护性能。</p><p>索引是建在某些列上的。<br>适合建索引的：<br>1）、在经常需要搜索的列上建索引，强制该列的唯一性和组织表中数据的排列结构。<br>2、在作为主键的列上创建索引，加快连接的速度。<br>3、在经常用到连接的列上建索引。<br>4、在经常需要根据范围进行搜索的列上创建索引。<br>5、在经常需要排序的列上创建索引。<br>6、在经常使用where子句的列上创建索引，加快条件判断。</p><p>不适合建索引的：<br>1）、在查询中很少使用到的列<br>2）、只有很少数据值的列<br>3）、定义为text和bit等数据类型的列，因为这些列的数据量要么大要么取值很少，不利于使用索引<br>4）当修改操作远远大于检索操作时，不该建索引。修改性能和检索性能是相互对立矛盾的。</p><p>7、存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。<br>8、%表示任意长度的通配符，_表示一个长度的通配符<br>9、LIMIT两种参数使用，limit n等同于limit 0 n。输出从0开始，到n之前的n行数据。</p><h1 id="设计模式："><a href="#设计模式：" class="headerlink" title="设计模式："></a>设计模式：</h1><p>1、面向对象最基本的五个设计原则：单一职责原则，开放封闭原则，依赖倒置原则，接口隔离原则和Liskov替换原则。</p><h1 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h1><p>1、N条直线有M个交点，则平面被划分成N+M+1个区域。</p><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h1><p>1、简述Java和C++的不同。<br>java运行在虚拟机上<br>c++支持无符号运算和指针，java不支持。<br>java中参数传递总是值传递（参数是对象时传递的是对象的引用），在c++中，参数传递有值传递、引用传递、指针传递。<br>java有垃圾回收，c++没有。<br>c++允许运算符重载，java不允许。<br>c++允许多继承，java只允许单继承。</p><p>2、常见的度量软件可靠性的指标。<br>MTTF平均失效前时间<br>MTBF平均无故障时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、C-内置类型&quot;&gt;&lt;a href=&quot;#1、C-内置类型&quot; class=&quot;headerlink&quot; title=&quot;1、C++内置类型&quot;&gt;&lt;/a&gt;1、C++内置类型&lt;/h1&gt;&lt;p&gt;包括基本类型和复合类型。&lt;br&gt;基本类型包括整数和浮点数。&lt;br&gt;复合类型包括数组、字符串、指针、引用、结构体和共用体等。&lt;br&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer+常用手写算法(C++)</title>
    <link href="http://yoursite.com/2018/05/28/%E5%89%91%E6%8C%87offer+%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/28/剑指offer+常见算法/</id>
    <published>2018-05-28T13:57:02.000Z</published>
    <updated>2018-10-09T16:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、编写赋值运算符"><a href="#1、编写赋值运算符" class="headerlink" title="1、编写赋值运算符"></a>1、编写赋值运算符</h1><p>四点：返回值、参数类型、释放已有内存、自身赋值特殊情况。<br>进阶：异常安全性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">CMyString temp(rhs);<span class="comment">//调用copy构造函数</span></span><br><span class="line"><span class="keyword">char</span>* ptemp=temp.m_pData;</span><br><span class="line">temp.m_pData=m_pData;</span><br><span class="line">m_pData=ptemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="2、简单实现一个Singleton类。"><a href="#2、简单实现一个Singleton类。" class="headerlink" title="2、简单实现一个Singleton类。"></a>2、简单实现一个Singleton类。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">initance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> singleton::mutex;</span><br><span class="line">singleton* singleton::initance()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">static</span> singleton obj;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleton()&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">static</span> object obj=<span class="keyword">new</span> object();<span class="comment">//一个互斥锁</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> Singleton&amp; GetInstance&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">lock(obj)&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="literal">NULL</span>)</span><br><span class="line">instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3、找出数组中重复的数字。"><a href="#3、找出数组中重复的数字。" class="headerlink" title="3、找出数组中重复的数字。"></a>3、找出数组中重复的数字。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">question3_3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (vec.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line"><span class="keyword">if</span> (vec[i]&lt;<span class="number">0</span> || vec[i]&gt;vec.size() - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (vec[i] != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vec[i] == vec[vec[i]])</span><br><span class="line"><span class="keyword">return</span> vec[i];</span><br><span class="line"><span class="keyword">int</span> temp = vec[i];</span><br><span class="line">vec[i] = vec[temp];</span><br><span class="line">vec[temp] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers.empty())</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line"><span class="keyword">if</span> (numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)</span><br><span class="line">++count;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">question3_02</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( numbers.size() &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> end = numbers.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> middle = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line"><span class="keyword">int</span> count = countRange(numbers, numbers.size(), start, middle);</span><br><span class="line"><span class="keyword">if</span> (end == start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; (middle - start + <span class="number">1</span>))</span><br><span class="line">end = middle;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">start = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、二维数组中的查找"><a href="#4、二维数组中的查找" class="headerlink" title="4、二维数组中的查找"></a>4、二维数组中的查找</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> m=<span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>&amp;&amp;<span class="built_in">array</span>[n<span class="number">-1</span>][m<span class="number">-1</span>]&lt;target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=m<span class="number">-1</span>;i&lt;n&amp;&amp;j&gt;=<span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j]&lt;target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、替换空格"><a href="#5、替换空格" class="headerlink" title="5、替换空格"></a>5、替换空格</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> spaceCnt=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">           <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">               spaceCnt++;</span><br><span class="line">       <span class="keyword">int</span> newLength=length+<span class="number">2</span>*spaceCnt;</span><br><span class="line">       str[newLength]=<span class="string">'\0'</span>;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">       newLength--;</span><br><span class="line">       <span class="keyword">for</span>(i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               str[newLength--]=<span class="string">'0'</span>;</span><br><span class="line">               str[newLength--]=<span class="string">'2'</span>;</span><br><span class="line">               str[newLength--]=<span class="string">'%'</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               str[newLength--]=str[i];</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、从尾到头打印链表。"><a href="#6、从尾到头打印链表。" class="headerlink" title="6、从尾到头打印链表。"></a>6、从尾到头打印链表。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursion</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next)</span><br><span class="line">            Recursion(head-&gt;next,res);</span><br><span class="line">        res.push_back(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Recursion(head,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表："><a href="#反转链表：" class="headerlink" title="反转链表："></a>反转链表：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* pre=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="树的四种遍历七种写法："><a href="#树的四种遍历七种写法：" class="headerlink" title="树的四种遍历七种写法："></a>树的四种遍历七种写法：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTra_Loop</span><span class="params">(TreeNode * root)</span><span class="comment">//先序循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"><span class="keyword">while</span> (cur || !sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur)<span class="comment">//找到最左</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">sta.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sta.empty())<span class="comment">//弹出栈顶元素并将选择其右子树再次遍历</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode* temp=sta.top();</span><br><span class="line">sta.pop();</span><br><span class="line">cur = temp-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTra_Recur</span><span class="params">(TreeNode * root)</span><span class="comment">//先序递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">PreorderTra_Recur(root-&gt;left);</span><br><span class="line">PreorderTra_Recur(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidorderTra_Loop</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur || !sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* temp = sta.top();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; temp-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">sta.pop();</span><br><span class="line">cur = temp-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidorderTra_Recur</span><span class="params">(TreeNode * root)</span><span class="comment">//中序递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">MidorderTra_Recur(root-&gt;left);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">MidorderTra_Recur(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序循环需要检查一个节点是否是第一次位于栈顶，若是第一次则引入它的右孩子，否则弹出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTra_Loop</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">TreeNode* cur = root;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">while</span> (cur || !sta.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* temp = sta.top();</span><br><span class="line"><span class="keyword">if</span> (m[temp] == <span class="number">0</span>)<span class="comment">//第一次</span></span><br><span class="line">&#123;</span><br><span class="line">cur = temp-&gt;right;</span><br><span class="line">m[temp]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; temp-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">sta.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTra_Recur</span><span class="params">(TreeNode * root)</span><span class="comment">//后序递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">PostorderTra_Recur(root-&gt;left);</span><br><span class="line">PostorderTra_Recur(root-&gt;right);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelTra</span><span class="params">(TreeNode * root)</span><span class="comment">//层次遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">TreeNode* node = root;</span><br><span class="line">q.push(node);</span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* front = q.front();</span><br><span class="line"><span class="keyword">if</span> (front-&gt;left)</span><br><span class="line">q.push(front-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (front-&gt;right)</span><br><span class="line">q.push(front-&gt;right);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; front-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、重建二叉树。"><a href="#7、重建二叉树。" class="headerlink" title="7、重建二叉树。"></a>7、重建二叉树。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">recursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre,<span class="keyword">const</span> <span class="keyword">int</span> preStart,<span class="keyword">const</span> <span class="keyword">int</span> preEnd,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vin,<span class="keyword">const</span> <span class="keyword">int</span> vinStart,<span class="keyword">const</span> <span class="keyword">int</span> vinEnd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart&gt;preEnd||vinStart&gt;vinEnd)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* node=<span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=vinStart;i&lt;=vinEnd;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i]==pre[preStart])</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;left=recursion(pre,preStart+<span class="number">1</span>,i-vinStart+preStart,vin,vinStart,vinEnd<span class="number">-1</span>);</span><br><span class="line">                node-&gt;right=recursion(pre,i-vinStart+preStart+<span class="number">1</span>,preEnd,vin,i+<span class="number">1</span>,vinEnd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=recursion(pre,<span class="number">0</span>,pre.size()<span class="number">-1</span>,vin,<span class="number">0</span>,vin.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="8、二叉树的下一节点"><a href="#8、二叉树的下一节点" class="headerlink" title="8、二叉树的下一节点"></a>8、二叉树的下一节点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pRight = pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span>(pRight-&gt;m_pLeft != <span class="literal">nullptr</span>)</span><br><span class="line">            pRight = pRight-&gt;m_pLeft;</span><br><span class="line"></span><br><span class="line">        pNext = pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;m_pParent != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        <span class="keyword">while</span>(pParent != <span class="literal">nullptr</span> &amp;&amp; pCurrent == pParent-&gt;m_pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9、用两个栈实现队列"><a href="#9、用两个栈实现队列" class="headerlink" title="9、用两个栈实现队列"></a>9、用两个栈实现队列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            res=stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            res=stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="10、斐波那契数列。"><a href="#10、斐波那契数列。" class="headerlink" title="10、斐波那契数列。"></a>10、斐波那契数列。</h1><p>最容易想到的是递归，但是递归效率低下，栈可能溢出，在面试中最好使用从下往上的循环而不用递归。<br>利用从下往上循环的DP解法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="快排："><a href="#快排：" class="headerlink" title="快排："></a>快排：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data.empty()  || start&lt;<span class="number">0</span> || end&gt;data.size() - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid Parameters"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = (<span class="keyword">int</span>)(rand() % (end - start + <span class="number">1</span>)) + start;</span><br><span class="line">swap(data[index], data[start]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pivot = data[start];</span><br><span class="line"><span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end&amp;&amp;data[end] &gt;= pivot)</span><br><span class="line">end--;</span><br><span class="line">data[start] = data[end];</span><br><span class="line"><span class="keyword">while</span> (start &lt; end&amp;&amp;data[start] &lt;= pivot)</span><br><span class="line">start++;</span><br><span class="line">data[end] = data[start];</span><br><span class="line">&#125;</span><br><span class="line">data[start] = pivot;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition_2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span><span class="comment">//这种划分方法可保证小于的部分相对位置不变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = data[end];</span><br><span class="line"><span class="keyword">int</span> i = start - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt;= end - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (data[j] &lt;= x)</span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">swap(data[i], data[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(data[i + <span class="number">1</span>], data[end]);</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> index = Partition(data, start, end);</span><br><span class="line"><span class="keyword">if</span> (index&gt;start)</span><br><span class="line">QuickSort(data, start, index - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (index &lt; end)</span><br><span class="line">QuickSort(data, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11、旋转数组的最小数字"><a href="#11、旋转数组的最小数字" class="headerlink" title="11、旋转数组的最小数字"></a>11、旋转数组的最小数字</h1><p>最好利用二分查找，时间效率快。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; rotateArray,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> small=rotateArray[left];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[i]&lt;small)</span><br><span class="line">                small=rotateArray[i];</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=rotateArray.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[left]&gt;=rotateArray[right])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid=right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果left、right、mid指向的三个数字相同，则只能进行顺序查找</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[left]==rotateArray[right]&amp;&amp;rotateArray[right]==rotateArray[mid])</span><br><span class="line">                <span class="keyword">return</span> MinInOrder(rotateArray,left,right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(rotateArray[left]&lt;=rotateArray[mid])</span><br><span class="line">                left=mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[right]&gt;=rotateArray[mid])</span><br><span class="line">                right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="12、矩阵中的路径（回溯法）"><a href="#12、矩阵中的路径（回溯法）" class="headerlink" title="12、矩阵中的路径（回溯法）"></a>12、矩阵中的路径（回溯法）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; ++col)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str,</span><br><span class="line">                pathLength, visited))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[pathLength] == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; matrix[row * cols + col] == str[pathLength]</span><br><span class="line">        &amp;&amp; !visited[row * cols + col])</span><br><span class="line">    &#123;</span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        hasPath = hasPathCore(matrix, rows, cols, row, col - <span class="number">1</span>,</span><br><span class="line">            str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row - <span class="number">1</span>, col,</span><br><span class="line">                str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row, col + <span class="number">1</span>,</span><br><span class="line">                str, pathLength, visited)</span><br><span class="line">            || hasPathCore(matrix, rows, cols, row + <span class="number">1</span>, col,</span><br><span class="line">                str, pathLength, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasPath)</span><br><span class="line">        &#123;</span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13、机器人的运动范围"><a href="#13、机器人的运动范围" class="headerlink" title="13、机器人的运动范围"></a>13、机器人的运动范围</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(threshold&lt;<span class="number">0</span>||rows&lt;=<span class="number">0</span>||cols&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        backTracking(rows,cols,<span class="number">0</span>,<span class="number">0</span>,threshold,cnt,visited);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">const</span> <span class="keyword">int</span>&amp; threshold,<span class="keyword">int</span>&amp; cnt,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((digitSum(i)+digitSum(j))&gt;threshold)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;i&lt;rows&amp;&amp;j&gt;=<span class="number">0</span>&amp;&amp;j&lt;cols&amp;&amp;visited[i][j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i][j]=<span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            backTracking(rows,cols,i<span class="number">-1</span>,j,threshold,cnt,visited);</span><br><span class="line">            backTracking(rows,cols,i,j<span class="number">-1</span>,threshold,cnt,visited);</span><br><span class="line">            backTracking(rows,cols,i+<span class="number">1</span>,j,threshold,cnt,visited);</span><br><span class="line">            backTracking(rows,cols,i,j+<span class="number">1</span>,threshold,cnt,visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=i%<span class="number">10</span>;</span><br><span class="line">            i/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="14、剪绳子"><a href="#14、剪绳子" class="headerlink" title="14、剪绳子"></a>14、剪绳子</h1><p>动态规划和贪婪法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规动态规划方法,要求至少剪一刀</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(length+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; length+<span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur = dp[i - j] * dp[j];</span><br><span class="line"><span class="keyword">if</span> (cur &gt; max)</span><br><span class="line">max = cur;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[length];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪婪法：需要想到数学证明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> timeOf3 = length / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (length % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">timeOf3--;</span><br><span class="line"><span class="keyword">int</span> timeOf2 = (length - <span class="number">3</span> * timeOf3) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, timeOf3))*(<span class="built_in">pow</span>(<span class="number">2</span>, timeOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="15、判断二进制数中1-的个数"><a href="#15、判断二进制数中1-的个数" class="headerlink" title="15、判断二进制数中1 的个数"></a>15、判断二进制数中1 的个数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             n=n&amp;(n<span class="number">-1</span>);</span><br><span class="line">             cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> cnt;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="16、数值的整数次方"><a href="#16、数值的整数次方" class="headerlink" title="16、数值的整数次方"></a>16、数值的整数次方</h1><p>注意：本例虽然过了，但是double 型数值的比较建议使用范围比较<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">PowerWithAbsexponent</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        <span class="keyword">double</span> result=PowerWithAbsexponent(base,exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        result*=result;</span><br><span class="line">        <span class="keyword">if</span>((exponent&amp;<span class="number">0x1</span>)==<span class="number">1</span>)</span><br><span class="line">            result*=base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">0.0</span>&amp;&amp;exponent&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            InvalidInput=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> absExponent=(exponent&gt;<span class="number">0</span>)?exponent:(<span class="number">0</span>-exponent);</span><br><span class="line">        <span class="keyword">double</span> result=PowerWithAbsexponent(base,absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">            result=<span class="number">1</span>/result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> InvalidInput=<span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="17、打印从1到最大的n位数"><a href="#17、打印从1到最大的n位数" class="headerlink" title="17、打印从1到最大的n位数"></a>17、打印从1到最大的n位数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18"><a href="#18" class="headerlink" title="18"></a>18</h1><h2 id="18-1、删除链表结点"><a href="#18-1、删除链表结点" class="headerlink" title="18-1、删除链表结点"></a>18-1、删除链表结点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">        *pListHead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;            </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        pNode-&gt;m_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-2-删除链表中重复结点"><a href="#18-2-删除链表中重复结点" class="headerlink" title="18-2 删除链表中重复结点"></a>18-2 删除链表中重复结点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur=pHead;</span><br><span class="line">        ListNode* pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next=pHead;</span><br><span class="line">        ListNode* next=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* p=pre;</span><br><span class="line">        <span class="keyword">bool</span> duplicationFlag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            duplicationFlag=<span class="literal">false</span>;</span><br><span class="line">            next=cur-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(next&amp;&amp;next-&gt;val==cur-&gt;val)<span class="comment">//next存在且和cur重复，就把next往前移</span></span><br><span class="line">            &#123;</span><br><span class="line">                next=next-&gt;next;</span><br><span class="line">                duplicationFlag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!next)<span class="comment">//next结束了，说明cur后面所有结点值都和cur相同</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (duplicationFlag)</span><br><span class="line">pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(duplicationFlag)</span><br><span class="line">                    pre-&gt;next=next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pre=cur;</span><br><span class="line">                cur=next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="19、正则表达式匹配"><a href="#19、正则表达式匹配" class="headerlink" title="19、正则表达式匹配"></a>19、正则表达式匹配</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pattern == *str || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">            <span class="comment">// 进入有限状态机的下一个状态</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>)</span><br><span class="line">            <span class="comment">// 继续留在有限状态机的当前状态 </span></span><br><span class="line">            || matchCore(str + <span class="number">1</span>, pattern)</span><br><span class="line">            <span class="comment">// 略过一个'*' </span></span><br><span class="line">            || matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 略过一个'*'</span></span><br><span class="line">            <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">        <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="20、表示数值的字符串"><a href="#20、表示数值的字符串" class="headerlink" title="20、表示数值的字符串"></a>20、表示数值的字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> numeric = scanInteger(&amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果出现'.'，接下来是数字的小数部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'.'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面一行代码用||的原因：</span></span><br><span class="line">        <span class="comment">// 1. 小数可以没有整数部分，例如.123等于0.123；</span></span><br><span class="line">        <span class="comment">// 2. 小数点后面可以没有数字，例如233.等于233.0；</span></span><br><span class="line">        <span class="comment">// 3. 当然小数点前面和后面可以有数字，例如233.666</span></span><br><span class="line">        numeric = scanUnsignedInteger(&amp;str) || numeric;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果出现'e'或者'E'，接下来跟着的是数字的指数部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面一行代码用&amp;&amp;的原因：</span></span><br><span class="line">        <span class="comment">// 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；</span></span><br><span class="line">        <span class="comment">// 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4</span></span><br><span class="line">        numeric = numeric &amp;&amp; scanInteger(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numeric &amp;&amp; *str == <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* before = *str;</span><br><span class="line">    <span class="keyword">while</span>(**str != <span class="string">'\0'</span> &amp;&amp; **str &gt;= <span class="string">'0'</span> &amp;&amp; **str &lt;= <span class="string">'9'</span>)</span><br><span class="line">        ++(*str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当str中存在若干0-9的数字时，返回true</span></span><br><span class="line">    <span class="keyword">return</span> *str &gt; before;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数的格式可以用[+|-]B表示, 其中B为无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(**str == <span class="string">'+'</span> || **str == <span class="string">'-'</span>)</span><br><span class="line">        ++(*str);</span><br><span class="line">    <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="21、调整数组顺序使奇数位于偶数前面"><a href="#21、调整数组顺序使奇数位于偶数前面" class="headerlink" title="21、调整数组顺序使奇数位于偶数前面"></a>21、调整数组顺序使奇数位于偶数前面</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">array</span>[i] &amp; <span class="number">0x1</span>) == <span class="number">1</span>)</span><br><span class="line">                res.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">array</span>[i] &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">                res.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span> = res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="23、找链表环的入口。"><a href="#23、找链表环的入口。" class="headerlink" title="23、找链表环的入口。"></a>23、找链表环的入口。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow=pHead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast=slow-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast)</span><br><span class="line">                fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fast)<span class="comment">//没有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow=pHead;<span class="comment">//slow回到原点</span></span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="24、反转链表"><a href="#24、反转链表" class="headerlink" title="24、反转链表"></a>24、反转链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pre,*cur,*next;</span><br><span class="line">        pre=<span class="literal">NULL</span>;</span><br><span class="line">        cur=pHead;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">递归：</span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead||!pHead-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* next=pHead-&gt;next;</span><br><span class="line">        pHead-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode* re=ReverseList(next);</span><br><span class="line">        next-&gt;next=pHead;</span><br><span class="line">        <span class="keyword">return</span> re; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="25、合并两个有序链表"><a href="#25、合并两个有序链表" class="headerlink" title="25、合并两个有序链表"></a>25、合并两个有序链表</h1><p>递归：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1&amp;&amp;!pHead2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(!pHead2)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        </span><br><span class="line">        ListNode* node=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val&lt;pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            node=pHead1;</span><br><span class="line">            node-&gt;next=Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node=pHead2;</span><br><span class="line">            node-&gt;next=Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="26、树的子结构"><a href="#26、树的子结构" class="headerlink" title="26、树的子结构"></a>26、树的子结构</h1><p>递归<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasOrNo</span><span class="params">(TreeNode* r1, TreeNode* r2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!r1&amp;&amp;r2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!r2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1-&gt;val!=r2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> HasOrNo(r1-&gt;left,r2-&gt;left)&amp;&amp;HasOrNo(r1-&gt;right,r2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val==pRoot2-&gt;val)</span><br><span class="line">            flag=HasOrNo(pRoot1,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            flag=HasOrNo(pRoot1-&gt;left,pRoot2);</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            flag=HasOrNo(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="27、二叉树的镜像"><a href="#27、二叉树的镜像" class="headerlink" title="27、二叉树的镜像"></a>27、二叉树的镜像</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* left=pRoot-&gt;left;</span><br><span class="line">        TreeNode* right=pRoot-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(left)<span class="comment">//has left subtree</span></span><br><span class="line">        &#123;</span><br><span class="line">            pRoot-&gt;right=left;</span><br><span class="line">            <span class="keyword">if</span>(!right)</span><br><span class="line">                pRoot-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right)</span><br><span class="line">        &#123;</span><br><span class="line">            pRoot-&gt;left=right;</span><br><span class="line">            <span class="keyword">if</span>(!left)</span><br><span class="line">                pRoot-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Mirror(pRoot-&gt;left);</span><br><span class="line">        Mirror(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//非递归：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* temp=st.top();</span><br><span class="line">            TreeNode* t=temp-&gt;left;</span><br><span class="line">            temp-&gt;left=temp-&gt;right;</span><br><span class="line">            temp-&gt;right=t;</span><br><span class="line">            </span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                st.push(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                st.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="28、对称的二叉树"><a href="#28、对称的二叉树" class="headerlink" title="28、对称的二叉树"></a>28、对称的二叉树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool isSymmetrical(TreeNode* left,TreeNode* right)；</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot-&gt;left,pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* left,TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left&amp;&amp;!right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!left||!right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val!=right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(left-&gt;right,right-&gt;left)</span><br><span class="line">             &amp;&amp;isSymmetrical(left-&gt;left,right-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="29、顺时针打印矩阵"><a href="#29、顺时针打印矩阵" class="headerlink" title="29、顺时针打印矩阵"></a>29、顺时针打印矩阵</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatrixInCircle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix,<span class="keyword">const</span> <span class="keyword">int</span> start,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endX=matrix[<span class="number">0</span>].size()<span class="number">-1</span>-start;</span><br><span class="line">        <span class="keyword">int</span> endY=matrix.size()<span class="number">-1</span>-start;</span><br><span class="line">        <span class="comment">//从左往右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=endX;i++)</span><br><span class="line">            res.push_back(matrix[start][i]);</span><br><span class="line">        <span class="comment">//从上往下，至少有两行的时候才需要</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endY)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=endY;i++)</span><br><span class="line">                res.push_back(matrix[i][endX]);</span><br><span class="line">        <span class="comment">//从右往左，至少两行两列才需要</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endX&amp;&amp;start&lt;endY)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=endX<span class="number">-1</span>;i&gt;=start;i--)</span><br><span class="line">                res.push_back(matrix[endY][i]);</span><br><span class="line">        <span class="comment">//从下往上，至少三行两列才需要</span></span><br><span class="line">        <span class="keyword">if</span>(start&lt;endX&amp;&amp;start&lt;endY<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=endY<span class="number">-1</span>;i&gt;=start+<span class="number">1</span>;i--)</span><br><span class="line">                res.push_back(matrix[i][start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>||matrix[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(matrix.size()&gt;start*<span class="number">2</span>&amp;&amp;matrix[<span class="number">0</span>].size()&gt;start*<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintMatrixInCircle(matrix,start,res);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="30、包含min的栈"><a href="#30、包含min的栈" class="headerlink" title="30、包含min的栈"></a>30、包含min的栈</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">        <span class="keyword">if</span>(m.empty())</span><br><span class="line">            m.push(value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(value&lt;=m.top())</span><br><span class="line">                m.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value=data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">        <span class="keyword">if</span>(value==m.top())</span><br><span class="line">            m.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="31、栈的压入弹出序列"><a href="#31、栈的压入弹出序列" class="headerlink" title="31、栈的压入弹出序列"></a>31、栈的压入弹出序列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.empty()||popV.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">        data.push(pushV[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;<span class="comment">//i指向pushV下标，j指向popV下标</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;popV.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data.top()==popV[j])<span class="comment">//弹出数字刚好是栈顶元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                data.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">bool</span> findFlag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(;i&lt;pushV.size();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    data.push(pushV[i]);</span><br><span class="line">                    <span class="keyword">if</span>(pushV[i]==popV[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        findFlag=<span class="literal">true</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!findFlag)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="32、从上到下打印二叉树（即层次遍历，具体代码看上面树的遍历代码）"><a href="#32、从上到下打印二叉树（即层次遍历，具体代码看上面树的遍历代码）" class="headerlink" title="32、从上到下打印二叉树（即层次遍历，具体代码看上面树的遍历代码）"></a>32、从上到下打印二叉树（即层次遍历，具体代码看上面树的遍历代码）</h1><p>题目扩展：每一层结点占一行，换行打印<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">            <span class="keyword">if</span>(!pRoot)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">            TreeNode* lineLast;</span><br><span class="line">            TreeNode* nextLineLast;</span><br><span class="line">            lineLast=nextLineLast=pRoot;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">            q.push(pRoot);</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* f=q.front();</span><br><span class="line">                line.push_back(f-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(f-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(f-&gt;left);</span><br><span class="line">                    nextLineLast=f-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(f-&gt;right);</span><br><span class="line">                    nextLineLast=f-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f==lineLast)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.push_back(line);</span><br><span class="line">                    line.clear();</span><br><span class="line">                    lineLast=nextLineLast;</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">扩展二：之字形打印</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"><span class="keyword">if</span> (!pRoot)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;TreeNode*&gt;&gt; stacks(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> stacksIndex = <span class="number">0</span>;<span class="comment">//stacks[0]从左到右</span></span><br><span class="line"></span><br><span class="line">stacks[<span class="number">0</span>].push(pRoot);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line"><span class="keyword">while</span> (!stacks[<span class="number">0</span>].empty() || !stacks[<span class="number">1</span>].empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* f = stacks[stacksIndex].top();</span><br><span class="line">stacks[stacksIndex].pop();</span><br><span class="line">line.push_back(f-&gt;val);</span><br><span class="line"><span class="keyword">if</span> (stacksIndex == <span class="number">0</span>)<span class="comment">//下一层从右往左</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;right)</span><br><span class="line">stacks[<span class="number">1</span>].push(f-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;left)</span><br><span class="line">stacks[<span class="number">1</span>].push(f-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;left)</span><br><span class="line">stacks[<span class="number">0</span>].push(f-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;right)</span><br><span class="line">stacks[<span class="number">0</span>].push(f-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stacks[stacksIndex].empty())&#123;</span><br><span class="line">reverse(line.begin(), line.end());</span><br><span class="line">res.push_back(line);</span><br><span class="line">line.clear();</span><br><span class="line">stacksIndex = <span class="number">1</span> - stacksIndex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   ``` </span><br><span class="line"># <span class="number">33</span>、二叉搜索树的后序遍历序列</span><br><span class="line">```C++</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> root=sequence[sequence.size()<span class="number">-1</span>];<span class="comment">//后序遍历中根节点是最后一个</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;sequence.size()<span class="number">-1</span>;i++)<span class="comment">//找左子树</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;root)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;sequence.size()<span class="number">-1</span>;j++)<span class="comment">//找右子树</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;root)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//右子树中如果有比根节点值小的，则返回false</span></span><br><span class="line">        <span class="keyword">bool</span> left=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; le(sequence.begin(),sequence.begin()+i);</span><br><span class="line">            left=VerifySquenceOfBST(le);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> right=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;sequence.size()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ri(sequence.begin()+i,sequence.end()<span class="number">-1</span>);</span><br><span class="line">            right=VerifySquenceOfBST(ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="34、二叉树中和为某一值的路径"><a href="#34、二叉树中和为某一值的路径" class="headerlink" title="34、二叉树中和为某一值的路径"></a>34、二叉树中和为某一值的路径</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(TreeNode* root,<span class="keyword">int</span> expectNum,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>((!root-&gt;left)&amp;&amp;(!root-&gt;right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(accumulate(path.begin(),path.end(),<span class="number">0</span>)==expectNum)</span><br><span class="line">                res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            backTracking(root-&gt;left,expectNum,res,path);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            backTracking(root-&gt;right,expectNum,res,path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        backTracking(root,expectNumber,res,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="35、复杂链表的复制"><a href="#35、复杂链表的复制" class="headerlink" title="35、复杂链表的复制"></a>35、复杂链表的复制</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1克隆节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* cloneNode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(cloneNode)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* cc=<span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">            cc-&gt;label=cloneNode-&gt;label;</span><br><span class="line">            cc-&gt;next=cloneNode-&gt;next;</span><br><span class="line">            cc-&gt;random=<span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">            cloneNode-&gt;next=cc;</span><br><span class="line">            cloneNode=cc-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2为每个新节点赋值random</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConnectRandomNode</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* p=pHead;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            RandomListNode* pp=p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;random)</span><br><span class="line">                pp-&gt;random=p-&gt;random-&gt;next;</span><br><span class="line">            p=pp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3将原链表拆成两个相同链表</span></span><br><span class="line">    <span class="function">RandomListNode* <span class="title">ReconnectNode</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RandomListNode* p=pHead;</span><br><span class="line">        RandomListNode *cloneHead=<span class="literal">NULL</span>,*cloneNode=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cloneHead=p-&gt;next;</span><br><span class="line">            cloneNode=p-&gt;next;</span><br><span class="line">            p-&gt;next=cloneNode-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cloneNode-&gt;next=p-&gt;next;</span><br><span class="line">            cloneNode=cloneNode-&gt;next;</span><br><span class="line">            p-&gt;next=cloneNode-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CloneNodes(pHead);</span><br><span class="line">        ConnectRandomNode(pHead);</span><br><span class="line">        <span class="keyword">return</span> ReconnectNode(pHead);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="36、二叉搜索树与双向链表"><a href="#36、二叉搜索树与双向链表" class="headerlink" title="36、二叉搜索树与双向链表"></a>36、二叉搜索树与双向链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* root,TreeNode *&amp;node)</span><span class="comment">//指针的引用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* cur=root;</span><br><span class="line">            InOrder(root-&gt;left,node);</span><br><span class="line">            cur-&gt;left=node;</span><br><span class="line">            <span class="keyword">if</span>(node)</span><br><span class="line">                node-&gt;right=cur;</span><br><span class="line">            node=cur;</span><br><span class="line">            InOrder(root-&gt;right,node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRootOfTree)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* node=<span class="literal">NULL</span>;</span><br><span class="line">        InOrder(pRootOfTree,node);</span><br><span class="line">        <span class="keyword">while</span>(node&amp;&amp;node-&gt;left)</span><br><span class="line">            node=node-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="37、序列化二叉树"><a href="#37、序列化二叉树" class="headerlink" title="37、序列化二叉树"></a>37、序列化二叉树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//牛客</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#,"</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        str=to_string(root-&gt;val);</span><br><span class="line">        str+=<span class="string">","</span>;</span><br><span class="line">        <span class="keyword">char</span>* left=Serialize(root-&gt;left);</span><br><span class="line">        <span class="keyword">char</span>* right=Serialize(root-&gt;right);</span><br><span class="line">        <span class="keyword">char</span>* res=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(left)+<span class="built_in">strlen</span>(right)+str.size()];</span><br><span class="line">        <span class="built_in">strcpy</span>(res,str.c_str());</span><br><span class="line">        <span class="built_in">strcat</span>(res,left);</span><br><span class="line">        <span class="built_in">strcat</span>(res,right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decode(str);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">decode</span><span class="params">(<span class="keyword">char</span> *&amp;str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str==<span class="string">'#'</span>)&#123;</span><br><span class="line">            str+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*str != <span class="string">','</span>)</span><br><span class="line">            num = num*<span class="number">10</span> + (*(str++)-<span class="string">'0'</span>);</span><br><span class="line">        str++;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">        root-&gt;left = decode(str);</span><br><span class="line">        root-&gt;right = decode(str);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//书上</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serialize</span><span class="params">(<span class="keyword">const</span> BinaryTreeNode* pRoot, ostream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stream &lt;&lt; <span class="string">"$,"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stream &lt;&lt; pRoot-&gt;m_nValue &lt;&lt; <span class="string">','</span>;</span><br><span class="line">    Serialize(pRoot-&gt;m_pLeft, stream);</span><br><span class="line">    Serialize(pRoot-&gt;m_pRight, stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReadStream</span><span class="params">(istream&amp; stream, <span class="keyword">int</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream.eof())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    stream &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stream.eof() &amp;&amp; ch != <span class="string">','</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buffer[i++] = ch;</span><br><span class="line">        stream &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isNumeric = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; buffer[<span class="number">0</span>] != <span class="string">'$'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *number = atoi(buffer);</span><br><span class="line">        isNumeric = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isNumeric;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deserialize</span><span class="params">(BinaryTreeNode** pRoot, istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(ReadStream(stream, &amp;number))</span><br><span class="line">    &#123;</span><br><span class="line">        *pRoot = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">        (*pRoot)-&gt;m_nValue = number;</span><br><span class="line">        (*pRoot)-&gt;m_pLeft = <span class="literal">nullptr</span>;</span><br><span class="line">        (*pRoot)-&gt;m_pRight = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        Deserialize(&amp;((*pRoot)-&gt;m_pLeft), stream);</span><br><span class="line">        Deserialize(&amp;((*pRoot)-&gt;m_pRight), stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="38、字符串的排列"><a href="#38、字符串的排列" class="headerlink" title="38、字符串的排列"></a>38、字符串的排列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursive</span><span class="params">(<span class="keyword">int</span> index,<span class="built_in">string</span>&amp; str,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=str.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(res.begin(),res.end(),str)==res.end())</span><br><span class="line">                res.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(str[index],str[i]);</span><br><span class="line">            Recursive(index+<span class="number">1</span>,str,res);</span><br><span class="line">            swap(str[index],str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Recursive(<span class="number">0</span>,str,res);</span><br><span class="line">        sort(res.begin(),res.end());<span class="comment">//保证输出是按字典序排的，若题目不要求可注释</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">扩展：字符串的字符组合</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Recursive</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index, <span class="built_in">string</span>&amp; str, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res,<span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (find(res.begin(), res.end(), s) == res.end())</span><br><span class="line">res.push_back(s);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= str.size())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//把index放入</span></span><br><span class="line">s += str[index];</span><br><span class="line">Recursive(num - <span class="number">1</span>, index + <span class="number">1</span>, str, res, s);</span><br><span class="line">s=s.substr(<span class="number">0</span>, s.size()<span class="number">-1</span>);<span class="comment">//去掉最后一个字符，回溯</span></span><br><span class="line"><span class="comment">//不放如index</span></span><br><span class="line">Recursive(num, index + <span class="number">1</span>, str, res, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">sort(str.begin(), str.end());</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.size()+<span class="number">1</span>; i++)<span class="comment">//i表示组合中字符个数</span></span><br><span class="line">Recursive(i, <span class="number">0</span>,str, res,s);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kmp算法实现："><a href="#kmp算法实现：" class="headerlink" title="kmp算法实现："></a>kmp算法实现：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用KMP算法结题，实现KMP算法</span></span><br><span class="line">        <span class="keyword">int</span> n=needle.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next=getNextArray(needle);<span class="comment">//获取next数组</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">-1</span>;<span class="comment">//用来标志needle，也代表匹配程度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;haystack.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(k&gt;<span class="number">-1</span>&amp;&amp;needle[k+<span class="number">1</span>]!=haystack[i])<span class="comment">//部分匹配但是接下来的不匹配，就计算往后退的步数，回溯</span></span><br><span class="line">                k=next[k];</span><br><span class="line">            <span class="keyword">if</span>(needle[k+<span class="number">1</span>]==haystack[i])<span class="comment">//下一位相同，又匹配了一位，k++</span></span><br><span class="line">                k++;</span><br><span class="line">            <span class="keyword">if</span>(k==n<span class="number">-1</span>)<span class="comment">//完全匹配</span></span><br><span class="line">                <span class="keyword">return</span> i-n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要实现kmp算法，需要先实现针对needle的next数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNextArray(<span class="built_in">string</span> &amp;needle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(needle.size(),<span class="number">0</span>);</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;<span class="comment">//-1表示不存在相同最大前缀和最大后缀</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;needle.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(k&gt;<span class="number">-1</span>&amp;&amp;needle[k+<span class="number">1</span>]!=needle[i])<span class="comment">//如果k&gt;-1并且下一个字符不同，k就往前回溯，找到与当前点相同的之前点</span></span><br><span class="line">                k=next[k];</span><br><span class="line">            <span class="keyword">if</span>(needle[k+<span class="number">1</span>]==needle[i])<span class="comment">//如果下一个字符相同，k++</span></span><br><span class="line">                k++;</span><br><span class="line">            next[i]=k;<span class="comment">//赋值next数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="39、数组中出现次数超过一半的数字"><a href="#39、数组中出现次数超过一半的数字" class="headerlink" title="39、数组中出现次数超过一半的数字"></a>39、数组中出现次数超过一半的数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> value=numbers[<span class="number">0</span>],cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numbers.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==value)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span>(cnt==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    value=numbers[i];</span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count(numbers.begin(),numbers.end(),value)*<span class="number">2</span>&gt;numbers.size())</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="40、最小的k个数"><a href="#40、最小的k个数" class="headerlink" title="40、最小的k个数"></a>40、最小的k个数</h1><p>以下实现使用最大堆，也可用基于红黑树实现的set。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;input.size()||k&lt;=<span class="number">0</span>||input.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        make_heap(res.begin(),res.end());<span class="comment">//构造堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;input.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i]&lt;res[<span class="number">0</span>])<span class="comment">//比堆顶数小</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(input[i]);</span><br><span class="line">                push_heap(res.begin(),res.end());</span><br><span class="line">                pop_heap(res.begin(),res.end());</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort_heap(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="41、数据流中的中位数"><a href="#41、数据流中的中位数" class="headerlink" title="41、数据流中的中位数"></a>41、数据流中的中位数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(((min.size() + max.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                max.push_back(num);</span><br><span class="line">                push_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">                num = max[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                pop_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line">                max.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            min.push_back(num);</span><br><span class="line">            push_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(min.size() &gt; <span class="number">0</span> &amp;&amp; min[<span class="number">0</span>] &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                min.push_back(num);</span><br><span class="line">                push_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">                num = min[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                pop_heap(min.begin(), min.end(), greater&lt;T&gt;());</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            max.push_back(num);</span><br><span class="line">            push_heap(max.begin(), max.end(), less&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = min.size() + max.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> exception(<span class="string">"No numbers are available"</span>);</span><br><span class="line"></span><br><span class="line">        T median = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((size &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            median = min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            median = (min[<span class="number">0</span>] + max[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> median;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; min;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="42、连续子数组的最大和"><a href="#42、连续子数组的最大和" class="headerlink" title="42、连续子数组的最大和"></a>42、连续子数组的最大和</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="built_in">array</span>.size(),<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxSum=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">array</span>.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&gt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i]=<span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;maxSum)</span><br><span class="line">                    maxSum=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="43、1-n整数中1出现的次数"><a href="#43、1-n整数中1出现的次数" class="headerlink" title="43、1~n整数中1出现的次数"></a>43、1~n整数中1出现的次数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i*=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> index = n % (i * <span class="number">10</span>) / i;<span class="comment">//得到i位数</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">1</span>)<span class="comment">//i位&gt;1</span></span><br><span class="line">    cnt += i*(n / (i * <span class="number">10</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>)<span class="comment">//i位==1</span></span><br><span class="line">    cnt += i*(n / (i * <span class="number">10</span>)) + (n%i) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//i位==0</span></span><br><span class="line">    cnt += i*(n / (i * <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="44、数字序列中某一位的数字"><a href="#44、数字序列中某一位的数字" class="headerlink" title="44、数字序列中某一位的数字"></a>44、数字序列中某一位的数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digits)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> digits = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> numbers = countOfIntegers(digits);</span><br><span class="line"><span class="keyword">if</span>(index &lt; numbers * digits)</span><br><span class="line"><span class="keyword">return</span> digitAtIndex(index, digits);</span><br><span class="line"></span><br><span class="line">index -= digits * numbers;</span><br><span class="line">digits++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">9</span> * count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> number = beginNumber(digits) + index / digits;</span><br><span class="line"><span class="keyword">int</span> indexFromRight = digits - index % digits;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; indexFromRight; ++i)</span><br><span class="line">number /= <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="45、把数组排成最小的数"><a href="#45、把数组排成最小的数" class="headerlink" title="45、把数组排成最小的数"></a>45、把数组排成最小的数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringNums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)</span><br><span class="line">            stringNums.push_back(to_string(numbers[i]));</span><br><span class="line">        sort(stringNums.begin(),stringNums.end(),[](<span class="built_in">string</span> s1,<span class="built_in">string</span> s2)</span><br><span class="line">             &#123;<span class="keyword">return</span> ((s1+s2).compare(s2+s1)&lt;<span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>; &#125;);</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stringNums.size();i++)</span><br><span class="line">            res+=stringNums[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="46、把数字翻译成字符串"><a href="#46、把数字翻译成字符串" class="headerlink" title="46、把数字翻译成字符串"></a>46、把数字翻译成字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTranslationCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; number)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTranslationCount</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> numberInString = to_string(number);</span><br><span class="line">    <span class="keyword">return</span> GetTranslationCount(numberInString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTranslationCount</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = number.length();</span><br><span class="line">    <span class="keyword">int</span>* counts = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">               count = counts[i + <span class="number">1</span>];</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">               count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; length - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> digit1 = number[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> digit2 = number[i + <span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> converted = digit1 * <span class="number">10</span> + digit2;</span><br><span class="line">            <span class="keyword">if</span>(converted &gt;= <span class="number">10</span> &amp;&amp; converted &lt;= <span class="number">25</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; length - <span class="number">2</span>)</span><br><span class="line">                    count += counts[i + <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        counts[i] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = counts[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] counts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="47、礼物的最大价值"><a href="#47、礼物的最大价值" class="headerlink" title="47、礼物的最大价值"></a>47、礼物的最大价值</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxValue_solution1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>** maxValues = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        maxValues[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                up = maxValues[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                left = maxValues[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            maxValues[i][j] = <span class="built_in">std</span>::max(left, up) + values[i * cols + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxValue = maxValues[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">        <span class="keyword">delete</span>[] maxValues[i];</span><br><span class="line">    <span class="keyword">delete</span>[] maxValues;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="48-、最长不包含重复字符的子字符串"><a href="#48-、最长不包含重复字符的子字符串" class="headerlink" title="48.、最长不包含重复字符的子字符串"></a>48.、最长不包含重复字符的子字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestSubstringWithoutDuplication_2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        position[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> prevIndex = position[str[i] - <span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(prevIndex &lt; <span class="number">0</span> || i - prevIndex &gt; curLength)</span><br><span class="line">            ++curLength;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curLength &gt; maxLength)</span><br><span class="line">                maxLength = curLength;</span><br><span class="line"></span><br><span class="line">            curLength = i - prevIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        position[str[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curLength &gt; maxLength)</span><br><span class="line">        maxLength = curLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] position;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="49、丑数"><a href="#49、丑数" class="headerlink" title="49、丑数"></a>49、丑数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> n1,<span class="keyword">int</span> n2,<span class="keyword">int</span> n3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1&lt;=n2?(n1&lt;=n3?n1:n3):(n2&lt;=n3?n2:n3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; uglyNums;</span><br><span class="line">        uglyNums.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> multiple2=<span class="number">0</span>,multiple3=<span class="number">0</span>,multiple5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(uglyNums.size()&lt;index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tempNum=Min(<span class="number">2</span>*uglyNums[multiple2],<span class="number">3</span>*uglyNums[multiple3],<span class="number">5</span>*uglyNums[multiple5]);</span><br><span class="line">            uglyNums.push_back(tempNum);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">2</span>*uglyNums[multiple2]&lt;=uglyNums[uglyNums.size()<span class="number">-1</span>])</span><br><span class="line">                multiple2++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">3</span>*uglyNums[multiple3]&lt;=uglyNums[uglyNums.size()<span class="number">-1</span>])</span><br><span class="line">                multiple3++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">5</span>*uglyNums[multiple5]&lt;=uglyNums[uglyNums.size()<span class="number">-1</span>])</span><br><span class="line">                multiple5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uglyNums[uglyNums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="50、第一次只出现一次的字符"><a href="#50、第一次只出现一次的字符" class="headerlink" title="50、第一次只出现一次的字符"></a>50、第一次只出现一次的字符</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; charAndCnt;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; charFirstIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(charAndCnt[str[i]]==<span class="number">0</span>)<span class="comment">//第一次出现</span></span><br><span class="line">                charFirstIndex[str[i]]=i;</span><br><span class="line">            charAndCnt[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> firstCharIndex=str.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:charAndCnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span>(charFirstIndex[p.first]&lt;firstCharIndex)</span><br><span class="line">                    firstCharIndex=charFirstIndex[p.first];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstCharIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="50-2、字符流中出现一次的第一个字符"><a href="#50-2、字符流中出现一次的第一个字符" class="headerlink" title="50_2、字符流中出现一次的第一个字符"></a>50_2、字符流中出现一次的第一个字符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution():index(<span class="number">0</span>),occurence(<span class="number">256</span>,<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(occurence[ch]==<span class="number">-1</span>)</span><br><span class="line">             occurence[ch]=index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(occurence[ch]&gt;=<span class="number">0</span>)</span><br><span class="line">            occurence[ch]=<span class="number">-2</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex=index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(occurence[i]&gt;=<span class="number">0</span>&amp;&amp;occurence[i]&lt;=minIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex=occurence[i];</span><br><span class="line">                ch=<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex==index)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; occurence;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="51、数组中的逆序对"><a href="#51、数组中的逆序对" class="headerlink" title="51、数组中的逆序对"></a>51、数组中的逆序对</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(data);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt=MergeSort(data,temp,<span class="number">0</span>,data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[left]=data[left];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid=left+((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> leftCnt=MergeSort(temp,data,left,mid);<span class="comment">//temp和data需要调换位置，使递归的data部分有序</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rightCnt=MergeSort(temp,data,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开辟辅助空间，对左右两半数组进行归并排序，在归并排序的过程中统计逆序次数</span></span><br><span class="line">        <span class="keyword">int</span> leftIndex=mid,rightIndex=right,tempIndex=right;</span><br><span class="line">        <span class="keyword">while</span>(leftIndex&gt;=left&amp;&amp;rightIndex&gt;=mid+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[leftIndex]&gt;data[rightIndex])<span class="comment">//左边大，出现逆序对</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt+=rightIndex-mid;</span><br><span class="line">                temp[tempIndex--]=data[leftIndex--];</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;<span class="number">1000000007</span>)</span><br><span class="line">                    cnt=cnt%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp[tempIndex--]=data[rightIndex--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(leftIndex&gt;=left)<span class="comment">//右半边结束了</span></span><br><span class="line">            temp[tempIndex--]=data[leftIndex--];</span><br><span class="line">        <span class="keyword">while</span>(rightIndex&gt;=mid+<span class="number">1</span>)</span><br><span class="line">            temp[tempIndex--]=data[rightIndex--];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt+leftCnt+rightCnt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="52、两个链表的第一个公共结点"><a href="#52、两个链表的第一个公共结点" class="headerlink" title="52、两个链表的第一个公共结点"></a>52、两个链表的第一个公共结点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1||!pHead2)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length1=<span class="number">1</span>,length2=<span class="number">1</span>;</span><br><span class="line">        ListNode* p1=pHead1,*p2=pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            length1++;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            length2++;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1!=p2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        p1=pHead1;</span><br><span class="line">        p2=pHead2;</span><br><span class="line">        <span class="keyword">int</span> n=(length1&gt;length2)?(length1-length2):(length2-length1);</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(length1&gt;length2)</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="53、数字在排序数组中出现的次数"><a href="#53、数字在排序数组中出现的次数" class="headerlink" title="53、数字在排序数组中出现的次数"></a>53、数字在排序数组中出现的次数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first =getFirst(data,<span class="number">0</span>,data.size()<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">int</span> last=getLast(data,<span class="number">0</span>,data.size()<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">if</span>(first&gt;<span class="number">-1</span>&amp;&amp;last&gt;<span class="number">-1</span>)</span><br><span class="line">            cnt=last-first+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=start+((end-start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> midData=data[mid];</span><br><span class="line">        <span class="keyword">if</span>(midData==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((mid&gt;<span class="number">0</span>&amp;&amp;data[mid<span class="number">-1</span>]!=k)||mid==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midData&gt;k)</span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getFirst(data,start,end,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=start+((end-start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> midData=data[mid];</span><br><span class="line">        <span class="keyword">if</span>(midData==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((mid&lt;data.size()<span class="number">-1</span>&amp;&amp;data[mid+<span class="number">1</span>]!=k)||mid==data.size()<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midData&lt;k)</span><br><span class="line">            start=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            end=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> getLast(data,start,end,k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="53-2：0-n-1中缺失的数字"><a href="#53-2：0-n-1中缺失的数字" class="headerlink" title="53_2：0~n-1中缺失的数字"></a>53_2：0~n-1中缺失的数字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMissingNumber</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[middle] != middle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(middle == <span class="number">0</span> || numbers[middle - <span class="number">1</span>] == middle - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == length)</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    <span class="comment">// 无效的输入，比如数组不是按要求排序的，</span></span><br><span class="line">    <span class="comment">// 或者有数字不在0到n-1范围之内</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="54、二叉搜索树的第k大节点"><a href="#54、二叉搜索树的第k大节点" class="headerlink" title="54、二叉搜索树的第k大节点"></a>54、二叉搜索树的第k大节点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Inorder</span><span class="params">(TreeNode* root,<span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        TreeNode* target=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            target=Inorder(root-&gt;left,k);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">                    target=root;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!target)</span><br><span class="line">                target=Inorder(root-&gt;right,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span>||!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Inorder(pRoot,k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="55、二叉树的深度"><a href="#55、二叉树的深度" class="headerlink" title="55、二叉树的深度"></a>55、二叉树的深度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> (left&gt;right)?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">判断是否是平衡二叉树：</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> JudgeBalanced(pRoot,depth);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">JudgeBalanced</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp; depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            depth=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">        <span class="keyword">if</span>(JudgeBalanced(root-&gt;left,left)&amp;&amp;JudgeBalanced(root-&gt;right,right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> diff=left-right;</span><br><span class="line">            <span class="keyword">if</span>(diff&lt;=<span class="number">1</span>&amp;&amp;diff&gt;=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                depth=(left&gt;right)?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="56-1：数组中只出现一次的两个数字"><a href="#56-1：数组中只出现一次的两个数字" class="headerlink" title="56_1：数组中只出现一次的两个数字"></a>56_1：数组中只出现一次的两个数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> ORResult=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:data)</span><br><span class="line">            ORResult=ORResult^i;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(ORResult&amp;n))</span><br><span class="line">            n=n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        *num1=*num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;n)</span><br><span class="line">                *num1^=i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2^=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="56-2：数组中唯一只出现一次的数字，其他数字出现三次"><a href="#56-2：数组中唯一只出现一次的数字，其他数字出现三次" class="headerlink" title="56_2：数组中唯一只出现一次的数字，其他数字出现三次"></a>56_2：数组中唯一只出现一次的数字，其他数字出现三次</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNumberAppearingOnce</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitSum[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = numbers[i] &amp; bitMask;</span><br><span class="line">            <span class="keyword">if</span>(bit != <span class="number">0</span>)</span><br><span class="line">                bitSum[j] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            bitMask = bitMask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="57-1、和为s的两个数字"><a href="#57-1、和为s的两个数字" class="headerlink" title="57_1、和为s的两个数字"></a>57_1、和为s的两个数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="built_in">array</span>.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> data=<span class="built_in">array</span>[left];</span><br><span class="line">            <span class="keyword">while</span>(data+<span class="built_in">array</span>[right]&gt;sum)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">if</span>(data+<span class="built_in">array</span>[right]==sum)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(data);</span><br><span class="line">                res.push_back(<span class="built_in">array</span>[right]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="57-2、和为s的连续正数序列"><a href="#57-2、和为s的连续正数序列" class="headerlink" title="57_2、和为s的连续正数序列"></a>57_2、和为s的连续正数序列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">1</span>,last=begin+<span class="number">1</span>,finish=(sum&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum=begin+last;</span><br><span class="line">        <span class="keyword">while</span>(begin&lt;finish)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum==sum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;=last;i++)</span><br><span class="line">                    temp.push_back(i);</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                last++;</span><br><span class="line">                curSum+=last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&gt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                curSum-=begin;</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&lt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                last++;</span><br><span class="line">                curSum+=last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="58-1、翻转单词顺序"><a href="#58-1、翻转单词顺序" class="headerlink" title="58_1、翻转单词顺序"></a>58_1、翻转单词顺序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        ReverseString(str,<span class="number">0</span>,str.size()<span class="number">-1</span>);<span class="comment">//总体逆序</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ReverseString(str,j,i<span class="number">-1</span>);</span><br><span class="line">                j=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==str.size()<span class="number">-1</span>)</span><br><span class="line">                ReverseString(str,j,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="built_in">string</span> &amp; str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c=str[start];</span><br><span class="line">            str[start]=str[end];</span><br><span class="line">            str[end]=c;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="58-2：左旋转字符串"><a href="#58-2：左旋转字符串" class="headerlink" title="58_2：左旋转字符串"></a>58_2：左旋转字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReverseString方法与上题相同</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.size()!=<span class="number">0</span>&amp;&amp;n&gt;str.size())</span><br><span class="line">            n=n%str.size();</span><br><span class="line">        <span class="keyword">if</span>(str.size()&lt;=<span class="number">0</span>||n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        ReverseString(str,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        ReverseString(str,n,str.size()<span class="number">-1</span>);</span><br><span class="line">        ReverseString(str,<span class="number">0</span>,str.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="59-1、滑动窗口的最大值"><a href="#59-1、滑动窗口的最大值" class="headerlink" title="59_1、滑动窗口的最大值"></a>59_1、滑动窗口的最大值</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(num.size()&lt;=<span class="number">0</span>||size==<span class="number">0</span>||size&gt;num.size())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">int</span> maxIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i]&gt;num[maxIndex])</span><br><span class="line">                maxIndex=i;</span><br><span class="line">        res.push_back(num[maxIndex]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num.size()-size+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxIndex&lt;i)</span><br><span class="line">            &#123;</span><br><span class="line">                maxIndex=i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">                    <span class="keyword">if</span>(num[i+j]&gt;num[maxIndex])</span><br><span class="line">                        maxIndex=i+j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(maxIndex&gt;=i&amp;&amp;num[i+size<span class="number">-1</span>]&gt;=num[maxIndex])</span><br><span class="line">                maxIndex=i+size<span class="number">-1</span>;</span><br><span class="line">            res.push_back(num[maxIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="60、n个骰子的点数"><a href="#60、n个骰子的点数" class="headerlink" title="60、n个骰子的点数"></a>60、n个骰子的点数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbability_Solution2</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pProbabilities[<span class="number">2</span>];</span><br><span class="line">    pProbabilities[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">    pProbabilities[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[g_maxValue * number + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g_maxValue * number + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pProbabilities[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        pProbabilities[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g_maxValue; ++i) </span><br><span class="line">        pProbabilities[flag][i] = <span class="number">1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= number; ++k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= g_maxValue * k; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            pProbabilities[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= g_maxValue; ++j) </span><br><span class="line">                pProbabilities[<span class="number">1</span> - flag][i] += pProbabilities[flag][i - j];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        flag = <span class="number">1</span> - flag;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> total = <span class="built_in">pow</span>((<span class="keyword">double</span>)g_maxValue, number);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = number; i &lt;= g_maxValue * number; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)pProbabilities[flag][i] / total;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %e\n"</span>, i, ratio);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pProbabilities[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="61、扑克牌中的顺子"><a href="#61、扑克牌中的顺子" class="headerlink" title="61、扑克牌中的顺子"></a>61、扑克牌中的顺子</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.size()!=<span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(numbers.begin(),numbers.end());</span><br><span class="line">        <span class="keyword">int</span> zeroCnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ZeroNeededCnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;numbers[i]==numbers[i<span class="number">-1</span>]&amp;&amp;numbers[i]!=<span class="number">0</span>)<span class="comment">//有对子</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==<span class="number">0</span>)</span><br><span class="line">                zeroCnt++;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;numbers[i<span class="number">-1</span>]!=<span class="number">0</span>&amp;&amp;numbers[i]-numbers[i<span class="number">-1</span>]&gt;<span class="number">1</span>)<span class="comment">//计算需要用大小王代替的个数</span></span><br><span class="line">                ZeroNeededCnt+=numbers[i]-numbers[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zeroCnt&gt;=ZeroNeededCnt)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="62、圆圈中最后剩下的数字（约瑟夫环）"><a href="#62、圆圈中最后剩下的数字（约瑟夫环）" class="headerlink" title="62、圆圈中最后剩下的数字（约瑟夫环）"></a>62、圆圈中最后剩下的数字（约瑟夫环）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典环状链表解决</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            numbers.push_back(i);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator cur=numbers.begin();</span><br><span class="line">        <span class="keyword">while</span>(numbers.size()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cur++;</span><br><span class="line"><span class="keyword">if</span> (cur == numbers.end())</span><br><span class="line">cur = numbers.begin();</span><br><span class="line">&#125;</span><br><span class="line">cur = numbers.erase(cur);</span><br><span class="line"><span class="keyword">if</span> (cur == numbers.end())</span><br><span class="line">cur = numbers.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *cur;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运用数学的解法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            last=(last+m)%i;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="63、股票的最大利润"><a href="#63、股票的最大利润" class="headerlink" title="63、股票的最大利润"></a>63、股票的最大利润</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxDiff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">unsigned</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> &amp;&amp; length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxDiff = numbers[<span class="number">1</span>] - min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i - <span class="number">1</span>] &lt; min)</span><br><span class="line">            min = numbers[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> currentDiff = numbers[i] - min;</span><br><span class="line">        <span class="keyword">if</span>(currentDiff &gt; maxDiff)</span><br><span class="line">            maxDiff = currentDiff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxDiff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="64、求1-2-3-……-n"><a href="#64、求1-2-3-……-n" class="headerlink" title="64、求1+2+3+……+n"></a>64、求1+2+3+……+n</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=n;</span><br><span class="line">        sum&amp;&amp;(sum+=Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="65、不用加减乘除做加法"><a href="#65、不用加减乘除做加法" class="headerlink" title="65、不用加减乘除做加法"></a>65、不用加减乘除做加法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum,carry;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=num1^num2;</span><br><span class="line">            carry=(num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1=sum;</span><br><span class="line">            num2=carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="66、构建乘积数组"><a href="#66、构建乘积数组" class="headerlink" title="66、构建乘积数组"></a>66、构建乘积数组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B;</span><br><span class="line">        <span class="keyword">if</span>(A.size()&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> B;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)</span><br><span class="line">            B.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C(A.size(),<span class="number">1</span>),D(A.size(),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i]=C[i<span class="number">-1</span>]*A[i<span class="number">-1</span>];</span><br><span class="line">            D[D.size()<span class="number">-1</span>-i]=D[D.size()-i]*A[A.size()-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.size();i++)</span><br><span class="line">            B[i]=C[i]*D[i];</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="67、字符串转换成数字"><a href="#67、字符串转换成数字" class="headerlink" title="67、字符串转换成数字"></a>67、字符串转换成数字</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inputStatus=inputInvalid;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> minus=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'+'</span>)</span><br><span class="line">            str=str.substr(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            minus=<span class="literal">true</span>;</span><br><span class="line">            str=str.substr(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num=StrToInt(str,minus);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span>&amp; str,<span class="keyword">bool</span> minus)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                num=num*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                inputStatus=inputInvalid;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((!minus&amp;&amp;num&gt;<span class="number">0x7fffffff</span>)||(minus&amp;&amp;num&lt;(<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minus)</span><br><span class="line">            num=<span class="number">0</span>-num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Status&#123;inputInvalid=<span class="number">0</span>,inputValid&#125;;<span class="comment">//记录输入是否有错</span></span><br><span class="line">    <span class="keyword">int</span> inputStatus=inputValid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="68、二叉树公共父节点"><a href="#68、二叉树公共父节点" class="headerlink" title="68、二叉树公共父节点"></a>68、二叉树公共父节点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetNodePath</span><span class="params">(TreeNode* root, TreeNode* node, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; path)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == node)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">path.push_back(root);</span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!found&amp;&amp;root-&gt;left)</span><br><span class="line">found = GetNodePath(root-&gt;left, node, path);</span><br><span class="line"><span class="keyword">if</span> (!found&amp;&amp;root-&gt;right)</span><br><span class="line">found = GetNodePath(root-&gt;right, node, path);</span><br><span class="line"><span class="keyword">if</span> (!found)</span><br><span class="line">path.pop_back();</span><br><span class="line"><span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNode</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;path1, <span class="built_in">vector</span>&lt;TreeNode*&gt; &amp;path2)</span></span>&#123;</span><br><span class="line">TreeNode *last = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; path1.size() &amp;&amp; j &lt; path2.size())&#123;</span><br><span class="line"><span class="keyword">if</span> (path1[i] == path2[j])</span><br><span class="line">last = path1[i];</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四个string函数"><a href="#四个string函数" class="headerlink" title="四个string函数"></a>四个string函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(str != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str)</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(str1 != <span class="literal">NULL</span>&amp;&amp;str2 != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str1 &amp;&amp; !(ret=*str1-*str2))</span><br><span class="line">&#123;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">my_strcat</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span> * strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *add = strDest;</span><br><span class="line">assert((strDest != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span> (*strDest)</span><br><span class="line">strDest++;</span><br><span class="line"><span class="keyword">while</span> (*strDest++ = *strSrc++);</span><br><span class="line"><span class="comment">//*strDest = '\0';</span></span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *strDes, <span class="keyword">const</span> <span class="keyword">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert((strDes != <span class="literal">NULL</span>) &amp;&amp; (strSrc != <span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">char</span> *add = strDes;</span><br><span class="line"><span class="keyword">while</span> (*strSrc)</span><br><span class="line">&#123;</span><br><span class="line">*strDes = *strSrc;</span><br><span class="line">strDes++;</span><br><span class="line">strSrc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四个图算法"><a href="#四个图算法" class="headerlink" title="四个图算法"></a>四个图算法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迪杰斯特拉算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DJS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis, <span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(dis.size(), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortestDis(dis.size(), INT_MAX);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(dis.size(),<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (dis[v0][i] &lt; INT_MAX)&#123;</span><br><span class="line">shortestDis[i] = dis[v0][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shortestDis[v0] = <span class="number">0</span>;</span><br><span class="line">visited[v0] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="comment">// 主循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0)&#123;</span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; dis.size(); w++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[w])</span><br><span class="line"><span class="keyword">if</span> (shortestDis[w]&lt;min)&#123;</span><br><span class="line">v = w;</span><br><span class="line">min = shortestDis[w];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visited[v] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; dis.size(); w++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[w] &amp;&amp; dis[v][w] != INT_MAX&amp;&amp; min + dis[v][w] &lt; shortestDis[w])</span><br><span class="line">&#123;</span><br><span class="line">shortestDis[w] = min + dis[v][w];</span><br><span class="line">path[w] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0)&#123;</span><br><span class="line"><span class="keyword">if</span> (shortestDis[i] == INT_MAX)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v0 &lt;&lt; <span class="string">"to"</span> &lt;&lt; i &lt;&lt; <span class="string">": no path"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v0 &lt;&lt; <span class="string">"to"</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span> &lt;&lt; shortestDis[i] &lt;&lt; <span class="string">" path:0 "</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="keyword">while</span> (j != <span class="number">-1</span>)&#123;</span><br><span class="line">p.push_back(j);</span><br><span class="line">j = path[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!p.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p[p.size() - <span class="number">1</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">p.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis2 = &#123;</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">11</span> &#125;,</span><br><span class="line">&#123; <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span> &#125;,</span><br><span class="line">&#123;<span class="number">3</span>, INT_MAX, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//弗洛伊德 ，其实 动规</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_FLOYD</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = dis2.size();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; path(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>));<span class="comment">//path[i][j]表示从i到j的最短路径之前的一个端点，-1表示两点直连</span></span><br><span class="line"><span class="comment">//dp[i][j][k]存的是从j到k中间顶点序号不超过i-1的最短路径</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n)));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">dp[<span class="number">0</span>][i][j] = dis2[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">//动规求解，递推公式如下</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t = dp[i - <span class="number">1</span>][j][i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][i - <span class="number">1</span>][k];</span><br><span class="line">dp[i][j][k] = dp[i - <span class="number">1</span>][j][k] &gt; t ? t : dp[i - <span class="number">1</span>][j][k];</span><br><span class="line"><span class="keyword">if</span> (t &lt; dp[i - <span class="number">1</span>][j][k])</span><br><span class="line">&#123;</span><br><span class="line">path[j][k] = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"shortest distance: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[n][i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"path: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; path[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis3= &#123;</span><br><span class="line">&#123; INT_MAX,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>,INT_MAX,INT_MAX &#125;,</span><br><span class="line">&#123; <span class="number">6</span>,INT_MAX,<span class="number">5</span>,INT_MAX,<span class="number">3</span>,INT_MAX&#125;,</span><br><span class="line">&#123; <span class="number">1</span>,<span class="number">5</span>,INT_MAX,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;,</span><br><span class="line">&#123; <span class="number">5</span>,INT_MAX,<span class="number">5</span>,INT_MAX,INT_MAX,<span class="number">2</span> &#125;,</span><br><span class="line">&#123; INT_MAX,<span class="number">3</span>,<span class="number">6</span>,INT_MAX,INT_MAX,<span class="number">6</span> &#125;,</span><br><span class="line">&#123; INT_MAX,INT_MAX,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,INT_MAX &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普里姆算法的时间复杂度 邻接矩阵：v2  邻接表：elogv，边数多选择普里姆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_PRIM</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis,<span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line"><span class="comment">// 初始化辅助数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; closeEdge(dis.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0)&#123;</span><br><span class="line">closeEdge[i][<span class="number">0</span>] = v0;</span><br><span class="line">closeEdge[i][<span class="number">1</span>] = dis3[v0][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closeEdge[v0][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//0表示节点v0被放入S集合中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i != v0)&#123;</span><br><span class="line"><span class="keyword">int</span> min = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.size(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (closeEdge[j][<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; closeEdge[j][<span class="number">1</span>] &lt; min)&#123;</span><br><span class="line">min = closeEdge[j][<span class="number">1</span>];</span><br><span class="line">index = closeEdge[j][<span class="number">0</span>];</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; index&lt;&lt;<span class="string">" to "</span>&lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">closeEdge[k][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.size(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (closeEdge[j][<span class="number">1</span>] &gt; dis[k][j])</span><br><span class="line">&#123;</span><br><span class="line">closeEdge[j][<span class="number">0</span>] = k;</span><br><span class="line">closeEdge[j][<span class="number">1</span>] = dis[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//克鲁斯卡尔，对边按照权重排序，eloge，边数少选择这个</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">int</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MST_KRUSKAL</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dis)</span></span>&#123;</span><br><span class="line"><span class="comment">//边初始化并按边长排序</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; dis.size(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (dis[i][j] != INT_MAX)&#123;</span><br><span class="line">Edge t = &#123; dis[i][j], i, j &#125;;</span><br><span class="line">edges.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(edges.begin(), edges.end(), [](Edge&amp; e1, Edge&amp; e2)&#123;</span><br><span class="line"><span class="keyword">return</span> e1.weight &lt; e2.weight;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化集合，同一个集合中的数字代表是最小值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father(dis.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)</span><br><span class="line">father[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (father[edges[i].start] != father[edges[i].end])&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"get edge: "</span> &lt;&lt; edges[i].start &lt;&lt; <span class="string">" to "</span> &lt;&lt; edges[i].end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//合并集合</span></span><br><span class="line"><span class="keyword">int</span> min = father[edges[i].start] &gt; father[edges[i].end] ? father[edges[i].end] : father[edges[i].start];</span><br><span class="line"><span class="keyword">int</span> max = father[edges[i].start] &lt; father[edges[i].end] ? father[edges[i].end] : father[edges[i].start];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (father[i] == max)&#123;</span><br><span class="line">father[i] = min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用排序算法总结"><a href="#常用排序算法总结" class="headerlink" title="常用排序算法总结"></a>常用排序算法总结</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i]&gt;A[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t=A[i];</span><br><span class="line">                    A[i]=A[j];</span><br><span class="line">                    A[j]=t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[k]&gt;A[j])</span><br><span class="line">                    k=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t=A[i];</span><br><span class="line">            A[i]=A[k];</span><br><span class="line">            A[k]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//插入排序：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//寻找插入点</span></span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i]&gt;=A[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入</span></span><br><span class="line">            <span class="keyword">int</span> t=A[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&gt;j+<span class="number">1</span>;k--)</span><br><span class="line">                A[k]=A[k<span class="number">-1</span>];</span><br><span class="line">            A[j+<span class="number">1</span>]=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//归并：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        mergeSortCore(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSortCore</span><span class="params">(<span class="keyword">int</span>* &amp;A,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(endIndex==startIndex)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid=startIndex+((endIndex-startIndex)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//分别处理左右，分治</span></span><br><span class="line">        mergeSortCore(A,startIndex,mid);</span><br><span class="line">        mergeSortCore(A,mid+<span class="number">1</span>,endIndex);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        Merge(A,startIndex,mid,endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* &amp;A,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> rbegin=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l=left;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=mid&amp;&amp;rbegin&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[left]&lt;=A[rbegin])</span><br><span class="line">                temp[i++]=A[left++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[i++]=A[rbegin++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rbegin&lt;=right)</span><br><span class="line">            temp[i++]=A[rbegin++];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=mid)</span><br><span class="line">            temp[i++]=A[left++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            A[l+j] = temp[j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//快速排序：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(!A)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        quickSort(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* &amp;A,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index=Partition(A,start,end);</span><br><span class="line">        <span class="keyword">if</span>(index&gt;start)</span><br><span class="line">            quickSort(A,start,index<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(index&lt;end)</span><br><span class="line">            quickSort(A,index+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* &amp;A,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=start+((end-start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> index=A[mid]&lt;A[start]?(A[mid]&lt;A[end]?mid:end):(A[start]&lt;A[end]?start:end);</span><br><span class="line">        swap(A[index],A[start]);</span><br><span class="line">        <span class="keyword">int</span> p=A[start];</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从后往前找到第一个比p小的数字，说明该交换了</span></span><br><span class="line">            <span class="keyword">while</span>(start&lt;end&amp;&amp;A[end]&gt;=p)</span><br><span class="line">                end--;</span><br><span class="line">            A[start]=A[end];</span><br><span class="line">            <span class="comment">//从前往后找到第一个比p大的数字</span></span><br><span class="line">            <span class="keyword">while</span>(start&lt;end&amp;&amp;A[start]&lt;=p)</span><br><span class="line">                start++;</span><br><span class="line">            A[end]=A[start];</span><br><span class="line">        &#125;</span><br><span class="line">        A[start]=p;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">//构造最大堆</span></span><br><span class="line">        make_heap(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//堆排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t=A[<span class="number">0</span>];</span><br><span class="line">            A[<span class="number">0</span>]=A[i];</span><br><span class="line">            A[i]=t;</span><br><span class="line">            make_heap(A,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//构造大根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span> start ,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=end;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index=i;</span><br><span class="line">            <span class="keyword">int</span> parentIndex=(i<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//父节点下标</span></span><br><span class="line">            <span class="keyword">while</span>(index<span class="number">-1</span>&gt;=<span class="number">0</span>)<span class="comment">//向上调整，直到头结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[parentIndex]&lt;A[index])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t=A[parentIndex];</span><br><span class="line">                    A[parentIndex]=A[index];</span><br><span class="line">                    A[index]=t;</span><br><span class="line">                    index=parentIndex;</span><br><span class="line">                    parentIndex=(parentIndex<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//希尔排序：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(!A|| n&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> inc = n/<span class="number">2</span>;inc&gt;<span class="number">0</span>;inc = inc/<span class="number">2</span>)&#123;<span class="comment">//inc是步伐长度</span></span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=inc;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(index-inc&gt;=<span class="number">0</span>&amp;&amp;A[index]&lt;A[index-inc])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> t=A[index];</span><br><span class="line">                        A[index]=A[index-inc];</span><br><span class="line">                        A[index-inc]=t;</span><br><span class="line">                        index-=inc;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、编写赋值运算符&quot;&gt;&lt;a href=&quot;#1、编写赋值运算符&quot; class=&quot;headerlink&quot; title=&quot;1、编写赋值运算符&quot;&gt;&lt;/a&gt;1、编写赋值运算符&lt;/h1&gt;&lt;p&gt;四点：返回值、参数类型、释放已有内存、自身赋值特殊情况。&lt;br&gt;进阶：异常安全性。&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CMyString&amp;amp; CMyString::&lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CMyString&amp;amp; rhs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;!=&amp;amp;rhs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		CMyString temp(rhs);&lt;span class=&quot;comment&quot;&gt;//调用copy构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* ptemp=temp.m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		temp.m_pData=m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		m_pData=ptemp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="职业学习" scheme="http://yoursite.com/categories/%E8%81%8C%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>初次见面</title>
    <link href="http://yoursite.com/2018/05/22/My-First-Post/"/>
    <id>http://yoursite.com/2018/05/22/My-First-Post/</id>
    <published>2018-05-22T14:18:52.000Z</published>
    <updated>2018-05-31T02:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018年5月22日，晴。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年5月22日，晴。&lt;/p&gt;

      
    
    </summary>
    
      <category term="余记" scheme="http://yoursite.com/categories/%E4%BD%99%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
