<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="面试,刷题,">





  <link rel="alternate" href="/atom.xml" title="ZRainy" type="application/atom+xml">






<meta name="description" content="90道1、引用和指针的区别。a、定义指针时分配内存，引用不分配内存，而和原变量内存地址相同，这是最本质的区别。b、引用必须初始化c、没有指向空值的引用，但是存在指向空值的指针。">
<meta name="keywords" content="面试,刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="春招面试准备">
<meta property="og:url" content="http://yoursite.com/2018/05/31/春招面试准备/index.html">
<meta property="og:site_name" content="ZRainy">
<meta property="og:description" content="90道1、引用和指针的区别。a、定义指针时分配内存，引用不分配内存，而和原变量内存地址相同，这是最本质的区别。b、引用必须初始化c、没有指向空值的引用，但是存在指向空值的指针。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-07-28T15:14:12.722Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="春招面试准备">
<meta name="twitter:description" content="90道1、引用和指针的区别。a、定义指针时分配内存，引用不分配内存，而和原变量内存地址相同，这是最本质的区别。b、引用必须初始化c、没有指向空值的引用，但是存在指向空值的指针。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/31/春招面试准备/">





  <title>春招面试准备 | ZRainy</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZRainy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/31/春招面试准备/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZRainy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZRainy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">春招面试准备</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-31T00:21:18+08:00">
                2018-05-31
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2019-07-28T23:14:12+08:00" content="2019-07-28">
              2019-07-28
              </time>
            </span>
          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/职业学习/" itemprop="url" rel="index">
                    <span itemprop="name">职业学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="90道"><a href="#90道" class="headerlink" title="90道"></a>90道</h1><h2 id="1、引用和指针的区别。"><a href="#1、引用和指针的区别。" class="headerlink" title="1、引用和指针的区别。"></a>1、引用和指针的区别。</h2><p>a、定义指针时分配内存，引用不分配内存，而和原变量内存地址相同，这是最本质的区别。<br>b、引用必须初始化<br>c、没有指向空值的引用，但是存在指向空值的指针。<br><a id="more"></a></p>
<h2 id="2、值传递、地址传递、引用传递的区别。"><a href="#2、值传递、地址传递、引用传递的区别。" class="headerlink" title="2、值传递、地址传递、引用传递的区别。"></a>2、值传递、地址传递、引用传递的区别。</h2><p>a、值传递，为形参重新分配内存空间，拷贝，形参不改变实参的值，结束后释放空间。<br>b、引用传递：不重新分配内存，形参会改变实参的值，不涉及内存分配和释放，效率最高。<br>c、地址传递：形参是指针变量，会给该指针变量分配内存空间，形参会改变实参的值，结束后释放空间。</p>
<h2 id="3、static的作用"><a href="#3、static的作用" class="headerlink" title="3、static的作用"></a>3、static的作用</h2><p>a、static变量的作用范围属于整个函数体，内存只会分配一次，和auto变量不同，多次调用该函数不会重<br>新分配新的变量，一次调用，持久保存。<br>普通函数f，调用三次，输出000<br>若f中有static，调用三次，输出012<br>b、在模块内的static变量可以被模块内函数访问，但不能被模块外其他函数访问，即使extern也不行。<br>c、static函数也会被限定在模块内<br>d、类中static成员变量属于整个类所拥有的，所有对象只有一个实例<br>e、类中static成员函数属于整个类所拥有，所以不接受this指针，只能访问类中static成员变量。</p>
<h2 id="4、const关键字的用处"><a href="#4、const关键字的用处" class="headerlink" title="4、const关键字的用处"></a>4、const关键字的用处</h2><p>a、阻止一个变量被改变，const表示常量，需要初始化<br>b、对指针来说，可以指定指针本身const，也可以指定指针所指的数据为const，或两者都是const<br>const int <em> p;//const是底层cosnt，表示p所指向的数据是一个常量，不可通过p修改该常量的值，但是p可以指向其他变量<br>int </em> const p;//顶层const，表示指针p本身是一个常量，不可以再指向其他变量，但是它所指的变量可以改变值<br>c、函数参数const，函数内不能改变值<br>d、类的成员函数const，常函数，不能修改类的成员变量<br>e、对类的成员函数，有时候会指定其返回值为cosnt，以使得返回值不为“左值”，因为在c++中可能存在给一个函数赋值的情况，即函数返回一个引用。</p>
<h2 id="5、链表和数组的区别。"><a href="#5、链表和数组的区别。" class="headerlink" title="5、链表和数组的区别。"></a>5、链表和数组的区别。</h2><p>a、数组是顺序表，开辟连续空间。而链表靠指针连接不连续的空间<br>b、数组要求空间连续，占用总空间小，链表则相反<br>c、数组方便排序查找，删除修改较慢；链表则相反。</p>
<h2 id="6、直接实现strlen（）"><a href="#6、直接实现strlen（）" class="headerlink" title="6、直接实现strlen（）"></a>6、直接实现strlen（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrlen</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(str==<span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;i++);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7、直接实现strstr-char-str-char-sub-搜寻子串的函数"><a href="#7、直接实现strstr-char-str-char-sub-搜寻子串的函数" class="headerlink" title="7、直接实现strstr(char str,char sub)搜寻子串的函数"></a>7、直接实现strstr(char <em>str,char </em>sub)搜寻子串的函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">mystrstr</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">char</span>* sub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *pos;</span><br><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</span><br><span class="line">&#123;</span><br><span class="line">	pos=&amp;str[i];</span><br><span class="line">	s=sub;</span><br><span class="line">	<span class="keyword">while</span>(*pos==*s)</span><br><span class="line">	&#123;</span><br><span class="line">		pos++;s++;</span><br><span class="line">		<span class="keyword">if</span>(*s==<span class="string">'\0'</span>)</span><br><span class="line">			<span class="keyword">return</span> &amp;str[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8、直接实现strcat-char-str1-char-str2"><a href="#8、直接实现strcat-char-str1-char-str2" class="headerlink" title="8、直接实现strcat(char str1,char str2)"></a>8、直接实现strcat(char <em>str1,char </em>str2)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p=str1;</span><br><span class="line">	<span class="keyword">while</span>(*str1!=<span class="string">'\0'</span>)</span><br><span class="line">		str1++;</span><br><span class="line">	<span class="keyword">while</span>(*str2!=<span class="string">'\0'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*str1=*str2;</span><br><span class="line">		str1++;</span><br><span class="line">		str2++;</span><br><span class="line">	&#125;</span><br><span class="line">	*str1=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9、直接实现strcmp-char-str1-char-str2"><a href="#9、直接实现strcmp-char-str1-char-str2" class="headerlink" title="9、直接实现strcmp(char str1,char str2)"></a>9、直接实现strcmp(char <em>str1,char </em>str2)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrcmp</span><span class="params">(<span class="keyword">char</span> *str1,<span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(str1==<span class="literal">NULL</span> || str2==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"invalid arguments"</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*str1&gt;*str2)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(*str1&lt;*str2)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(*str1==<span class="string">'\0'</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				str1++;str2++;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10、请给出函数指针数组等定义"><a href="#10、请给出函数指针数组等定义" class="headerlink" title="10、请给出函数指针数组等定义"></a>10、请给出函数指针数组等定义</h2><p>int *<em>a;指向指针的指针<br>int </em>a[10];一个数组，每个元素是一个int指针<br>int (<em>a)[10];一个指针，指向有10个元素的int数组<br>int (</em>a) (int);一个指向函数的指针，该函数有一个整形参数并返回一个整形<br>int (*a[10])(int);函数指针数组，一个包含10个元素的数组，每个元素是一个函数指针，每个函数一个int参数返回一个int</p>
<h2 id="11、给定一个整形变量a，设置或清除bit-N"><a href="#11、给定一个整形变量a，设置或清除bit-N" class="headerlink" title="11、给定一个整形变量a，设置或清除bit N"></a>11、给定一个整形变量a，设置或清除bit N</h2><p>与或非操作</p>
<h2 id="12、C-中的空类，默认产生哪些成员函数"><a href="#12、C-中的空类，默认产生哪些成员函数" class="headerlink" title="12、C++中的空类，默认产生哪些成员函数."></a>12、C++中的空类，默认产生哪些成员函数.</h2><p>缺省构造函数<br>拷贝构造函数<br>析构函数<br>赋值运算符<br>当类成员有指针的时候，拷贝构造和赋值运算符需要重写。</p>
<h2 id="13、struct和class的区别"><a href="#13、struct和class的区别" class="headerlink" title="13、struct和class的区别"></a>13、struct和class的区别</h2><p>c中struct不可以有成员函数，c++中可以<br>c++中 struct默认权限public，class默认权限private</p>
<h2 id="14、内存思考题"><a href="#14、内存思考题" class="headerlink" title="14、内存思考题"></a>14、内存思考题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);&#125;</span><br><span class="line"><span class="function">voit <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str=<span class="literal">NULL</span>;</span><br><span class="line">get(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str,<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序崩溃，因为get不会传递动态内存，test中的str一直是null。<br>指针free后需要置为null，否则会成野指针</p>
<h2 id="15、关键字volatile有什么含义"><a href="#15、关键字volatile有什么含义" class="headerlink" title="15、关键字volatile有什么含义"></a>15、关键字volatile有什么含义</h2><p>被volatile修饰的变量是说这个变量可能会被意想不到地改变<br>比如硬件寄存器中的值可能经常变，所以使用的时候就要读取<br>多线程中的变量也是一样。<br>volatile告诉编译器不要优化这个变量，每次读取都读取实际的值而不是读取缓存</p>
<h2 id="16、读写绝对地址"><a href="#16、读写绝对地址" class="headerlink" title="16、读写绝对地址"></a>16、读写绝对地址</h2><p>int <em>ptr;<br>ptr=(int </em>)0x67a9;<br>*ptr=0xaa55</p>
<h2 id="17、heap与stack的区别"><a href="#17、heap与stack的区别" class="headerlink" title="17、heap与stack的区别"></a>17、heap与stack的区别</h2><p>stack的空间由操作系统自动分配/释放，heap上的空间是手动分配释放的。<br>stack空间有限，heap有很大的自由存储区（new）<br>程序在编译期对变量和函数分配内存都在栈上，且程序运行过程中函数调用参数的传递也在栈上。<br>还有一种静态内存，保存局部static对象</p>
<h2 id="18、不借助第三个数交换两个数的值。"><a href="#18、不借助第三个数交换两个数的值。" class="headerlink" title="18、不借助第三个数交换两个数的值。"></a>18、不借助第三个数交换两个数的值。</h2><p>第一种：a=a+b;b=a-b;a=a-b;<br>第二种：a=a*b;b=a/b;a=a/b;（b不为0）<br>第三种：a=a^b;b=a^b;a=a^b;</p>
<h2 id="19、用宏定义写出swap（x，y）"><a href="#19、用宏定义写出swap（x，y）" class="headerlink" title="19、用宏定义写出swap（x，y）"></a>19、用宏定义写出swap（x，y）</h2><p>#define swap(x,y) (x)=(x)+(y);(y)=(x)-(y);(x)=(x)-(y);<br>宏定义时参数用括号括起来，且表达式之间不要有空格</p>
<h2 id="20、用宏定义返回两个参数中较小的一个"><a href="#20、用宏定义返回两个参数中较小的一个" class="headerlink" title="20、用宏定义返回两个参数中较小的一个"></a>20、用宏定义返回两个参数中较小的一个</h2><p>#define Min(x,y) ((x)&gt;(y)?(y):(x))<br>结尾没有分号</p>
<h2 id="21、带参数的宏和带参数的函数的区别"><a href="#21、带参数的宏和带参数的函数的区别" class="headerlink" title="21、带参数的宏和带参数的函数的区别"></a>21、带参数的宏和带参数的函数的区别</h2><p>a、宏在编译时处理，会展开，而函数在运行时处理<br>b、宏里的参数不需要定义类型，函数中参数必须有类型<br>c、宏会使程序变长，而函数不会<br>d、宏不占用存储空间，函数占用<br>e、宏不占用运行时间，函数调用和返回时占用运行时间<br>带参宏简单，不灵活</p>
<h2 id="22、定义宏，求出数组元素的个数"><a href="#22、定义宏，求出数组元素的个数" class="headerlink" title="22、定义宏，求出数组元素的个数"></a>22、定义宏，求出数组元素的个数</h2><p>#define NTBL(table) (sizeof(table)/sizeof(table[0]))</p>
<h2 id="23、两个栈实现一个队列的功能"><a href="#23、两个栈实现一个队列的功能" class="headerlink" title="23、两个栈实现一个队列的功能"></a>23、两个栈实现一个队列的功能</h2><p>入队：将元素压入栈a<br>出队：<br>（1）判断栈b是否为空<br>（2）如果不为空，则将栈a中所有元素依次pop出并push到栈b<br>（3）将栈b的栈顶元素pop出，即出队元素</p>
<h2 id="24、在c-中调用c函数，为什么要加extern-c"><a href="#24、在c-中调用c函数，为什么要加extern-c" class="headerlink" title="24、在c++中调用c函数，为什么要加extern c?"></a>24、在c++中调用c函数，为什么要加extern c?</h2><p>答：c++支持函数重载，c语言不支持函数重载。函数被c++编译后在库中的名字和c的不同。<br>void foo(int x,int y)<br>在c中编译结果：_foo<br>在c++中：_foo_int_int<br>所以要加extern “c”来解决名字匹配问题</p>
<h2 id="25、找出程序中的错误"><a href="#25、找出程序中的错误" class="headerlink" title="25、找出程序中的错误"></a>25、找出程序中的错误</h2><p>视频第26题：5个错误<br>27题：4个（可不看）</p>
<h2 id="26、一句话判断x是否是2的次幂"><a href="#26、一句话判断x是否是2的次幂" class="headerlink" title="26、一句话判断x是否是2的次幂"></a>26、一句话判断x是否是2的次幂</h2><p>a、x&amp;(x-1)<br>上式为0，则是，否则不是。<br>b、判断logx/log2是不是整数</p>
<h2 id="27、按要求定义变量"><a href="#27、按要求定义变量" class="headerlink" title="27、按要求定义变量"></a>27、按要求定义变量</h2><p>定义全零全一的变量<br>unsigned int zero=0;<br>unsigned int compzero=~0;<br>不能写unsigned int compzero=0xFFFF，因为处理器位数不一定</p>
<h2 id="28、malloc分配内存"><a href="#28、malloc分配内存" class="headerlink" title="28、malloc分配内存"></a>28、malloc分配内存</h2><p>ptr=(char *)malloc(0)<br>分配能否成功？<br>分配虽然成功，但它是0个字节，无法真正使用。</p>
<h2 id="29、对数组名取地址"><a href="#29、对数组名取地址" class="headerlink" title="29、对数组名取地址"></a>29、对数组名取地址</h2><p>数组名本身表示数组第一个元素的地址<br>数组名取地址代表整个数组，该地址+1是加了整个数组的长度。</p>
<h2 id="30、static修饰局部变量"><a href="#30、static修饰局部变量" class="headerlink" title="30、static修饰局部变量"></a>30、static修饰局部变量</h2><p>生命周期延长</p>
<h2 id="31、switch。。。case接受哪种基本数据类型？省略break会怎样？"><a href="#31、switch。。。case接受哪种基本数据类型？省略break会怎样？" class="headerlink" title="31、switch。。。case接受哪种基本数据类型？省略break会怎样？"></a>31、switch。。。case接受哪种基本数据类型？省略break会怎样？</h2><p>不接受float、double。<br>若省略break则匹配成功后一直运行到结束或遇到第一个break</p>
<h2 id="32、无符号数据类型转换"><a href="#32、无符号数据类型转换" class="headerlink" title="32、无符号数据类型转换"></a>32、无符号数据类型转换</h2><p>无符号和有符号相运算，有符号会转化成无符号，若是负数则会变为极大的正数。</p>
<h2 id="33、算出一个字节中被置1的位个数"><a href="#33、算出一个字节中被置1的位个数" class="headerlink" title="33、算出一个字节中被置1的位个数"></a>33、算出一个字节中被置1的位个数</h2><p>循环移位并判断最后一位是否为1<br>或者用x&amp;(x-1)计算</p>
<h2 id="34、编写函数将给定的字符串转换成整数。"><a href="#34、编写函数将给定的字符串转换成整数。" class="headerlink" title="34、编写函数将给定的字符串转换成整数。"></a>34、编写函数将给定的字符串转换成整数。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">invert</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*str!=<span class="string">'\0'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> d=*str<span class="number">-48</span>;</span><br><span class="line">		num=num*<span class="number">10</span>+d;</span><br><span class="line">		str=str+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="35、将整数转换成字符串。"><a href="#35、将整数转换成字符串。" class="headerlink" title="35、将整数转换成字符串。"></a>35、将整数转换成字符串。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> *pval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> strval[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> val0=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> val1=<span class="number">0</span>;</span><br><span class="line">	val0=num;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		val1=val0%<span class="number">10</span>;</span><br><span class="line">		val0=val0/<span class="number">10</span>;</span><br><span class="line">		strval[i]=val1+<span class="number">48</span>;</span><br><span class="line">		<span class="keyword">if</span>(val0&lt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			strval[i]=val0+<span class="number">48</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">		pval[j]=strval[i-j];</span><br><span class="line">	pval[j]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="36、怎么判断链表中是否有环？"><a href="#36、怎么判断链表中是否有环？" class="headerlink" title="36、怎么判断链表中是否有环？"></a>36、怎么判断链表中是否有环？</h2><p>追逐方式。<br>两个指针遍历链表，一个每次走一步，一个每次走两步，若后者能追上前者，则表示有环。</p>
<h2 id="37、双向链表的插入和删除。"><a href="#37、双向链表的插入和删除。" class="headerlink" title="37、双向链表的插入和删除。"></a>37、双向链表的插入和删除。</h2><p>插入修改四个指针。<br>删除只需要修改两个。</p>
<h2 id="38、二维数组转置。"><a href="#38、二维数组转置。" class="headerlink" title="38、二维数组转置。"></a>38、二维数组转置。</h2><p>核心操作:b[j][i]=a[i][j]</p>
<h2 id="39、输入一行字符，统计其中有多少个单词。"><a href="#39、输入一行字符，统计其中有多少个单词。" class="headerlink" title="39、输入一行字符，统计其中有多少个单词。"></a>39、输入一行字符，统计其中有多少个单词。</h2><p>按空格累加。</p>
<h2 id="40、杨辉三角"><a href="#40、杨辉三角" class="headerlink" title="40、杨辉三角"></a>40、杨辉三角</h2><h2 id="41、计算字符串中子串出现的次数"><a href="#41、计算字符串中子串出现的次数" class="headerlink" title="41、计算字符串中子串出现的次数"></a>41、计算字符串中子串出现的次数</h2><p>循环比较。</p>
<h2 id="42、数组a-n-，存放1到n，找出被重复的数字，时间复杂度为O（n）"><a href="#42、数组a-n-，存放1到n，找出被重复的数字，时间复杂度为O（n）" class="headerlink" title="42、数组a[n]，存放1到n，找出被重复的数字，时间复杂度为O（n）"></a>42、数组a[n]，存放1到n，找出被重复的数字，时间复杂度为O（n）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_dup</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	sum=sum-(N<span class="number">-1</span>)(N)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43、16bit的整数，每4bit为一个数，写函数求他们的和"><a href="#43、16bit的整数，每4bit为一个数，写函数求他们的和" class="headerlink" title="43、16bit的整数，每4bit为一个数，写函数求他们的和"></a>43、16bit的整数，每4bit为一个数，写函数求他们的和</h2><p>循环，移位相加即可。<br>c+=n&15;<br>n=n&gt;&gt;4;</p>
<h2 id="47、什么函数不能声明为虚函数？"><a href="#47、什么函数不能声明为虚函数？" class="headerlink" title="47、什么函数不能声明为虚函数？"></a>47、什么函数不能声明为虚函数？</h2><p>virtual<br>a、内联函数，内联函数在编译时展开，而虚函数是运行时动态绑定，所以两者矛盾。<br>b、构造函数，构造函数用来创建一个新的对象，而虚函数运行时建立在对象基础上，在构造函数时对象尚未形成。<br>c、静态成员函数，静态成员函数属于一个类而非某一对象，没有this指针，无法进行对象的判别。<br>d、非成员函数<br>e、类的成员函数是模板函数的时候。</p>
<h2 id="48、编写一个函数作用是把char数组字符串循环右移n位"><a href="#48、编写一个函数作用是把char数组字符串循环右移n位" class="headerlink" title="48、编写一个函数作用是把char数组字符串循环右移n位"></a>48、编写一个函数作用是把char数组字符串循环右移n位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoopMove</span><span class="params">(<span class="keyword">char</span> *pstr,<span class="keyword">int</span> steps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="built_in">strlen</span>(pstr)-steps;</span><br><span class="line">	<span class="keyword">char</span> temp[MAX_LEN];</span><br><span class="line">	<span class="built_in">strcpy</span>(temp,pstr+n);</span><br><span class="line">	<span class="built_in">strcpy</span>(temp+steps,pstr);</span><br><span class="line">	*(tmp+<span class="built_in">strlen</span>(pstr))=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(pstr,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="49、编写类String的构造函数、析构函数和赋值函数。"><a href="#49、编写类String的构造函数、析构函数和赋值函数。" class="headerlink" title="49、编写类String的构造函数、析构函数和赋值函数。"></a>49、编写类String的构造函数、析构函数和赋值函数。</h2><p>一个类包含指针的话，一般会有析构函数，而且要重写拷贝构造和赋值运算符，因为默认是地址的拷贝和赋值，对指针来说无意义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	String(<span class="keyword">const</span> <span class="keyword">char</span> *str=<span class="literal">NULL</span>);</span><br><span class="line">	String(<span class="keyword">const</span> <span class="built_in">string</span> &amp;other);<span class="comment">//拷贝构造</span></span><br><span class="line">	~String();</span><br><span class="line">	String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;other);<span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="50、指向二维数组的指针1。"><a href="#50、指向二维数组的指针1。" class="headerlink" title="50、指向二维数组的指针1。"></a>50、指向二维数组的指针1。</h2><h2 id="51、指向二维数组的指针2。"><a href="#51、指向二维数组的指针2。" class="headerlink" title="51、指向二维数组的指针2。"></a>51、指向二维数组的指针2。</h2><p>注意++到底是加的一维数组还是一个元素。</p>
<h2 id="52、逗号运算符（优先级最低）"><a href="#52、逗号运算符（优先级最低）" class="headerlink" title="52、逗号运算符（优先级最低）"></a>52、逗号运算符（优先级最低）</h2><p>a=3;b=5;<br>c=a,b;<br>d=(a,b);<br>执行之后，c=3，d=5.</p>
<h2 id="53、sizeof运算符。"><a href="#53、sizeof运算符。" class="headerlink" title="53、sizeof运算符。"></a>53、sizeof运算符。</h2><p>int i=3;<br>int j;<br>j=sizeof(++i+ ++i);<br>print(“i=%d,j=%d”,i,j);<br>输出：i=3，j=4<br>原因：编译器进行优化，发现++对sizeof根本没影响，所以会优化不计算++，发生短路现象。</p>
<h2 id="54、递归展开求值。"><a href="#54、递归展开求值。" class="headerlink" title="54、递归展开求值。"></a>54、递归展开求值。</h2><h2 id="55、赋值运算符-作为循环条件。"><a href="#55、赋值运算符-作为循环条件。" class="headerlink" title="55、赋值运算符=作为循环条件。"></a>55、赋值运算符=作为循环条件。</h2><p>赋非零值，无限循环。<br>赋0，不循环。</p>
<h2 id="56、（a-b）-c与（a-c）-b是否恒等"><a href="#56、（a-b）-c与（a-c）-b是否恒等" class="headerlink" title="56、（a+b）+c与（a+c）+b是否恒等"></a>56、（a+b）+c与（a+c）+b是否恒等</h2><p>不一定，可能会溢出。假设a+b溢出，但是c是负数，a+c后再加b就不一定溢出了。<br>a+b+c一定等于b+a+c</p>
<h2 id="57、进程和线程的差别。"><a href="#57、进程和线程的差别。" class="headerlink" title="57、进程和线程的差别。"></a>57、进程和线程的差别。</h2><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>a、线程是调度分配的基本单位，进程是拥有资源的基本单位。<br>b、并发性，都可以并发。进程切换比线程切换开销大。<br>c、拥有资源，进程是拥有资源的独立单位，线程不拥有系统资源，但是可以访问所属进程的资源。<br>d、系统开销，在创建或撤销进程时，由于系统都要分配和回收资源，所以开销较大。</p>
<h2 id="58、解释const-char-const-p"><a href="#58、解释const-char-const-p" class="headerlink" title="58、解释const char * const p"></a>58、解释const char * const p</h2><p>左边是底层const，右边是顶层const。<br>char <em> const p//常量指针，p的地址不可以修改，即指针本身不可修改<br>const char </em> p;//指向常量的指针，指针本身可修改，但指向的内容不可修改。<br>char const * p;//同上<br>两个const就是指针本身不可以修改，所指内容也不可更改。</p>
<h2 id="59、memset、memcpy和strcpy的根本区别。"><a href="#59、memset、memcpy和strcpy的根本区别。" class="headerlink" title="59、memset、memcpy和strcpy的根本区别。"></a>59、memset、memcpy和strcpy的根本区别。</h2><p>memset和memcpy需要包含memory.h，strcpy需要string.h<br>memset用来对一段内存空间全部设置为某个字符 memset(a,0,sizeof(a))<br>memcpy用来内存拷贝，拷贝任何数据类型的对象 memcpy(b,a,sizeof(b))<br>strcpy只能拷贝字符串，遇到’\0’就结束，所以不需要指定大小。<br>要注意内存溢出。</p>
<h2 id="60、析构函数有何特点。"><a href="#60、析构函数有何特点。" class="headerlink" title="60、析构函数有何特点。"></a>60、析构函数有何特点。</h2><p>a、析构函数也是特殊的类成员函数，和构造函数一样没有返回类型<br>b、没有参数<br>c、不能重载<br>d、public、private、protected对析构函数无效<br>e、析构函数不能手动调用，只有在类对象生命周期结束的时候，由系统自动调用释放在构造函数中分配的资源，回收内存。<br>f、构造函数不可以是virtual，但析构函数可以。</p>
<h2 id="61、虚函数有什么用？"><a href="#61、虚函数有什么用？" class="headerlink" title="61、虚函数有什么用？"></a>61、虚函数有什么用？</h2><p>a、虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没覆盖调用父类中的函数，从而实现灵活扩展和多态性。<br>b、如果是纯虚函数，则纯粹是为了在子类覆盖时有个统一的命名而已，子类必须覆盖纯虚函数，否则子类也是抽象类<br>c、含有纯虚函数的类称为抽象类，不能实例化对象，主要用于做接口</p>
<h2 id="62、虚析构函数的作用"><a href="#62、虚析构函数的作用" class="headerlink" title="62、虚析构函数的作用"></a>62、虚析构函数的作用</h2><p>虚构函数调用是先子后父。<br>当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，就会导致运行时派生类不会被销毁，然而基类部分已经被销毁，这就导致了部分析构，造成内存泄露。<br>此时就需要给基类一个虚析构函数。</p>
<h2 id="63、分别给出bool、in、float、指针变量与零值比较的if语句"><a href="#63、分别给出bool、in、float、指针变量与零值比较的if语句" class="headerlink" title="63、分别给出bool、in、float、指针变量与零值比较的if语句"></a>63、分别给出bool、in、float、指针变量与零值比较的if语句</h2><p>bool:if(!var)<br>int:if(var==0)<br>float: const float var=0.000001;<br>​    if(x&gt;-var &amp;&amp; x&lt;var)<br>浮点数不能精确到0，所以需要在一个范围内近似看做0<br>指针：if(var==NULL)</p>
<h2 id="64、32位下，计算sizeof"><a href="#64、32位下，计算sizeof" class="headerlink" title="64、32位下，计算sizeof"></a>64、32位下，计算sizeof</h2><p>a、<br>void fun(char str[100])<br>{<br>sizeof(str)=?//4<br>}<br>原因：数组做函数形参，会转化成指针<br>b、<br>void <em>p=malloc(100);<br>sizeof(p) //4<br>c、<br>int a[100]<br>sizeof(a)//4</em>100<br>d、<br>char *p=”aaa”<br>sizeof(p)=?//4</p>
<h2 id="65、写函数返回1-2-3-。。-n的值"><a href="#65、写函数返回1-2-3-。。-n的值" class="headerlink" title="65、写函数返回1+2+3+。。+n的值"></a>65、写函数返回1+2+3+。。+n的值</h2><p>解法1：一重循环<br>解法2：利用高斯公式直接求 （1+n）*n/2</p>
<h2 id="66、深度广度遍历二叉树。"><a href="#66、深度广度遍历二叉树。" class="headerlink" title="66、深度广度遍历二叉树。"></a>66、深度广度遍历二叉树。</h2><h2 id="67、内联函数和普通函数的区别。"><a href="#67、内联函数和普通函数的区别。" class="headerlink" title="67、内联函数和普通函数的区别。"></a>67、内联函数和普通函数的区别。</h2><p>a、内联函数是将简单函数内嵌道调用它的程序代码中，目的是节约原本函数调用时的时空开销，不能含有循环、条件、选择等复杂的结构。<br>b、内联函数和宏的区别，宏是由预处理器对宏进行替代，而内联函数是通过编译器来控制的。内联函数是真正的函数，取消了函数的参数压栈，减少调用开销，不用担心像宏函数的问题。<br>c、用inline定义内联函数，任何在类的说明部分定义的函数都会自动认为是内联函数。</p>
<h2 id="68、c-重写和重载重定义区别"><a href="#68、c-重写和重载重定义区别" class="headerlink" title="68、c++重写和重载重定义区别"></a>68、c++重写和重载重定义区别</h2><p>a、重载特征：相同的范围（同一个类），函数名字相同，参数不同<br>b、重写（覆盖）：派生类函数覆盖基类函数，分别位于基类和派生类中，名字相同，参数相同，基类函数必须有virtual<br>c、重定义是指派生类的函数屏蔽了与其同名的基类函数<br>如果派生类的函数和基类的函数同名，参数不同，此时不管有无virtual，基类的函数被隐藏<br>如果派生类的函数与基类的函数同名，参数也相同，但基类没有virtual，此时基类的函数被隐藏</p>
<h2 id="69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。"><a href="#69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。" class="headerlink" title="69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。"></a>69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。</h2><p>可以的。<br>static一般在类外初始化，const一般在构造函数里初始化。<br>既是const又是static就在类外初始化，但要在类外初始化的同时声明为const。</p>
<h2 id="70、构造函数和析构函数的异同点。"><a href="#70、构造函数和析构函数的异同点。" class="headerlink" title="70、构造函数和析构函数的异同点。"></a>70、构造函数和析构函数的异同点。</h2><p>构造函数的特点：<br>1、构造函数名字与类名相同<br>2、构造函数可以有任意的参数，但不能具有返回类型<br>3、定义对象时，编译系统自动调用构造函数<br>4、够咱函数是特殊的成员函数，函数体可以在类内，也可以在类外<br>5、构造函数不能像其他成员函数那样被显示调用，它是在定义对象的同时被调用</p>
<p>析构函数的特点：<br>1、析构函数名字与类型相同，析构函数前加一个~<br>2、析构函数没有参数，也没有返回值，不能被重载，一个类只能有一个析构函数<br>3、在撤销对象时，编译系统会自动调用析构函数<br>4、析构函数可以是virtual，而构造函数不可以。</p>
<h2 id="71、自动调用拷贝构造函数的几种情形。"><a href="#71、自动调用拷贝构造函数的几种情形。" class="headerlink" title="71、自动调用拷贝构造函数的几种情形。"></a>71、自动调用拷贝构造函数的几种情形。</h2><p>拷贝构造函数是用一个已知对象来初始化另一个同类对象。<br>拷贝构造函数也是类的构造函数，与雷鸣相同，又一个该类对象引用的参数。<br>若自己不写，则会自动生成一个默认的。<br>若一个类中有指针，就需要自己写，不能用默认的，因为默认的是地址拷贝。</p>
<p>自动调用情况：<br>1当类的一个对象去初始化该类另一个对象时。<br>2如果函数形参是类的对象，调用函数进行形参和实参结合时<br>3如果函数返回值是类对象，函数返回时。</p>
<h2 id="72、类型转换构造函数是什么？"><a href="#72、类型转换构造函数是什么？" class="headerlink" title="72、类型转换构造函数是什么？"></a>72、类型转换构造函数是什么？</h2><p>自动调用类型匹配的构造函数，自动将基本数据类型转换成对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> height;</span><br><span class="line">Person(<span class="keyword">double</span> h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p=<span class="number">2.3</span>;<span class="comment">//类型转换构造函数，将2.3转换成double调用该构造函数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">类型转换函数可以产生自动类型转换匹配，如下：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">intheight;</span><br><span class="line">Person(<span class="keyword">int</span> h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span>的构造函数也可以调用成功。</span><br></pre></td></tr></table></figure></p>
<h2 id="73、异常处理方式。"><a href="#73、异常处理方式。" class="headerlink" title="73、异常处理方式。"></a>73、异常处理方式。</h2><p>步骤：<br>1、程序执行时发生错误<br>2、以一个异常对象记录错误的原因及相关信息<br>3、程序检测到这个错误（读取错误对象）<br>4、程序决定如何处理错误<br>5、错误处理，并在此后恢复或终止程序的执行</p>
<h2 id="74、成员函数和友元函数的区别"><a href="#74、成员函数和友元函数的区别" class="headerlink" title="74、成员函数和友元函数的区别"></a>74、成员函数和友元函数的区别</h2><p>a、成员函数是类定义的一部分通过特定的对象来调用。成员函数可以隐式访问对象的成员，而无须使用成员操作符<br>b、友元函数不是类的组成部分，因为被称为直接函数调用。友元函数不能隐式访问类成员，必须将成员操作符用于参数传递的对象。</p>
<h2 id="75、c-中哪些运算符不能重载"><a href="#75、c-中哪些运算符不能重载" class="headerlink" title="75、c++中哪些运算符不能重载"></a>75、c++中哪些运算符不能重载</h2><p>.<br>?:<br>sizeof（不是函数是运算符）<br>::<br><em>（指针解引用不可以重载，乘号可以）<br>.</em></p>
<h2 id="76、如何重载前-和后"><a href="#76、如何重载前-和后" class="headerlink" title="76、如何重载前++和后++"></a>76、如何重载前++和后++</h2><p>前++不带参数，后++带一个（int）以示区分<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iCount &amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">	data++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">iCount <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	iCount temp=*<span class="keyword">this</span>;</span><br><span class="line">	data++;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="77、请说出STL标准模板库中的几个常用类"><a href="#77、请说出STL标准模板库中的几个常用类" class="headerlink" title="77、请说出STL标准模板库中的几个常用类"></a>77、请说出STL标准模板库中的几个常用类</h2><p>vector<br>list<br>set<br>stack<br>queue<br>map</p>
<h2 id="78、函数模板和函数重载的异同"><a href="#78、函数模板和函数重载的异同" class="headerlink" title="78、函数模板和函数重载的异同"></a>78、函数模板和函数重载的异同</h2><p>函数重载是指函数名字相同，但是参数类型或者个数不同，顺序不同。<br>函数模板是指函数算法相同，而参数类型不同。</p>
<h2 id="79、类型转换构造函数是什么？"><a href="#79、类型转换构造函数是什么？" class="headerlink" title="79、类型转换构造函数是什么？"></a>79、类型转换构造函数是什么？</h2><p>是隐式调用构造函数，将基本数据类型转换成对象。<br>对象不可转换成基本数据类型。</p>
<h2 id="80、c-中explicit关键字有什么用。"><a href="#80、c-中explicit关键字有什么用。" class="headerlink" title="80、c++中explicit关键字有什么用。"></a>80、c++中explicit关键字有什么用。</h2><p>explicit和构造函数一起使用，指明构造函数只能显式调用，目的是为了防止不必要的隐式调用类型转换构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> height;</span><br><span class="line">explicit Person(double h):height(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p=<span class="number">2.3</span>;<span class="comment">//会报错，因为explicit阻止了隐式调用，必须显式调用</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">2.4</span>)</span></span>;<span class="comment">//显示调用，可以</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="81、c-中restrict关键字有什么作用？"><a href="#81、c-中restrict关键字有什么作用？" class="headerlink" title="81、c++中restrict关键字有什么作用？"></a>81、c++中restrict关键字有什么作用？</h2><p>是用来优化的，是c99新加的关键字。<br>restrict只能修饰指针，修饰的指针时能够访问所指区域的唯一入口，限制多个指针指向同一地址。<br>如果两个指针指向同一个地址，一个被释放了，另一个就成了野指针。</p>
<h2 id="82、c-中常用的设计模式又哪些？"><a href="#82、c-中常用的设计模式又哪些？" class="headerlink" title="82、c++中常用的设计模式又哪些？"></a>82、c++中常用的设计模式又哪些？</h2><p>工厂方法<br>策略模式<br>单例模式<br>迭代器模式<br>抽象工厂模式<br>建造者模式<br>适配器模式<br>桥接模式<br>折磨死<br>解释器模式<br>命令模式<br>中介者模式<br>观察者陌生<br>状态模式<br>代理模式</p>
<h2 id="83、写一个单例模式的例子。"><a href="#83、写一个单例模式的例子。" class="headerlink" title="83、写一个单例模式的例子。"></a>83、写一个单例模式的例子。</h2><p>其目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。比如定义常量的类。<br>将构造函数私有。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	C()&#123;&#125;;<span class="comment">//构造函数私有</span></span><br><span class="line">	<span class="keyword">static</span> C * p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> C * <span class="title">Get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">			p=<span class="keyword">new</span> C();</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">C * C::p==<span class="literal">NULL</span>;<span class="comment">//static属性类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C* p1=C::get();</span><br><span class="line">	C* p2=C::get();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;(p1==p2)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="84、面向对象的三大特征。"><a href="#84、面向对象的三大特征。" class="headerlink" title="84、面向对象的三大特征。"></a>84、面向对象的三大特征。</h2><p>a、封装<br>b、继承<br>c、多态</p>
<h2 id="85、什么是封装"><a href="#85、什么是封装" class="headerlink" title="85、什么是封装"></a>85、什么是封装</h2><p>封装是面向对象的特征之一，是对象和类概念的主要特性。<br>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<br>c++中，public、protected、private就是封装的访问权限说明符。</p>
<h2 id="86、什么是继承"><a href="#86、什么是继承" class="headerlink" title="86、什么是继承"></a>86、什么是继承</h2><p>继承可以使现有类的所有功能，并在无需重新编写原来类的情况下对功能进行扩展。<br>c++支持单继承和多继承，也有多级继承。<br>用public、protected和private修饰继承特性。</p>
<h2 id="87、什么是多态"><a href="#87、什么是多态" class="headerlink" title="87、什么是多态"></a>87、什么是多态</h2><p>polymorphisn<br>允许将父对象设置成为一个或更多的他的子对象相等的技术。<br>父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。<br>父类的指针用引用赋子类的值。<br>两种方式，覆盖（重写），重载。<br>覆盖，子类重新定义父类的virtual虚函数。<br>重载，允许存在多个同名函数，但参数列表不同。</p>
<h2 id="88、类和对象的区别。"><a href="#88、类和对象的区别。" class="headerlink" title="88、类和对象的区别。"></a>88、类和对象的区别。</h2><p>是一般与个别、抽象与具体、集体与个体的区别。<br>举个例子即可（人类和张三）</p>
<h2 id="89、c-中的namespace是什么？"><a href="#89、c-中的namespace是什么？" class="headerlink" title="89、c++中的namespace是什么？"></a>89、c++中的namespace是什么？</h2><p>命名空间，类似于java中的包<br>避免在不同程序库中的命名冲突。<br>详看c++ primer</p>
<h2 id="90、什么是可重入和不可重入函数？"><a href="#90、什么是可重入和不可重入函数？" class="headerlink" title="90、什么是可重入和不可重入函数？"></a>90、什么是可重入和不可重入函数？</h2><p>可重入性：reentrant<br>函数可以由多于一个任务并发使用，而不必担心数据错误，可以在任意时刻被中断，稍后再继续运行不会丢失数据。<br>不可重入函数不能超过一个任务所共享。</p>
<p>可重入函数：<br>不为连续的调用持有静态数据<br>不返回指向静态数据的指针<br>使用本地数据<br>如果必须访问全局变量需要利用互斥信号量<br>不调用不可重入函数</p>
<p>不可重入函数：<br>使用了静态变量<br>返回静态变量<br>调用了不可重入函数<br>调用了malloc或free<br>调用了其他标准i/o</p>
<p>总的来说，一个函数使用了未受保护的共享资源，就不可重入。</p>
<h1 id="hash函数、数据库基本"><a href="#hash函数、数据库基本" class="headerlink" title="hash函数、数据库基本"></a>hash函数、数据库基本</h1><p>hash函数性质：输入域巨大，输出域固定<br>1、输入域无限<br>2、相同输入，结果相同<br>3、不通输入，结果可能相同也可能不同<br>4、不同输入值得到的hash值，均匀分布在输出域上（优劣评判）</p>
<p>32位无符号整数范围，0到40一亿左右。    </p>
<p>第一范式：每一个分量都是不可分的数据项。<br>第二范式：每一个非主属性完全函数依赖于任何一个候选码。<br>第三范式：每一个非主属性既不传递依赖于码，也不部分依赖于码。<br>BCNF：若每一个决定因素都包含码。<br>一个满足BCNF的关系模式有：<br>所有非主属性对每一个码都是完全函数依赖。<br>所有主属性对每一个不包含它的码也是完全函数依赖。<br>没有任何属性完全函数依赖于非码的任何一组属性。</p>
<p>事务的ACID特性<br>原子性：事务中的操作要么都做，要么都不做。<br>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。<br>隔离性：一个事务的执行不能被其他事务干扰。<br>持续性：事务一旦提交，它对数据库中数据的改变就应是永久性的。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>1、网络协议主要由三要素组成：语法、语义和 同步。</p>
<p>2、osi体系结构<br>物理层：单位bit，为上层提供了传输数据的物理介质。<br>数据链路层：单位帧，在不可靠的物理介质上提供可靠的传输。HDLC、PPP。<br>网络层：单位分组或数据包，负责对子网间的数据包进行路由选择。IP。<br>传输层：单位报文，是第一个端到端即进程到进程的层次，提供端到端的传输。TCP、UDP。<br>会话层：负责建立、管理、终止进程之间的会话。<br>表示层：进行数据转换，包括加密、压缩、格式转换等。<br>应用层：为操作系统或网络应用程序提供网络服务的接口。FTP、HTTP。</p>
<p>tcp/ip体系结构：网络接口层、网际层、传输层和应用层。<br>五层体系结构就是把网络接口层依然分解为物理层和数据链路层。</p>
<p>3、数据链路层三个基本问题：数据成帧，透明传输，差错检测。<br>CRC检验码的位数就是生成多项式的最高次数。</p>
<p>4、路由器分组转发流程<br>a、从分组首部提取目的站的IP地址D，得出目的网络地址为N<br>b、若网络N与此路由器直接相连，则直接将分组交付给目的站D，否则转到c<br>c、若路由表中有目的地址为D的特定主机路由，则将分组传送给路由表中所指明的下一跳路由器，否则转d<br>d、若路由表有到达网络N的路由，则将分组传送给路由器表指明的下一跳路由器，否则转e<br>e、若路由表中有一个默认路由，则将分组传送到默认路由，否则报错。</p>
<p>5、ping的过程<br>ping是ICMP的一个重要应用。<br>ping同一个网段的主机：查找目的主机的mac地址，然后直接交付。如果没查到mac地址，就进行一次arp请求。<br>ping不同网段的主机：发送到网关让其进行转发，同样要发送到网关也得知道网关的mac地址，根据mac地址进行转发。</p>
<p>6、三块专用地址<br>A类：10.0.0.0 ~ 10.255.255.255<br>B类：172.16.0.0 ~ 172.31.255.255<br>C类：192.168.0.0 ~ 192.168.255.255</p>
<p>7、用户数据包协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。</p>
<p>传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）</p>
<p>8、web页面请求过程<br>a、向DNS服务器发送DNS查询报文解析域名获得IP地址。<br>b、通过TCP向服务器发送连接请求。<br>c、服务器上会有个服务进程在不断监听80端口，当监听到连接请求后便与浏览器建立连接。建立之后服务器会随机分配一个端口号给客户端，之后的tcp传输都用这个分配的客户端。<br>d、TCP建立后，浏览器向服务器放松要求获取某一Web页面的http请求。<br>e、服务器收到http请求后构建所需信息，通过HTTP响应返回给浏览器。<br>f、浏览器将信息进行解析并渲染，显示页面。最后会断开tcp连接。</p>
<h1 id="HTTP部分"><a href="#HTTP部分" class="headerlink" title="HTTP部分"></a>HTTP部分</h1><p>1、get和post的请求都能使用额外的参数，但是get的参数是以查询字符串出现在url中，而post的参数存储在实体主体部分。<br>get的传参方式相比于post安全性较差，因为get传的参数在url是可见的，可能会谢露私密信息。并且get只支ASCII字符，如果参数为中文则可能会出现乱码，而post支持标准字符集。<br>get的主要目的是获取资源，而post的主要目的是传输实体主体数据。</p>
<p>head和get一样，但是不返回报文实体主体部分。<br>put不带验证机制，存在安全问题。<br>delete作用和put相反。<br>trace追踪路径<br>connect要求用隧道协议连接代理，加密后经过隧道传输。</p>
<p>状态码：<br>1xx：信息性状态码<br>2xx：成功<br>3xx：重定向<br>4xx：客户端错误<br>5xx：服务器错误</p>
<p>四种类型首部字段：<br>通用首部、请求首部、响应首部和实体首部</p>
<p>HTTP协议是无状态的，主要是为了让HTTP协议尽可能简单，使得它能够处理大量事务。HTTP/1.1引入Cookie来保存状态信息。</p>
<p>Cookie信息存在浏览器上。</p>
<p>Session和Cookie区别<br>Session是服务器用来跟踪用户的一种手段，每个Session都有一个唯一标识Session ID。<br>当服务器创建一个Session时，给客户端发送的响应报文就包含了Set-Cookie字段，其中有个名为sid的键值对，这就是Session ID。当客户端收到后就把Cookie保存在浏览器中，并且之后发送的请求报文都包含Session ID。<br>HTTP就是通过Session和Cookie一起合作实现跟踪用户状态的，Session用于服务器端，Cookie用于客户端。</p>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。 持久连接 只需要进行一次 TCP 连接就能进行多次 HTTP 通信。HTTP/1.1 开始，所有的连接默认都是持久连接。</p>
<p>持久连接需要使用Connection首部字段进行管理。<br>HTTP1.1开始HTTP默认是持久连接，若要关闭需要客户端或服务端提出断开，使用connection：close。<br>而在HTTP1.1之前默认是非持久连接，若要持久连接则需要使用keep-alive。</p>
<p>代理服务器不会改变url，主要目的是缓存、网络访问控制以及访问日志记录。<br>网关服务器则不同，会将HTTP转化为其他协议进行通信，从而请求非HTTP服务器。</p>
<p>隧道：使用SSL等加密手段，为客户端和服务器之间建立一条安全的通信线路。</p>
<p>HTTP安全问题：<br>1、使用明文进行通信，内容可能会被窃听<br>2、不验证通信方的身份，通信方的身份可能遭遇伪装<br>3、无法证明报文的完整性，报文有可能被篡改。</p>
<p>HTTPS并不是新协议，而是HTTP先和SSL通信，再由SSL和TCP通信，提供了加密、认证和完整性保护。</p>
<p>加密：HTTPs使用混合加密机制，使用公钥加密用于传输信息的对称秘钥，之后使用对称秘钥进行通信。<br>对称秘钥的缺点：无法安全传输秘钥本身。<br>公钥缺点：更耗时。</p>
<p>认证使用证书。<br>SSL提供摘要功能来验证完整性。</p>
<p>HTTP/1.1新增内容：<br>1、默认为持久连接<br>2、提供了范围请求功能<br>3、提供了虚拟主机功能<br>4.、多了一些缓存处理字段<br>5、多了一些状态码</p>
<h1 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h1><p>操作系统基本特征：并发、共享、虚拟、异步</p>
<p>进程和线程的区别：<br>1、进程是除CPU外资源分配的基本单位，但是线程不拥有资源，线程访问隶属进程的资源<br>2、调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程内的线程时，会引起进程切换。<br>3、系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，所付出的开销远大于创建或撤销线程时的开销。类似的，在进程切换时，涉及到当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。<br>4、通信方面：进程间通信需要进程同步和异步手段的辅助，以保证数据的一致性。而进程内部通信可以通过直接读/写同一进程中的数据段来进行通信。</p>
<p>windows进程间通信：管道、共享内存、消息队列，信号量，socket<br>Windows线程间通信：临界区、互斥量、信号量和事件。</p>
<p>临界区与互斥体的区别<br>1、临界区只能用来同步本进程内的线程，而不能同步多个进程中的线程。互斥量、信号量、事件都可以跨越进程使用来进行同步数据操作。<br>2、临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。<br>3、临界区和互斥体在windows平台下都可用。</p>
<p>死锁的必要条件：<br>1、互斥条件<br>2、占有和等待<br>3、不剥夺条件<br>4、循环等待<br>死锁防止策略：<br>打破1，可同时访问<br>打破2，进程执行前申请需要的全部资源，在执行过程中不再申请资源<br>打破3，占有资源的进程若要申请新资源，必须主动释放已占用资源<br>打破4，层次分配。</p>
<p>死锁避免：银行家算法</p>
<p>分段分页的区别：<br>1、分页透明，分区需要程序员显式划分每个段。<br>2、分页是一维地址，分段是二维地址。<br>3、页的大小不可变，而段的大小可以动态改变。<br>4、分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了让程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
<h1 id="内存池、Nginx"><a href="#内存池、Nginx" class="headerlink" title="内存池、Nginx"></a>内存池、Nginx</h1><p>内存池可以减少内存碎片、避免内存泄露，提高内存分配效率。</p>
<p>通常我们习惯直接使用new、malloc等API申请分配内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。</p>
<p>Nginx（发音同 engine x）是一款轻量级的Web 服务器／反向代理服务器及电子邮件（IMAP/POP3）代理服务器</p>
<p>Nginx提供的负载均衡有两种：内置策略和扩展策略。<br>内置策略微轮询，加权轮询，IP hash。<br>扩展策略url hash</p>
<h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>目的：因为阻塞模型在没有收到数据的时候就会阻塞卡住，如果一次需要接受多个socket fd的时候，就会导致必须处理完前面的fd，才能处理后面的fd，即使可能后面的fd比前面的fd还要先准备好，所以这样就会造成客户端的严重延迟。为了处理多个请求，我们自然先想到用多线程来处理多个socket fd，但是这样又会启动大量的线程，造成资源的浪费，所以这个时候就出现了io多路复用技术。就是用一个进程来处理多个fd的请求。</p>
<p>与多进程/多线程相比，IO多路复用最大的好处就是系统开销小。</p>
<p>1应用层数据到kernel<br>2 kernel复制到user space<br>阻塞io模型就是将这个两个过程合并在一起，一起阻塞。非阻塞就是第一个不阻塞，而是不断轮询，第二个仍然阻塞。</p>
<p>select：<br>程序呼叫select，然后整个程序就阻塞了，这个时候kernel就会轮询检查所有select负责的fd，当找到其中一个client的数据准备好了，select就会返回，这个时候程序启动系统调用，将数据从kernel复制到进程缓冲区。</p>
<p>poll<br>原理和select十分相似，差别如下：<br>描述fd集合的方式不同，poll没使用select的fd_set结构，所以poll是链式的，没有最大连接数的限制。<br>poll有个特点是水平触发，也就是通知fd就绪后，如果这次没有被处理，那么下次poll的时候会再次通知同个fd已经就绪。</p>
<p>select缺点：<br>1fd_size大小为32个整数（32位机器上就是32*32，1024bit），每个fd一个bit，所以最大只能处理1024个fd</p>
<p>2每一次呼叫select都要从user space把fd_set复制到kernel中，因为每一次呼叫前，set都可能有变动，而epoll提供了共享记忆存储结构。</p>
<p>3kernel轮询每个fd，约限行时间，消耗大且效率低下。</p>
<p>epoll提供三个函数：<br>创建epoll对象，传回id<br>事件注册函数，将需要监听的事件和需要监听的fd交给epoll对象。<br>等待注册的事件被触发或timeout。等待函数。</p>
<p>epoll没有数量限制，最大数量只和系统能够打开多少fd有关。<br>epoll不需要每次都将set赋值到kernel检查，因为在注册的时候已经将fd拷贝了进来。<br>select/poll都是主动轮询，而epoll是被动，它不仅可以知道有fd就绪，还可以知道是哪个fd就绪，直接处理。（类比轮询和中断方式。）</p>
<h1 id="3-12"><a href="#3-12" class="headerlink" title="3-12"></a>3-12</h1><p>nginx：异步非阻塞</p>
<p>nginx的请求处理：<br>1、操作系统提供的机制产生相关的时间<br>2、接受和处理这些事件，如果接收到数据，则产生更高层的request对象<br>3、处理request的header和body<br>4、产生响应，并发送回客户端<br>5、完成request的处理<br>6、重新初始化定时器及其他事件</p>
<h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><p>C++11新特性（很多，节选，完整看C++ Primer）<br>1、新定义long long类型，一个long long类型至少和一个long一样大。<br>2、列表初始化，就是用大括号来初始化变量。<br>3、引入新常量nullptr，用来得到或者初始化指针。<br>4、引入auto和decltype，auto一般会忽略顶层const，decltype处理顶层const和引用的方式和auto不同，他会将变量包括顶层const和引用在内的信息都返回。<br>5、范围for语句<br>6、引入了两个新函数cbegin和cend。<br>7、C++11规定商一律向0取整，不论正负。<br>8、initializer_list，参数数量未知但是全部实参类型相同时可以使用该类型，和vector类似，只是其中存储的元素都是常量，不能修改。<br>9、尾置返回类型：auto fun() -&gt; int (*)[10]，返回类型是一个指向一个十个整形数组的指针。<br>10、constexpr函数是指能够用于常量表达式的函数，函数的返回类型和所有形参类型都必须是字面值类型。<br>11、可以定义所谓的委托构造函数，使用它所属类的其他构造函数来执行它自己的初始化过程。<br>12、定义了array和forward_list，数组和单向链表。<br>13、新标准引入了三个新成员—emplace，这些操作构造而不是拷贝元素，将参数传给元素类型的构造参数。<br>14、lambda表达式<br>15、bind函数。<br>16、四个无序容器，unordere_map  unordered_set unordered_multiset  unordered_multimap，使用hash函数和==运算符<br>17、智能指针。shared_ptr允许多个指针指向同一个对象，unique_ptr则独占所指向的对象。还有一种weak_ptr的伴随类，是一种弱引用，指向shared_ptr所管理的对象，不改变引用计数。<br>18、使用=default生成默认构造函数</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>观察者模式：定义了对象间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>装饰模式：动态地将责任附加到对象上。在扩展功能上，装饰者提供了比继承更有弹性的替代方案。</p>
<p>工厂模式：<br>简单工厂：在实例化一个超类的时候，可以用它的所有子类来进行实例化，要根据具体的情况来决定使用哪个子类。<br>工厂模式：定义一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把类实例化推迟到子类。<br>抽象工厂模式：提供一个接口，用于创建相关对象家族，而不需要明确指定具体类。</p>
<p>单例模式：<br>确保一个类只有一个实例，并提供一个全局访问点。<br>使用一个私有构造器、一个私有静态变量以及一个公有静态函数来实现。</p>
<p>命令模式：将命令封装成对象，以便使用不同的命令来参数化其他对象。</p>
<p>适配器模式：将一个类的接口，转换为客户期望的另一个接口。适配器让原来不兼容的类可以合作无间。</p>
<p>外观模式：提供一个统一的接口，用来访问子系统中一群接口，从而让子系统更容易使用。</p>
<p>模板方法模式：在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。这使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>迭代器模式：提供顺序访问一个聚合对象中各个元素的方法，而不暴露聚合对象内部的表示。<br>组合模式：允许将对象组合成树形结构来表现整体/部分层次结构。组合能让客户以一致的方式处理个别对象以及组合对象。</p>
<p>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<p>复合模式：<br>MVC：视图使用组合模式、模型使用观察着模式，控制器使用策略模式。</p>
<p>主流PC机的每秒钟计算量约为10^7~10^8次，一亿次左右。</p>
<h1 id="3-14-2018"><a href="#3-14-2018" class="headerlink" title="3.14.2018"></a>3.14.2018</h1><p>C++11新标准补充：<br>1、可以用=delete定义删除的函数，删除的函数意思是：虽然声明了它们，但不能以任何方式使用它们。<br>2、新标准引入了移动构造函数和move的标准库函数。<br>3、引入了右值引用，右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。左值持久，右值短暂，不能将右值引用绑定到一个左值上。可以用static_cast显示的将一个左值转换为一个右值引用。<br>4.、标准库move函数来获得绑定到左值上的右值引用。<br>5、移动构造函数通常是noexcept。<br>6、虚函数的override指示符。<br>7、定义类为final来阻止继承。<br>8、引用折叠</p>
<h1 id="3-15、Effective-C-："><a href="#3-15、Effective-C-：" class="headerlink" title="3-15、Effective C++："></a>3-15、Effective C++：</h1><p>1、对于单纯常量，最好以const对象或enums替换#defines。对于形似函数的宏，最好改用inline函数来替换。<br>2、当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。<br>3、为内置型对象进行手工初始化，因为C++不保证初始化它们。构造函数最好使用成员初值列，而不要在构造函数体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。<br>为免除跨编译单元之初始化次序问题，请以local static对象替换non-local static对象。<br>4、编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。<br>5、带有多态性质的base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。如果不是为了作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数。<br>6、析构函数不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们或结束程序。<br>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数执行该操作。<br>7、在构造函数和析构函数中绝不要调用virtual函数。<br>8、令赋值操作符返回一个reference to *this。<br>9、确保当对象自我赋值时有良好行为，其中技术包括1比较来源对象和目标对象的地址2精心周到的语句顺序3copy and swap<br>10、copy函数应该确保复制对象内的所有成员变量以及所有base class成分。不要尝试以某个copy函数实现另一个copy函数，应该将共同机能放入第三个函数内，然后由两个copy函数分别调用它。<br>11、以对象管理资源。为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。两个常被使用RAII classes是shared_ptr和auto_ptr，前者通常是较佳选择，因为auto_ptr的copy操作会使它指向NULL。<br>12、赋值RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。<br>13、APIs往往要求访问原始资源，所以每一个RAII classes应该提供一个取得其所管理资源的方法。对原始资源的访问可能经由显式转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。<br>14、以独立语句将newed对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。<br>15、宁以pass-by-reference-to-const替换pass-by-value，但对于内置类型以及STL的迭代器和函数对象来说，pass-by-value比较好。<br>16、必须返回对象时，别妄想返回其reference。不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象。<br>17、将成员变量声明为private，这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证。protected并不比public更具封装性。<br>18、使用non-member、non-friend替换member函数。<br>19、如果一个函数的所有参数都需要类型转换，请为此采用non-member函数。<br>20、尽可能延后变量定义式的出现时间。<br>21、尽量少做转型动作，四种类型转换。<br>const_cast，转变对象的常量性，是唯一能将对象的常量性移除的C++转型操作符。<br>dynamic_cast：安全向下转型，唯一无法由旧式语法执行的动作。<br>reinterpret_cast：执行低级转型，强转。<br>static_cast:强迫隐式转换。<br>22、避免返回reference、pointer、iterator指向对象内部成分。<br>23、异常安全函数提供三个保证之一：<br>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。<br>强烈保证：如果异常被抛出、程序状态不会改变。如果函数成功，就是完全成功，如果函数失败，程序会回复到调用函数之前的状态。<br>不抛掷保证：承诺绝不抛出异常。<br>24、inline函数：会导致代码膨胀<br>inline只是一个申请，不是强制命令。<br>不能是virtual<br>通过函数指针而进行的调用可能也不会被inline<br>不要只因为function templates出现在头文件，就将他们声明为inlines。</p>
<h1 id="3-16、effective-C"><a href="#3-16、effective-C" class="headerlink" title="3-16、effective C++"></a>3-16、effective C++</h1><p>1、支持编译依存性最小化的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是handle classes和interface classes。程序库头文件应该以完全且仅有声明式的形式存在。这种做法不论是否涉及templates都试用。<br>2、public继承意味is-a，适用于base classes身上的每一件事情一定也适用于derived classes身上，每一个derived class对象也都是一个base class对象。<br>3、派生类内的名称会遮掩基类内的名称。在public继承下从来没有人希望如此。为了让被遮掩的名称再见天日，可使用using声明式。<br>4、接口继承与实现继承不同，在public继承下，derived classes纵使继承base classes的接口。<br>纯虚函数只具体指定接口继承。<br>非纯虚函数具体指定接口继承以及缺省的实现继承。<br>非虚函数指定接口继承和强制性实现继承。<br>5、绝不重新定义继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数是动态绑定。<br>6、复合的意义和public继承完全不同。在应用域，复合意味has-a，在实现域，复合意味着is-implemented-in-terms-of。<br>7、private继承意味is-implemented-in-terms-of，通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。<br>8、谨慎使用多重继承。如果virtual base classes不带任何数据，将是最具实用价值的情况。<br>9、TMP模板元编程是编写template-based C++程序并执行于编译期的过程，可以将工作由运行期移到编译期，因为得以实现早期错误侦测和更高的执行效率。<br>10、operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0bytes申请。operator delete应该在收到null指针时不做任何事。class专属版本还应该能够处理比正确大小更大的错误申请。<br>11、当你写一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，可能会发生隐微而时断时续的内存泄露。当你声明placement new 和placement delete，请不要无意识的遮掩他们的正常版本。</p>
<h1 id="3-18更新"><a href="#3-18更新" class="headerlink" title="3-18更新"></a>3-18更新</h1><p>redis<br>redis是速度非常快的非关系型内存键值数据库，可以存储五种不同类型之间的映射。<br>五种数据类型：<br>字符串string、列表list、集合set、有序集合zset、散列表hash。</p>
<p>键的过期时间：<br>redis可以为每个键设置过期时间，时间一到，自动删除。<br>但对于散列表，只能为整个散列表设置过期时间，而不能为键里面的单个元素设置过期时间。</p>
<p>redis最简单的事务实现方式是使用multi和exec命令将事务操作包裹起来。</p>
<p>持久化：<br>1、快照持久化<br>2、aof持久化</p>
<p>复制：<br>slave of host port命令来让一个服务器成为另一个服务器的从服务器<br>1、从服务器连接主服务器的过程<br>a、主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令。<br>b、从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令<br>c、主服务器每执行一次写命令，就向从服务器发送相同的写命令。<br>2、主从链<br>当负载不断增多时，可以创建中间层分担主服务器的复制工作。</p>
<p>分片<br>通过对数据进行分片，用户可以将数据存储到多台机器里面。<br>客户端分片：一致性hash<br>代理分片：将客户端请求发送到代理上，由代理转发<br>服务器分片：redis cluster</p>
<p>redis适用场景：<br>缓存、消息队列、计数器、好友关系</p>
<h1 id="h文件，-lib文件以及-dll文件"><a href="#h文件，-lib文件以及-dll文件" class="headerlink" title=".h文件，.lib文件以及.dll文件"></a>.h文件，.lib文件以及.dll文件</h1><p>头文件的作用是声明函数接口，用于编译阶段。<br>dll文件是函数可执行代码，用于运行阶段。<br>lib文件告诉编译器调用的函数在哪个dll文件中以及在该dll文件中哪个位置。是h和dll的桥梁。如果生成静态库文件，则没有dll，只有lib，这时函数的可执行代码也在lib中。用于链接阶段。</p>
<p>静态链接库和动态链接库的区别：<br>a、静态链接库就是把用到的函数代码直接链接进目标程序，程序运行的时候不再需要其他库文件。动态链接库就是把调用的函数所在文件模块和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从dll中寻找相应代码，因此需要dll的支持。<br>b、如果采用静态链接的方式，则无论你愿不愿意，lib中的指令都全部被包含在最终生成的exe文件中，所以会导致应用程序比较大。但如果使用动态链接库，该dll最终不会被包含在exe中，exe执行时动态的引用和卸载该dll文件。<br>c、静态链接库中不能再包含其他静态库或动态库，而动态链接库中可以包含其他动态或静态链接库。</p>
<p>dll的用法：<br>a、使用h、lib以及dll。<br>b、直接用dll，此时需要利用win32 的api函数LoadLibrary和GetProcAddress把函数指针取出来再用。</p>
<h1 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B-B+树"></a>B-B+树</h1><p>B-树：<br>B-树是一种平衡的多路查找树，在文件系统中很有用。<br>一棵m阶的B树，或者是一棵空树，或者是满足下列特性的m叉树：<br>1、树中每个结点至多有m棵子树<br>2、若根结点不是叶子结点，则至少有量棵子树<br>3、除根之外的所有非终端结点至少有m/2上限整数棵子树<br>4、所有非终端结点包含下列信息数据（n,A0,K1,A1,K2，A2……Kn，An）<br>5、所有的叶子结点都出现在同一层次上，并且不带信息。</p>
<p>B树的插入删除，看书。</p>
<p>B+树和B-树差异在于：<br>1、有n棵子树的结点中含有n个关键字<br>2、所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
            <a href="/tags/刷题/" rel="tag"># 刷题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/31/王道笔记/" rel="next" title="王道程序员面试宝典笔记">
                <i class="fa fa-chevron-left"></i> 王道程序员面试宝典笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/31/未完待续-壹/" rel="prev" title="未完待续-壹">
                未完待续-壹 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjgzMy8xMzM2OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ZRainy</p>
              <p class="site-description motion-element" itemprop="description">故事没结束，别急着去哭</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#90道"><span class="nav-number">1.</span> <span class="nav-text">90道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、引用和指针的区别。"><span class="nav-number">1.1.</span> <span class="nav-text">1、引用和指针的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、值传递、地址传递、引用传递的区别。"><span class="nav-number">1.2.</span> <span class="nav-text">2、值传递、地址传递、引用传递的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、static的作用"><span class="nav-number">1.3.</span> <span class="nav-text">3、static的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、const关键字的用处"><span class="nav-number">1.4.</span> <span class="nav-text">4、const关键字的用处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、链表和数组的区别。"><span class="nav-number">1.5.</span> <span class="nav-text">5、链表和数组的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、直接实现strlen（）"><span class="nav-number">1.6.</span> <span class="nav-text">6、直接实现strlen（）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、直接实现strstr-char-str-char-sub-搜寻子串的函数"><span class="nav-number">1.7.</span> <span class="nav-text">7、直接实现strstr(char str,char sub)搜寻子串的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、直接实现strcat-char-str1-char-str2"><span class="nav-number">1.8.</span> <span class="nav-text">8、直接实现strcat(char str1,char str2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、直接实现strcmp-char-str1-char-str2"><span class="nav-number">1.9.</span> <span class="nav-text">9、直接实现strcmp(char str1,char str2)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、请给出函数指针数组等定义"><span class="nav-number">1.10.</span> <span class="nav-text">10、请给出函数指针数组等定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、给定一个整形变量a，设置或清除bit-N"><span class="nav-number">1.11.</span> <span class="nav-text">11、给定一个整形变量a，设置或清除bit N</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、C-中的空类，默认产生哪些成员函数"><span class="nav-number">1.12.</span> <span class="nav-text">12、C++中的空类，默认产生哪些成员函数.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、struct和class的区别"><span class="nav-number">1.13.</span> <span class="nav-text">13、struct和class的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、内存思考题"><span class="nav-number">1.14.</span> <span class="nav-text">14、内存思考题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15、关键字volatile有什么含义"><span class="nav-number">1.15.</span> <span class="nav-text">15、关键字volatile有什么含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16、读写绝对地址"><span class="nav-number">1.16.</span> <span class="nav-text">16、读写绝对地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17、heap与stack的区别"><span class="nav-number">1.17.</span> <span class="nav-text">17、heap与stack的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18、不借助第三个数交换两个数的值。"><span class="nav-number">1.18.</span> <span class="nav-text">18、不借助第三个数交换两个数的值。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19、用宏定义写出swap（x，y）"><span class="nav-number">1.19.</span> <span class="nav-text">19、用宏定义写出swap（x，y）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20、用宏定义返回两个参数中较小的一个"><span class="nav-number">1.20.</span> <span class="nav-text">20、用宏定义返回两个参数中较小的一个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21、带参数的宏和带参数的函数的区别"><span class="nav-number">1.21.</span> <span class="nav-text">21、带参数的宏和带参数的函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22、定义宏，求出数组元素的个数"><span class="nav-number">1.22.</span> <span class="nav-text">22、定义宏，求出数组元素的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23、两个栈实现一个队列的功能"><span class="nav-number">1.23.</span> <span class="nav-text">23、两个栈实现一个队列的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24、在c-中调用c函数，为什么要加extern-c"><span class="nav-number">1.24.</span> <span class="nav-text">24、在c++中调用c函数，为什么要加extern c?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25、找出程序中的错误"><span class="nav-number">1.25.</span> <span class="nav-text">25、找出程序中的错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26、一句话判断x是否是2的次幂"><span class="nav-number">1.26.</span> <span class="nav-text">26、一句话判断x是否是2的次幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27、按要求定义变量"><span class="nav-number">1.27.</span> <span class="nav-text">27、按要求定义变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28、malloc分配内存"><span class="nav-number">1.28.</span> <span class="nav-text">28、malloc分配内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29、对数组名取地址"><span class="nav-number">1.29.</span> <span class="nav-text">29、对数组名取地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30、static修饰局部变量"><span class="nav-number">1.30.</span> <span class="nav-text">30、static修饰局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31、switch。。。case接受哪种基本数据类型？省略break会怎样？"><span class="nav-number">1.31.</span> <span class="nav-text">31、switch。。。case接受哪种基本数据类型？省略break会怎样？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32、无符号数据类型转换"><span class="nav-number">1.32.</span> <span class="nav-text">32、无符号数据类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33、算出一个字节中被置1的位个数"><span class="nav-number">1.33.</span> <span class="nav-text">33、算出一个字节中被置1的位个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34、编写函数将给定的字符串转换成整数。"><span class="nav-number">1.34.</span> <span class="nav-text">34、编写函数将给定的字符串转换成整数。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35、将整数转换成字符串。"><span class="nav-number">1.35.</span> <span class="nav-text">35、将整数转换成字符串。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36、怎么判断链表中是否有环？"><span class="nav-number">1.36.</span> <span class="nav-text">36、怎么判断链表中是否有环？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37、双向链表的插入和删除。"><span class="nav-number">1.37.</span> <span class="nav-text">37、双向链表的插入和删除。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38、二维数组转置。"><span class="nav-number">1.38.</span> <span class="nav-text">38、二维数组转置。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39、输入一行字符，统计其中有多少个单词。"><span class="nav-number">1.39.</span> <span class="nav-text">39、输入一行字符，统计其中有多少个单词。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40、杨辉三角"><span class="nav-number">1.40.</span> <span class="nav-text">40、杨辉三角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41、计算字符串中子串出现的次数"><span class="nav-number">1.41.</span> <span class="nav-text">41、计算字符串中子串出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42、数组a-n-，存放1到n，找出被重复的数字，时间复杂度为O（n）"><span class="nav-number">1.42.</span> <span class="nav-text">42、数组a[n]，存放1到n，找出被重复的数字，时间复杂度为O（n）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43、16bit的整数，每4bit为一个数，写函数求他们的和"><span class="nav-number">1.43.</span> <span class="nav-text">43、16bit的整数，每4bit为一个数，写函数求他们的和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47、什么函数不能声明为虚函数？"><span class="nav-number">1.44.</span> <span class="nav-text">47、什么函数不能声明为虚函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48、编写一个函数作用是把char数组字符串循环右移n位"><span class="nav-number">1.45.</span> <span class="nav-text">48、编写一个函数作用是把char数组字符串循环右移n位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49、编写类String的构造函数、析构函数和赋值函数。"><span class="nav-number">1.46.</span> <span class="nav-text">49、编写类String的构造函数、析构函数和赋值函数。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50、指向二维数组的指针1。"><span class="nav-number">1.47.</span> <span class="nav-text">50、指向二维数组的指针1。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51、指向二维数组的指针2。"><span class="nav-number">1.48.</span> <span class="nav-text">51、指向二维数组的指针2。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52、逗号运算符（优先级最低）"><span class="nav-number">1.49.</span> <span class="nav-text">52、逗号运算符（优先级最低）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53、sizeof运算符。"><span class="nav-number">1.50.</span> <span class="nav-text">53、sizeof运算符。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54、递归展开求值。"><span class="nav-number">1.51.</span> <span class="nav-text">54、递归展开求值。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55、赋值运算符-作为循环条件。"><span class="nav-number">1.52.</span> <span class="nav-text">55、赋值运算符=作为循环条件。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56、（a-b）-c与（a-c）-b是否恒等"><span class="nav-number">1.53.</span> <span class="nav-text">56、（a+b）+c与（a+c）+b是否恒等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57、进程和线程的差别。"><span class="nav-number">1.54.</span> <span class="nav-text">57、进程和线程的差别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58、解释const-char-const-p"><span class="nav-number">1.55.</span> <span class="nav-text">58、解释const char * const p</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59、memset、memcpy和strcpy的根本区别。"><span class="nav-number">1.56.</span> <span class="nav-text">59、memset、memcpy和strcpy的根本区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60、析构函数有何特点。"><span class="nav-number">1.57.</span> <span class="nav-text">60、析构函数有何特点。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61、虚函数有什么用？"><span class="nav-number">1.58.</span> <span class="nav-text">61、虚函数有什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62、虚析构函数的作用"><span class="nav-number">1.59.</span> <span class="nav-text">62、虚析构函数的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63、分别给出bool、in、float、指针变量与零值比较的if语句"><span class="nav-number">1.60.</span> <span class="nav-text">63、分别给出bool、in、float、指针变量与零值比较的if语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64、32位下，计算sizeof"><span class="nav-number">1.61.</span> <span class="nav-text">64、32位下，计算sizeof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65、写函数返回1-2-3-。。-n的值"><span class="nav-number">1.62.</span> <span class="nav-text">65、写函数返回1+2+3+。。+n的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66、深度广度遍历二叉树。"><span class="nav-number">1.63.</span> <span class="nav-text">66、深度广度遍历二叉树。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67、内联函数和普通函数的区别。"><span class="nav-number">1.64.</span> <span class="nav-text">67、内联函数和普通函数的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68、c-重写和重载重定义区别"><span class="nav-number">1.65.</span> <span class="nav-text">68、c++重写和重载重定义区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。"><span class="nav-number">1.66.</span> <span class="nav-text">69、一个数据成员是否可以既是const又是static，为什么？如果可以，如何初始化。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#70、构造函数和析构函数的异同点。"><span class="nav-number">1.67.</span> <span class="nav-text">70、构造函数和析构函数的异同点。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#71、自动调用拷贝构造函数的几种情形。"><span class="nav-number">1.68.</span> <span class="nav-text">71、自动调用拷贝构造函数的几种情形。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72、类型转换构造函数是什么？"><span class="nav-number">1.69.</span> <span class="nav-text">72、类型转换构造函数是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73、异常处理方式。"><span class="nav-number">1.70.</span> <span class="nav-text">73、异常处理方式。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#74、成员函数和友元函数的区别"><span class="nav-number">1.71.</span> <span class="nav-text">74、成员函数和友元函数的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#75、c-中哪些运算符不能重载"><span class="nav-number">1.72.</span> <span class="nav-text">75、c++中哪些运算符不能重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#76、如何重载前-和后"><span class="nav-number">1.73.</span> <span class="nav-text">76、如何重载前++和后++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#77、请说出STL标准模板库中的几个常用类"><span class="nav-number">1.74.</span> <span class="nav-text">77、请说出STL标准模板库中的几个常用类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#78、函数模板和函数重载的异同"><span class="nav-number">1.75.</span> <span class="nav-text">78、函数模板和函数重载的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#79、类型转换构造函数是什么？"><span class="nav-number">1.76.</span> <span class="nav-text">79、类型转换构造函数是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#80、c-中explicit关键字有什么用。"><span class="nav-number">1.77.</span> <span class="nav-text">80、c++中explicit关键字有什么用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#81、c-中restrict关键字有什么作用？"><span class="nav-number">1.78.</span> <span class="nav-text">81、c++中restrict关键字有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82、c-中常用的设计模式又哪些？"><span class="nav-number">1.79.</span> <span class="nav-text">82、c++中常用的设计模式又哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83、写一个单例模式的例子。"><span class="nav-number">1.80.</span> <span class="nav-text">83、写一个单例模式的例子。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#84、面向对象的三大特征。"><span class="nav-number">1.81.</span> <span class="nav-text">84、面向对象的三大特征。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#85、什么是封装"><span class="nav-number">1.82.</span> <span class="nav-text">85、什么是封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#86、什么是继承"><span class="nav-number">1.83.</span> <span class="nav-text">86、什么是继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#87、什么是多态"><span class="nav-number">1.84.</span> <span class="nav-text">87、什么是多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#88、类和对象的区别。"><span class="nav-number">1.85.</span> <span class="nav-text">88、类和对象的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#89、c-中的namespace是什么？"><span class="nav-number">1.86.</span> <span class="nav-text">89、c++中的namespace是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#90、什么是可重入和不可重入函数？"><span class="nav-number">1.87.</span> <span class="nav-text">90、什么是可重入和不可重入函数？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hash函数、数据库基本"><span class="nav-number">2.</span> <span class="nav-text">hash函数、数据库基本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-number">3.</span> <span class="nav-text">计算机网络</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP部分"><span class="nav-number">4.</span> <span class="nav-text">HTTP部分</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统："><span class="nav-number">5.</span> <span class="nav-text">操作系统：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存池、Nginx"><span class="nav-number">6.</span> <span class="nav-text">内存池、Nginx</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O多路复用"><span class="nav-number">7.</span> <span class="nav-text">I/O多路复用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-12"><span class="nav-number">8.</span> <span class="nav-text">3-12</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-11新特性"><span class="nav-number">9.</span> <span class="nav-text">C++11新特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式"><span class="nav-number">10.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-14-2018"><span class="nav-number">11.</span> <span class="nav-text">3.14.2018</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-15、Effective-C-："><span class="nav-number">12.</span> <span class="nav-text">3-15、Effective C++：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-16、effective-C"><span class="nav-number">13.</span> <span class="nav-text">3-16、effective C++</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-18更新"><span class="nav-number">14.</span> <span class="nav-text">3-18更新</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#h文件，-lib文件以及-dll文件"><span class="nav-number">15.</span> <span class="nav-text">.h文件，.lib文件以及.dll文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B-B-树"><span class="nav-number">16.</span> <span class="nav-text">B-B+树</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZRainy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
