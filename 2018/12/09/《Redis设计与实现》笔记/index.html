<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="ZRainy" type="application/atom+xml">






<meta name="description" content="第二章 简单动态字符串在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8">
<meta property="og:type" content="article">
<meta property="og:title" content="《Redis设计与实现》笔记">
<meta property="og:url" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/index.html">
<meta property="og:site_name" content="ZRainy">
<meta property="og:description" content="第二章 简单动态字符串在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/redisServerMainLoop.png">
<meta property="og:updated_time" content="2018-12-19T15:55:57.764Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Redis设计与实现》笔记">
<meta name="twitter:description" content="第二章 简单动态字符串在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8">
<meta name="twitter:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/redisServerMainLoop.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/">





  <title>《Redis设计与实现》笔记 | ZRainy</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZRainy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZRainy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZRainy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Redis设计与实现》笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-09T16:33:16+08:00">
                2018-12-09
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2018-12-19T23:55:57+08:00" content="2018-12-19">
              2018-12-19
              </time>
            </span>
          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/职业学习/" itemprop="url" rel="index">
                    <span itemprop="name">职业学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h1><p>在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8</p>
<a id="more"></a>
<h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sds.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用该结构比直接使用C字符串有以下好处：</p>
<ol>
<li>获取字符串长度的复杂度从O（n）降低到O（1）；</li>
<li>杜绝缓冲区溢出，SDS在进行字符串操作时会先检查是否有足够的空间p11；</li>
<li>减少修改字符串时带来的内存重分配次数，通过free字段，SDS实现了空间预分配和惰性空间释放两种优化策略。对于空间预分配策略而言，如果对SDS修改后len小于1MB，则将分配和len相同长度的未使用空间，如果修改后len大于1MB，则分配1MB的未使用空间；对于惰性空间释放，则是说缩短字符串长度时，并没有真正释放空间，而是将free值增大而已，便于将来可能有的增长操作。另外SDS也提供了相应的API用来真正释放未使用空间。</li>
<li>C字符串中不能包含空字符，所以也不能保存像图片、音频等二进制数据，但SDS可以，它是二进制安全的。</li>
<li>兼容部分C字符串函数，如strcasecamp、strcat。</li>
</ol>
<p>主要API见p17。</p>
<h1 id="第三章-链表"><a href="#第三章-链表" class="headerlink" title="第三章 链表"></a>第三章 链表</h1><p>当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除此以外，发布与订阅、慢查询、监视器等功能也用到了链表。</p>
<h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//adlist.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode* head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode* tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> * ptr,<span class="keyword">void</span> * key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>双端</li>
<li>无环</li>
<li>有头尾节点</li>
<li>有链表长度计数器</li>
<li>多态，链表节点使用void*指针保存节点值，所以可以保存各种不同类型的值</li>
</ul>
<p>API见p21</p>
<h1 id="第四章-字典"><a href="#第四章-字典" class="headerlink" title="第四章 字典"></a>第四章 字典</h1><p>Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查也是构建在对字典的操作之上的。当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p>
<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h/dictht</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;<span class="comment">//dictEntry定义也在dict.h中，每个dictEntry保存一个键值对</span></span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">//指向下个hash表节点，形成链表，解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;distEntry;</span><br></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引，当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*keyDup)(<span class="keyword">void</span> * privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*valDup)(<span class="keyword">void</span> privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span>* key1,<span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure>
<p>一般情况下，字典只使用ht[0]哈希表，ht[1]只会在对ht[0]进行rehash时使用。</p>
<h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>Redis计算哈希值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字典设置的哈希函数计算键key的哈希值</span></span><br><span class="line">hash=dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">//使用哈希表的sizemask属性和哈希值计算出索引值，根据情况不同，ht[x]可以是ht[0] 或 //ht[1]</span></span><br><span class="line">index=hash&amp;dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<p>因为dictEntry节点组成的链表没有指向链表尾部的指针，所以在哈希冲突的时候为了速度考虑，程序总是将新节点添加到链表的表头位置（O（1）），排在已有元素前面。</p>
<p>当字典呗用作数据库或哈希键的底层实现时，Redis使用MurmurHash2算法来计算哈希值。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会增多或减少，为了保证负载因子在一个合理的范围内，则需要对哈希表的大小进行相应的扩展或者收缩，这可以通过rehash来完成。</p>
<p>步骤如下：</p>
<ol>
<li>为ht[1]分配空间，如果是扩展操作，则大小等于第一个大于等于ht[0].used*2的2^n，如果是收缩操作，则大小等于第一个大于等于ht[0].used的2^n；</li>
<li>将ht[0]中的所有键值对重新计算哈希值和索引值放入ht[1]中；</li>
<li>释放ht[0]，并将ht[1]置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次做准备。</li>
</ol>
<p>当以下条件之一满足时，会开始扩展：</p>
<ol>
<li>服务器没有执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于1；</li>
<li>服务器在执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于5；</li>
</ol>
<p>当负载因子小于0.1时，或进行收缩操作。</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>为了避免一次性rehash对服务器性能造成影响，服务器分多次、渐进地将ht[0]慢慢rehash到ht[1]。</p>
<p>步骤如下：</p>
<ol>
<li>为ht[1]分配空间；</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它赋值为0，标志rehash开始；</li>
<li>在rehash期间，每次对字典执行增删改查时，除了执行该操作外，还会顺带将ht[0]中rehashidx上的所有键值对rehash到ht[1]上，当rehash完成后，rehashidx++；</li>
<li>当ht[0]所有键值对都rehash到ht[1]上时，rehashidx置为-1，结束rehash。</li>
</ol>
<p>在rehash期间，删改查会在两个哈希表上进行，而增操作只会在ht[1]上进行。</p>
<p>主要API见p36.</p>
<h1 id="第五章-跳跃表"><a href="#第五章-跳跃表" class="headerlink" title="第五章 跳跃表"></a>第五章 跳跃表</h1><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>查找效率平均水平O（logN），最坏O（N），大部分情况下，跳跃表的效率可以和平衡树媲美，所以有些程序可以用跳跃表来代替平衡树。</p>
<p>Redis使用跳跃表来作为有序集合键的底层实现之一，也被用在集群节点中，其余地方没有再用。</p>
<p>如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会用跳跃表来作为有序集合键的底层实现。</p>
<h2 id="跳跃表实现"><a href="#跳跃表实现" class="headerlink" title="跳跃表实现"></a>跳跃表实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点 redis.h/zskiplistNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//层，程序可以通过层来加快访问其他节点的速度，一般来说</span></span><br><span class="line">    <span class="comment">//层越多，访问其他节点的速度就越快</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针，用于从表头向表尾方向访问节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度，跨度越大，相距越远，与遍历操作无关，是用来计算排位的，排位就是在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来的值</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值，可相同</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象，不可相同</span></span><br><span class="line">    robj* obj;</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure>
<p>多个跳跃表节点就可以组成一个跳跃表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量，不算表头节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> longn length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数，每个层高都是1至32之间的随机数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>
<p>API见p45</p>
<h1 id="第六章-整数集合"><a href="#第六章-整数集合" class="headerlink" title="第六章 整数集合"></a>第六章 整数集合</h1><p>整数集合（intset）时候集合键的底层实现之一，当一个集合只包含整数值元素，并且集合元素数量不多时，Redis就会使用整数集合来作为集合键的底层实现。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并保证不会重复。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intset.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组，各个项在数组中升序排列，虽然声明写的是int8_t，但真正保存的类型取决于encoding属性的值，分别能存16/32/64位的整数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长的时候，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。</p>
<p>升级分三步：</p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间；</li>
<li>将原来的所有元素都转换成新类型，注意这里扩展空间后原来的元素是从后往前被重新放到正确的位置上的</li>
<li>添加新元素</li>
</ol>
<p>向整数集合中添加新元素的时间复杂度是O（n）</p>
<p>升级的好处：</p>
<ol>
<li>提升灵活性</li>
<li>节约内存</li>
</ol>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>要注意的是，整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>
<p>API见p51</p>
<h1 id="第七章-压缩列表"><a href="#第七章-压缩列表" class="headerlink" title="第七章 压缩列表"></a>第七章 压缩列表</h1><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且每个列表项要么是小整数要么是长度比较短的字符串，Redis就会使用压缩列表来做列表键的底层实现。哈希键同理。</p>
<h2 id="压缩列表构成"><a href="#压缩列表构成" class="headerlink" title="压缩列表构成"></a>压缩列表构成</h2><p>压缩列表各个组成部分以及书名</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">长度（字节）</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">zlbytes</td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">4</td>
<td style="text-align:center">整个压缩表占用的内存字节数</td>
</tr>
<tr>
<td style="text-align:center">zltail</td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">4</td>
<td style="text-align:center">压缩表表尾节点距离起始地址有多少字节</td>
</tr>
<tr>
<td style="text-align:center">zllen</td>
<td style="text-align:center">uint16_t</td>
<td style="text-align:center">2</td>
<td style="text-align:center">压缩列表包含的节点数量，当该值等于UINT16_MAX时，节点真实数量需要遍历整个压缩列表得出</td>
</tr>
<tr>
<td style="text-align:center">entryX</td>
<td style="text-align:center">列表节点</td>
<td style="text-align:center">不定</td>
<td style="text-align:center">各个节点长度由保存的内容决定</td>
</tr>
<tr>
<td style="text-align:center">zlend</td>
<td style="text-align:center">uint8_t</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0xFF，标志末尾</td>
</tr>
</tbody>
</table>
<p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中字节数组可以是以下三种长度中的一种：</p>
<ol>
<li>长度小于（2^6-1）</li>
<li>长度小于2^14-1</li>
<li>长度小于2^32-1</li>
</ol>
<p>而整数值可以是六种长度中的一种：</p>
<ol>
<li>4位长，介于0至12之间的无符号整数；</li>
<li>1字节长有符号整数</li>
<li>3字节长有符号整数</li>
<li>int16_t</li>
<li>int32_t</li>
<li>int64_t</li>
</ol>
<p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。</p>
<p>previous_entry_length可以是1字节或5字节长，如果前一节点的长度小于254字节，则previous_entry_length是1字节，保存前一个节点的长度，如果前一节点的长度大于等于254字节，则previous_entry_length长度是五字节，其中第一字节被置为0xFE，而后四个字节用来保存前一节点的长度。这个属性可以用来逆序遍历节点。</p>
<p>encoding属性记录节点的conten属性所存数据的类型和长度，具体可以看p56，简单来说以11开头表示整数编码，content存的是整数，而以00/01/10开头则表示content存的是字节数组，后面几位存的是长度。</p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>添加和删除节点都可能导致连锁更新的现象，所谓连锁更新，简单来说就是原来e1…eN存的都是250~253字节的数据，那么它们的previous_entry_length只需要1字节，但如果这时在e1之前插入一个大于等于254长度的数据，那么e1的previous_entry_length就不够了，就要从1字节扩充成5字节，但这就导致e1长度超过253字节，导致后续所有节点都要重新分配内存，这就是连锁更新，最坏时间复杂度将达到O（n^2）。</p>
<p>但要注意的是，连锁更新真正造成性能问题的几率是很低的，因为O（n^2）的时间复杂度是在很极端的情况下达到的，所以平均复杂度只是线性的。</p>
<p>具体API见p59</p>
<h1 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章 对象"></a>第八章 对象</h1><p>前面介绍了Redis用到的主要数据结构，但Redis并没有直接使用这些数据结构，而是基于这些数据结构创建了一个对象系统。</p>
<p>Redis对象系统实现了基于引用计数的内存回收机制，还通过引用计数实现了对象共享机制，最后对象带有访问时间记录信息。</p>
<h2 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h2><p>每当在Redis数据中新创建一个键值对时，都至少会创建两个对象，每个对象都由一个redisObject表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisObject;</span><br></pre></td></tr></table></figure>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对象的type属性记录了对象的类型，type属性对应REDIS_STRING/REDIS_LIST/REDIS_HASH/REDIS_SET/REDIS_ZSET五中类型中的一种。</p>
<h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，一共有八种。。</p>
<p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码。</p>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，则字符串对象会将字符串对象的编码设置为int。</p>
<p>如果一个字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，则用一个SDS来保存，编码设置为raw。</p>
<p>如果一个字符串对象保存的是一个字符串值，并且长度小于等于32字节，则使用embstr编码的方式来保存。</p>
<p>int和embstr编码的字符串对象会在某些情况下转换为raw编码，比较特殊的一点是embstr编码的字符串对象实际上时只读的，当修改值的时候就会变成raw。</p>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p>
<p>当列表对象同时满足以下两个条件的时候，使用ziplist编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于64字节；</li>
<li>列表对象保存的元素数量小于512个；</li>
</ol>
<p>否则使用linkedlist编码。</p>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p>
<p>当哈希对象同时满足以下两个条件时，使用ziplist编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li>
<li>哈希对象保存的键值对数量小于512个。</li>
</ol>
<p>否则使用hashtable编码。</p>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是intset或者hashtable。</p>
<p>当集合对象同时满足以下两个对象时，使用intset编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数；</li>
<li>集合对象保存的元素数量不超过512个。</li>
</ol>
<p>否则使用hashtable编码。</p>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist。</p>
<p>skiplist编码的有序结合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist* zsl;<span class="comment">//按分值从小到大保存了所有集合元素</span></span><br><span class="line">    dict* dict;<span class="comment">//创建了一个从成员到分值的映射</span></span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure>
<p>当有序集合对象同时满足以下两个条件时，可以使用ziplist编码：</p>
<ol>
<li>有序集合保存的元素数量小于128个；</li>
<li>有序集合保存的所有元素成员的长度都小于64字节；</li>
</ol>
<p>否则使用skiplist编码。</p>
<h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>在Redis中，有些命令可以在多种类型上执行，但有些则不行。</p>
<p>为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入建的类型是否正确，然后再决定是否执行该命令。</p>
<p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>每个对象的引用计数信息由redisObject结构的refcount属性记录，即是基于引用计数的内存回收机制。</p>
<h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>除了用于实现内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p>
<p>目前来说，Redis会在初始化服务器时创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当需要用到的时候，服务器就会使用这些共享对象。</p>
<h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>Redis中的RedisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。</p>
<p>利用OBJECT IDLETIME命令可以打印出给定键的空转时长，即当前时间减去lru时间算出的值。</p>
<h1 id="第九章-数据库"><a href="#第九章-数据库" class="headerlink" title="第九章 数据库"></a>第九章 数据库</h1><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每一个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中所有数据库</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>默认情况下，客户端的目标数据库为0号数据库，但可以通过SELECT命令切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录客户端当前正在使用的数据库库</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure>
<p>目前Redis没有可以返回客户端目标数据库的命令。</p>
<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//数据库建空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict* dict;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure>
<p>在读取一个键之后，服务器会根据键是否存在来更新键的hit次数和miss次数，这两个值可以在INFO stats命令的keyspace_hits和keyspace_misses属性中查看。</p>
<h2 id="设置生存时间或过期时间"><a href="#设置生存时间或过期时间" class="headerlink" title="设置生存时间或过期时间"></a>设置生存时间或过期时间</h2><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，过期后就会自动删除生存时间为0的键。</p>
<p>而EXPIREAT或PEXPIREAT命令则以秒或毫秒给数据库中的某个键设置过期时间，过期时间是一个UNIX时间戳，当该时间来临时服务器自动删除该键。</p>
<p>其中EXPIRE、PEXPIRE、EXPIREAT三个命令最后都是转换成PEXPIREAT一样。</p>
<p>redisDb结构中会有一个名为expires的字典，该字典中保存了数据库中所有键的过期时间，这个字典也被称作过期字典。</p>
<p>过期字典的键是一个指针，这个指针指向键空间中的某个键对象，值是一个longlong类型的整数。</p>
<p>PERSIST命令可以移除一个键的过期时间，即将该键值对从过期字典中移除。</p>
<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>有三种不同的删除策略：</p>
<ul>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。【对CPU不友好，内存友好】</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键，如果没有过期就返回该键。【CPU友好，内存不友好】</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。【结合】</li>
</ul>
<h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>使用的是惰性删除和定期删除两种策略。</p>
<p>惰性删除在db.c/expireIfNeeded方法中。</p>
<p>定期删除策略在redis.c/activeExpireCycle方法中。周期性执行，每次执行的时候，则在规定时间内分多次遍历服务器中的各个数据库，随机检查一部分键的过期时间并删除过期的。</p>
<h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><h3 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h3><p>在执行SAVE命令或者BGSAVE创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件中。</p>
<h3 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h3><p>如果服务器以主服务器模式运行，那么在载入RDB文件时会进行检查，过期键会被忽略。</p>
<p>如果以从服务器模式运行，那么不会检查，所有键都被载入。但因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以一般也不会有影响。</p>
<h3 id="AOF写入"><a href="#AOF写入" class="headerlink" title="AOF写入"></a>AOF写入</h3><p>如果数据库中的某个键已经过期但还没有被惰性删除或定期删除，那么AOF文件不会因此而有任何影响，但当过期键被惰性删除或者定期删除之后，程序就会向AOF文件追加一条DEL命令，显示记录该键被删除。</p>
<p>AOF重写和RDB类似，不会管已过期的键。</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li>主服务器删除一个键后，会向所有从服务器发送一个del命令，通知从服务器删除该键；</li>
<li>从服务器本身不会删除键，即使该键已经过期，也仍然按未过期处理，该get还是能get到，只有在收到主服务器的del命令时才进行删除。</li>
</ul>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>该功能可以让客户端通过订阅给定的频道或者模式，来获取数据库中键的变化，以及数据库中命令的执行情况。</p>
<p>分为两种：</p>
<ul>
<li>键空间通知：某个键执行了什么命令</li>
<li>键事件通知：某个命令被什么键执行了</li>
</ul>
<p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型。</p>
<h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现，具体实现见p120.</p>
<h1 id="第十章-RDB持久化"><a href="#第十章-RDB持久化" class="headerlink" title="第十章 RDB持久化"></a>第十章 RDB持久化</h1><h2 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h2><p>Save和BGSAVE两个命令都可以生成RDB文件，但又有不同，save是阻塞的，而BGSAVE则是生成一个子进程创建RDB文件，父进程继续处理命令请求。</p>
<p>实际工作由rdb.c/rdbSave函数完成，上述两个命令都是调用该函数的，载入时实际调用的函数是rdb.c/rdbLoad函数。</p>
<p>在执行BGSAVE命令期间，客户端发送的SAVE和GBSAVE命令会被服务器拒绝，而对于BGREWRITEAOF则会等到BGSAVE写完后再调用。</p>
<p>如果BGREWRITEAOF执行期间调用了BGSAVE，则BGSAVE会被拒绝。</p>
<p>载入RDB文件期间，服务器会一直处于阻塞状态。</p>
<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>Redis会定期使用BGSAVE命令，当Redis服务器启动时，用户可以指定配置文件或传入启动参数设置save选项，若用户没有指定则使用默认的。</p>
<p>save 900 1</p>
<p>save 300 10</p>
<p>save 60 10000</p>
<p>接着设置服务器状态redisServer结构的saveparams属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>* <span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//修改计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="comment">//上一次执行bgsave的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">//修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>服务器会以100ms为周期周期性执行函数serverCron，该函数用于对正在运行的服务器进行维护，它会检查save属性中设置的条件是否已经满足，满足就执行BGSAVE。</p>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p>Redis文件所包含的各个部分：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">REDIS</td>
<td style="text-align:center">db_version</td>
<td style="text-align:center">databases</td>
<td style="text-align:center">EOF</td>
<td style="text-align:center">check_num</td>
</tr>
</tbody>
</table>
<p>RDB文件的最开头是REDIS部分，长度5字节，保存“REDIS”五个字符，用来判断文件是否是RDB文件。</p>
<p>db_version长度为4字节，记录RDB文件的版本号。</p>
<p>databases包含着另个或多个数据库，以及各个数据库中的键值对数据。</p>
<p>EOF长度为1字节，标志着RDB文件正文内容的结束。</p>
<p>check_num是一个8字节的无符号整数，保存一个检验和。</p>
<h3 id="database部分"><a href="#database部分" class="headerlink" title="database部分"></a>database部分</h3><p>database部分可以保存任意多个非空数据库，每个非空数据库在RDb文件中可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p>
<p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读的是一个数据库号码。</p>
<p>db_number保存一个数据库号码，根据号码大小不同，长度可以是1字节、2字节或5字节。</p>
<p>当程序读入该部分后，服务器会调用SELECT命令切换到对应数据库。</p>
<p>key_value_pairs部分保存该数据库中所有键值对数据。</p>
<h3 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h3><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成。</p>
<p>带有过期时间的键值对的结构由五部分组成：EXPIRETIME_MS、ms、TYPE、key以及value。</p>
<p>根据TYPE不同，不同类型的值对象在RDB文件中的保存结构都不相同，详细见p128起的叙述，这里只简单记录一下。</p>
<ul>
<li>字符串对象，有两种编码：REDIS_ENCODING_INT或者REDIS_ENCODING_RAW，如果是前者则按照ENCODING和integer两部分保存，若是后者，则又有压缩或不压缩两种方式保存。</li>
<li>列表对象，TYPE的值为REDIS_RDB_TYPE_LIST，则表示value存的是REDIS_ENCODING_LINKEDLIST编码对象，RDB中保存结构分为list_length、item1、item2…itemN。</li>
<li>集合对象，编码REDIS_ENCODING_HT，也是分为长度和元素集合存储。</li>
<li>哈希表对象，也是长度，后面跟各个kv对。</li>
<li>有序集合对象，也一样，长度跟上分值和成员本身值。</li>
<li>INTSET编码的集合，存的时候整数转换成字符串存，取的时候再转换回整数。</li>
<li>ZIPLIST编码的列表、哈希表或者有序集合，存的时候是把压缩列表转换成了一个字符串对象。</li>
</ul>
<h2 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h2><p>od命令可以打印RDB文件</p>
<p><code>od -c dump.rdb</code></p>
<p>具体可看这一节书中的例子。</p>
<p>Redis本身带有RDB检查工具redis-check-dump。</p>
<p>od命令加上-c参数和-x参数可以同时以ASCII编码和十六进制显示，便于查看检验和。</p>
<h1 id="第十一章-AOF持久化"><a href="#第十一章-AOF持久化" class="headerlink" title="第十一章 AOF持久化"></a>第十一章 AOF持久化</h1><p>AOF(Append Only File)</p>
<p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p>
<p>是纯文本格式。</p>
<h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>AOF持久化功能的实现可以分为命令追加append、文件写入、文件同步sync三个步骤。</p>
<p>服务器配置的appendfsync选项有三个值：always、everysec和no。</p>
<table>
<thead>
<tr>
<th>appendfsync的值</th>
<th>flushAppendOnlyFile的行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>将aof_buf缓冲区的所有内容写入并同步到AOF文件</td>
</tr>
<tr>
<td>everysec</td>
<td>将aof_buf缓冲区的所有内容写入到AOF文件，但每隔一秒才同步一次</td>
</tr>
<tr>
<td>no</td>
<td>只写，不同步，什么时候同步由操作系统控制</td>
</tr>
</tbody>
</table>
<h2 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h2><ol>
<li>创建一个不带网络连接的微客户端；</li>
<li>从AOF文件中分析并读取一条写命令；</li>
<li>使用伪客户端执行读出的写命令；</li>
<li>重复步骤2和3，直到AOF文件中所有写命令都被处理完毕。</li>
</ol>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>随着时间流逝，AOF文件内容会越来越多，为了解决AOF文件体积膨胀的问题，Redis提供了AOF重写功能，新AOF文件中不会包含任何浪费空间的冗余命令，所以体积要小很多。</p>
<p>虽然功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读写操作，真正操作时读取服务器当前的数据库状态来实现的。</p>
<p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写时会先检查元素数量，如果超过<code>redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>值时，就分成多条命令来写，所以并不是简单的一个键值对数据用一条命令来代替，具体见p147。</p>
<p>为了避免AOF操作重写造成线程长时间阻塞，会让子进程执行重写，这就是AOF后台重写，但这样又会导致子进程在重写的时候父进程执行了新的写操作，使得子进程重写后的AOF文件并不一致。</p>
<p>为了解决这个问题，Redis设置了一个AOF重写缓冲区，这个缓冲区在子进程被创建之后开始使用，当Redis执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程接收到该信号之后会调用一个信号处理函数，并执行以下两步：</p>
<ol>
<li>将AOF重写缓冲区的所有内容写入到新AOF文件中；</li>
<li>对新的AOF文件进行改命，原子地覆盖原有的AOF文件。</li>
</ol>
<p>完成这两步后，父进程就可以正常接收命令请求了。</p>
<p>整个步骤里，父进程只有在最后调用信号处理函数的时候会阻塞。</p>
<p>这就是AOF后台重写，也是命令BGREWRITEAOF命令的实现原理。</p>
<h1 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章 事件"></a>第十二章 事件</h1><p>Redis服务器是一个事件驱动程序，需要处理以下两类事件：</p>
<ol>
<li>文件事件（file event）：服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象，完成一系列网络通信操作。</li>
<li>时间事件（time event）：Redis服务器中的一些操作需要在给定的时间点执行，时间事件就是对这类定时操作的抽象。</li>
</ol>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>使用I/O多路复用来同时监听多个套接字。</p>
<p>是基于Reactor模式实现的网络通信程序。</p>
<p>文件事件处理器有四个组成部分：套接字、I/O多路复用程序、文件时间分派器（dispatcher）以及事件处理器。</p>
<p>尽管多个文件事件可能会并发出现，但I/O多路复用程序总是将所有产生事件的套接字都放在一个队列里，然后通过这个队列以有序地、同步地、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后，再进行下一个。</p>
<p>I/O多路复用程序的实现中包装了常见的select、epoll、evport和kqueue。</p>
<p>有两类事件：AE_READABLE和AE_WRITABLE。</p>
<p>如果一个套接字同时产生了这两种事件，那么文件事件分派器优先处理AE_READABLE事件。</p>
<p>文件事件有多个处理器，最常用的是连接应答处理器、命令请求处理器和命令回复处理器。</p>
<p>具体看p156.</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类：</p>
<ul>
<li>定时事件</li>
<li>周期性事件</li>
</ul>
<p>一个时间事件主要由以下三个属性组成：</p>
<ul>
<li>id，全局唯一，新的比旧的大</li>
<li>when：毫秒精度unix时间戳，记录时间事件的到达时间</li>
<li>timeProc：时间事件处理器，一个函数。如果该函数返回值为AE_NOMORE，则为定时事件，否则是周期性事件。</li>
</ul>
<p>书上说目前版本的Redis只使用了周期事件。</p>
<p>在实现方面，服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表找到所有已到达的时间事件，并调用相应的事件处理器。</p>
<p>【注】在目前的版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，在benchmark模式下也只有两个时间事件，所以用无序链表不会影响性能。</p>
<h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>事件的调度和执行由<code>ae.c/aeProcessEvents</code>函数负责，大致逻辑如下：</p>
<ol>
<li>获取到达时间离当前时间最近的时间事件，最计算出距离还有多少毫秒赋值给remaind_ms</li>
<li>如果剩余时间小于0，则将remaind_ms更新为0</li>
<li>根据remaind_ms创建一个timeval结构</li>
<li>根据timeval结构阻塞并等待文件事件产生，如果remaind_ms==0，则不阻塞</li>
<li>处理所有产生的文件事件</li>
<li>处理所有已到达的时间事件</li>
</ol>
<p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数。<br><img src="/2018/12/09/《Redis设计与实现》笔记/redisServerMainLoop.png" title="Redis服务器主循环"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/08/Redis入门/" rel="next" title="Redis入门">
                <i class="fa fa-chevron-left"></i> Redis入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjgzMy8xMzM2OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ZRainy</p>
              <p class="site-description motion-element" itemprop="description">故事没结束，别急着去哭</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-简单动态字符串"><span class="nav-number">1.</span> <span class="nav-text">第二章 简单动态字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDS的定义"><span class="nav-number">1.1.</span> <span class="nav-text">SDS的定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-链表"><span class="nav-number">2.</span> <span class="nav-text">第三章 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表和链表节点的实现"><span class="nav-number">2.1.</span> <span class="nav-text">链表和链表节点的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-字典"><span class="nav-number">3.</span> <span class="nav-text">第四章 字典</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字典的实现"><span class="nav-number">3.1.</span> <span class="nav-text">字典的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表"><span class="nav-number">3.1.1.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表节点"><span class="nav-number">3.1.2.</span> <span class="nav-text">哈希表节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典"><span class="nav-number">3.1.3.</span> <span class="nav-text">字典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash算法"><span class="nav-number">3.2.</span> <span class="nav-text">hash算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rehash"><span class="nav-number">3.3.</span> <span class="nav-text">rehash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渐进式rehash"><span class="nav-number">3.4.</span> <span class="nav-text">渐进式rehash</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-跳跃表"><span class="nav-number">4.</span> <span class="nav-text">第五章 跳跃表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#跳跃表实现"><span class="nav-number">4.1.</span> <span class="nav-text">跳跃表实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-整数集合"><span class="nav-number">5.</span> <span class="nav-text">第六章 整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整数集合的实现"><span class="nav-number">5.1.</span> <span class="nav-text">整数集合的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#升级"><span class="nav-number">5.2.</span> <span class="nav-text">升级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#降级"><span class="nav-number">5.3.</span> <span class="nav-text">降级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-压缩列表"><span class="nav-number">6.</span> <span class="nav-text">第七章 压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩列表构成"><span class="nav-number">6.1.</span> <span class="nav-text">压缩列表构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连锁更新"><span class="nav-number">6.2.</span> <span class="nav-text">连锁更新</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章-对象"><span class="nav-number">7.</span> <span class="nav-text">第八章 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的类型和编码"><span class="nav-number">7.1.</span> <span class="nav-text">对象的类型和编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">7.1.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码和底层实现"><span class="nav-number">7.1.2.</span> <span class="nav-text">编码和底层实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串对象"><span class="nav-number">7.2.</span> <span class="nav-text">字符串对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表对象"><span class="nav-number">7.3.</span> <span class="nav-text">列表对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希对象"><span class="nav-number">7.4.</span> <span class="nav-text">哈希对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合对象"><span class="nav-number">7.5.</span> <span class="nav-text">集合对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序集合对象"><span class="nav-number">7.6.</span> <span class="nav-text">有序集合对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型检查与命令多态"><span class="nav-number">7.7.</span> <span class="nav-text">类型检查与命令多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存回收"><span class="nav-number">7.8.</span> <span class="nav-text">内存回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象共享"><span class="nav-number">7.9.</span> <span class="nav-text">对象共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的空转时长"><span class="nav-number">7.10.</span> <span class="nav-text">对象的空转时长</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九章-数据库"><span class="nav-number">8.</span> <span class="nav-text">第九章 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器中的数据库"><span class="nav-number">8.1.</span> <span class="nav-text">服务器中的数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切换数据库"><span class="nav-number">8.2.</span> <span class="nav-text">切换数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库键空间"><span class="nav-number">8.3.</span> <span class="nav-text">数据库键空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置生存时间或过期时间"><span class="nav-number">8.4.</span> <span class="nav-text">设置生存时间或过期时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过期键删除策略"><span class="nav-number">8.5.</span> <span class="nav-text">过期键删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的过期键删除策略"><span class="nav-number">8.6.</span> <span class="nav-text">Redis的过期键删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF、RDB和复制功能对过期键的处理"><span class="nav-number">8.7.</span> <span class="nav-text">AOF、RDB和复制功能对过期键的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成RDB文件"><span class="nav-number">8.7.1.</span> <span class="nav-text">生成RDB文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#载入RDB文件"><span class="nav-number">8.7.2.</span> <span class="nav-text">载入RDB文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF写入"><span class="nav-number">8.7.3.</span> <span class="nav-text">AOF写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制"><span class="nav-number">8.7.4.</span> <span class="nav-text">复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库通知"><span class="nav-number">8.8.</span> <span class="nav-text">数据库通知</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送通知"><span class="nav-number">8.8.1.</span> <span class="nav-text">发送通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十章-RDB持久化"><span class="nav-number">9.</span> <span class="nav-text">第十章 RDB持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB文件的创建与载入"><span class="nav-number">9.1.</span> <span class="nav-text">RDB文件的创建与载入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动间隔性保存"><span class="nav-number">9.2.</span> <span class="nav-text">自动间隔性保存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB文件结构"><span class="nav-number">9.3.</span> <span class="nav-text">RDB文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#database部分"><span class="nav-number">9.3.1.</span> <span class="nav-text">database部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-value-pairs部分"><span class="nav-number">9.3.2.</span> <span class="nav-text">key_value_pairs部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析RDB文件"><span class="nav-number">9.4.</span> <span class="nav-text">分析RDB文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章-AOF持久化"><span class="nav-number">10.</span> <span class="nav-text">第十一章 AOF持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF持久化的实现"><span class="nav-number">10.1.</span> <span class="nav-text">AOF持久化的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF文件的载入与数据还原"><span class="nav-number">10.2.</span> <span class="nav-text">AOF文件的载入与数据还原</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF重写"><span class="nav-number">10.3.</span> <span class="nav-text">AOF重写</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十二章-事件"><span class="nav-number">11.</span> <span class="nav-text">第十二章 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件事件"><span class="nav-number">11.1.</span> <span class="nav-text">文件事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间事件"><span class="nav-number">11.2.</span> <span class="nav-text">时间事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件的调度与执行"><span class="nav-number">11.3.</span> <span class="nav-text">事件的调度与执行</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZRainy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
