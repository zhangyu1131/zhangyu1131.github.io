<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redis,">





  <link rel="alternate" href="/atom.xml" title="ZRainy" type="application/atom+xml">






<meta name="description" content="第二章 简单动态字符串在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="《Redis设计与实现》笔记">
<meta property="og:url" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/index.html">
<meta property="og:site_name" content="ZRainy">
<meta property="og:description" content="第二章 简单动态字符串在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/redisServerMainLoop.png">
<meta property="og:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/持久化检查.png">
<meta property="og:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/psync实现.png">
<meta property="og:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/clustermeet.png">
<meta property="og:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/ask错误.png">
<meta property="og:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/事务命令入队.png">
<meta property="og:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/lua.png">
<meta property="og:updated_time" content="2019-07-28T15:11:53.772Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Redis设计与实现》笔记">
<meta name="twitter:description" content="第二章 简单动态字符串在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8">
<meta name="twitter:image" content="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/redisServerMainLoop.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/">





  <title>《Redis设计与实现》笔记 | ZRainy</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZRainy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/《Redis设计与实现》笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZRainy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZRainy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Redis设计与实现》笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-09T16:33:16+08:00">
                2018-12-09
              </time>
            

            

            
          </span>
          
            <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2019-07-28T23:11:53+08:00" content="2019-07-28">
              2019-07-28
              </time>
            </span>
          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/职业学习/" itemprop="url" rel="index">
                    <span itemprop="name">职业学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h1><p>在Redis中，C字符串只会作用字符串字面量用在一些无需对字符串值进行修改的地方，当需要修改的时候，Redis会使用自己构建的一种名为简单动态字符串的抽象类型SDS来表示。SDS还会用在AOF模块和客户端状态中的缓冲区里。p8</p>
<a id="more"></a>
<h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sds.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组，保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用该结构比直接使用C字符串有以下好处：</p>
<ol>
<li>获取字符串长度的复杂度从O（n）降低到O（1）；</li>
<li>杜绝缓冲区溢出，SDS在进行字符串操作时会先检查是否有足够的空间p11；</li>
<li>减少修改字符串时带来的内存重分配次数，通过free字段，SDS实现了空间预分配和惰性空间释放两种优化策略。对于空间预分配策略而言，如果对SDS修改后len小于1MB，则将分配和len相同长度的未使用空间，如果修改后len大于1MB，则分配1MB的未使用空间；对于惰性空间释放，则是说缩短字符串长度时，并没有真正释放空间，而是将free值增大而已，便于将来可能有的增长操作。另外SDS也提供了相应的API用来真正释放未使用空间。</li>
<li>C字符串中不能包含空字符，所以也不能保存像图片、音频等二进制数据，但SDS可以，它是二进制安全的。</li>
<li>兼容部分C字符串函数，如strcasecamp、strcat。</li>
</ol>
<p>主要API见p17。</p>
<h1 id="第三章-链表"><a href="#第三章-链表" class="headerlink" title="第三章 链表"></a>第三章 链表</h1><p>当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。除此以外，发布与订阅、慢查询、监视器等功能也用到了链表。</p>
<h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//adlist.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点值</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode* head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode* tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> * ptr,<span class="keyword">void</span> * key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>双端</li>
<li>无环</li>
<li>有头尾节点</li>
<li>有链表长度计数器</li>
<li>多态，链表节点使用void*指针保存节点值，所以可以保存各种不同类型的值</li>
</ul>
<p>API见p21</p>
<h1 id="第四章-字典"><a href="#第四章-字典" class="headerlink" title="第四章 字典"></a>第四章 字典</h1><p>Redis的数据库就是使用字典来作为底层实现的，对数据库的增删改查也是构建在对字典的操作之上的。当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。</p>
<h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h/dictht</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;<span class="comment">//dictEntry定义也在dict.h中，每个dictEntry保存一个键值对</span></span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>
<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">//指向下个hash表节点，形成链表，解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;distEntry;</span><br></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dict.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引，当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * key)</span></span>;</span><br><span class="line">    <span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*keyDup)(<span class="keyword">void</span> * privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*valDup)(<span class="keyword">void</span> privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span>* key1,<span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    <span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">//销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span>* privdata,<span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure>
<p>一般情况下，字典只使用ht[0]哈希表，ht[1]只会在对ht[0]进行rehash时使用。</p>
<h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>Redis计算哈希值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字典设置的哈希函数计算键key的哈希值</span></span><br><span class="line">hash=dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">//使用哈希表的sizemask属性和哈希值计算出索引值，根据情况不同，ht[x]可以是ht[0] 或 //ht[1]</span></span><br><span class="line">index=hash&amp;dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<p>因为dictEntry节点组成的链表没有指向链表尾部的指针，所以在哈希冲突的时候为了速度考虑，程序总是将新节点添加到链表的表头位置（O（1）），排在已有元素前面。</p>
<p>当字典呗用作数据库或哈希键的底层实现时，Redis使用MurmurHash2算法来计算哈希值。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会增多或减少，为了保证负载因子在一个合理的范围内，则需要对哈希表的大小进行相应的扩展或者收缩，这可以通过rehash来完成。</p>
<p>步骤如下：</p>
<ol>
<li>为ht[1]分配空间，如果是扩展操作，则大小等于第一个大于等于ht[0].used*2的2^n，如果是收缩操作，则大小等于第一个大于等于ht[0].used的2^n；</li>
<li>将ht[0]中的所有键值对重新计算哈希值和索引值放入ht[1]中；</li>
<li>释放ht[0]，并将ht[1]置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次做准备。</li>
</ol>
<p>当以下条件之一满足时，会开始扩展：</p>
<ol>
<li>服务器没有执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于1；</li>
<li>服务器在执行BGSAVE或BGREWRITEAOF命令，且负载因子大于等于5；</li>
</ol>
<p>当负载因子小于0.1时，或进行收缩操作。</p>
<h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>为了避免一次性rehash对服务器性能造成影响，服务器分多次、渐进地将ht[0]慢慢rehash到ht[1]。</p>
<p>步骤如下：</p>
<ol>
<li>为ht[1]分配空间；</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它赋值为0，标志rehash开始；</li>
<li>在rehash期间，每次对字典执行增删改查时，除了执行该操作外，还会顺带将ht[0]中rehashidx上的所有键值对rehash到ht[1]上，当rehash完成后，rehashidx++；</li>
<li>当ht[0]所有键值对都rehash到ht[1]上时，rehashidx置为-1，结束rehash。</li>
</ol>
<p>在rehash期间，删改查会在两个哈希表上进行，而增操作只会在ht[1]上进行。</p>
<p>主要API见p36.</p>
<h1 id="第五章-跳跃表"><a href="#第五章-跳跃表" class="headerlink" title="第五章 跳跃表"></a>第五章 跳跃表</h1><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>查找效率平均水平O（logN），最坏O（N），大部分情况下，跳跃表的效率可以和平衡树媲美，所以有些程序可以用跳跃表来代替平衡树。</p>
<p>Redis使用跳跃表来作为有序集合键的底层实现之一，也被用在集群节点中，其余地方没有再用。</p>
<p>如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会用跳跃表来作为有序集合键的底层实现。</p>
<h2 id="跳跃表实现"><a href="#跳跃表实现" class="headerlink" title="跳跃表实现"></a>跳跃表实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点 redis.h/zskiplistNode</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//层，程序可以通过层来加快访问其他节点的速度，一般来说</span></span><br><span class="line">    <span class="comment">//层越多，访问其他节点的速度就越快</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针，用于从表头向表尾方向访问节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度，跨度越大，相距越远，与遍历操作无关，是用来计算排位的，排位就是在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来的值</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值，可相同</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象，不可相同</span></span><br><span class="line">    robj* obj;</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure>
<p>多个跳跃表节点就可以组成一个跳跃表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量，不算表头节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> longn length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数，每个层高都是1至32之间的随机数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>
<p>API见p45</p>
<h1 id="第六章-整数集合"><a href="#第六章-整数集合" class="headerlink" title="第六章 整数集合"></a>第六章 整数集合</h1><p>整数集合（intset）时候集合键的底层实现之一，当一个集合只包含整数值元素，并且集合元素数量不多时，Redis就会使用整数集合来作为集合键的底层实现。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并保证不会重复。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intset.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组，各个项在数组中升序排列，虽然声明写的是int8_t，但真正保存的类型取决于encoding属性的值，分别能存16/32/64位的整数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长的时候，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。</p>
<p>升级分三步：</p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间；</li>
<li>将原来的所有元素都转换成新类型，注意这里扩展空间后原来的元素是从后往前被重新放到正确的位置上的</li>
<li>添加新元素</li>
</ol>
<p>向整数集合中添加新元素的时间复杂度是O（n）</p>
<p>升级的好处：</p>
<ol>
<li>提升灵活性</li>
<li>节约内存</li>
</ol>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>要注意的是，整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>
<p>API见p51</p>
<h1 id="第七章-压缩列表"><a href="#第七章-压缩列表" class="headerlink" title="第七章 压缩列表"></a>第七章 压缩列表</h1><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且每个列表项要么是小整数要么是长度比较短的字符串，Redis就会使用压缩列表来做列表键的底层实现。哈希键同理。</p>
<h2 id="压缩列表构成"><a href="#压缩列表构成" class="headerlink" title="压缩列表构成"></a>压缩列表构成</h2><p>压缩列表各个组成部分以及书名</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">长度（字节）</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">zlbytes</td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">4</td>
<td style="text-align:center">整个压缩表占用的内存字节数</td>
</tr>
<tr>
<td style="text-align:center">zltail</td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">4</td>
<td style="text-align:center">压缩表表尾节点距离起始地址有多少字节</td>
</tr>
<tr>
<td style="text-align:center">zllen</td>
<td style="text-align:center">uint16_t</td>
<td style="text-align:center">2</td>
<td style="text-align:center">压缩列表包含的节点数量，当该值等于UINT16_MAX时，节点真实数量需要遍历整个压缩列表得出</td>
</tr>
<tr>
<td style="text-align:center">entryX</td>
<td style="text-align:center">列表节点</td>
<td style="text-align:center">不定</td>
<td style="text-align:center">各个节点长度由保存的内容决定</td>
</tr>
<tr>
<td style="text-align:center">zlend</td>
<td style="text-align:center">uint8_t</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0xFF，标志末尾</td>
</tr>
</tbody>
</table>
<p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中字节数组可以是以下三种长度中的一种：</p>
<ol>
<li>长度小于（2^6-1）</li>
<li>长度小于2^14-1</li>
<li>长度小于2^32-1</li>
</ol>
<p>而整数值可以是六种长度中的一种：</p>
<ol>
<li>4位长，介于0至12之间的无符号整数；</li>
<li>1字节长有符号整数</li>
<li>3字节长有符号整数</li>
<li>int16_t</li>
<li>int32_t</li>
<li>int64_t</li>
</ol>
<p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。</p>
<p>previous_entry_length可以是1字节或5字节长，如果前一节点的长度小于254字节，则previous_entry_length是1字节，保存前一个节点的长度，如果前一节点的长度大于等于254字节，则previous_entry_length长度是五字节，其中第一字节被置为0xFE，而后四个字节用来保存前一节点的长度。这个属性可以用来逆序遍历节点。</p>
<p>encoding属性记录节点的conten属性所存数据的类型和长度，具体可以看p56，简单来说以11开头表示整数编码，content存的是整数，而以00/01/10开头则表示content存的是字节数组，后面几位存的是长度。</p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>添加和删除节点都可能导致连锁更新的现象，所谓连锁更新，简单来说就是原来e1…eN存的都是250~253字节的数据，那么它们的previous_entry_length只需要1字节，但如果这时在e1之前插入一个大于等于254长度的数据，那么e1的previous_entry_length就不够了，就要从1字节扩充成5字节，但这就导致e1长度超过253字节，导致后续所有节点都要重新分配内存，这就是连锁更新，最坏时间复杂度将达到O（n^2）。</p>
<p>但要注意的是，连锁更新真正造成性能问题的几率是很低的，因为O（n^2）的时间复杂度是在很极端的情况下达到的，所以平均复杂度只是线性的。</p>
<p>具体API见p59</p>
<h1 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章 对象"></a>第八章 对象</h1><p>前面介绍了Redis用到的主要数据结构，但Redis并没有直接使用这些数据结构，而是基于这些数据结构创建了一个对象系统。</p>
<p>Redis对象系统实现了基于引用计数的内存回收机制，还通过引用计数实现了对象共享机制，最后对象带有访问时间记录信息。</p>
<h2 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h2><p>每当在Redis数据中新创建一个键值对时，都至少会创建两个对象，每个对象都由一个redisObject表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisObject;</span><br></pre></td></tr></table></figure>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对象的type属性记录了对象的类型，type属性对应REDIS_STRING/REDIS_LIST/REDIS_HASH/REDIS_SET/REDIS_ZSET五中类型中的一种。</p>
<h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定，一共有八种。。</p>
<p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码。</p>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，则字符串对象会将字符串对象的编码设置为int。</p>
<p>如果一个字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，则用一个SDS来保存，编码设置为raw。</p>
<p>如果一个字符串对象保存的是一个字符串值，并且长度小于等于32字节，则使用embstr编码的方式来保存。</p>
<p>int和embstr编码的字符串对象会在某些情况下转换为raw编码，比较特殊的一点是embstr编码的字符串对象实际上时只读的，当修改值的时候就会变成raw。</p>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码可以是ziplist或者linkedlist。</p>
<p>当列表对象同时满足以下两个条件的时候，使用ziplist编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于64字节；</li>
<li>列表对象保存的元素数量小于512个；</li>
</ol>
<p>否则使用linkedlist编码。</p>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable。</p>
<p>当哈希对象同时满足以下两个条件时，使用ziplist编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li>
<li>哈希对象保存的键值对数量小于512个。</li>
</ol>
<p>否则使用hashtable编码。</p>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是intset或者hashtable。</p>
<p>当集合对象同时满足以下两个对象时，使用intset编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数；</li>
<li>集合对象保存的元素数量不超过512个。</li>
</ol>
<p>否则使用hashtable编码。</p>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist。</p>
<p>skiplist编码的有序结合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist* zsl;<span class="comment">//按分值从小到大保存了所有集合元素</span></span><br><span class="line">    dict* dict;<span class="comment">//创建了一个从成员到分值的映射</span></span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure>
<p>当有序集合对象同时满足以下两个条件时，可以使用ziplist编码：</p>
<ol>
<li>有序集合保存的元素数量小于128个；</li>
<li>有序集合保存的所有元素成员的长度都小于64字节；</li>
</ol>
<p>否则使用skiplist编码。</p>
<h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>在Redis中，有些命令可以在多种类型上执行，但有些则不行。</p>
<p>为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入建的类型是否正确，然后再决定是否执行该命令。</p>
<p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>每个对象的引用计数信息由redisObject结构的refcount属性记录，即是基于引用计数的内存回收机制。</p>
<h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>除了用于实现内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p>
<p>目前来说，Redis会在初始化服务器时创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当需要用到的时候，服务器就会使用这些共享对象。</p>
<h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>Redis中的RedisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。</p>
<p>利用OBJECT IDLETIME命令可以打印出给定键的空转时长，即当前时间减去lru时间算出的值。</p>
<h1 id="第九章-数据库"><a href="#第九章-数据库" class="headerlink" title="第九章 数据库"></a>第九章 数据库</h1><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每一个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一个数组，保存着服务器中所有数据库</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//服务器的数据库数量，默认16</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>默认情况下，客户端的目标数据库为0号数据库，但可以通过SELECT命令切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录客户端当前正在使用的数据库库</span></span><br><span class="line">    redisDb* db;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure>
<p>目前Redis没有可以返回客户端目标数据库的命令。</p>
<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//数据库建空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict* dict;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure>
<p>在读取一个键之后，服务器会根据键是否存在来更新键的hit次数和miss次数，这两个值可以在INFO stats命令的keyspace_hits和keyspace_misses属性中查看。</p>
<h2 id="设置生存时间或过期时间"><a href="#设置生存时间或过期时间" class="headerlink" title="设置生存时间或过期时间"></a>设置生存时间或过期时间</h2><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，过期后就会自动删除生存时间为0的键。</p>
<p>而EXPIREAT或PEXPIREAT命令则以秒或毫秒给数据库中的某个键设置过期时间，过期时间是一个UNIX时间戳，当该时间来临时服务器自动删除该键。</p>
<p>其中EXPIRE、PEXPIRE、EXPIREAT三个命令最后都是转换成PEXPIREAT一样。</p>
<p>redisDb结构中会有一个名为expires的字典，该字典中保存了数据库中所有键的过期时间，这个字典也被称作过期字典。</p>
<p>过期字典的键是一个指针，这个指针指向键空间中的某个键对象，值是一个longlong类型的整数。</p>
<p>PERSIST命令可以移除一个键的过期时间，即将该键值对从过期字典中移除。</p>
<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>有三种不同的删除策略：</p>
<ul>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。【对CPU不友好，内存友好】</li>
<li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话就删除该键，如果没有过期就返回该键。【CPU友好，内存不友好】</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。【结合】</li>
</ul>
<h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>使用的是惰性删除和定期删除两种策略。</p>
<p>惰性删除在db.c/expireIfNeeded方法中。</p>
<p>定期删除策略在redis.c/activeExpireCycle方法中。周期性执行，每次执行的时候，则在规定时间内分多次遍历服务器中的各个数据库，随机检查一部分键的过期时间并删除过期的。</p>
<h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><h3 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h3><p>在执行SAVE命令或者BGSAVE创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会保存到新创建的RDB文件中。</p>
<h3 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h3><p>如果服务器以主服务器模式运行，那么在载入RDB文件时会进行检查，过期键会被忽略。</p>
<p>如果以从服务器模式运行，那么不会检查，所有键都被载入。但因为主从服务器在进行数据同步的时候，从服务器的数据库会被清空，所以一般也不会有影响。</p>
<h3 id="AOF写入"><a href="#AOF写入" class="headerlink" title="AOF写入"></a>AOF写入</h3><p>如果数据库中的某个键已经过期但还没有被惰性删除或定期删除，那么AOF文件不会因此而有任何影响，但当过期键被惰性删除或者定期删除之后，程序就会向AOF文件追加一条DEL命令，显示记录该键被删除。</p>
<p>AOF重写和RDB类似，不会管已过期的键。</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li>主服务器删除一个键后，会向所有从服务器发送一个del命令，通知从服务器删除该键；</li>
<li>从服务器本身不会删除键，即使该键已经过期，也仍然按未过期处理，该get还是能get到，只有在收到主服务器的del命令时才进行删除。</li>
</ul>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>该功能可以让客户端通过订阅给定的频道或者模式，来获取数据库中键的变化，以及数据库中命令的执行情况。</p>
<p>分为两种：</p>
<ul>
<li>键空间通知：某个键执行了什么命令</li>
<li>键事件通知：某个命令被什么键执行了</li>
</ul>
<p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型。</p>
<h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>发送数据库通知的功能是由notify.c/notifyKeyspaceEvent函数实现，具体实现见p120.</p>
<h1 id="第十章-RDB持久化"><a href="#第十章-RDB持久化" class="headerlink" title="第十章 RDB持久化"></a>第十章 RDB持久化</h1><h2 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h2><p>Save和BGSAVE两个命令都可以生成RDB文件，但又有不同，save是阻塞的，而BGSAVE则是生成一个子进程创建RDB文件，父进程继续处理命令请求。</p>
<p>实际工作由rdb.c/rdbSave函数完成，上述两个命令都是调用该函数的，载入时实际调用的函数是rdb.c/rdbLoad函数。</p>
<p>在执行BGSAVE命令期间，客户端发送的SAVE和GBSAVE命令会被服务器拒绝，而对于BGREWRITEAOF则会等到BGSAVE写完后再调用。</p>
<p>如果BGREWRITEAOF执行期间调用了BGSAVE，则BGSAVE会被拒绝。</p>
<p>载入RDB文件期间，服务器会一直处于阻塞状态。</p>
<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>Redis会定期使用BGSAVE命令，当Redis服务器启动时，用户可以指定配置文件或传入启动参数设置save选项，若用户没有指定则使用默认的。</p>
<p>save 900 1</p>
<p>save 300 10</p>
<p>save 60 10000</p>
<p>接着设置服务器状态redisServer结构的saveparams属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>* <span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//修改计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="comment">//上一次执行bgsave的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">//修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>服务器会以100ms为周期周期性执行函数serverCron，该函数用于对正在运行的服务器进行维护，它会检查save属性中设置的条件是否已经满足，满足就执行BGSAVE。</p>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p>Redis文件所包含的各个部分：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">REDIS</td>
<td style="text-align:center">db_version</td>
<td style="text-align:center">databases</td>
<td style="text-align:center">EOF</td>
<td style="text-align:center">check_num</td>
</tr>
</tbody>
</table>
<p>RDB文件的最开头是REDIS部分，长度5字节，保存“REDIS”五个字符，用来判断文件是否是RDB文件。</p>
<p>db_version长度为4字节，记录RDB文件的版本号。</p>
<p>databases包含着另个或多个数据库，以及各个数据库中的键值对数据。</p>
<p>EOF长度为1字节，标志着RDB文件正文内容的结束。</p>
<p>check_num是一个8字节的无符号整数，保存一个检验和。</p>
<h3 id="database部分"><a href="#database部分" class="headerlink" title="database部分"></a>database部分</h3><p>database部分可以保存任意多个非空数据库，每个非空数据库在RDb文件中可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p>
<p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读的是一个数据库号码。</p>
<p>db_number保存一个数据库号码，根据号码大小不同，长度可以是1字节、2字节或5字节。</p>
<p>当程序读入该部分后，服务器会调用SELECT命令切换到对应数据库。</p>
<p>key_value_pairs部分保存该数据库中所有键值对数据。</p>
<h3 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h3><p>不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成。</p>
<p>带有过期时间的键值对的结构由五部分组成：EXPIRETIME_MS、ms、TYPE、key以及value。</p>
<p>根据TYPE不同，不同类型的值对象在RDB文件中的保存结构都不相同，详细见p128起的叙述，这里只简单记录一下。</p>
<ul>
<li>字符串对象，有两种编码：REDIS_ENCODING_INT或者REDIS_ENCODING_RAW，如果是前者则按照ENCODING和integer两部分保存，若是后者，则又有压缩或不压缩两种方式保存。</li>
<li>列表对象，TYPE的值为REDIS_RDB_TYPE_LIST，则表示value存的是REDIS_ENCODING_LINKEDLIST编码对象，RDB中保存结构分为list_length、item1、item2…itemN。</li>
<li>集合对象，编码REDIS_ENCODING_HT，也是分为长度和元素集合存储。</li>
<li>哈希表对象，也是长度，后面跟各个kv对。</li>
<li>有序集合对象，也一样，长度跟上分值和成员本身值。</li>
<li>INTSET编码的集合，存的时候整数转换成字符串存，取的时候再转换回整数。</li>
<li>ZIPLIST编码的列表、哈希表或者有序集合，存的时候是把压缩列表转换成了一个字符串对象。</li>
</ul>
<h2 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h2><p>od命令可以打印RDB文件</p>
<p><code>od -c dump.rdb</code></p>
<p>具体可看这一节书中的例子。</p>
<p>Redis本身带有RDB检查工具redis-check-dump。</p>
<p>od命令加上-c参数和-x参数可以同时以ASCII编码和十六进制显示，便于查看检验和。</p>
<h1 id="第十一章-AOF持久化"><a href="#第十一章-AOF持久化" class="headerlink" title="第十一章 AOF持久化"></a>第十一章 AOF持久化</h1><p>AOF(Append Only File)</p>
<p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p>
<p>是纯文本格式。</p>
<h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>AOF持久化功能的实现可以分为命令追加append、文件写入、文件同步sync三个步骤。</p>
<p>服务器配置的appendfsync选项有三个值：always、everysec和no。</p>
<table>
<thead>
<tr>
<th>appendfsync的值</th>
<th>flushAppendOnlyFile的行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>将aof_buf缓冲区的所有内容写入并同步到AOF文件</td>
</tr>
<tr>
<td>everysec</td>
<td>将aof_buf缓冲区的所有内容写入到AOF文件，但每隔一秒才同步一次</td>
</tr>
<tr>
<td>no</td>
<td>只写，不同步，什么时候同步由操作系统控制</td>
</tr>
</tbody>
</table>
<h2 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h2><ol>
<li>创建一个不带网络连接的微客户端；</li>
<li>从AOF文件中分析并读取一条写命令；</li>
<li>使用伪客户端执行读出的写命令；</li>
<li>重复步骤2和3，直到AOF文件中所有写命令都被处理完毕。</li>
</ol>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>随着时间流逝，AOF文件内容会越来越多，为了解决AOF文件体积膨胀的问题，Redis提供了AOF重写功能，新AOF文件中不会包含任何浪费空间的冗余命令，所以体积要小很多。</p>
<p>虽然功能命名为AOF文件重写，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读写操作，真正操作时读取服务器当前的数据库状态来实现的。</p>
<p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写时会先检查元素数量，如果超过<code>redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code>值时，就分成多条命令来写，所以并不是简单的一个键值对数据用一条命令来代替，具体见p147。</p>
<p>为了避免AOF操作重写造成线程长时间阻塞，会让子进程执行重写，这就是AOF后台重写，但这样又会导致子进程在重写的时候父进程执行了新的写操作，使得子进程重写后的AOF文件并不一致。</p>
<p>为了解决这个问题，Redis设置了一个AOF重写缓冲区，这个缓冲区在子进程被创建之后开始使用，当Redis执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程接收到该信号之后会调用一个信号处理函数，并执行以下两步：</p>
<ol>
<li>将AOF重写缓冲区的所有内容写入到新AOF文件中；</li>
<li>对新的AOF文件进行改命，原子地覆盖原有的AOF文件。</li>
</ol>
<p>完成这两步后，父进程就可以正常接收命令请求了。</p>
<p>整个步骤里，父进程只有在最后调用信号处理函数的时候会阻塞。</p>
<p>这就是AOF后台重写，也是命令BGREWRITEAOF命令的实现原理。</p>
<h1 id="第十二章-事件"><a href="#第十二章-事件" class="headerlink" title="第十二章 事件"></a>第十二章 事件</h1><p>Redis服务器是一个事件驱动程序，需要处理以下两类事件：</p>
<ol>
<li>文件事件（file event）：服务器通过套接字与客户端连接，文件事件就是服务器对套接字操作的抽象，完成一系列网络通信操作。</li>
<li>时间事件（time event）：Redis服务器中的一些操作需要在给定的时间点执行，时间事件就是对这类定时操作的抽象。</li>
</ol>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>使用I/O多路复用来同时监听多个套接字。</p>
<p>是基于Reactor模式实现的网络通信程序。</p>
<p>文件事件处理器有四个组成部分：套接字、I/O多路复用程序、文件时间分派器（dispatcher）以及事件处理器。</p>
<p>尽管多个文件事件可能会并发出现，但I/O多路复用程序总是将所有产生事件的套接字都放在一个队列里，然后通过这个队列以有序地、同步地、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后，再进行下一个。</p>
<p>I/O多路复用程序的实现中包装了常见的select、epoll、evport和kqueue。</p>
<p>有两类事件：AE_READABLE和AE_WRITABLE。</p>
<p>如果一个套接字同时产生了这两种事件，那么文件事件分派器优先处理AE_READABLE事件。</p>
<p>文件事件有多个处理器，最常用的是连接应答处理器、命令请求处理器和命令回复处理器。</p>
<p>具体看p156.</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis的时间事件分为以下两类：</p>
<ul>
<li>定时事件</li>
<li>周期性事件</li>
</ul>
<p>一个时间事件主要由以下三个属性组成：</p>
<ul>
<li>id，全局唯一，新的比旧的大</li>
<li>when：毫秒精度unix时间戳，记录时间事件的到达时间</li>
<li>timeProc：时间事件处理器，一个函数。如果该函数返回值为AE_NOMORE，则为定时事件，否则是周期性事件。</li>
</ul>
<p>书上说目前版本的Redis只使用了周期事件。</p>
<p>在实现方面，服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表找到所有已到达的时间事件，并调用相应的事件处理器。</p>
<p>【注】在目前的版本中，正常模式下的Redis服务器只使用serverCron一个时间事件，在benchmark模式下也只有两个时间事件，所以用无序链表不会影响性能。</p>
<h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>事件的调度和执行由<code>ae.c/aeProcessEvents</code>函数负责，大致逻辑如下：</p>
<ol>
<li>获取到达时间离当前时间最近的时间事件，最计算出距离还有多少毫秒赋值给remaind_ms</li>
<li>如果剩余时间小于0，则将remaind_ms更新为0</li>
<li>根据remaind_ms创建一个timeval结构</li>
<li>根据timeval结构阻塞并等待文件事件产生，如果remaind_ms==0，则不阻塞</li>
<li>处理所有产生的文件事件</li>
<li>处理所有已到达的时间事件</li>
</ol>
<p>将aeProcessEvents函数置于一个循环里面，加上初始化和清理函数，这就构成了Redis服务器的主函数。<br><img src="/2018/12/09/《Redis设计与实现》笔记/redisServerMainLoop.png" title="Redis服务器主循环"></p>
<h1 id="第十三章-客户端"><a href="#第十三章-客户端" class="headerlink" title="第十三章 客户端"></a>第十三章 客户端</h1><p>Redis服务器是典型的一对多服务器程序。</p>
<p>对于每个与服务器进行连接的客户端，服务器都会其建立了相应的<code>redis.h/redisClient</code>结构，该结构保存了客户端当前的状态信息以及相关数据结构。</p>
<p>Redis服务器状态结构的clients属性是一个链表，保存了所有与服务器相连的客户端的状态结构。</p>
<h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><p>客户端属性可以分为两类：</p>
<ol>
<li>一类是比较通用的属性；</li>
<li>另一类是和特定功能相关的属性，比如操作数据库时用到的db属性等等。</li>
</ol>
<h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>fd属性的值是-1或者大于-1的整数，-1表示伪客户端，其他表示普通客户端。</p>
<h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><p>name属性一般是空，但可以使用CLIENT setname设置一个，使得客户端更好区分。</p>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>flags属性记录了客户端的角色以及目前所处的状态，具体各个标志可看书p165或redis.h源码。</p>
<h3 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h3><p>客户端状态的输入缓冲区用于保存客户端发送的命令请求。</p>
<h3 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h3><p>在服务器将客户端发送的命令请求保存到客户端的输入缓冲区之后，服务器会解析得到命令参数以及参数个数，并把这两个值分别保存到argv属性和argc属性。</p>
<h3 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h3><p>服务器之后会到命令表（一个字典）中根据argv[0]的值查找命令实现的一个数据结构redisCommand，argv[0]不区分大小写，找到后将客户端状态的cmd属性指向该结构。</p>
<h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><p>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区中，每个客户端都有两个输出缓冲区可用，一个大小固定，一个大小可变。</p>
<ul>
<li>大小固定的缓冲区用于保存长度比较小的回复</li>
<li>大小可变的缓冲区用于保存长度比较大的回复</li>
</ul>
<p>大小固定的缓冲区由buf和bufpos两个属性组成，buf是一个大小为<code>REDIS_REPLY_CHUNK_BYTES</code>字节的字节数组，而bufpos属性则记录buf数组已使用的字节数量，数组长度默认16KB。</p>
<p>可变大小缓冲区由reply链表和一个或多个字符串对象组成。</p>
<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>authenticated属性用于记录客户端是否通过了身份验证，仅在服务器启用了身份验证功能时使用。</p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>c_time：记录创建客户端的时间，CLIENT list命令的age域记录了这个秒数。</p>
<p>lastinteraction属性记录客户端与服务器最后一次互动的时间，idle域记录该秒数。</p>
<p>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制的时间。</p>
<h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><h3 id="普通客户端"><a href="#普通客户端" class="headerlink" title="普通客户端"></a>普通客户端</h3><p>创建普通客户端时，就把新的客户端状态添加到服务器状态结构clients链表的末尾。</p>
<p>普通客户端被关闭的原因有多种：</p>
<ul>
<li>客户端进程退出或者被杀死；</li>
<li>客户端向服务器发送了带有不符合协议格式的命令请求；</li>
<li>客户端成了CLIENT KILL命令的目标；</li>
<li>客户端空转时间超过了timeout配置选项（有一些例外情况见书上p173）</li>
<li>客户端发送的命令请求大小超过输入缓冲区限制大小；</li>
<li>要发送给客户端的命令回复大小超过了输出缓冲区的限制。服务器使用两种模式来限制客户端输出缓冲区的大小：硬性限制和软性限制。</li>
</ul>
<h2 id="Lua脚本的伪客户端"><a href="#Lua脚本的伪客户端" class="headerlink" title="Lua脚本的伪客户端"></a>Lua脚本的伪客户端</h2><p>服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中；</p>
<p>lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。</p>
<h2 id="AOF文件的伪客户端"><a href="#AOF文件的伪客户端" class="headerlink" title="AOF文件的伪客户端"></a>AOF文件的伪客户端</h2><p>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后关闭该伪客户端。</p>
<h1 id="第十四章-服务器"><a href="#第十四章-服务器" class="headerlink" title="第十四章 服务器"></a>第十四章 服务器</h1><p>Redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p>
<h2 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h2><ol>
<li>客户端向服务器发送命令请求，命令请求会转换成协议格式发送</li>
<li>服务器接受命令请求并存入客户端状态的输入缓冲区中，然后处理，在数据库中进行设置操作，并产生命令回复</li>
<li>服务器将命令回复发送给客户端</li>
<li>客户端接受服务器返回的命令回复并将命令回复打印给用户观看</li>
</ol>
<h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>serverCron函数默认每隔100ms执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p>
<h3 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h3><p>为了减少对当前时间系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存了秒级精度的系统当前unix时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line">    <span class="comment">//保存了毫秒级精度的系统当前unix时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这两个属性记录的时间精确度并不高，当需要执行高精度时间的功能来说，服务器还是会再次执行系统调用。</p>
<h3 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h3><p>服务器状态中的lruclock属性保存了服务器的LRU时钟，也是服务器时间缓存的一种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//默认每十秒更新一次，用于计算键的空转时长</span></span><br><span class="line">    <span class="keyword">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>空转时间就是lruclock-lru的值，当然只是一个模糊估计值。</p>
<h3 id="更新服务器每秒执行命令次数"><a href="#更新服务器每秒执行命令次数" class="headerlink" title="更新服务器每秒执行命令次数"></a>更新服务器每秒执行命令次数</h3><p>serverCron函数中的trackOperationsPerSecond函数会以抽样计算的方式估算并记录最近一秒钟处理的命令请求数量，可通过INFO status命令中的instantaneous_ops_per_sec查看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//上一次抽样的时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_last_sample_time;</span><br><span class="line">    <span class="comment">//上一次抽样时服务器已执行命令的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_last_sample_ops;</span><br><span class="line">    <span class="comment">//数组中的每一项记录了一次抽象结果</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ops_sec_samples[REDIS_OPS_SEC_SAMPLES];</span><br><span class="line">    <span class="comment">//数组索引，每次抽样后加1，索引到最后一格则变成0，形成环形数组</span></span><br><span class="line">    <span class="keyword">int</span> ops_sec_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>数组中记录的值是根据服务器平均每一毫秒处理了多少个命令请求乘以1000估算出来的。</p>
<p>instantaneous_ops_per_sec的值则是根据环形数组里的值求平均数得到的估算值。</p>
<h3 id="更新服务器内存峰值记录"><a href="#更新服务器内存峰值记录" class="headerlink" title="更新服务器内存峰值记录"></a>更新服务器内存峰值记录</h3><p>服务器状态中的stat_peak_memory属性记录该值。</p>
<h3 id="处理SIGTERM信号"><a href="#处理SIGTERM信号" class="headerlink" title="处理SIGTERM信号"></a>处理SIGTERM信号</h3><p>收到该信号后悔调用sigtermHandler函数，会打开服务器状态的shutdown_asap标志，用于关闭服务器。</p>
<h3 id="管理客户端资源"><a href="#管理客户端资源" class="headerlink" title="管理客户端资源"></a>管理客户端资源</h3><p>serverCron函数中每次都会调用clientsCron函数，该函数会对一些客户端进行一些检查。</p>
<h3 id="管理数据库资源"><a href="#管理数据库资源" class="headerlink" title="管理数据库资源"></a>管理数据库资源</h3><p>serverCron函数每次都会调用databasesCron函数，会对一部分数据库进行检查。</p>
<h3 id="执行被延迟的BGREWRITEAOF命令"><a href="#执行被延迟的BGREWRITEAOF命令" class="headerlink" title="执行被延迟的BGREWRITEAOF命令"></a>执行被延迟的BGREWRITEAOF命令</h3><p>服务器状态的aof_rewrite_scheduled标志记录是否延迟。</p>
<h3 id="检查持久化操作的运行状态"><a href="#检查持久化操作的运行状态" class="headerlink" title="检查持久化操作的运行状态"></a>检查持久化操作的运行状态</h3><p>服务器状态使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程的ID，也可以用来查询这两个命令是否在执行。</p>
<img src="/2018/12/09/《Redis设计与实现》笔记/持久化检查.png" title="判断是否需要执行持久化操作">
<h3 id="将AOF缓冲区中的内容写入AOF文件"><a href="#将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="将AOF缓冲区中的内容写入AOF文件"></a>将AOF缓冲区中的内容写入AOF文件</h3><h3 id="关闭异步客户端"><a href="#关闭异步客户端" class="headerlink" title="关闭异步客户端"></a>关闭异步客户端</h3><h3 id="增加cronloops计数器的值"><a href="#增加cronloops计数器的值" class="headerlink" title="增加cronloops计数器的值"></a>增加cronloops计数器的值</h3><p>该值记录serverCron函数执行的次数。</p>
<h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><p>服务器从刚启动到能够接受客户端命令请求，需要经过一系列的初始化和设置过程，比如初始化服务器状态，接受用户指定的服务器配置，创建相应的数据结构和网络连接等等。</p>
<h3 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h3><p>初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为各个属性设置默认值。</p>
<p>主要函数是initServerConfig，会做以下工作：</p>
<ul>
<li>设置服务器的运行ID</li>
<li>设置服务器的默认运行频率。</li>
<li>设置服务器的默认配置文件路径</li>
<li>设置服务器的运行架构</li>
<li>设置服务器的默认端口号</li>
<li>设置服务器的默认RDB和AOF持久化条件</li>
<li>初始化LRU时钟</li>
<li>创建命令表</li>
</ul>
<h3 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h3><h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>在initServerConfig函数中只初始化了命令表一个数据结构，不过除了命令表之外，服务器状态还包含其他数据结构，这里列两个比较熟悉的，更多数据结构见书：</p>
<ul>
<li>server.clients链表</li>
<li>server.db数组</li>
</ul>
<p>主要函数是initServer函数，除了初始化数据结构外，该函数还做了一些其他重要的操作设置：</p>
<ul>
<li>为服务器设置进程信号处理器</li>
<li>创建共享对象</li>
<li>打开服务器监听端口</li>
<li>为serverCron函数创建时间事件</li>
<li>检查AOF</li>
<li>初始化后台I/O模块</li>
</ul>
<h3 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h3><h3 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h3><h1 id="第十五章-复制"><a href="#第十五章-复制" class="headerlink" title="第十五章 复制"></a>第十五章 复制</h1><p>在Redis中，用户可以通过SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，则被复制的服务器为主服务器，进行复制的称作从服务器。</p>
<h2 id="旧版复制功能的实现（2-8版本以前）"><a href="#旧版复制功能的实现（2-8版本以前）" class="headerlink" title="旧版复制功能的实现（2.8版本以前）"></a>旧版复制功能的实现（2.8版本以前）</h2><p>Redis的复制功能分为同步（sync）和命令传播两个操作。</p>
<p>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p>
<p>命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态不一致时，让主从服务器数据重新回到一致的状态。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当客户端向从服务器发送SLAVEOF命令时，要求从服务器复制主服务器，从服务器需要执行同步操作。</p>
<ol>
<li>从服务器向主服务器发送SYNC命令。</li>
<li>主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用缓冲区来记录从现在开始执行的所有写命令</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器</li>
<li>主服务器将缓冲区里的所有写命令发送给从服务器。</li>
</ol>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>同步操作执行完之后，主从服务器两者的数据库将达到一致状态，但这种一致并不是永远的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就可能被修改并导致主从服务器状态不再一致，这时就需要主服务器将运行的写命令传播给从服务器，使两者数据库保持一致。</p>
<h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>简单来说，同步完成之后主从服务器之间是通过命令传播来保持一致的，但如果在命令传播阶段主从服务器断开连接了，等到从服务器重新连上来的时候，它会重新发送SYNC同步命令将自上次同步之后的所有命令都重新生成RDB文件同步一遍，但这RDB文件中可能有很多操作是在掉线之前的命令传播阶段就做了的，所以会很低效，而且SYNC是一个非常耗费资源的资源。</p>
<h2 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h2><p>为了解决上述缺陷，Redis从2.8版本开始使用PSYNC命令代替SYNC命令来执行复制时的同步操作。</p>
<p>PSYNC命令具有完整重同步和部分重同步两种模式：</p>
<ul>
<li>完整重同步用于处理初次复制情况，和SYNC命令执行步骤基本一样。</li>
<li>部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只处理这些写命令。</li>
</ul>
<h2 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h2><p>部分重同步功能由以下三个部分构成：</p>
<ul>
<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量。个人感觉可以和TCP连接中收发端的滑动窗口以及序号类比，主服务器发了N字节，就把主服务器的偏移量加上N，从服务器接收到N字节就把自己的偏移量加上N，主从一致时，主从服务器的偏移量应该是一样的。</li>
<li>主服务器的复制积压缓冲区（replication backlog），主服务器每次往从服务器命令传播时也会往一个叫做复制积压缓冲区的定长先进先出队列中写入相同命令，当主从服务器断开连接，这时主从服务器的偏移量就不一样了，当从服务器重新连上来时会检查主从偏移量之间的差距，如果相差的数据大小没有超过复制积压缓冲区大小，则可从积压缓冲区中将没接收到的数据重新发送，即PSYNC，否则只能完整重同步；</li>
<li>服务器的运行ID（run ID），实现部分重同步还需要用到服务器运行ID，是40个随机十六进制，当从服务器初次对主服务器进行复制时，主服务器会将自己的运行ID传送给从服务器，掉线重连后从服务器会向主服务器发送该ID，如果相同则说明连上的就是之前的主服务器，就执行PSYNC，否则只能完整重同步。</li>
</ul>
<h2 id="PSYNC命令实现流程"><a href="#PSYNC命令实现流程" class="headerlink" title="PSYNC命令实现流程"></a>PSYNC命令实现流程</h2><img src="/2018/12/09/《Redis设计与实现》笔记/psync实现.png" title="PSYNC命令调用流程图">
<h2 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h2><p>通过向从服务器发送SLAVEOF命令，可以让一个从服务器去复制一个主服务器（2.8版本以上）。</p>
<p><code>SALVEOF &lt;mater_ip&gt; &lt;master_port&gt;</code></p>
<p>本节是一个具体例子，可以看p211，这里简单列出步骤：</p>
<ol>
<li>设置主服务器的地址和端口；</li>
<li>建立套接字连接；</li>
<li>发送ping命令；</li>
<li>身份验证；</li>
<li>发送端口信息；</li>
<li>同步，从服务器向主服务器发送PSYNC命令，值得一提的是在同步操作之前只有从服务器时主服务器的客户端，但是在执行同步操作之后，主服务器也是从服务器的客户端；</li>
<li>命令传播。</li>
</ol>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>在命令传播阶段，从服务器会默认以每秒一次的频率向主服务器发送命令<code>REPLCONF ACK &lt;replication_offset&gt;</code>，主要有三个作用：检测主从服务器的网络连接状态、辅助实现min-slaves选项、检测命令丢失。</p>
<p>2.8版本之前没有这个命令，所以尽量使用2.8版本以上的Redis。</p>
<h1 id="第十六章-Sentinel"><a href="#第十六章-Sentinel" class="headerlink" title="第十六章 Sentinel"></a>第十六章 Sentinel</h1><p>Sentinel（哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器以及这些主服务器下的所有从服务器，当被监视的主服务器下线时，Sentinel系统会自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续执行命令请求。</p>
<h2 id="启动并初始化Sentinel"><a href="#启动并初始化Sentinel" class="headerlink" title="启动并初始化Sentinel"></a>启动并初始化Sentinel</h2><p>启动一个Sentinel可以使用命令：<code>redis-sentinel /path/to/your/sentinel.conf</code>或者命令<code>redis-server /path/to/your/sentinel.conf --sentinel</code>.</p>
<p>启动步骤如下：</p>
<ol>
<li>初始化一个服务器</li>
<li>将普通Redis服务器使用的代码替换城Sentinel专用代码</li>
<li>初始化Sentinel状态</li>
<li>根据给定的配置文件，初始化Sentinel的监视主服务器列表</li>
<li>创建连上主服务器的网络连接，对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接：一个是命令连接，一个是订阅连接。</li>
</ol>
<h2 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h2><p>Sentinel默认会以每十秒一次的频率向被监视的主服务器发送INFO命令，从命令返回的结果中可以看出该主服务器的信息以及其属下的从服务器信息，并进行更新。</p>
<h2 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h2><p>当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建新的实例之外，还会创建连接到从服务器的命令连接和订阅连接。</p>
<p>Sentinel也会默认每十秒一次向从服务器发送INFO命令。</p>
<h2 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h2><p>默认下，Sentinel会以每两秒一次的频率向所有被监视的主从服务器发送以下格式的命令：</p>
<p><code>PUBLISH \__sentine__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_pi&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</code></p>
<p>s_开头的是Sentinel本身的信息，m_表示的是当前监视的主或从服务器的信息。</p>
<h2 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h2><p>当Sentinel与一个主服务器或从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令：<code>SUBSCRIBE \__sentinel__: hello</code>，对该频道的订阅会一直持续到连接断开为止。</p>
<p>对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到并处理。</p>
<p>Sentinel和Sentinel之间不会创建订阅连接，只有命令连接。</p>
<h2 id="检测主观下线状态"><a href="#检测主观下线状态" class="headerlink" title="检测主观下线状态"></a>检测主观下线状态</h2><p>默认下，Sentinel会以每秒一次的频率向所有与它建立了命令接连的实例发送ping命令，并通过返回的结果判断实例是否在线。</p>
<p>Sentinel配置文件中的down-after-milliseconds选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在down-after-milliseconds毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开SRI_S_DOWN标识，以此来表示这个实例已经进入主观下线状态。</p>
<h2 id="检查客观下线状态"><a href="#检查客观下线状态" class="headerlink" title="检查客观下线状态"></a>检查客观下线状态</h2><p>当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的其他Sentinel进行询问，当Sentinel从其他Sentinel那接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，打开主服务器实例结构flags属性的SRI_O_DOWN标识，并对主服务器执行故障转移操作。</p>
<h2 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a>选举领头Sentinel</h2><p>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，由它对下线主服务器进行故障转移操作。</p>
<p>选举规则还比较复杂，详细看p239.</p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移擦操作，该操作包含以下三个步骤：</p>
<ol>
<li>在已下线主服务器属下的所有从服务器中挑选出一个转换成主服务器；</li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器；</li>
<li>将已下线主服务器设置为新的主服务器的从服务器。</li>
</ol>
<h1 id="第十七章-集群"><a href="#第十七章-集群" class="headerlink" title="第十七章 集群"></a>第十七章 集群</h1><p>Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>连接各个节点的工作可以使用<code>CLUSTER MEET</code>命令来完成，Redis服务器会在启动时根据cluster-enabled配置选项是否是yes来决定是否开启服务器的集群模式。</p>
<h3 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h3><p>clusterNode结构保存了一个节点的当前状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line">    <span class="comment">//节点名字，由40个十六进制组成</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    <span class="comment">//节点标识</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//节点当前的配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line">    <span class="comment">//节点ip</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line">    <span class="comment">//节点端口</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">//保持连接节点所需的有关信息</span></span><br><span class="line">    clusterLink* link;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clustereLink</span>&#123;</span></span><br><span class="line">    <span class="comment">//连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line">    <span class="comment">//TCP套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//输出缓冲区，保存着等待发送给其他节点的消息</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    <span class="comment">//输入缓冲区，保存着从其他节点接收到的消息</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line">    <span class="comment">//与这个连接相关联的节点，如果没有就为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个节点都保存一个clusterState结构，记录在当前节点的视角下集群目前所处的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//指向当前节点的指针</span></span><br><span class="line">    clusterNode* myself;</span><br><span class="line">    <span class="comment">//配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">//集群当前的状态，在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="comment">//集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//集群节点名单</span></span><br><span class="line">    dict* nodes;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<h3 id="CLUSTER-MEET命令的实现"><a href="#CLUSTER-MEET命令的实现" class="headerlink" title="CLUSTER MEET命令的实现"></a>CLUSTER MEET命令的实现</h3><img src="/2018/12/09/《Redis设计与实现》笔记/clustermeet.png" title="节点的握手过程">
<h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p>Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理0个或最多16384个槽。</p>
<p>当所有16384个槽都有节点在处理时，集群处于上线状态，否则处于下线状态。</p>
<p>可以利用CLUSTER ADDSLOTS命令将一个或多个槽指派给节点负责。</p>
<h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>slots属性是一个二进制位数组，每一位用来表示该节点是否负责处理该槽，1表示处理。</p>
<h3 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h3><p>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots之外，还会将自己的slots数组通过消息发送给集群中的其他节点。</p>
<h3 id="记录集群所有槽的指派信息"><a href="#记录集群所有槽的指派信息" class="headerlink" title="记录集群所有槽的指派信息"></a>记录集群所有槽的指派信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* slots[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure>
<h3 id="CLUSTER-ADDSLOTS命令的实现"><a href="#CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="CLUSTER ADDSLOTS命令的实现"></a>CLUSTER ADDSLOTS命令的实现</h3><ol>
<li>遍历所有输入的槽，如果有哪怕一个槽已经指派给了某个节点，则返回错误</li>
<li>若所有输入槽都是未指派槽，则再次遍历所有输入槽，指派给当前节点，修改clusterState.slots数组和clusterNode.slots数组</li>
</ol>
<h2 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h2><p>集群上线后，当客户端向节点发送命令时，接收命令的节点会计算出命令要处理的数据库属于哪个槽，如果是自己则直接执行，如果不是自己则向客户端返回MOVED错误，指引客户端转向正确的节点。</p>
<h3 id="计算键属于哪个槽"><a href="#计算键属于哪个槽" class="headerlink" title="计算键属于哪个槽"></a>计算键属于哪个槽</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slot_number</span><span class="params">(key)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> CRC16(key) &amp; <span class="number">16383</span></span><br></pre></td></tr></table></figure>
<h3 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h3><p>节点和单机服务器在数据库方面的一个区别是，节点只能使用0号数据库，而单机Redis没有这个限制，其他地方则相同。</p>
<h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点。</p>
<p>重新分片可以在线进行。</p>
<p>Redis集群的重新分片操作时由Redis的集群管理软件redis-trib负责执行的，具体步骤如下：</p>
<ol>
<li>redis-trib向目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让目标节点准备好从源节点导入属于槽slot的键值对</li>
<li>redis-trib对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>，让源节点准备好将属于槽slot的键值对迁移到目标节点</li>
<li>redis-trib向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令，获得最多count个属于槽slot的键值对的键名</li>
<li>对于3中获得的每个键名，redis-trib都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>命令，将被选中的键值对原子地迁移</li>
<li>重复3和4直到所有节点都完成迁移</li>
<li>redis-trib向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>命令，将槽slot指派给目标节点，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。</li>
</ol>
<h2 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h2><img src="/2018/12/09/《Redis设计与实现》笔记/ask错误.png" title="判断是否发送ASK错误的过程">
<h3 id="CLUSTER-SETSLOT-IMPORTING命令的实现"><a href="#CLUSTER-SETSLOT-IMPORTING命令的实现" class="headerlink" title="CLUSTER SETSLOT IMPORTING命令的实现"></a>CLUSTER SETSLOT IMPORTING命令的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* importing_slots_from[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure>
<p>如果importing_slots_from[i]的值不是NULL，而是指向一个clusterNode节点，那么表示当前节点正在从clusterNode所代表的节点导入槽i。</p>
<p>在对集群进行重新分片的时候，向目标节点发送命令：</p>
<p><code>CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</code>可以将目标节点的importing_slots_from[i]的值设置为source_id所代表的节点的clusterNode结构。</p>
<h3 id="CLUSTER-SETSLOT-MIGRATING命令的实现"><a href="#CLUSTER-SETSLOT-MIGRATING命令的实现" class="headerlink" title="CLUSTER SETSLOT MIGRATING命令的实现"></a>CLUSTER SETSLOT MIGRATING命令的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode* migrating_slots_to[<span class="number">16384</span>];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure>
<p>同理，如果migrating_slots_to[i]的值不为NULL，则表示正在向所指的clusterNode节点迁移。</p>
<p>命令：<code>CLUSTER SETSLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</code></p>
<h3 id="ASK错误-1"><a href="#ASK错误-1" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>如果节点收到一个键key的请求，但并没有在自己的数据库里找到键key，那么节点会检查自己的clusterState.migrating_slots_to[i]，如果正在迁移，则会向客户端发送一个ASK错误，引导客户端到正在导入槽i的节点去查找key。</p>
<h3 id="ASKING命令"><a href="#ASKING命令" class="headerlink" title="ASKING命令"></a>ASKING命令</h3><p>ASKING命令唯一要做的就是打开发送该命令的客户端的REDIS_ASKING标识。</p>
<p>当客户端接受到ASK错误时会先向转向节点发一个ASKING命令，然后才再次发送命令。</p>
<p>客户端的REDIS_ASKING标识是一个一次性标识，当节点执行了一个带有REDIS_ASKING标识的客户端发送的命令之后，该客户端的REDIS_ASKING标识就会被移除。</p>
<h3 id="ASK错误和MOVED错误的区别"><a href="#ASK错误和MOVED错误的区别" class="headerlink" title="ASK错误和MOVED错误的区别"></a>ASK错误和MOVED错误的区别</h3><p>MOVED错误代表槽的负责权已经从一个节点转移到了另一个节点；</p>
<p>ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施。</p>
<h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p>Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，从节点用于复制某个主节点，并在被复制的主节点下线时代替下线主节点继续处理命令请求。</p>
<h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>向一个节点发送命令：<code>CLUSTER REPLICATE &lt;node_id&gt;</code>可以让接收命令的节点成为noid_id所指定节点的从节点并开始复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//如果这时一个从节点，那么指向主节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">slaveof</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>集群中的所有节点都会在代表主节点的clusterNode结构的slaves属性和numslaves属性中记录正在复制这个主节点的从节点名单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//正在复制这个主节点的从节点数量</span></span><br><span class="line">    <span class="keyword">int</span> numslaves;</span><br><span class="line">    <span class="comment">//一个数组，每个项指向一个正在复制这个主节点的从节点的clusterNode结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>** <span class="title">slaves</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中的每个节点都会定期向集群中的其他节点发送ping消息，如果接受ping消息的节点没有在规定的时间内返回pong消息，则会被标记为疑似下线（probable fail，PFAIL）。</p>
<p>当一个主节点A通过消息得知主节点B认为主节点C进入了PFAIL，主节点A会在自己的clusterState.nodes字典里找到主节点C，并将B的下线报告添加到fail_reports链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//一个链表，记录了所有其他节点对该节点的下线报告</span></span><br><span class="line">    <span class="built_in">list</span>* fail_reports;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span>&#123;</span></span><br><span class="line">    <span class="comment">//报告目标节点已经下线的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">//最后一次从node节点收到下线报告的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> time;</span><br><span class="line">&#125;<span class="keyword">typedef</span> clusterNodeFailReport;</span><br></pre></td></tr></table></figure>
<p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线，将X标记为已下线的节点会向集群广播此消息，所有收到该消息的节点都会立刻将X标记为已下线。</p>
<h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><p>当一个从节点发现自己正在复制的主节点进入了已下线状态，则会开始进行故障转移。</p>
<ol>
<li>从所有从节点中选中一个节点，选举方法和16章中选举零头Sentinel的方法非常相似，因为两者都是基于Raft算法的领头选举方法来实现的；</li>
<li>被选中的从节点执行SLAVEOF no one命令，成为新的主节点；</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己；</li>
<li>新的主节点广播PONG消息；</li>
<li>新的主节点开始接受命令请求。</li>
</ol>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>节点发送的消息主要有以下五种：</p>
<ol>
<li>MEET消息</li>
<li>PING消息</li>
<li>PONG消息，以上三种消息都是用相同的消息正文，所以是通过消息头的type属性来判断的，每次发送这三种消息的时候，发送者都从自己的已知节点列表中随机选出两个节点保存到clusterMsgDataGossip结构中发送出去。</li>
<li>FAIL消息，当主节点A将主节点B标记为FAIl时，A会向集群广播关于B的FAIL消息，FAIL消息的正文里只包含nodename属性。</li>
<li>PUBLISH消息，当客户端向集群中的某个节点发送命令<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>命令，接收到PUBLISH命令的节点不仅会向channel频道发送消息message，还会向集群广播一条PUBLISH消息，所有接受到这条PUBLISH消息的节点都会向channel发送message。</li>
</ol>
<p>一条消息由消息头和消息正文组成。</p>
<p>消息头的主要字段见p282，由clusterMsg结构表示。</p>
<h1 id="第十八章-发布与订阅"><a href="#第十八章-发布与订阅" class="headerlink" title="第十八章 发布与订阅"></a>第十八章 发布与订阅</h1><p>Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。</p>
<h2 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h2><p>当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立起了一种订阅关系。</p>
<p>Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存所有频道的订阅关系</span></span><br><span class="line">    dict* pubsub_channels;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>订阅和退订就是在字典上进行操作，p294。</p>
<h2 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h2><p>PSUBSCRIBE命令用来订阅模式，与频道类似，服务器也将所有模式的订阅关系都保存在一个属性里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//保存所有模式订阅关系</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该属性是一个链表，链表中的每个节点都包含着一个pubsubPattern结构，这个结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span>&#123;</span></span><br><span class="line">    <span class="comment">//订阅模式的客户端</span></span><br><span class="line">    redisClient * client;</span><br><span class="line">    <span class="comment">//被订阅的模式</span></span><br><span class="line">    robj* pattern;</span><br><span class="line">&#125;pubsubPattern;</span><br></pre></td></tr></table></figure>
<p>模式的订阅与退订也就是在list上进行操作，p296.</p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>当一个Redis客户端执行<code>PUBLISH &lt;channel&gt; &lt;message&gt;</code>命令将消息message发送给频道channel的时候，服务器需要执行以下两个动作：</p>
<ol>
<li>将消息message发送给channel频道的所有订阅者；</li>
<li>如果有一个或多个模式和channel频道匹配，那么将message发送给pattern模式的订阅者。</li>
</ol>
<h2 id="查看订阅信息"><a href="#查看订阅信息" class="headerlink" title="查看订阅信息"></a>查看订阅信息</h2><p><code>PUBSUB</code>命令是Redis2.8新增加的命令之一，客户端可以通过这个命令来查看频道或模式的相关信息。</p>
<p><code>PUBSUB CHANNELS [pattern]</code>用于返回服务器当前被订阅的频道</p>
<p><code>PUBSUB NUMSUB [channel-1 channel-2 ...]</code>接受任意多个频道作为输入参数，并返回这些频道的订阅者数量。</p>
<p><code>PUBSUB NUMPAT</code>命令用于返回服务器当前被订阅模式的数量，即返回pubsub_patterns链表的长度。</p>
<h1 id="第十九章-事务"><a href="#第十九章-事务" class="headerlink" title="第十九章 事务"></a>第十九章 事务</h1><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务功能。</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>一个事务从开始到结束通常会经历三个阶段：</p>
<ul>
<li><p>事务开始，MULTI命令的执行标志着事务的开始，打开了客户端状态的flags属性中的REDIS_MULTI标识。</p>
</li>
<li><p>命令入队</p>
<img src="/2018/12/09/《Redis设计与实现》笔记/事务命令入队.png" title="服务器判断命令是该入队还是该执行的过程">
</li>
<li><p>事务执行，每个客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里，该属性是一个multiState结构：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span>&#123;</span></span><br><span class="line">    <span class="comment">//事务队列，fifo顺序</span></span><br><span class="line">    multiCmd* commands;</span><br><span class="line">    <span class="comment">//已入队命令计数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125; multiState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span>&#123;</span></span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="comment">//命令指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure>
<p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行，服务器会遍历该客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p>
<h2 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h2><p>WATCH命令是一个乐观锁，它可以在EXEC命令执行之前监视任意数量的数据库键，并在EXEC命令执行时检查被监视的键是否至少有一个已经被修改过，如果是，服务器将拒绝执行事务并返回代表执行失败的空回复。</p>
<p>每个Redis数据库都保存着一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//正在被WATCH命令监视的键</span></span><br><span class="line">    dict* watched_keys;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有对数据库进行修改的命令在执行之后都会调用multi.c/touchWatchKey函数对该字典进行检查，查看是否有客户端正在监视刚刚被修改过的键，如果有则打开该客户端的REDIS_DIRTY_CAS标识，标识客户端的事务安全性已经被破坏。</p>
<p>当服务器接收到某客户端的EXEC命令时会检查该客户端是否打开了REDIS_DIRTY_CAS标识，如果打开了则拒绝执行。</p>
<h2 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h2><p>原子性（Atomicity）、一致性（Consistency）、隔离性（isolation）以及持久性（durability），前三者总是有的，当Redis运行在某种特定的持久化模式下时，事务也具有持久性。</p>
<p>Redis没有事务回滚机制。</p>
<p>Redis事务中三个可能出错的地方：</p>
<ol>
<li>入队错误</li>
<li>执行错误</li>
<li>服务器停机</li>
</ol>
<p>Redis事务只有当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时才具有持久性（同时还需要no-appendfsync-on-rewrite配置选项没有被打开）。</p>
<p>其实不管Redis在什么模式下运作，在一个事务的最后加上SAVE命令总可以保证事物的耐久性，但这种做法效率太低，所以不具有实用性。</p>
<h1 id="第二十章-Lua脚本"><a href="#第二十章-Lua脚本" class="headerlink" title="第二十章 Lua脚本"></a>第二十章 Lua脚本</h1><p>Redis从2.6版本开始引入对Lua脚本的支持，客户端可以通过使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p>
<h2 id="创建并修改Lua环境"><a href="#创建并修改Lua环境" class="headerlink" title="创建并修改Lua环境"></a>创建并修改Lua环境</h2><ul>
<li>创建一个基础的Lua环境</li>
<li>载入函数库</li>
<li>创建redis全局表格</li>
<li>使用redis自制的随机函数来替换Lua原有的随机函数</li>
<li>创建排序辅助函数</li>
<li>创建redis.pcall函数的错误报告辅助函数</li>
<li>保护lua的全局环境</li>
<li>将lua环境保存到服务器状态的lua属性中</li>
</ul>
<h2 id="lua环境协作组件"><a href="#lua环境协作组件" class="headerlink" title="lua环境协作组件"></a>lua环境协作组件</h2><p>一个是负责执行Lua脚本中的redis命令的伪客户端，一个是用于保存Lua脚本的lua_scripts字典，该字典有两个作用：实现SCRIPT EXISTS命令和实现脚本复制功能。</p>
<img src="/2018/12/09/《Redis设计与实现》笔记/lua.png" title="Lua脚本执行Redis命令时的通信步骤">
<h2 id="EVAL命令的实现"><a href="#EVAL命令的实现" class="headerlink" title="EVAL命令的实现"></a>EVAL命令的实现</h2><ol>
<li>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数</li>
<li>将客户端给定的脚本保存到lua_srcipts字典，等待将来进一步使用</li>
<li>执行刚刚在Lua环境中定义的函数</li>
</ol>
<h2 id="EVALSHA命令的实现"><a href="#EVALSHA命令的实现" class="headerlink" title="EVALSHA命令的实现"></a>EVALSHA命令的实现</h2><p>只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的。</p>
<h2 id="脚本管理命令的实现"><a href="#脚本管理命令的实现" class="headerlink" title="脚本管理命令的实现"></a>脚本管理命令的实现</h2><p><code>SCRIPT FLUSH</code>：用于清除服务器中所有和Lua脚本有关的命令，这个命令会释放并重建lua_scripts字典，关闭现有的lua环境并重新创建一个新的Lua环境。</p>
<p><code>SCRIPT EXISTS</code>：根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p>
<p><code>SCRIPT LOAD</code>：和EVAL命令执行脚本所做的前两步完全一样：命令首先在Lua环境中为脚本创建相对应的函数，然后再将脚本保存到lua_scripts字典中。</p>
<p><code>SCRIPT KILL</code>：如果超时运行的脚本未执行过任何写入操作，那么客户端可以通过SCRIPT KILL命令来指示服务器停止执行这个脚本，并向执行该脚本的客户端发送一个错误回复。</p>
<h2 id="脚本复制"><a href="#脚本复制" class="headerlink" title="脚本复制"></a>脚本复制</h2><p>复制EVAL、SCRIPT FLUSH和SCRIPT LOAD命令时，主服务器会直接向所有从服务器发送该命令。</p>
<p>而在传播EVALSHA命令的时候，必须确保EVALSHA命令要执行的脚本已经被所有从服务器载入过，否则主服务器会将EVALSHA命令转换成一个等价的EVAL命令进行传播。</p>
<p>主服务器使用服务器状态的repl_scriptcache_dict字典记录自己已经将哪些脚本传播给了所有从服务器，键是SHA1校验和，而值都是NULL。</p>
<p>每当主服务器添加一个新的从服务器时，主服务器都会清空自己的repl_scriptcache_dict字典。</p>
<h1 id="第二十一章-排序"><a href="#第二十一章-排序" class="headerlink" title="第二十一章 排序"></a>第二十一章 排序</h1><p>Redis的SORT命令可以对列表键、集合键或者有序集合键的值进行排序。</p>
<p>用的是快排。</p>
<h2 id="SORT-命令的实现"><a href="#SORT-命令的实现" class="headerlink" title="SORT 命令的实现"></a>SORT <key>命令的实现</key></h2><p>该命令可以对一个包含数字值的键key进行排序，详细步骤如下：</p>
<ol>
<li>创建一个和numbers列表长度相同的数组，数组每一项都是一个RedisSortObject结构；</li>
<li>遍历该数组，将各个数组项的obj指针分别指向numbers列表的各个项，并将obj指针所指的列表项转换成一个double类型浮点数存在相应数组项的u.score属性里面；</li>
<li>根据u.score的值对数组排序；</li>
<li>遍历数组，顺序输出obj所指的列表项。</li>
</ol>
<p>ALPHA、ASC以及DESC选项的实现都是在对数组排序的时候有所不同，具体看p347开始的几页。</p>
<h2 id="LIMIT选项的实现"><a href="#LIMIT选项的实现" class="headerlink" title="LIMIT选项的实现"></a>LIMIT选项的实现</h2><p>在默认情况下，SORT命令总会将排序后的所有元素都返回给客户端，但是通过LIMIT选项可以只返回其中一部分。</p>
<p><code>LIMIT &lt;offset&gt; &lt;count&gt;</code></p>
<h2 id="GET选项的实现"><a href="#GET选项的实现" class="headerlink" title="GET选项的实现"></a>GET选项的实现</h2><p>通过GET选项，我们可以让SORT命令在对键进行排序之后，根据被排序的元素，以及GET选项所指定的模式，查找并返回某些键的值。</p>
<h2 id="STORE选项的实现"><a href="#STORE选项的实现" class="headerlink" title="STORE选项的实现"></a>STORE选项的实现</h2><p>默认情况下，SORT命令只向客户端返回排序结果，而不保存排序结果。</p>
<p>通过STORE选项，可以将排序结果保存到指定的键里面，并在又需要的时候重用这个排序结果。</p>
<p><code>SORT key ALPHA STORE key2</code></p>
<h2 id="多个选项的执行顺序"><a href="#多个选项的执行顺序" class="headerlink" title="多个选项的执行顺序"></a>多个选项的执行顺序</h2><ol>
<li>排序：在这一步命令会使用ALPHA、ASC或DESC、BY这几个选项；</li>
<li>限制排序结果集的长度，会使用LIMIT选项；</li>
<li>获取外部键，会使用GET选项</li>
<li>保存排序结果集：使用STORE选项</li>
<li>向客户端返回排序结果集</li>
</ol>
<h2 id="选项的摆放顺序"><a href="#选项的摆放顺序" class="headerlink" title="选项的摆放顺序"></a>选项的摆放顺序</h2><p>除了GET选项之外，改变选项的摆放顺序并不会影响SORT命令执行这些选项的顺序。</p>
<h1 id="第二十二章-二进制位数组"><a href="#第二十二章-二进制位数组" class="headerlink" title="第二十二章 二进制位数组"></a>第二十二章 二进制位数组</h1><p>Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组。</p>
<p>BITOP命令既可以对多个位数组进行按位与、按位或、按位异或运算，也可以对给定的数组进行取反运算。</p>
<h2 id="位数组的表示"><a href="#位数组的表示" class="headerlink" title="位数组的表示"></a>位数组的表示</h2><p>Redis使用SDS结构来保存位数组，并使用SDS结构的操作函数来处理位数组。</p>
<p>【注意】buf数组保存位数组的顺序和我们平时书写位数组的顺序是完全相反的，比如buf[0]字节中各个位分别是1/0/1/1/0/0/1/0，表示的其实是01001101。这样来保存可以简化SETBIT命令的实现。</p>
<h2 id="GETBIT命令的实现"><a href="#GETBIT命令的实现" class="headerlink" title="GETBIT命令的实现"></a>GETBIT命令的实现</h2><p><code>GETBIT &lt;bitarray&gt; &lt;offset&gt;</code></p>
<ol>
<li>计算byte=offset/8</li>
<li>计算bit=（offset mod 8）+1</li>
<li>根据byte和bit去取值。</li>
</ol>
<p>时间复杂度O（1）。</p>
<h2 id="SETBIT命令的实现"><a href="#SETBIT命令的实现" class="headerlink" title="SETBIT命令的实现"></a>SETBIT命令的实现</h2><p><code>SETBIT &lt;bitarray&gt; &lt;offset&gt; &lt;value&gt;</code></p>
<ol>
<li>计算len=offset/8+1</li>
<li>检查bitarray键保存的位数组的长度是否小于len，如果是则扩展为len个字节，并将新扩展的二进制位都设置为0；</li>
<li>计算byte=offset/8</li>
<li>计算bit=（offset mod 8）+1</li>
<li>根据byte和bit定位offset偏移量指定的二进制位，首先将该位上的值保存在oldvalue中，然后将新值value设置为这个二进制的值</li>
<li>向客户端返回oldvalue的值</li>
</ol>
<p>时间复杂度O(1)。</p>
<p>【注意】因为buf数组使用逆序来保存位数组，所以当程序需要对buf数组进行扩展时，写入操作可以直接在新扩展的二进制位中完成，而不必改动位数组原来已有的二进制位。如果buf数组使用和书写一样的顺序来保存位数组，那么每次扩展buf数组后都需要将已有的位进行移动，然后才能执行写操作，影响执行速度。</p>
<h2 id="BITCOUNT命令的实现"><a href="#BITCOUNT命令的实现" class="headerlink" title="BITCOUNT命令的实现"></a>BITCOUNT命令的实现</h2><p>几种可能的实现方式：</p>
<ol>
<li>遍历</li>
<li>查表，即映射hash，以空间换时间</li>
<li>variable-precison SWAR算法</li>
</ol>
<p>前两种有明显缺陷，主要看下第三种。</p>
<p>统计一个数组中非0二进制位的数量，在数学上被称为“计算汉明重量”，对于普通处理器来说，目前已知效率最好的通用算法就是variable-precison SWAR算法，该算法通过一系列位移和位运算操作，可以在常数时间内计算多个字节的汉明重量，并且不需要任何额外内存。</p>
<p>具体例子和算法见p372，看下来主要逻辑就是利用移位和位运算先算每两位有多少个1，然后算每四位有多少个1，接着是每八位有多少个1，依次类推，最后算出总的，但这个总数是在最高位的，所以需要再进行一个移位操作把值移到最低字节便于查看。</p>
<h3 id="Redis中的实现"><a href="#Redis中的实现" class="headerlink" title="Redis中的实现"></a>Redis中的实现</h3><p>BITCOUNT命令的实现用到了查表和SWAR两种算法：</p>
<ul>
<li>查表算法使用键长8位的表，表中记录从0000 0000到1111 1111在内的所有二进制位的汉明重量；</li>
<li>而SWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precision SWAR算法来计算这128个二进制位的汉明重量。</li>
</ul>
<p>在执行命令时，会根据未处理的二进制位的数量来决定具体使用哪种算法，大于等于128就用SWAR，否则用查表法。</p>
<p>时间复杂度O(n)。</p>
<h2 id="BITOP命令的实现"><a href="#BITOP命令的实现" class="headerlink" title="BITOP命令的实现"></a>BITOP命令的实现</h2><p>因为C语言直接支持对字节执行逻辑与或非以及异或操作，所有BITOP命令的AND、OR、XOR和NOT四个操作都是直接基于这些逻辑操作实现的。</p>
<p>NOT复杂度O(n)，其他的O(n^2)。</p>
<h1 id="第二十三章-慢查询日志"><a href="#第二十三章-慢查询日志" class="headerlink" title="第二十三章 慢查询日志"></a>第二十三章 慢查询日志</h1><p>Redis的慢查询日志功能用于记录执行时间超过给定时长的命令请求，用户可以通过这个功能产生的日志来监视和优化查询速度。</p>
<p>服务器配置中有两个和慢查询日至相关的选项：</p>
<ul>
<li><code>showlog-log-slower-than</code>选项指定执行时间超过多少微妙的命令请求会被记录到日志上；</li>
<li><code>showlog-max-len</code>选项指定服务器最多保存多少条查询日志。</li>
</ul>
<p>服务器使用先进先出的方式保存慢查询日志。</p>
<p><code>SLOWLOG GET</code>命令查看服务器所保存的慢查询日志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//下一条慢查询日志的ID</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;</span><br><span class="line">    <span class="comment">//保存了所有慢查询日志的链表</span></span><br><span class="line">    <span class="built_in">list</span>* slowlog;</span><br><span class="line">    <span class="comment">//服务器配置slowlog-log-slower-than选项的值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//slowlog链表中每个节点都是一个slowlogEntry结构，新的节点插入在表头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntrt</span>&#123;</span></span><br><span class="line">    <span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">//命令执行时的时间，格式为UNIX时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> time;</span><br><span class="line">    <span class="comment">//执行命令消耗的时间，以微妙为单位</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration;</span><br><span class="line">    <span class="comment">//命令与命令参数</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="comment">//命令与命令参数的数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">&#125;slowlogEntry;</span><br></pre></td></tr></table></figure>
<p>在每次执行命令的前后，程序都会记录微秒格式的当前UNIX时间戳，这两个时间戳之间的差就是服务器执行命令所耗费的时长，这个时长会传给slowlogPushEntryIfNeeded函数，会根据情况检查是否需要为自己执行的命令创建慢查询日志。</p>
<p>slowlogPushEntryIfNeeded函数作用有两个：检查命令的执行时长是否超过阈值、检查慢查询日志的长度是否超过最大长度。</p>
<h1 id="第二十四章-监视器"><a href="#第二十四章-监视器" class="headerlink" title="第二十四章 监视器"></a>第二十四章 监视器</h1><p>执行MONITOR命令，客户端可以将自己变为一个监视器，实时地接收并打印出服务器当前处理的命令请求的相关信息。</p>
<p>每当一个客户端向服务器发送一条命令请求时，服务器除了会处理这条命令外，还会将关于这条命令请求的信息发送给所有监视器。</p>
<p><code>MONITOR</code>执行步骤如下：</p>
<ol>
<li>打开客户端监视器标志REDIS_MONITOR</li>
<li>将客户端添加到服务器状态的monitors链表的末尾</li>
<li>向客户端返回OK</li>
</ol>
<p>服务器每次处理命令之前，都会调用replicationFeedMonitors函数，由该函数将被处理的命令请求的相关信息发送给各个监视器，该函数步骤如下：</p>
<ol>
<li>根据执行命令的客户端、当前数据库的号码、命令参数、命令参数个数等参数创建要发送给各个监视器的信息</li>
<li>遍历所有监视器，发送信息</li>
</ol>
<p>举个例子，若服务器在时间1378822257，根据IP为127.0.0.1、端口56604的客户端发送的命令请求，对0号数据库执行命令<code>KEYS *</code>，那么服务器创建的信息如下：</p>
<p><code>1378822257 [0 127.0.0.1:56604] &quot;KEYS&quot; &quot;*&quot;</code></p>
<p>【END】</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/08/Redis入门/" rel="next" title="Redis入门">
                <i class="fa fa-chevron-left"></i> Redis入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/27/C-编程规范笔记/" rel="prev" title="C++编程规范笔记">
                C++编程规范笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjgzMy8xMzM2OQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ZRainy</p>
              <p class="site-description motion-element" itemprop="description">故事没结束，别急着去哭</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-简单动态字符串"><span class="nav-number">1.</span> <span class="nav-text">第二章 简单动态字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDS的定义"><span class="nav-number">1.1.</span> <span class="nav-text">SDS的定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-链表"><span class="nav-number">2.</span> <span class="nav-text">第三章 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链表和链表节点的实现"><span class="nav-number">2.1.</span> <span class="nav-text">链表和链表节点的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-字典"><span class="nav-number">3.</span> <span class="nav-text">第四章 字典</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字典的实现"><span class="nav-number">3.1.</span> <span class="nav-text">字典的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表"><span class="nav-number">3.1.1.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表节点"><span class="nav-number">3.1.2.</span> <span class="nav-text">哈希表节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典"><span class="nav-number">3.1.3.</span> <span class="nav-text">字典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash算法"><span class="nav-number">3.2.</span> <span class="nav-text">hash算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rehash"><span class="nav-number">3.3.</span> <span class="nav-text">rehash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渐进式rehash"><span class="nav-number">3.4.</span> <span class="nav-text">渐进式rehash</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-跳跃表"><span class="nav-number">4.</span> <span class="nav-text">第五章 跳跃表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#跳跃表实现"><span class="nav-number">4.1.</span> <span class="nav-text">跳跃表实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-整数集合"><span class="nav-number">5.</span> <span class="nav-text">第六章 整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整数集合的实现"><span class="nav-number">5.1.</span> <span class="nav-text">整数集合的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#升级"><span class="nav-number">5.2.</span> <span class="nav-text">升级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#降级"><span class="nav-number">5.3.</span> <span class="nav-text">降级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-压缩列表"><span class="nav-number">6.</span> <span class="nav-text">第七章 压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩列表构成"><span class="nav-number">6.1.</span> <span class="nav-text">压缩列表构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连锁更新"><span class="nav-number">6.2.</span> <span class="nav-text">连锁更新</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章-对象"><span class="nav-number">7.</span> <span class="nav-text">第八章 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的类型和编码"><span class="nav-number">7.1.</span> <span class="nav-text">对象的类型和编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型"><span class="nav-number">7.1.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码和底层实现"><span class="nav-number">7.1.2.</span> <span class="nav-text">编码和底层实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串对象"><span class="nav-number">7.2.</span> <span class="nav-text">字符串对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表对象"><span class="nav-number">7.3.</span> <span class="nav-text">列表对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希对象"><span class="nav-number">7.4.</span> <span class="nav-text">哈希对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合对象"><span class="nav-number">7.5.</span> <span class="nav-text">集合对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序集合对象"><span class="nav-number">7.6.</span> <span class="nav-text">有序集合对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型检查与命令多态"><span class="nav-number">7.7.</span> <span class="nav-text">类型检查与命令多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存回收"><span class="nav-number">7.8.</span> <span class="nav-text">内存回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象共享"><span class="nav-number">7.9.</span> <span class="nav-text">对象共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的空转时长"><span class="nav-number">7.10.</span> <span class="nav-text">对象的空转时长</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九章-数据库"><span class="nav-number">8.</span> <span class="nav-text">第九章 数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器中的数据库"><span class="nav-number">8.1.</span> <span class="nav-text">服务器中的数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切换数据库"><span class="nav-number">8.2.</span> <span class="nav-text">切换数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库键空间"><span class="nav-number">8.3.</span> <span class="nav-text">数据库键空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置生存时间或过期时间"><span class="nav-number">8.4.</span> <span class="nav-text">设置生存时间或过期时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过期键删除策略"><span class="nav-number">8.5.</span> <span class="nav-text">过期键删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的过期键删除策略"><span class="nav-number">8.6.</span> <span class="nav-text">Redis的过期键删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF、RDB和复制功能对过期键的处理"><span class="nav-number">8.7.</span> <span class="nav-text">AOF、RDB和复制功能对过期键的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成RDB文件"><span class="nav-number">8.7.1.</span> <span class="nav-text">生成RDB文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#载入RDB文件"><span class="nav-number">8.7.2.</span> <span class="nav-text">载入RDB文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF写入"><span class="nav-number">8.7.3.</span> <span class="nav-text">AOF写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制"><span class="nav-number">8.7.4.</span> <span class="nav-text">复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库通知"><span class="nav-number">8.8.</span> <span class="nav-text">数据库通知</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送通知"><span class="nav-number">8.8.1.</span> <span class="nav-text">发送通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十章-RDB持久化"><span class="nav-number">9.</span> <span class="nav-text">第十章 RDB持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB文件的创建与载入"><span class="nav-number">9.1.</span> <span class="nav-text">RDB文件的创建与载入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动间隔性保存"><span class="nav-number">9.2.</span> <span class="nav-text">自动间隔性保存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB文件结构"><span class="nav-number">9.3.</span> <span class="nav-text">RDB文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#database部分"><span class="nav-number">9.3.1.</span> <span class="nav-text">database部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-value-pairs部分"><span class="nav-number">9.3.2.</span> <span class="nav-text">key_value_pairs部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析RDB文件"><span class="nav-number">9.4.</span> <span class="nav-text">分析RDB文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章-AOF持久化"><span class="nav-number">10.</span> <span class="nav-text">第十一章 AOF持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF持久化的实现"><span class="nav-number">10.1.</span> <span class="nav-text">AOF持久化的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF文件的载入与数据还原"><span class="nav-number">10.2.</span> <span class="nav-text">AOF文件的载入与数据还原</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF重写"><span class="nav-number">10.3.</span> <span class="nav-text">AOF重写</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十二章-事件"><span class="nav-number">11.</span> <span class="nav-text">第十二章 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件事件"><span class="nav-number">11.1.</span> <span class="nav-text">文件事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间事件"><span class="nav-number">11.2.</span> <span class="nav-text">时间事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件的调度与执行"><span class="nav-number">11.3.</span> <span class="nav-text">事件的调度与执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十三章-客户端"><span class="nav-number">12.</span> <span class="nav-text">第十三章 客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端属性"><span class="nav-number">12.1.</span> <span class="nav-text">客户端属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#套接字描述符"><span class="nav-number">12.1.1.</span> <span class="nav-text">套接字描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名字"><span class="nav-number">12.1.2.</span> <span class="nav-text">名字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标志"><span class="nav-number">12.1.3.</span> <span class="nav-text">标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入缓冲区"><span class="nav-number">12.1.4.</span> <span class="nav-text">输入缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令与命令参数"><span class="nav-number">12.1.5.</span> <span class="nav-text">命令与命令参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令的实现函数"><span class="nav-number">12.1.6.</span> <span class="nav-text">命令的实现函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出缓冲区"><span class="nav-number">12.1.7.</span> <span class="nav-text">输出缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#身份验证"><span class="nav-number">12.1.8.</span> <span class="nav-text">身份验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间"><span class="nav-number">12.1.9.</span> <span class="nav-text">时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端的创建与关闭"><span class="nav-number">12.2.</span> <span class="nav-text">客户端的创建与关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#普通客户端"><span class="nav-number">12.2.1.</span> <span class="nav-text">普通客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lua脚本的伪客户端"><span class="nav-number">12.3.</span> <span class="nav-text">Lua脚本的伪客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF文件的伪客户端"><span class="nav-number">12.4.</span> <span class="nav-text">AOF文件的伪客户端</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十四章-服务器"><span class="nav-number">13.</span> <span class="nav-text">第十四章 服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#命令请求的执行过程"><span class="nav-number">13.1.</span> <span class="nav-text">命令请求的执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#serverCron函数"><span class="nav-number">13.2.</span> <span class="nav-text">serverCron函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#更新服务器时间缓存"><span class="nav-number">13.2.1.</span> <span class="nav-text">更新服务器时间缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新LRU时钟"><span class="nav-number">13.2.2.</span> <span class="nav-text">更新LRU时钟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新服务器每秒执行命令次数"><span class="nav-number">13.2.3.</span> <span class="nav-text">更新服务器每秒执行命令次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新服务器内存峰值记录"><span class="nav-number">13.2.4.</span> <span class="nav-text">更新服务器内存峰值记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理SIGTERM信号"><span class="nav-number">13.2.5.</span> <span class="nav-text">处理SIGTERM信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理客户端资源"><span class="nav-number">13.2.6.</span> <span class="nav-text">管理客户端资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理数据库资源"><span class="nav-number">13.2.7.</span> <span class="nav-text">管理数据库资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行被延迟的BGREWRITEAOF命令"><span class="nav-number">13.2.8.</span> <span class="nav-text">执行被延迟的BGREWRITEAOF命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查持久化操作的运行状态"><span class="nav-number">13.2.9.</span> <span class="nav-text">检查持久化操作的运行状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将AOF缓冲区中的内容写入AOF文件"><span class="nav-number">13.2.10.</span> <span class="nav-text">将AOF缓冲区中的内容写入AOF文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭异步客户端"><span class="nav-number">13.2.11.</span> <span class="nav-text">关闭异步客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增加cronloops计数器的值"><span class="nav-number">13.2.12.</span> <span class="nav-text">增加cronloops计数器的值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化服务器"><span class="nav-number">13.3.</span> <span class="nav-text">初始化服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化服务器状态结构"><span class="nav-number">13.3.1.</span> <span class="nav-text">初始化服务器状态结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#载入配置选项"><span class="nav-number">13.3.2.</span> <span class="nav-text">载入配置选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化服务器数据结构"><span class="nav-number">13.3.3.</span> <span class="nav-text">初始化服务器数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#还原数据库状态"><span class="nav-number">13.3.4.</span> <span class="nav-text">还原数据库状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行事件循环"><span class="nav-number">13.3.5.</span> <span class="nav-text">执行事件循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十五章-复制"><span class="nav-number">14.</span> <span class="nav-text">第十五章 复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#旧版复制功能的实现（2-8版本以前）"><span class="nav-number">14.1.</span> <span class="nav-text">旧版复制功能的实现（2.8版本以前）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步"><span class="nav-number">14.1.1.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令传播"><span class="nav-number">14.1.2.</span> <span class="nav-text">命令传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旧版复制功能的缺陷"><span class="nav-number">14.1.3.</span> <span class="nav-text">旧版复制功能的缺陷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新版复制功能的实现"><span class="nav-number">14.2.</span> <span class="nav-text">新版复制功能的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#部分重同步的实现"><span class="nav-number">14.3.</span> <span class="nav-text">部分重同步的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PSYNC命令实现流程"><span class="nav-number">14.4.</span> <span class="nav-text">PSYNC命令实现流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制的实现"><span class="nav-number">14.5.</span> <span class="nav-text">复制的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#心跳检测"><span class="nav-number">14.6.</span> <span class="nav-text">心跳检测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十六章-Sentinel"><span class="nav-number">15.</span> <span class="nav-text">第十六章 Sentinel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#启动并初始化Sentinel"><span class="nav-number">15.1.</span> <span class="nav-text">启动并初始化Sentinel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取主服务器信息"><span class="nav-number">15.2.</span> <span class="nav-text">获取主服务器信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取从服务器信息"><span class="nav-number">15.3.</span> <span class="nav-text">获取从服务器信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向主服务器和从服务器发送信息"><span class="nav-number">15.4.</span> <span class="nav-text">向主服务器和从服务器发送信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接收来自主服务器和从服务器的频道信息"><span class="nav-number">15.5.</span> <span class="nav-text">接收来自主服务器和从服务器的频道信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测主观下线状态"><span class="nav-number">15.6.</span> <span class="nav-text">检测主观下线状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检查客观下线状态"><span class="nav-number">15.7.</span> <span class="nav-text">检查客观下线状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选举领头Sentinel"><span class="nav-number">15.8.</span> <span class="nav-text">选举领头Sentinel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#故障转移"><span class="nav-number">15.9.</span> <span class="nav-text">故障转移</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十七章-集群"><span class="nav-number">16.</span> <span class="nav-text">第十七章 集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#节点"><span class="nav-number">16.1.</span> <span class="nav-text">节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集群数据结构"><span class="nav-number">16.1.1.</span> <span class="nav-text">集群数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLUSTER-MEET命令的实现"><span class="nav-number">16.1.2.</span> <span class="nav-text">CLUSTER MEET命令的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#槽指派"><span class="nav-number">16.2.</span> <span class="nav-text">槽指派</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#记录节点的槽指派信息"><span class="nav-number">16.2.1.</span> <span class="nav-text">记录节点的槽指派信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传播节点的槽指派信息"><span class="nav-number">16.2.2.</span> <span class="nav-text">传播节点的槽指派信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记录集群所有槽的指派信息"><span class="nav-number">16.2.3.</span> <span class="nav-text">记录集群所有槽的指派信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLUSTER-ADDSLOTS命令的实现"><span class="nav-number">16.2.4.</span> <span class="nav-text">CLUSTER ADDSLOTS命令的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在集群中执行命令"><span class="nav-number">16.3.</span> <span class="nav-text">在集群中执行命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算键属于哪个槽"><span class="nav-number">16.3.1.</span> <span class="nav-text">计算键属于哪个槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点数据库的实现"><span class="nav-number">16.3.2.</span> <span class="nav-text">节点数据库的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重新分片"><span class="nav-number">16.4.</span> <span class="nav-text">重新分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ASK错误"><span class="nav-number">16.5.</span> <span class="nav-text">ASK错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CLUSTER-SETSLOT-IMPORTING命令的实现"><span class="nav-number">16.5.1.</span> <span class="nav-text">CLUSTER SETSLOT IMPORTING命令的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLUSTER-SETSLOT-MIGRATING命令的实现"><span class="nav-number">16.5.2.</span> <span class="nav-text">CLUSTER SETSLOT MIGRATING命令的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASK错误-1"><span class="nav-number">16.5.3.</span> <span class="nav-text">ASK错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASKING命令"><span class="nav-number">16.5.4.</span> <span class="nav-text">ASKING命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASK错误和MOVED错误的区别"><span class="nav-number">16.5.5.</span> <span class="nav-text">ASK错误和MOVED错误的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制与故障转移"><span class="nav-number">16.6.</span> <span class="nav-text">复制与故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置从节点"><span class="nav-number">16.6.1.</span> <span class="nav-text">设置从节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障检测"><span class="nav-number">16.6.2.</span> <span class="nav-text">故障检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移-1"><span class="nav-number">16.6.3.</span> <span class="nav-text">故障转移</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息"><span class="nav-number">16.7.</span> <span class="nav-text">消息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十八章-发布与订阅"><span class="nav-number">17.</span> <span class="nav-text">第十八章 发布与订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#频道的订阅与退订"><span class="nav-number">17.1.</span> <span class="nav-text">频道的订阅与退订</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模式的订阅与退订"><span class="nav-number">17.2.</span> <span class="nav-text">模式的订阅与退订</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发送消息"><span class="nav-number">17.3.</span> <span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看订阅信息"><span class="nav-number">17.4.</span> <span class="nav-text">查看订阅信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十九章-事务"><span class="nav-number">18.</span> <span class="nav-text">第十九章 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事务的实现"><span class="nav-number">18.1.</span> <span class="nav-text">事务的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WATCH命令的实现"><span class="nav-number">18.2.</span> <span class="nav-text">WATCH命令的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务的ACID性质"><span class="nav-number">18.3.</span> <span class="nav-text">事务的ACID性质</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十章-Lua脚本"><span class="nav-number">19.</span> <span class="nav-text">第二十章 Lua脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建并修改Lua环境"><span class="nav-number">19.1.</span> <span class="nav-text">创建并修改Lua环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lua环境协作组件"><span class="nav-number">19.2.</span> <span class="nav-text">lua环境协作组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EVAL命令的实现"><span class="nav-number">19.3.</span> <span class="nav-text">EVAL命令的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EVALSHA命令的实现"><span class="nav-number">19.4.</span> <span class="nav-text">EVALSHA命令的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#脚本管理命令的实现"><span class="nav-number">19.5.</span> <span class="nav-text">脚本管理命令的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#脚本复制"><span class="nav-number">19.6.</span> <span class="nav-text">脚本复制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十一章-排序"><span class="nav-number">20.</span> <span class="nav-text">第二十一章 排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SORT-命令的实现"><span class="nav-number">20.1.</span> <span class="nav-text">SORT 命令的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LIMIT选项的实现"><span class="nav-number">20.2.</span> <span class="nav-text">LIMIT选项的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET选项的实现"><span class="nav-number">20.3.</span> <span class="nav-text">GET选项的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STORE选项的实现"><span class="nav-number">20.4.</span> <span class="nav-text">STORE选项的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多个选项的执行顺序"><span class="nav-number">20.5.</span> <span class="nav-text">多个选项的执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选项的摆放顺序"><span class="nav-number">20.6.</span> <span class="nav-text">选项的摆放顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十二章-二进制位数组"><span class="nav-number">21.</span> <span class="nav-text">第二十二章 二进制位数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#位数组的表示"><span class="nav-number">21.1.</span> <span class="nav-text">位数组的表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GETBIT命令的实现"><span class="nav-number">21.2.</span> <span class="nav-text">GETBIT命令的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SETBIT命令的实现"><span class="nav-number">21.3.</span> <span class="nav-text">SETBIT命令的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BITCOUNT命令的实现"><span class="nav-number">21.4.</span> <span class="nav-text">BITCOUNT命令的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis中的实现"><span class="nav-number">21.4.1.</span> <span class="nav-text">Redis中的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BITOP命令的实现"><span class="nav-number">21.5.</span> <span class="nav-text">BITOP命令的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十三章-慢查询日志"><span class="nav-number">22.</span> <span class="nav-text">第二十三章 慢查询日志</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二十四章-监视器"><span class="nav-number">23.</span> <span class="nav-text">第二十四章 监视器</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZRainy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
